(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["DS"] = factory();
	else
		root["DS"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 156);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(162)
var ieee754 = __webpack_require__(240)
var isArray = __webpack_require__(106)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 1 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(0).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(117)(module)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = exports;

elliptic.version = __webpack_require__(233).version;
elliptic.utils = __webpack_require__(232);
elliptic.rand = __webpack_require__(82);
elliptic.curve = __webpack_require__(43);
elliptic.curves = __webpack_require__(224);

// Protocols
elliptic.ec = __webpack_require__(225);
elliptic.eddsa = __webpack_require__(228);


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(158);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),
/* 6 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 7 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(39)(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 9 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var anObject       = __webpack_require__(29)
  , IE8_DOM_DEFINE = __webpack_require__(96)
  , toPrimitive    = __webpack_require__(62)
  , dP             = Object.defineProperty;

exports.f = __webpack_require__(8) ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(183)
  , defined = __webpack_require__(52);
module.exports = function(it){
  return IObject(defined(it));
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var hash = exports;

hash.utils = __webpack_require__(238);
hash.common = __webpack_require__(234);
hash.sha = __webpack_require__(237);
hash.ripemd = __webpack_require__(236);
hash.hmac = __webpack_require__(235);

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = __webpack_require__(67);
/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(32);
util.inherits = __webpack_require__(1);
/*</replacement>*/

var Readable = __webpack_require__(114);
var Writable = __webpack_require__(69);

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

/***/ }),
/* 15 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(35);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Queue
 *
 * first in first out, FIFO
 * rearfront
 */

// 
var Queue = function () {
    function Queue() {
        (0, _classCallCheck3.default)(this, Queue);

        this.rear = this.front = null;
        this.size = 0;
    }

    Queue.prototype.isEmpty = function isEmpty() {
        return this.rear === null;
    };

    Queue.prototype.clear = function clear() {
        this.rear = this.front = null;
        this.size = 0;
    };

    Queue.prototype.getHead = function getHead() {
        return this.front ? this.front.data : null;
    };

    Queue.prototype.enQueue = function enQueue(elem) {
        if (this.front === null) {
            this.rear = this.front = { data: elem, next: null };
        } else {
            var p = { data: elem, next: null };
            this.rear.next = p;
            this.rear = p;
        }
        this.size++;
    };

    Queue.prototype.deQueue = function deQueue() {
        if (this.front) {
            var elem = this.front.data;
            this.front = this.front.next;
            if (this.front === null) {
                this.rear = null;
            }
            this.size--;
            return elem;
        } else {
            return null;
        }
    };

    Queue.prototype.forEach = function forEach(iterator) {
        if (typeof iterator !== 'function') throw new Error('iterator should be function');

        var current = this.front;
        while (current) {
            if (iterator(current.data)) break;
            current = current.next;
        }
    };

    Queue.prototype[Symbol.iterator] = _regenerator2.default.mark(function _callee() {
        var current;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        current = this.front;

                    case 1:
                        if (!current) {
                            _context.next = 7;
                            break;
                        }

                        _context.next = 4;
                        return current.data;

                    case 4:
                        current = current.next;
                        _context.next = 1;
                        break;

                    case 7:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    });

    Queue.prototype.peekAt = function peekAt() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        if (index < this.size) {
            var current = this.front;
            for (var i = 0; i < index; i++) {
                current = current.next;
            }
            return current.data;
        }

        return -1;
    };

    Queue.prototype.toString = function toString() {
        if (this.front === null) {
            return null;
        }

        var arr = [];
        var current = this.front;

        for (var i = 0, len = this.size; i < len; i++) {
            arr[i] = current.data;
            current = current.next;
        }

        return arr;
    };

    return Queue;
}();

exports.default = Queue;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var Transform = __webpack_require__(23).Transform
var inherits = __webpack_require__(1)
var StringDecoder = __webpack_require__(70).StringDecoder
module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  this._decoder = null
  this._encoding = null
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (this.hashMode) {
    return this
  }
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}

CipherBase.prototype.setAutoPadding = function () {}

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this._final())
  } catch (e) {
    err = e
  } finally {
    done(err)
  }
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }
  if (this._encoding !== enc) {
    throw new Error('can\'t switch encodings')
  }
  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }
  return out
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 18 */
/***/ (function(module, exports) {

var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(10)
  , createDesc = __webpack_require__(41);
module.exports = __webpack_require__(8) ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var store      = __webpack_require__(60)('wks')
  , uid        = __webpack_require__(42)
  , Symbol     = __webpack_require__(6).Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var inherits = __webpack_require__(1)
var md5 = __webpack_require__(103)
var rmd160 = __webpack_require__(258)
var sha = __webpack_require__(260)

var Base = __webpack_require__(17)

function HashNoConstructor(hash) {
  Base.call(this, 'digest')

  this._hash = hash
  this.buffers = []
}

inherits(HashNoConstructor, Base)

HashNoConstructor.prototype._update = function (data) {
  this.buffers.push(data)
}

HashNoConstructor.prototype._final = function () {
  var buf = Buffer.concat(this.buffers)
  var r = this._hash(buf)
  this.buffers = null

  return r
}

function Hash(hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if ('md5' === alg) return new HashNoConstructor(md5)
  if ('rmd160' === alg || 'ripemd160' === alg) return new HashNoConstructor(rmd160)

  return new Hash(sha(alg))
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = new Buffer(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
  this._s = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = new Buffer(data, enc)
  }

  var l = this._len += data.length
  var s = this._s || 0
  var f = 0
  var buffer = this._block

  while (s < l) {
    var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
    var ch = (t - f)

    for (var i = 0; i < ch; i++) {
      buffer[(s % this._blockSize) + i] = data[i + f]
    }

    s += ch
    f += ch

    if ((s % this._blockSize) === 0) {
      this._update(buffer)
    }
  }
  this._s = s

  return this
}

Hash.prototype.digest = function (enc) {
  // Suppose the length of the message M, in bits, is l
  var l = this._len * 8

  // Append the bit 1 to the end of the message
  this._block[this._len % this._blockSize] = 0x80

  // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
  this._block.fill(0, this._len % this._blockSize + 1)

  if (l % (this._blockSize * 8) >= this._finalSize * 8) {
    this._update(this._block)
    this._block.fill(0)
  }

  // to this append the block which is equal to the number l written in binary
  // TODO: handle case where l is > Math.pow(2, 29)
  this._block.writeInt32BE(l, this._blockSize - 4)

  var hash = this._update(this._block) || this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(44).EventEmitter;
var inherits = __webpack_require__(1);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(253);
Stream.Writable = __webpack_require__(255);
Stream.Duplex = __webpack_require__(250);
Stream.Transform = __webpack_require__(254);
Stream.PassThrough = __webpack_require__(252);

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChildSiblingTree = exports.ChildTree = exports.ParentTree = exports.BinaryTree = undefined;

var _regenerator = __webpack_require__(35);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _index = __webpack_require__(25);

var _index2 = _interopRequireDefault(_index);

var _Queue = __webpack_require__(16);

var _Queue2 = _interopRequireDefault(_Queue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 
/**
 * 
 *
 * Treenn>=0
 * 1Root
 * 2n>1m(m>0)T1,T2,T3,...TmSubtree
 *
 * a
 * b13A3T1={B,E,F,K,L},t2={D,H,I,J,M};T1,T2T3A
 *
 * DegreebA3C1F0.0Leaf0b3.ChildParentSibling
 * Levelll+1GEF,H,I,JDepthb4
 *
 * 
 * Forestmm>=0
 *
 *
 */

/**
 * Binary Tree2
 *
 * 
 * 1.i2i-1(i>=1)
 * 2.k2k-1(k>=1)
 * 3.Tn02n2n0 = n2 + 1;
 *      k2k-1
 *      knk1n
 * 
 * 4.nMath.floor(log 2 n) + 1
 * 5.nMath.floor(log 2 n) + 11Math.floor(2 n) + 11<=i<=n
 *     (1)i=1ii>1parent(i)Math.floor(i/2)
 *     (2)2i > niiLChild(i)2i.
 *     (3)2i + 1 > niRChild(i)2i + 1;
 */

/*
 

 1.
 ii-10
 kk22n-1

 2.
 
 nn+1---

 
 
 

 */

var BinaryTree = exports.BinaryTree = function () {
    function BinaryTree() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var leftChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var rightChild = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        (0, _classCallCheck3.default)(this, BinaryTree);

        this.data = data;
        // 
        this.leftChild = leftChild;
        this.rightChild = rightChild;
    }

    // 


    BinaryTree.prototype.isSimilar = function isSimilar(tree) {
        return !!(tree && (this.leftChild && this.leftChild.isSimilar(tree.leftChild) || !this.leftChild && !tree.leftChild) && (this.rightChild && this.rightChild.isSimilar(tree.rightChild) || !this.rightChild && !tree.rightChild));
    };

    BinaryTree.prototype.createBinaryTree = function createBinaryTree(tree) {
        void function preOrderRecursive(node, x, visit) {
            visit(node, tree[x]);

            var p = void 0;
            if (tree[2 * x + 1]) {
                p = node.leftChild = new BinaryTree();
                preOrderRecursive(p, 2 * x + 1, visit);
            }
            if (tree[2 * x + 2]) {
                p = node.rightChild = new BinaryTree();
                preOrderRecursive(p, 2 * x + 2, visit);
            }

            if (p) p.parentNode = node;
        }(this, 0, function (node, value) {
            node.data = value;
        });
    };

    /**
     * 
     * type
     * 1:  2:  3: 
     * @param {Number} iteratorType
     * 
     * @memberOf BinaryTree
     */


    BinaryTree.prototype[Symbol.iterator] = _regenerator2.default.mark(function _callee() {
        var iteratorType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        _context.t0 = iteratorType;
                        _context.next = _context.t0 === 1 ? 3 : _context.t0 === 2 ? 10 : _context.t0 === 3 ? 17 : 24;
                        break;

                    case 3:
                        _context.next = 5;
                        return this.data;

                    case 5:
                        if (!this.leftChild) {
                            _context.next = 7;
                            break;
                        }

                        return _context.delegateYield(this.leftChild, 't1', 7);

                    case 7:
                        if (!this.rightChild) {
                            _context.next = 9;
                            break;
                        }

                        return _context.delegateYield(this.rightChild, 't2', 9);

                    case 9:
                        return _context.abrupt('break', 24);

                    case 10:
                        if (!this.leftChild) {
                            _context.next = 12;
                            break;
                        }

                        return _context.delegateYield(this.leftChild, 't3', 12);

                    case 12:
                        _context.next = 14;
                        return this.data;

                    case 14:
                        if (!this.rightChild) {
                            _context.next = 16;
                            break;
                        }

                        return _context.delegateYield(this.rightChild, 't4', 16);

                    case 16:
                        return _context.abrupt('break', 24);

                    case 17:
                        if (!this.leftChild) {
                            _context.next = 19;
                            break;
                        }

                        return _context.delegateYield(this.leftChild, 't5', 19);

                    case 19:
                        if (!this.rightChild) {
                            _context.next = 21;
                            break;
                        }

                        return _context.delegateYield(this.rightChild, 't6', 21);

                    case 21:
                        _context.next = 23;
                        return this.data;

                    case 23:
                        return _context.abrupt('break', 24);

                    case 24:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    });

    // 

    BinaryTree.prototype.preOrderNonRecursive = function preOrderNonRecursive(visit) {
        var stack = new _index2.default();
        var p = this;

        while (p || stack.length) {
            // 
            if (p) {
                stack.push(p);
                p.data && visit(p.data);
                p = p.leftChild;
            } else {
                p = stack.pop();
                p = p.rightChild;
            }
        }
    };

    // 


    BinaryTree.prototype.inOrderNonRecursive = function inOrderNonRecursive(visit) {
        var stack = new _index2.default();
        var p = this;

        while (p || stack.length) {
            if (p) {
                stack.push(p);
                p = p.leftChild;
            } else {
                p = stack.pop();
                p.data && visit(p.data);
                p = p.rightChild;
            }
        }
    };

    // mark
    // mark=0mark=1
    // mark=2mark


    BinaryTree.prototype.postOrderNonRecursive = function postOrderNonRecursive(visit) {
        var stack = new _index2.default();
        stack.push([this, 0]);

        while (stack.length) {
            var a = stack.pop();
            var node = a[0];

            switch (a[1]) {
                case 0:
                    stack.push([node, 1]); // mark
                    if (node.leftChild) stack.push([node.leftChild, 0]); // 
                    break;
                case 1:
                    stack.push([node, 2]);
                    if (node.rightChild) stack.push([node.rightChild, 0]);
                    break;
                case 2:
                    node.data && visit(node.data);
                    break;
                default:
                    break;
            }
        }
    };

    BinaryTree.prototype.preOrderRecursive = function preOrderRecursive(visit) {
        visit(this.data);
        if (this.leftChild) this.leftChild.preOrderRecursive(visit);
        if (this.rightChild) this.rightChild.preOrderRecursive(visit);
    };

    BinaryTree.prototype.inOrderRecursive = function inOrderRecursive(visit) {
        if (this.leftChild) this.leftChild.inOrderRecursive(visit);
        visit(this.data);
        if (this.rightChild) this.rightChild.inOrderRecursive(visit);
    };

    BinaryTree.prototype.postOrderRecursive = function postOrderRecursive(visit) {
        if (this.leftChild) this.leftChild.postOrderRecursive(visit);
        if (this.rightChild) this.rightChild.postOrderRecursive(visit);
        visit(this.data);
    };

    BinaryTree.prototype.levelOrderTraverse = function levelOrderTraverse(visit) {
        var queue = new _Queue2.default();
        queue.enQueue(this);

        while (queue.rear) {
            var p = queue.deQueue();
            p.data && visit(p.data);
            p.leftChild && queue.enQueue(p.leftChild);
            p.rightChild && queue.enQueue(p.rightChild);
        }
    };

    // k


    BinaryTree.prototype.getPreSequence = function getPreSequence(k) {
        var count = 0;
        var data = null;

        void function recurse(node) {
            if (node) {
                if (++count === k) data = node.data;else {
                    recurse(node.leftChild);
                    recurse(node.rightChild);
                }
            }
        }(this);

        return data;
    };

    // 


    BinaryTree.prototype.countLeaves = function countLeaves() {
        return function recurse(node) {
            if (!node) return 0;else if (!node.leftChild && !node.rightChild) return 1;else return recurse(node.leftChild) + recurse(node.rightChild);
        }(this);
    };

    // 


    BinaryTree.prototype.revoluteBinaryTree = function revoluteBinaryTree() {
        var _ref = [this.rightChild, this.leftChild];
        this.leftChild = _ref[0];
        this.rightChild = _ref[1];


        if (this.leftChild) this.leftChild.revoluteBinaryTree();
        if (this.rightChild) this.rightChild.revoluteBinaryTree();
    };

    BinaryTree.prototype.revoluteNonRecursive = function revoluteNonRecursive() {
        var stack = [];
        stack.push(this);

        while (stack.length) {
            var node = stack.pop();
            var _ref2 = [node.rightChild, node.leftChild];
            node.leftChild = _ref2[0];
            node.rightChild = _ref2[1];


            if (node.leftChild) stack.push(node.leftChild);
            if (node.rightChild) stack.push(node.rightChild);
        }
    };

    // x


    BinaryTree.prototype.getSubDepth = function getSubDepth(x) {
        var count = 0;
        var stack = new _index2.default();
        stack.push(this);

        while (stack.length) {
            var node = stack.pop();

            if (node.data === x) {
                count = node.getDepth();
                break;
            } else {
                if (node.leftChild) stack.push(node.leftChild);
                if (node.rightChild) stack.push(node.rightChild);
            }
        }

        return count;
    };

    BinaryTree.prototype.getDepth = function getDepth() {
        var m = this.leftChild && this.leftChild.getDepth() || 0;
        var n = this.rightChild && this.rightChild.getDepth() || 0;
        return (m > n ? m : n) + 1;
    };

    // x


    BinaryTree.prototype.delSubX = function delSubX(x) {
        if (this.data === x) {
            this.leftChild = null;
            this.rightChild = null;
        } else {
            if (this.leftChild) this.leftChild.delSubX(x);
            if (this.rightChild) this.rightChild.delSubX(x);
        }
    };

    /**
     * 
     * @param {Function} cb 
     * @returns {Cstr} 
     */


    BinaryTree.prototype.copy = function copy() {
        var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

        // 
        var stack1 = new _index2.default();
        // 
        var stack2 = new _index2.default();
        stack1.push(this);
        var Cstr = this.constructor;
        var newTree = new Cstr();
        var q = newTree;
        stack2.push(newTree);
        var p = void 0;

        while (stack1.length) {
            // 
            while (p = stack1.peek()) {
                if (p.leftChild) q.leftChild = new Cstr();
                q = q.leftChild;
                stack1.push(p.leftChild);
                stack2.push(q);
            }

            p = stack1.pop();
            q = stack2.pop();

            if (stack1.length) {
                p = stack1.pop();
                q = stack2.pop();
                if (p.rightChild) q.rightChild = new Cstr();
                q.data = p.data;
                cb(q, p);
                q = q.rightChild;
                stack1.push(p.rightChild); // 
                stack2.push(q);
            }
        }

        return newTree;
    };

    // pq


    BinaryTree.prototype.findNearAncient = function findNearAncient(pNode, qNode) {
        var pathP = findPath(this, pNode, 0);
        var pathQ = findPath(this, qNode, 0);

        for (var i = 0; pathP[i] == pathQ[i] && pathP[i]; i++) {}
        return pathP[--i];
    };

    // todo


    BinaryTree.prototype.toString = function toString() {};

    // 


    BinaryTree.prototype.lushDegree = function lushDegree() {
        var countArr = [];
        var queue = new _Queue2.default();
        queue.enQueue({
            node: this,
            layer: 0
        });
        // 
        var r = void 0;
        while (queue.rear) {
            r = queue.deQueue();
            countArr[r.layer] = (countArr[r.layer] || 0) + 1;

            if (r.node.leftChild) queue.enQueue({
                node: r.node.leftChild,
                layer: r.layer + 1
            });
            if (r.node.rightChild) queue.enQueue({
                node: r.node.rightChild,
                layer: r.layer + 1
            });
        }

        // 
        var height = r.layer;
        var max = countArr[0];
        for (var i = 1; countArr[i]; i++) {
            // 
            if (countArr[i] > max) max = countArr[i];
        }return height * max;
    };

    // descNum


    BinaryTree.prototype.descNum = function descNum() {
        return function recurse(node) {
            var d = void 0;
            if (!node) return -1;else d = recurse(node.leftChild) + recurse(node.rightChild) + 2;

            node.descNum = d;

            return d;
        }(this);
    };

    // 


    BinaryTree.isFullBinaryTree = function isFullBinaryTree(tree) {
        var queue = new _Queue2.default();
        var flag = 0;
        queue.enQueue(tree);

        while (queue.rear) {
            var p = queue.deQueue();

            if (!p) flag = 1;else if (flag) return false;else {
                queue.enQueue(p.leftChild);
                queue.enQueue(p.rightChild);
            }
        }

        return true;
    };

    return BinaryTree;
}();

// treenode


function findPath(tree, node) {
    var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    var path = [];
    var found = false;

    void function recurse(tree, i) {
        if (tree == node) {
            found = true;
            return;
        }

        path[i] = tree;
        if (tree.leftChild) recurse(tree.leftChild, i + 1);
        if (tree.rightChild && !found) recurse(tree.rightChild, i + 1);
        if (!found) path[i] = null;
    }(tree, i);

    return path;
}

var global = Function('return this;')();

// 
function printPath_maxDepthS1(tree) {
    var maxh = tree.getDepth();
    var path = [];

    if (maxh < 2) return false;
    find_h(tree, 1);

    function find_h(tree, h) {
        path[h] = tree;

        if (h == maxh - 1) {
            var s = ' ';
            for (var i = 1; path[i]; i++) {
                s += path[i].data + (path[i + 1] ? ' -> ' : '');
            }console.log(s);
            return;
        } else {
            if (tree.leftChild) find_h(tree.leftChild, h + 1);
            if (tree.rightChild) find_h(tree.rightChild, h + 1);
        }

        path[h] = null;
    }
}

var tree = [1, 2, 3, 4, 5,, 6,,, 7];
var test = new BinaryTree();
test.createBinaryTree(tree);

console.log('iterator: ');
for (var _iterator = test, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref3;

    if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref3 = _iterator[_i++];
    } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref3 = _i.value;
    }

    var x = _ref3;

    console.log(x);
}

/**
 * 3
 */

// 1.
// parent(tree, x)
// 

var ParentTree = exports.ParentTree = function () {
    function ParentTree() {
        (0, _classCallCheck3.default)(this, ParentTree);

        this.nodes = [];
    }

    ParentTree.prototype.getDepth = function getDepth() {
        var maxDepth = 0;

        for (var i = 0; i < this.nodes.length; i++) {
            var dep = 0;
            for (var j = i; j >= 0; j = this.nodes[i].parent) {
                dep++;
            }if (dep > maxDepth) maxDepth = dep;
        }

        return maxDepth;
    };

    return ParentTree;
}();

var ParentTreeNode = function ParentTreeNode() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    (0, _classCallCheck3.default)(this, ParentTreeNode);

    // type: ParentTree
    this.data = data;
    //  {Number}
    this.parent = parent;
};

var pt = new ParentTree();
pt.nodes.push(new ParentTreeNode('R', -1));
pt.nodes.push(new ParentTreeNode('A', 0));
pt.nodes.push(new ParentTreeNode('B', 0));
pt.nodes.push(new ParentTreeNode('C', 0));
pt.nodes.push(new ParentTreeNode('D', 1));
pt.nodes.push(new ParentTreeNode('E', 1));
pt.nodes.push(new ParentTreeNode('F', 3));
pt.nodes.push(new ParentTreeNode('G', 6));
pt.nodes.push(new ParentTreeNode('H', 6));
pt.nodes.push(new ParentTreeNode('I', 6));

// 

var ChildTree = exports.ChildTree = function () {
    function ChildTree() {
        (0, _classCallCheck3.default)(this, ChildTree);

        this.nodes = [];
    }

    ChildTree.prototype.getDepth = function getDepth() {
        var self = this;
        return function subDepth(rootIndex) {
            if (!self.nodes[rootIndex]) return 1;

            var sd = 1;
            for (var p = self.nodes[rootIndex]; p; p = p.next) {
                var d = subDepth(p.child);
                if (d > sd) sd = d;
            }

            return sd + 1;
        }(this.data[0]);
    };

    return ChildTree;
}();
/**
 *
 * @param {*} data
 * @param {ChildTreeNode} firstChild 
 * @constructor
 */


var ChildTreeBox = function ChildTreeBox() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var firstChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _classCallCheck3.default)(this, ChildTreeBox);

    this.data = data;
    this.firstChild = firstChild;
};

/**
 * 
 *
 * @param {Number} child
 * @param {ChildTreeNode} next
 * @constructor
 */


var ChildTreeNode = function ChildTreeNode() {
    var child = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _classCallCheck3.default)(this, ChildTreeNode);

    this.child = child;
    this.next = next;
};

/*
 parent
 
 */

// ()
// parentparent


var ChildSiblingTree = exports.ChildSiblingTree = function () {
    function ChildSiblingTree() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var firstChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var nextSibling = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        (0, _classCallCheck3.default)(this, ChildSiblingTree);

        this.data = data;
        this.firstChild = firstChild;
        this.nextSibling = nextSibling;
    }

    // 


    ChildSiblingTree.prototype.print = function print() {
        for (var child = this.firstChild; child; child = child.nextSibling) {
            console.log('%c %c', this.data, child.data);
            child.print();
        }
    };

    // 


    ChildSiblingTree.prototype.leafCount = function leafCount() {
        if (!this.firstChild) return 1;else {
            var count = 0;
            for (var child = this.firstChild; child; child = child.nextSibling) {
                count += child.leafCount();
            }
            return count;
        }
    };

    // 


    ChildSiblingTree.prototype.getDegree = function getDegree() {
        if (!this.firstChild) return 0;else {
            var degree = 0;
            for (var p = this.firstChild; p; p = p.nextSibling) {
                degree++;
            }for (var _p = this.firstChild; _p; _p = _p.nextSibling) {
                var d = _p.getDegree();
                if (d > degree) degree = d;
            }

            return degree;
        }
    };

    ChildSiblingTree.prototype.getDepth = function getDepth() {
        if (this === global) return 0;else {
            var maxd = 0;
            for (var p = this.firstChild; p; p = p.nextSibling) {
                var d = p.getDepth();
                if (d > maxd) maxd = d;
            }

            return maxd + 1;
        }
    };

    return ChildSiblingTree;
}();

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 
 *
 * topbottom
 * last in first out
 */

/**
 * 
 * top
 *
 */

// 
var Stack = function () {
    function Stack() {
        (0, _classCallCheck3.default)(this, Stack);

        this.top = null;
        this.length = 0;
    }

    Stack.prototype.isEmpty = function isEmpty() {
        return this.length === 0;
    };

    Stack.prototype.push = function push(data) {
        var node = {
            data: data,
            next: null
        };

        node.next = this.top;
        this.top = node;
        this.length++;
    };

    Stack.prototype.peek = function peek() {
        return this.top === null ? null : this.top.data;
    };

    Stack.prototype.pop = function pop() {
        if (this.top === null) return null;

        var out = this.top;
        this.top = this.top.next;

        if (this.length > 0) this.length--;

        return out.data;
    };

    Stack.prototype.clear = function clear() {
        this.top = null;
        this.length = 0;
    };

    Stack.prototype.toString = function toString() {
        if (this.top === null) return null;

        var arr = [];
        var current = this.top;

        for (var i = 0, len = this.size; i < len; i++) {
            arr[i] = current.data;
            current = current.next;
        }

        return arr;
    };

    (0, _createClass3.default)(Stack, [{
        key: "size",
        get: function get() {
            return this.length;
        }
    }]);
    return Stack;
}();

exports.default = Stack;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = exports;

asn1.bignum = __webpack_require__(3);

asn1.define = __webpack_require__(148).define;
asn1.base = __webpack_require__(27);
asn1.constants = __webpack_require__(77);
asn1.decoders = __webpack_require__(152);
asn1.encoders = __webpack_require__(154);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var base = exports;

base.Reporter = __webpack_require__(150).Reporter;
base.DecoderBuffer = __webpack_require__(76).DecoderBuffer;
base.EncoderBuffer = __webpack_require__(76).EncoderBuffer;
base.Node = __webpack_require__(149);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(31);
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(6)
  , core      = __webpack_require__(18)
  , ctx       = __webpack_require__(94)
  , hide      = __webpack_require__(19)
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, Buffer, process) {

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}

var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > 65536) throw new Error('requested too many random bytes')
  // in case browserify  isn't using the Uint8Array version
  var rawBytes = new global.Uint8Array(size)

  // This will not work in older browsers.
  // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
  if (size > 0) {  // getRandomValues fails on IE if size == 0
    crypto.getRandomValues(rawBytes)
  }
  // phantomjs doesn't like a buffer being passed here
  var bytes = new Buffer(rawBytes.buffer)

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15), __webpack_require__(0).Buffer, __webpack_require__(7)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defaultCompare;
/**
 * Created by ldp on 2015/4/12.
 */

function defaultCompare(a, b) {
  return a - b;
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(256);


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec

// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function scrub_vec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
  return false
}

function Global () {
  this.SBOX = []
  this.INV_SBOX = []
  this.SUB_MIX = [[], [], [], []]
  this.INV_SUB_MIX = [[], [], [], []]
  this.init()
  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
}

Global.prototype.init = function () {
  var d, i, sx, t, x, x2, x4, x8, xi, _i
  d = (function () {
    var _i, _results
    _results = []
    for (i = _i = 0; _i < 256; i = ++_i) {
      if (i < 128) {
        _results.push(i << 1)
      } else {
        _results.push((i << 1) ^ 0x11b)
      }
    }
    return _results
  })()
  x = 0
  xi = 0
  for (i = _i = 0; _i < 256; i = ++_i) {
    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    this.SBOX[x] = sx
    this.INV_SBOX[sx] = x
    x2 = d[x]
    x4 = d[x2]
    x8 = d[x4]
    t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    this.SUB_MIX[3][x] = t
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    this.INV_SUB_MIX[3][sx] = t
    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }
  return true
}

var G = new Global()

AES.blockSize = 4 * 4

AES.prototype.blockSize = AES.blockSize

AES.keySize = 256 / 8

AES.prototype.keySize = AES.keySize

function bufferToArray (buf) {
  var len = buf.length / 4
  var out = new Array(len)
  var i = -1
  while (++i < len) {
    out[i] = buf.readUInt32BE(i * 4)
  }
  return out
}
function AES (key) {
  this._key = bufferToArray(key)
  this._doReset()
}

AES.prototype._doReset = function () {
  var invKsRow, keySize, keyWords, ksRow, ksRows, t
  keyWords = this._key
  keySize = keyWords.length
  this._nRounds = keySize + 6
  ksRows = (this._nRounds + 1) * 4
  this._keySchedule = []
  for (ksRow = 0; ksRow < ksRows; ksRow++) {
    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t)
  }
  this._invKeySchedule = []
  for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
    ksRow = ksRows - invKsRow
    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)]
    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]]
  }
  return true
}

AES.prototype.encryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var temp = [M[3], M[1]]
  M[1] = temp[0]
  M[3] = temp[1]
  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrub_vec(this._keySchedule)
  scrub_vec(this._invKeySchedule)
  scrub_vec(this._key)
}

AES.prototype._doCryptBlock = function (M, keySchedule, SUB_MIX, SBOX) {
  var ksRow, s0, s1, s2, s3, t0, t1, t2, t3

  s0 = M[0] ^ keySchedule[0]
  s1 = M[1] ^ keySchedule[1]
  s2 = M[2] ^ keySchedule[2]
  s3 = M[3] ^ keySchedule[3]
  ksRow = 4
  for (var round = 1; round < this._nRounds; round++) {
    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }
  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  return [
    fixup_uint32(t0),
    fixup_uint32(t1),
    fixup_uint32(t2),
    fixup_uint32(t3)
  ]
}

exports.AES = AES

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 37 */
/***/ (function(module, exports) {

exports['aes-128-ecb'] = {
  cipher: 'AES',
  key: 128,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-192-ecb'] = {
  cipher: 'AES',
  key: 192,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-256-ecb'] = {
  cipher: 'AES',
  key: 256,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-128-cbc'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes-192-cbc'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes-256-cbc'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes128'] = exports['aes-128-cbc']
exports['aes192'] = exports['aes-192-cbc']
exports['aes256'] = exports['aes-256-cbc']
exports['aes-128-cfb'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-192-cfb'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-256-cfb'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-128-cfb8'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-192-cfb8'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-256-cfb8'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-128-cfb1'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-192-cfb1'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-256-cfb1'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-128-ofb'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-192-ofb'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-256-ofb'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-128-ctr'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-192-ctr'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-256-ctr'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-128-gcm'] = {
  cipher: 'AES',
  key: 128,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}
exports['aes-192-gcm'] = {
  cipher: 'AES',
  key: 192,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}
exports['aes-256-gcm'] = {
  cipher: 'AES',
  key: 256,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(28)

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}

function getBlock (self) {
  var out = self._cipher.encryptBlock(self._prev)
  incr32(self._prev)
  return out
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = __webpack_require__(101)
  , enumBugKeys = __webpack_require__(53);

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

/***/ }),
/* 42 */
/***/ (function(module, exports) {

var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = exports;

curve.base = __webpack_require__(220);
curve.short = __webpack_require__(223);
curve.mont = __webpack_require__(222);
curve.edwards = __webpack_require__(221);


/***/ }),
/* 44 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var md5 = __webpack_require__(103)
module.exports = EVP_BytesToKey
function EVP_BytesToKey (password, salt, keyLen, ivLen) {
  if (!Buffer.isBuffer(password)) {
    password = new Buffer(password, 'binary')
  }
  if (salt && !Buffer.isBuffer(salt)) {
    salt = new Buffer(salt, 'binary')
  }
  keyLen = keyLen / 8
  ivLen = ivLen || 0
  var ki = 0
  var ii = 0
  var key = new Buffer(keyLen)
  var iv = new Buffer(ivLen)
  var addmd = 0
  var md_buf
  var i
  var bufs = []
  while (true) {
    if (addmd++ > 0) {
      bufs.push(md_buf)
    }
    bufs.push(password)
    if (salt) {
      bufs.push(salt)
    }
    md_buf = md5(Buffer.concat(bufs))
    bufs = []
    i = 0
    if (keyLen > 0) {
      while (true) {
        if (keyLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        key[ki++] = md_buf[i]
        keyLen--
        i++
      }
    }
    if (ivLen > 0 && i !== md_buf.length) {
      while (true) {
        if (ivLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        iv[ii++] = md_buf[i]
        ivLen--
        i++
      }
    }
    if (keyLen === 0 && ivLen === 0) {
      break
    }
  }
  for (i = 0; i < md_buf.length; i++) {
    md_buf[i] = 0
  }
  return {
    key: key,
    iv: iv
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var asn1 = __webpack_require__(243)
var aesid = __webpack_require__(242)
var fixProc = __webpack_require__(245)
var ciphers = __webpack_require__(49)
var compat = __webpack_require__(109)
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = new Buffer(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen)
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __webpack_require__(159);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(157);

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(81);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__(81);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var ciphers = __webpack_require__(164)
exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
var deciphers = __webpack_require__(163)
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
var modes = __webpack_require__(37)
function getCiphers () {
  return Object.keys(modes)
}
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(3);
var randomBytes = __webpack_require__(33);
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p);
  h.imul(q);
  m2.iadd(h);
  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var buffer = __webpack_require__(0);
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 52 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 53 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = true;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = __webpack_require__(29)
  , dPs         = __webpack_require__(189)
  , enumBugKeys = __webpack_require__(53)
  , IE_PROTO    = __webpack_require__(59)('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(95)('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(182).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 57 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(10).f
  , has = __webpack_require__(9)
  , TAG = __webpack_require__(20)('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(60)('keys')
  , uid    = __webpack_require__(42);
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(6)
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};

/***/ }),
/* 61 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(31);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var global         = __webpack_require__(6)
  , core           = __webpack_require__(18)
  , LIBRARY        = __webpack_require__(55)
  , wksExt         = __webpack_require__(64)
  , defineProperty = __webpack_require__(10).f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(20);

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var createHash = __webpack_require__(21);
var inherits = __webpack_require__(1)

var Transform = __webpack_require__(23).Transform

var ZEROS = new Buffer(128)
ZEROS.fill(0)

function Hmac(alg, key) {
  Transform.call(this)
  alg = alg.toLowerCase()
  if (typeof key === 'string') {
    key = new Buffer(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = createHash(alg).update(key).digest()

  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = new Buffer(blocksize)
  var opad = this._opad = new Buffer(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = createHash(alg).update(ipad)
}

inherits(Hmac, Transform)

Hmac.prototype.update = function (data, enc) {
  this._hash.update(data, enc)

  return this
}

Hmac.prototype._transform = function (data, _, next) {
  this._hash.update(data)

  next()
}

Hmac.prototype._flush = function (next) {
  this.push(this.digest())

  next()
}

Hmac.prototype.digest = function (enc) {
  var h = this._hash.digest()

  return createHash(this._alg).update(this._opad).update(h).digest(enc)
}

module.exports = function createHmac(alg, key) {
  return new Hmac(alg, key)
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.utils = __webpack_require__(216);
exports.Cipher = __webpack_require__(213);
exports.DES = __webpack_require__(214);
exports.CBC = __webpack_require__(212);
exports.EDE = __webpack_require__(215);


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(14);

/*<replacement>*/
var util = __webpack_require__(32);
util.inherits = __webpack_require__(1);
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



module.exports = Writable;

/*<replacement>*/
var processNextTick = __webpack_require__(67);
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__(32);
util.inherits = __webpack_require__(1);
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(266)
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = __webpack_require__(23);
  } catch (_) {} finally {
    if (!Stream) Stream = __webpack_require__(44).EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = __webpack_require__(0).Buffer;
/*<replacement>*/
var bufferShim = __webpack_require__(51);
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(14);

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(14);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = Buffer.isBuffer(chunk);

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    chunk = decodeChunk(state, chunk, encoding);
    if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(265).setImmediate))

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = __webpack_require__(0).Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 
 * 
 * @export
 * @class Heap
 */
var Heap = function () {
    function Heap() {
        var compare = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultCompre;
        (0, _classCallCheck3.default)(this, Heap);

        this.arr = [];
        this.compare = compare;
    }

    Heap.prototype.add = function add(elem) {
        this.arr.push(elem);

        if (this.arr.length === 1) return;

        this._upHeapAdjust((this.arr.length >> 1) - 1);
    };

    Heap.prototype.remove = function remove() {
        if (!this.arr.length) return;

        var heap = this.arr;
        // 
        var data = heap[0];
        // 
        heap[0] = heap[heap.length - 1];
        // 
        heap.pop();

        //
        if (heap.length > 1) this._downHeapAdjust(0);

        return data;
    };

    Heap.prototype.clear = function clear() {
        this.arr.length = 0;
    };

    // 


    Heap.prototype._upHeapAdjust = function _upHeapAdjust(parent) {
        var heap = this.arr;
        var len = heap.length;

        while (parent >= 0) {
            var leftChild = 2 * parent + 1;
            var rightChild = leftChild + 1;
            var max = leftChild;

            if (rightChild < len) {
                max = this.compare(heap[leftChild], heap[rightChild]) < 0 ? rightChild : leftChild;
            }

            // parent
            if (this.compare(heap[parent], heap[max]) < 0) {
                var temp = heap[parent];
                heap[parent] = heap[max];
                heap[max] = temp;

                // 
                parent = Math.ceil(parent / 2) - 1;
            } else break;
        }
    };

    // 


    Heap.prototype._downHeapAdjust = function _downHeapAdjust(parent) {
        var heap = this.arr;
        var len = heap.length;

        while (2 * parent + 1 < len) {
            var leftChild = 2 * parent + 1;
            var rightChild = leftChild + 1;
            var max = leftChild;

            if (rightChild < len) {
                max = this.compare(heap[leftChild], heap[rightChild]) < 0 ? rightChild : leftChild;
            }

            if (this.compare(heap[parent], heap[max]) < 0) {
                var temp = heap[parent];
                heap[parent] = heap[max];
                heap[max] = temp;

                parent = max;
            } else break;
        }
    };

    return Heap;
}();

exports.default = Heap;
;

function defaultCompre(a, b) {
    return a - b;
}

// var arr = [1, 0, 5, 4, 3];
// var heap = new Heap();
// for (let ele of arr) {
//     heap.add(ele);
// }
// console.log(`heap: ${heap.arr.join(',')}`);
// for (let ele of arr) {
//     heap.remove();
//     console.log(`heap: ${heap.arr.join(',')}`);
// }

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(35);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 
 *
 * 
 * 
 *
 * 
 */

var Node = function Node(data) {
    var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var next = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    (0, _classCallCheck3.default)(this, Node);

    this.data = data;
    this.prev = prev;
    this.next = next;
};

function defaultCompare(a, b) {
    return a === b;
}

var DoubleLinkedList = function () {
    function DoubleLinkedList() {
        var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var compare = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultCompare;
        (0, _classCallCheck3.default)(this, DoubleLinkedList);

        this.head = null;
        this.tail = null;
        this.size = 0;
        this.compare = compare;

        if (sqList && sqList.length) {
            for (var _iterator = sqList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var item = _ref;

                this.push(item);
            }
        }
    }

    DoubleLinkedList.prototype[Symbol.iterator] = _regenerator2.default.mark(function _callee() {
        var current;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        current = this.head;

                    case 1:
                        if (!current) {
                            _context.next = 7;
                            break;
                        }

                        _context.next = 4;
                        return current.data;

                    case 4:

                        current = current.next;
                        _context.next = 1;
                        break;

                    case 7:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    });

    DoubleLinkedList.prototype.clear = function clear() {
        this.head = null;
        this.tail = null;
        this.size = 0;

        return true;
    };

    DoubleLinkedList.prototype.push = function push(data) {
        if (typeof data === 'undefined') throw new Error('param data required');

        ++this.size;

        if (!this.head) {
            this.head = this.tail = new Node(data);
        } else {
            var node = new Node(data, this.tail, null);
            this.tail.next = node;
            this.tail = node;
        }

        return data;
    };

    DoubleLinkedList.prototype.unshift = function unshift(data) {
        if (typeof data === 'undefined') throw new Error('param data required');

        ++this.size;

        if (!this.head) {
            this.head = this.tail = new Node(data);
        } else {
            var node = new Node(data, null, this.head);
            this.head.prev = node;
            this.head = node;
        }

        return data;
    };

    DoubleLinkedList.prototype.pop = function pop() {
        if (!this.tail) {
            this.head = this.tail = null;
            return;
        }

        --this.size;

        var data = this.tail.data;

        this.tail.prev.next = null;
        this.tail = this.tail.prev;

        return data;
    };

    DoubleLinkedList.prototype.shift = function shift() {
        if (!this.head) {
            this.head = this.tail = null;
            return;
        }

        --this.size;

        var data = this.head.data;

        this.head.next.prev = null;
        this.head = this.head.next;

        return data;
    };

    /**
     * update the value of existing node by index
     * @param {Number} index 
     * @param {*} data 
     */


    DoubleLinkedList.prototype.update = function update(index, data) {
        var node = this.findByIndex(index, true);

        if (node) node.data = data;

        return !!node;
    };

    /**
     * Remove the first matched data
     * @param {*} data 
     */


    DoubleLinkedList.prototype.remove = function remove(data) {
        if (typeof data === 'function') throw new Error('Param data required');

        var current = this.head;

        while (current) {
            if (this.compare(data, current.data)) {
                --this.size;

                if (current === this.head) {
                    this.head = this.head.next;

                    if (this.head) {
                        this.head.prev = null;
                    } else {
                        this.head = this.tail = null;
                    }
                } else if (current === this.tail) {
                    this.tail = this.tail.prev;

                    if (this.tail) {
                        this.tail.next = null;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    current.prev.next = current.next;
                    current.next.prev = current.prev;
                }

                return current.data;
            }

            current = current.next;
        }

        return null;
    };

    DoubleLinkedList.prototype.indexOf = function indexOf(data) {
        var current = this.head;
        var index = -1;

        while (current) {
            ++index;
            if (this.compare(data, current.data)) return index;

            current = current.next;
        }

        return -1;
    };

    /**
     * find node or data by index
     * @param {Number} index 
     * @param {Boolean} returnNode true: return the node object; otherwise return data;
     */


    DoubleLinkedList.prototype.findByIndex = function findByIndex() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var returnNode = arguments[1];

        var current = this.head;
        var j = 0;

        while (current) {
            if (j++ === index) break;

            current = current.next;
        }

        return returnNode ? current : current ? current.data : null;
    };

    DoubleLinkedList.prototype.forEach = function forEach() {
        var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (typeof cb !== 'function') throw new Error('argument should be a function');

        var current = this.head;
        var index = 0;

        while (current) {
            cb(current.data, index++);

            current = current.next;
        }
    };

    DoubleLinkedList.prototype.toJSON = function toJSON() {
        var list = [];
        var current = this.head;

        while (current) {
            list.push(current.data);

            current = current.next;
        }

        return list;
    };

    DoubleLinkedList.prototype.toString = function toString() {
        return this.toJSON() + '';
    };

    (0, _createClass3.default)(DoubleLinkedList, [{
        key: 'length',
        get: function get() {
            return this.size;
        }
    }]);
    return DoubleLinkedList;
}();

// let a = new DoubleLinkedList([2, 3]);
// a.unshift(1);
// a.push(4);
// console.log(a.indexOf(4));
// console.log(a.findByIndex(2));

// for(let item of a){
//     console.log(item);
// }

// a.pop();
// a.shift();
// a.remove(2);
// a.remove(32);
// a.remove(3);


exports.default = DoubleLinkedList;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 
/*
 
 cur
 0
 
 
 */

var StaticLinkedList = function () {
    function StaticLinkedList(MAXSIZE) {
        (0, _classCallCheck3.default)(this, StaticLinkedList);

        this[-1] = { cur: 0 };
        this.length = 0;
        this.MAXSIZE = MAXSIZE + 1 || 1000;
    }

    /**
     * L1e
     * L
     * @param data
     */


    StaticLinkedList.prototype.find = function find(data) {
        var i = this[0].cur;
        while (i && this[i].data !== data) {
            i = this[i].cur;
        }
        return i;
    };
    /**
     * 
     * this[0].cur
     */


    StaticLinkedList.prototype.init = function init(len) {
        len = len ? len + 1 : this.MAXSIZE;
        for (var i = 0; i < len - 1; ++i) {
            this[i] = this[i] || { data: null, cur: null };
            this[i].cur = i + 1;
        }

        this[len - 1] = this[len - 1] || {};
        this[len - 1].cur = 0;
    };
    /**
     * 0
     * @returns {*}
     */


    StaticLinkedList.prototype.malloc = function malloc() {
        var i = this[-1].cur;
        if (typeof this[-1].cur !== 'undefined') this[-1].cur = this[i].cur;
        return i;
    };
    /**
     * k
     * @param k
     */


    StaticLinkedList.prototype.free = function free(k) {
        this[k].cur = this[0].cur;
        this[0].cur = k;
    };

    StaticLinkedList.prototype.create = function create(sqList) {
        // 
        this.init(sqList.length);
        // s
        var s = this.malloc();
        // rs
        var r = s;
        var m = sqList.length;

        // A
        for (var j = 0; j < m; ++j) {
            //
            var i = this.malloc();
            // A
            this[i].data = sqList[j];
            // 
            this[r].cur = i;
            ++this.length;
            r = i;
        }
        // 
        this[r].cur = 0;
    };

    // todo


    StaticLinkedList.prototype.add = function add(index, elem) {};

    StaticLinkedList.prototype.remove = function remove(index) {};

    return StaticLinkedList;
}();

/**
 * (A-B)U(B-A)
 * s
 * @returns {*}
 */


exports.default = StaticLinkedList;
function difference(sllist, arr1, arr2) {
    // 
    sllist.init();
    // s
    var s = sllist.malloc();
    // rs
    var r = s;
    // AB
    var m = arr1.length;
    var n = arr2.length;

    // A
    for (var j = 0; j < m; ++j) {
        //
        var i = sllist.malloc();
        // A
        sllist[i].data = arr1[j];
        // 
        sllist[r].cur = i;
        r = i;
    }
    // 
    sllist[r].cur = 0;

    // B
    // 
    for (var _j = 0; _j < n; ++_j) {
        var b = arr2[_j];
        var p = s;
        // k
        var k = sllist[s].cur;
        // 
        while (k !== sllist[r].cur && sllist[k].data !== b) {
            p = k;
            k = sllist[k].cur;
        }
        // rr
        if (k === sllist[r].cur) {
            var _i = sllist.malloc();
            sllist[_i].data = b;
            sllist[_i].cur = sllist[r].cur;
            sllist[r].cur = _i;

            // 
        } else {
            sllist[p].cur = sllist[k].cur;
            sllist.free(k);
            // r
            if (r === k) r = p;
        }
    }
}

var sl = new StaticLinkedList(10);
var ret = difference(sl, [1, 2, 3], [3, 4, 5]);
console.log(sl);

var test = new StaticLinkedList(10);
test.create([49, 38, 65, 97, 76, 13, 27, 49]);
console.log(test);

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(48);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(47);

var _inherits3 = _interopRequireDefault(_inherits2);

var _BinaryTree2 = __webpack_require__(24);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BSTNode = function (_BinaryTree) {
    (0, _inherits3.default)(BSTNode, _BinaryTree);

    function BSTNode() {
        (0, _classCallCheck3.default)(this, BSTNode);

        for (var _len = arguments.length, arg = Array(_len), _key = 0; _key < _len; _key++) {
            arg[_key] = arguments[_key];
        }

        return (0, _possibleConstructorReturn3.default)(this, _BinaryTree.call.apply(_BinaryTree, [this].concat(arg)));
    }

    /**
     * BST
     * @param {*} key
     * @returns {*}
     */


    BSTNode.prototype.search = function search(key) {
        if (this.data != null) {
            if (this.data === key) return this;else if (key < this.data) {
                if (this.leftChild) return this.leftChild.search(key);
            } else {
                if (this.rightChild) return this.rightChild.search(key);
            }
        }

        return null;
    };

    /**
     * BST
     * @param {*} key
     * @returns {*}
     */


    BSTNode.prototype.searchNonRecursive = function searchNonRecursive(key) {
        if (this.data == null) return null;

        var p = this;
        while (p && p.data !== key) {
            if (key < p.data) p = p.leftChild;else p = p.rightChild;
        }

        if (!p || key !== p.data) return null;else return p;
    };

    /**
     * BST
     * @param {*} key
     */


    BSTNode.prototype.insert = function insert(key) {
        if (this.data == null) {
            this.data = key;
            return;
        }
        if (key === this.data) return;

        var node = new BSTNode(key);
        if (key < this.data) {
            if (!this.leftChild) this.leftChild = node;
            this.leftChild.insert(key);
        } else {
            if (!this.rightChild) this.rightChild = node;
            this.rightChild.insert(key);
        }
    };

    /**
     * BST
     * @param {*} key
     */


    BSTNode.prototype.insertNonRecursive = function insertNonRecursive(key) {
        if (this.data == null) {
            this.data = key;
            return;
        }

        var p = this;
        var q = void 0;
        while (p) {
            if (p.data === key) return;
            // qp
            q = p;
            if (key < p.data) p = p.leftChild;else p = p.rightChild;
        }

        var node = new BSTNode(key);
        if (key < q.data) q.leftChild = node;else q.rightChild = node;
    };

    /**
     * BSTBST
     * @param {Array} arr
     * @param {Boolean|undefined} useNonRecursive 
     */


    BSTNode.prototype.createBST = function createBST(arr, useNonRecursive) {
        var i = void 0;
        if (useNonRecursive) {
            for (i = 0; i < arr.length; ++i) {
                this.insertNonRecursive(arr[i]);
            }
        } else {
            for (i = 0; i < arr.length; ++i) {
                this.insert(arr[i]);
            }
        }

        return this;
    };

    /**
     * 
     * @param {*} key 
     * @param {BSTNode} parent 
     * @returns {Boolean}
     */


    BSTNode.prototype.remove = function remove(key, parent) {
        // 
        if (this.data == null) return false;

        // 
        if (this.data === key) return deleteNode(this, parent);
        // 
        else if (key < this.data) {
                if (this.leftChild) return this.leftChild.remove(key, this);
            }
            // 
            else {
                    if (this.rightChild) return this.rightChild.remove(key, this);
                }

        // 
        return false;
    };

    /**
     * 
     * @param {*} key 
     * @returns {boolean}
     */


    BSTNode.prototype.removeNonRecursive = function removeNonRecursive(key) {
        var p = this;
        var f = void 0;

        while (p && p.data !== key) {
            f = p;
            if (key < p.data) p = p.leftChild;else p = p.rightChild;
        }

        // 
        if (!p) return false;

        // p
        var s = p;
        var q = void 0;
        // 
        if (p.leftChild && p.rightChild) {
            f = p;
            s = p.leftChild;

            // 
            while (s.rightChild) {
                f = s;
                s = s.rightChild;
            }

            p.data = s.data;
        }

        // s
        if (s.leftChild) q = s.leftChild;else q = s.rightChild;

        // 
        if (!f) this.data = null;else if (f.leftChild == s) f.leftChild = q;else f.rightChild = q;

        return true;
    };

    /**
     * xx
     * @param {String|Number} x
     * @returns {Array} [min, max]
     */


    BSTNode.prototype.findNeighborElem = function findNeighborElem(x) {
        var last = typeof this.data === 'number' ? -Infinity : 'a';
        var ret = [];

        void function recurse(tree, x) {
            if (tree.leftChild) recurse(tree.leftChild, x);
            if (last < x && tree.data >= x) ret[0] = last;
            if (last <= x && tree.data > x) ret[1] = tree.data;
            last = tree.data;
            if (tree.rightChild) recurse(tree.rightChild, x);
        }(this, x);

        return ret;
    };

    /**
     * bst
     * @param {BSTNode} bst
     */


    BSTNode.prototype.merge = function merge(bst) {
        if (bst.leftChild) this.merge(bst.leftChild);
        if (bst.rightChild) this.merge(bst.rightChild);
        this.insert(bst.data);
    };

    /**
     * 
     * @param {BSTNode} node 
     */


    BSTNode.prototype.insertNode = function insertNode(node) {
        if (this.data == null) {
            this.data = node.data;
        } else {
            if (node.data > this.data) {
                if (!this.rightChild) this.rightChild = node;else this.rightChild.insertNode(node);
            } else if (node.data < this.data) {
                if (!this.leftChild) this.leftChild = node;else this.leftChild.insertNode(node);
            }
        }

        node.leftChild = node.rightChild = null;
    };

    /**
     * 
     * @param {*} x
     * @returns {BSTNode[a, b]} axbx
     */


    BSTNode.prototype.split = function split(x) {
        var a = new BSTNode();
        var b = new BSTNode();

        void function split(tree, x) {
            if (tree.leftChild) split(tree.leftChild, x);
            if (tree.rightChild) split(tree.rightChild, x);
            if (tree.data <= x) a.insertNode(tree);else b.insertNode(tree);
        }(this, x);

        return [a, b];
    };

    /**
     * tree
     * @param tree
     */


    BSTNode.isBSTTree = function isBSTTree(tree) {
        var last = typeof tree.data === 'number' ? -Infinity : 'a';
        var flag = true;

        void function isBSTTree(tree) {
            if (tree.leftChild && flag) isBSTTree(tree.leftChild);
            if (tree.data < last) flag = false;
            last = tree.data;
            if (tree.rightChild && flag) isBSTTree(tree.rightChild);
        }(tree);

        return flag;
    };

    return BSTNode;
}(_BinaryTree2.BinaryTree);

/**
 * 
 * @param {BSTNode} p 
 * @param {BSTNode} parent 
 * @returns {boolean} 
 */
/*
 

 
 


 (BST)

 (Binary Sort TreeBinary Search Tree) 
 (1) ()
 (2) ()
 (3) 
 


 BST
 1  
 K 
  KBST
  KBST

 ASL(n)()


 BST

 BSTBST

 1 
 BSTxBSTxBSTxT
   
   x.key<T->keyxT
   x.key>T->keyxT

 BST
 BST


 BST

 1  
 BSTBSTpf 
   p p
   p()p()pfpfpfpfpf
  p 
   pppsp(sp)ssps
  pppsp(sp)ssps

 */

exports.default = BSTNode;
function deleteNode(p, parent) {
    // 
    if (!p.leftChild && !p.rightChild) {
        // 
        var pos = parent && parent.leftChild == p ? 'leftChild' : 'rightChild';
        if (parent) parent[pos] = null;
        // 
        else p.data = null;
    }
    // 
    else if (!p.rightChild) {
            p.data = p.leftChild.data;
            p.leftChild = p.leftChild.leftChild;
        }
        // 
        else if (!p.leftChild) {
                p.data = p.rightChild.data;
                p.rightChild = p.rightChild.rightChild;
            }
            // 
            else {
                    var s = p.leftChild;
                    // q
                    var q = p;
                    // 
                    while (s.rightChild) {
                        q = s;
                        s = s.rightChild;
                    }

                    p.data = s.data;
                    if (q != p) q.rightChild = s.leftChild;else q.leftChild = s.leftChild;
                }

    return true;
}

var bst = new BSTNode();
bst.createBST([45, 24, 53, 12, 24, 90]);
console.log(bst.search(12));
console.log(bst.search(13));

var bst2 = new BSTNode();
bst2.createBST([45, 24, 53, 12, 24, 90], true);
console.log(bst2.searchNonRecursive(12));
console.log(bst2.searchNonRecursive(13));

console.log('\nfindSiblingElem: ');
console.log(bst.findNeighborElem(12) + '');
console.log(bst.findNeighborElem(90) + '');
console.log(bst.findNeighborElem(45) + '');

console.log(bst.remove(45));
console.log(bst.remove(1));
console.log(bst.remove(53));
console.log(bst.remove(12));
console.log(bst.remove(90));
console.log(bst.remove(24));
console.log(bst.remove(2));

//console.log(bst2.removeNonRecursive(45));
//console.log(bst2.removeNonRecursive(1));
//console.log(bst2.removeNonRecursive(53));
//console.log(bst2.removeNonRecursive(12));
//console.log(bst2.removeNonRecursive(90));
//console.log(bst2.removeNonRecursive(24));
//console.log(bst2.removeNonRecursive(2));

console.log('\nisBSTTree: ');
console.log(BSTNode.isBSTTree(bst));
//console.log(BSTNode.isBSTTree(sosTree));


/**
 * x
 * @param bst
 * @param x
 */
function printNotLessThan(bst, x) {
    if (bst.rightChild) printNotLessThan(bst.rightChild, x);
    if (bst.data < x) return;
    console.log(bst.data);
    if (bst.leftChild) printNotLessThan(bst.leftChild, x);
}

console.log('\nprintNotLessThan: ');
printNotLessThan(bst2, 90);
console.log('\n');
printNotLessThan(bst2, 12);

bst.merge(bst2);

var a1 = new BSTNode(5);
var a2 = new BSTNode(91);
bst2.insertNode(a1);
bst2.insertNode(a2);

bst2.split(45);

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bubbleSort = bubbleSort;
exports.bubbleSort2 = bubbleSort2;
exports.cockTailSort = cockTailSort;
exports.cockTailSort2 = cockTailSort2;
exports.quickSortRecursive = quickSortRecursive;
exports.quickSortRecursive2 = quickSortRecursive2;
exports.quickSortNonRecursive = quickSortNonRecursive;
exports.quickSort = quickSort;
exports.oddEvenSort = oddEvenSort;

var _defaultComparision = __webpack_require__(34);

var _defaultComparision2 = _interopRequireDefault(_defaultComparision);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 

 (Bubble Sort)

 
 1  
 ()
      L->R[1]L->R[2](L->R[1]L->R[2])L->R[2]L->R[3]L->R[n-1]L->R[n]L->R[n]
       n-1
 iL->R[1  n-i+1]nn-1

 2  
 923, 38, 22, 45, 23, 67, 31, 15, 41

 :  23    38     22     45     23     67     31     15    41
 :    23    22     38     23     45     31     15     41    67
 :    22    23     23     38     31     15     41     45    67
 :    22    23     23     31     15     38     41     45    67
 :    22    23     23     15     31     38     41     45    67
 :    22    23     15     23     31     38     41     45    67
 :    22    15     23     23     31     38     41     45    67
 :    15    22     23     23     31     38     41     45    67

3.
 
   ()n-10
   ()
  n * (n - 1) / 2
  3*n*(n - 1) / 2

 T(n)=O(n)
 S(n)=O(1)

 */

function bubbleSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    for (var i = 1, len = sqList.length; i < len; ++i) {
        var change = 0;

        for (var j = 0; j <= len - i; ++j) {
            if (comp(sqList[j + 1], sqList[j]) < 0) {
                change = 1;
                var temp = sqList[j];
                sqList[j] = sqList[j + 1];
                sqList[j + 1] = temp;
            }
        }

        if (!change) break;
    }
} /**
   * Created by Luke on 2015/2/2.
   */

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
bubbleSort(arr);
console.log('bubbleSort:\n' + arr + '');

// 1
function bubbleSort2(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var len = sqList.length;
    var change = len - 1;

    while (change) {
        var c = 0;
        for (var i = 0; i < change; ++i) {
            if (comp(sqList[i], sqList[i + 1]) > 0) {
                var temp = sqList[i];
                sqList[i] = sqList[i + 1];
                sqList[i + 1] = temp;
                // c
                c = i + 1;
            }
        }

        change = c;
    }
}

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
bubbleSort2(arr);
console.log('bubbleSort2:\n' + arr + '');

// 
function cockTailSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var len = sqList.length;
    // 
    var low = 0,
        high = len - 1;
    var change = 1;
    var temp = void 0;

    while (low < high && change) {
        change = 0;

        // 
        for (var i = low; i < high; ++i) {
            if (comp(sqList[i], sqList[i + 1]) > 0) {
                temp = sqList[i];
                sqList[i] = sqList[i + 1];
                sqList[i + 1] = temp;
                change = 1;
            }
        }
        // 
        --high;

        // 
        for (var _i = high; _i > low; --_i) {
            if (comp(sqList[_i], sqList[_i - 1]) < 0) {
                temp = sqList[_i];
                sqList[_i] = sqList[_i - 1];
                sqList[_i - 1] = temp;
                change = 1;
            }
        }
        // 
        ++low;
    }
}

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
cockTailSort(arr);
console.log('cockTailSort:\n' + arr + '');

// 3
function cockTailSort2(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var b = {};
    var len = sqList.length;
    // d 1-1
    var d = 1;
    // b[0]b[2]b[1]
    b[0] = 0;
    b[2] = len - 1;
    var change = 1;

    while (b[0] < b[2] && change) {
        change = 0;

        // 
        for (var i = b[1 - d]; i !== b[1 + d]; i += d) {
            // 
            if (comp(sqList[i], sqList[i + d]) * d > 0) {
                var temp = sqList[i];
                sqList[i] = sqList[i + d];
                sqList[i + d] = temp;
                change = 1;
            }
        }

        // 
        b[1 + d] -= d;
        // 
        d *= -1;
    }
}

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
cockTailSort2(arr);
console.log('cockTailSort2:\n' + arr + '');

/*
 

 1  
 

 2  
 R[st] (R[s])()R[s].key
      R[s]
      R[s]
 R[s].keyiR[st]

 3  
 

 lowhigh1
 iji=lowj=highR[low].key(R[low]temp) 
  jtempR[j].key
     tempR[j].key j=j-1 i=jtemp>R[j].key
     temp>R[j].key R[j]R[i]R[j] i=i+1
  itempR[i].key
     tempR[i].key i=i+1 i=jtemp<R[i].key
     temp<R[i].key R[i]R[j]R[i] j=j-1
  i=jitemp()

 
 kk-1 nC(n)C(n)=n-1+C(k)+C(n-k-1) 
   
 C(n)<=hn+2hC(n/2h) n/2h=1
 C(n)O(n2n) 
   n-1()
 :  C(n)=O(n2)
    nT(n)
      nnC C
      
        Tavg(n)=C(n)+Tavg(k-1)+Tavg(n-k)          

 T(n)=O(n2n)
 [2n]+1 

 S(n)=O(2n)
 

 */

function partition1(sqList, low, high) {
    var temp = sqList[low];

    while (low < high) {
        while (low < high && sqList[high] >= temp) {
            --high;
        }sqList[low] = sqList[high];
        while (low < high && sqList[low] <= temp) {
            ++low;
        }sqList[high] = sqList[low];
    }

    sqList[low] = temp;

    return low;
}

//  partition
// T(n)=O(n2n)
function partition2(sqList, low, high) {
    var temp = void 0;
    var n = high - low + 1;
    var rand = Math.floor(Math.random() * n) + low;

    //let rand = (low + high) >> 1;
    temp = sqList[high];
    sqList[high] = sqList[rand];
    sqList[rand] = temp;

    var i = low - 1;
    var pivot = sqList[high];

    for (var j = low; j < high; ++j) {
        if (sqList[j] <= pivot) {
            ++i;
            temp = sqList[i];
            sqList[i] = sqList[j];
            sqList[j] = temp;
        }
    }

    ++i;
    sqList[high] = sqList[i];
    sqList[i] = pivot;

    return i;
}

function partition(sqList, low, high, comp) {
    var temp = void 0;
    var i = low;
    var j = high + 1;
    var rand = Math.floor(Math.random() * (high - low)) + low + 1;
    //let rand = (low + high) >> 1;

    temp = sqList[low];
    sqList[low] = sqList[rand];
    sqList[rand] = temp;

    var x = sqList[low];

    while (1) {
        while (comp(sqList[++i], x) < 0 && i < high) {}
        while (comp(sqList[--j], x) > 0) {}
        if (i >= j) break;
        temp = sqList[i];
        sqList[i] = sqList[j];
        sqList[j] = temp;
    }

    sqList[low] = sqList[j];
    sqList[j] = x;

    return j;
}

function quickSortRecursive() {
    var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var low = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var high = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sqList.length - 1;
    var comp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _defaultComparision2.default;

    if (low >= high) return;

    var k = partition(sqList, low, high, comp);
    quickSortRecursive(sqList, low, k - 1, comp);
    quickSortRecursive(sqList, k + 1, high, comp);
}

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
quickSortRecursive(arr);
console.log('quickSortRecursive:\n' + arr + '');

/*
O(logn)
 */
function quickSortRecursive2() {
    var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var low = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var high = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sqList.length - 1;
    var comp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _defaultComparision2.default;

    while (low < high) {
        var k = partition(sqList, low, high, comp);

        // 
        // 
        // 
        // O(logn)
        if (k - low + 1 < high - k) {
            quickSortRecursive2(sqList, low, k - 1, comp);
            low = k + 1;
        } else {
            quickSortRecursive2(sqList, k + 1, high, comp);
            high = k - 1;
        }
    }
}
var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
quickSortRecursive2(arr);
console.log('quickSortRecursive2:\n' + arr + '');

function quickSortNonRecursive() {
    var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var low = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var high = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sqList.length - 1;
    var comp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _defaultComparision2.default;

    var stack = [];
    var k = void 0;

    do {
        while (low < high) {
            k = partition(sqList, low, high, comp);
            // ,
            stack.push(high, k + 1);
            //stack.push(k + 1);
            high = k - 1;
        }

        if (!stack.length) return;

        low = stack.pop();
        high = stack.pop();
    } while (1);
}

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
quickSortNonRecursive(arr);
console.log('quickSortNonRecursive:\n' + arr + '');

// 
function quickSort() {
    var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var low = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var high = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sqList.length - 1;
    var comp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _defaultComparision2.default;

    var stack = [];
    var pivot = void 0;

    do {
        // 3
        if (high - low > 2) {
            // 
            pivot = partition(sqList, low, high, comp);

            // 
            // 
            if (high - pivot > pivot - low) {
                stack.push(high, pivot + 1);
                //stack.push();
                high = pivot - 1;
            } else {
                stack.push(pivot - 1, low);
                //stack.push();
                low = pivot + 1;
            }
        }
        // 3
        // 
        else if (low < high && high - low < 3) {
                easySort(sqList, low, high, comp);
                low = high;
            }
            // 
            // 
            else {
                    if (!stack.length) return;

                    low = stack.pop();
                    high = stack.pop();
                }
    } while (1);
}

function easySort(sqList, low, high, comp) {
    var temp = void 0;

    if (high - low === 1) {
        if (comp(sqList[low], sqList[high]) > 0) {
            temp = sqList[low];
            sqList[low] = sqList[high];
            sqList[high] = temp;
        }
    } else {
        if (comp(sqList[low], sqList[low + 1]) > 0) {
            temp = sqList[low];
            sqList[low] = sqList[low + 1];
            sqList[low + 1] = temp;
        }
        if (comp(sqList[low + 1], sqList[high]) > 0) {
            temp = sqList[low + 1];
            sqList[low + 1] = sqList[high];
            sqList[high] = temp;
        }
        if (comp(sqList[low], sqList[low + 1]) > 0) {
            temp = sqList[low];
            sqList[low] = sqList[low + 1];
            sqList[low + 1] = temp;
        }
    }
}

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
quickSort(arr);
console.log('quickSort:\n' + arr + '');

// 
function oddEvenSort() {
    var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var change = 1;
    var temp = void 0;
    var len = sqList.length;

    while (change) {
        change = 0;
        // 
        for (var i = 1; i < len - 1; i += 2) {
            if (comp(sqList[i], sqList[i + 1]) > 0) {
                temp = sqList[i];
                sqList[i] = sqList[i + 1];
                sqList[i + 1] = temp;

                change = 1;
            }
        }

        // 
        for (var _i2 = 0; _i2 < len - 1; _i2 += 2) {
            if (comp(sqList[_i2], sqList[_i2 + 1]) > 0) {
                temp = sqList[_i2];
                sqList[_i2] = sqList[_i2 + 1];
                sqList[_i2 + 1] = temp;

                change = 1;
            }
        }
    }
}

var arr = [23, 38, 22, 45, 23, 67, 31, 15, 41];
oddEvenSort(arr);
console.log('oddEvenSort:\n' + arr + '');

/*


jikj
 */
var RED = 0;
var WHITE = 1;
var BLUE = 2;

function flagArrange(colors) {
    var i = 0;
    var j = 0;
    var k = colors.length - 1;
    var temp = void 0;

    while (j <= k) {
        switch (colors[j]) {
            case RED:
                temp = colors[i];
                colors[i] = colors[j];
                colors[j] = temp;
                ++i;
                ++j;
                break;
            case WHITE:
                ++j;
                break;
            case BLUE:
                temp = colors[j];
                colors[j] = colors[k];
                colors[k] = temp;
                --k;
                break;
            default:
                break;
        }
    }
}

var arr = [2, 1, 0, 2, 1, 1, 0, 2, 0, 2, 1];
flagArrange(arr);
console.log(arr + '');

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(1);
var Reporter = __webpack_require__(27).Reporter;
var Buffer = __webpack_require__(0).Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = __webpack_require__(151);


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(1);

var asn1 = __webpack_require__(26);
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
                                                    options) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    var tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(1);
var Buffer = __webpack_require__(0).Buffer;

var asn1 = __webpack_require__(26);
var base = asn1.base;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(35);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 
 */

var Node = function Node() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _classCallCheck3.default)(this, Node);

    this.data = data;
    this.next = next;
};

var LinkedList = function () {
    function LinkedList() {
        var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        (0, _classCallCheck3.default)(this, LinkedList);

        this.head = null;
        this.tail = null;

        if (sqList) {
            for (var i = 0, len = sqList.length; i < len; ++i) {
                this.push(sqList[i]);
            }
        }
    }

    /**
     * merge list, note: this operation will delete a and b nodes.
     * @param {LinkedList} a 
     * @param {LinkedList} b
     * @param {*} compare 
     */


    LinkedList.mergeList = function mergeList(a, b) {
        var compare = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : compFn;

        var ha = a.head;
        var hb = b.head;
        var pa = ha;
        var pb = hb;
        var c = new LinkedList();
        var q = void 0;

        while (pa && pb) {
            var data1 = pa.data;
            var data2 = pb.data;

            if (!compare(data1, data2)) {
                // delete head node
                q = a.shift();
                // append the node to c linkedList
                c.append(q);
                pa = a.head;
            } else {
                q = b.shift();
                c.append(q);
                pb = b.head;
            }
        }

        if (pa) {
            c.append(pa);
            c.tail = a.tail;
        } else {
            c.append(pb);
            c.tail = b.tail;
        }

        return c;
    };

    /**
     * remove the first element and return it
     */


    LinkedList.prototype.shift = function shift() {
        var head = this.head;
        this.head = this.head.next;
        head.next = null;

        if (this.head === null) this.tail = null;
        return head;
    };

    /**
     * remove the last element and return it
     */


    LinkedList.prototype.pop = function pop() {
        var current = this.head;
        var previous = this.head;
        var elem = void 0;

        while (current !== null) {
            if (this.tail === current) {
                if (current === this.head) {
                    elem = this.tail.data;
                    this.head = null;
                    break;
                }

                this.tail = previous;

                previous.next = current.next;
                elem = current.data;
                break;
            }

            previous = current;
            current = current.next;
        }

        if (this.head === null) this.tail = null;

        return elem ? elem : false;
    };

    /**
     * append node
     * @param {Node} node 
     */


    LinkedList.prototype.append = function append(node) {
        if (this.head !== null) {
            this.tail.next = node;
            this.tail = this.tail.next;
        } else {
            this.head = node;
            this.tail = node;
        }
    };

    /**
     * add data
     * @param {*} data 
     */


    LinkedList.prototype.push = function push(data) {
        if (this.head === null) {
            this.head = new Node(data);
            this.tail = this.head;
        } else {
            this.tail.next = new Node(data);
            this.tail = this.tail.next;
        }

        this.tail.data = data;
    };

    /**
     * remove data
     * @param {*} data 
     */


    LinkedList.prototype.remove = function remove(data) {
        var current = this.head;
        var previous = this.head;
        var elem = void 0;

        while (current !== null) {
            if (data === current.data) {
                if (current === this.head) {
                    this.head = current.next;
                    elem = current.data;
                    break;
                }

                if (current === this.tail) this.tail = previous;

                previous.next = current.next;
                elem = current.data;
                break;
            }

            previous = current;
            current = current.next;
        }

        if (this.head === null) this.tail = null;

        return elem ? elem : false;
    };

    /**
     * find the index of matched data 
     * @param {*} data 
     */


    LinkedList.prototype.indexOf = function indexOf(data) {
        var current = this.head;
        var index = -1;
        while (current !== null) {
            ++index;
            if (current.data === data) {
                return index;
            }

            current = current.next;
        }

        return index;
    };

    /**
     * add data to the front
     * @param {*} data 
     */


    LinkedList.prototype.unshift = function unshift(data) {
        var temp = new Node(data);
        temp.next = this.head;
        this.head = temp;
    };

    /**
     * 
     * @param {*} target 
     * @param {*} data 
     */


    LinkedList.prototype.insertAfter = function insertAfter(target, data) {
        var current = this.head;
        while (current !== null) {
            if (current.data === target) {
                var temp = new Node(data);
                temp.next = current.next;

                if (current === this.tail) this.tail = temp;

                current.next = temp;
                return;
            }

            current = current.next;
        }
    };

    LinkedList.prototype.item = function item(index) {
        var current = this.head;

        while (current !== null) {
            if (--index === 0) return current;

            current = current.next;
        }

        return null;
    };

    LinkedList.prototype.forEach = function forEach(callback) {
        if (typeof callback !== 'function') return;

        for (var current = this.head, index = 0; current; current = current.next) {
            if (callback(current.data, index++)) break;
        }
    };

    LinkedList.prototype[Symbol.iterator] = _regenerator2.default.mark(function _callee() {
        var current;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        current = this.head;

                    case 1:
                        if (!current) {
                            _context.next = 7;
                            break;
                        }

                        _context.next = 4;
                        return current.data;

                    case 4:
                        current = current.next;
                        _context.next = 1;
                        break;

                    case 7:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    });

    LinkedList.prototype.toString = function toString() {
        var str = '';

        this.forEach(function (node) {
            str += node.data + (node.next ? ',' : '');
        });

        return str;
    };

    /**
     * insert element by order
     * @param {*} data 
     * @param {Function} cmp 
     */


    LinkedList.prototype.orderInsert = function orderInsert(data, cmp) {
        cmp = typeof cmp === 'function' ? cmp : function (a, b) {
            if (a > b) return 1;else if (a === b) return 0;else return -1;
        };
        var previous = this.head;
        var current = this.head;

        if (current === null) {
            this.head = this.tail = new Node(data);
            return;
        }

        var me = this;
        while (current) {
            var ret = cmp(data, current.data);
            // 
            if (ret > 0) {
                previous = current;
                current = current.next;

                // 
            } else if (ret === 0) {
                return insertBetween(data, previous, current);

                // 
                // 
            } else {
                if (this.head === previous && previous === current) return this.unshift(data);else return insertBetween(data, previous, current);
            }
        }

        // 
        previous.next = new Node(data);
        this.tail = previous.next;

        function insertBetween(data, a, b) {
            if (a == b) {
                if (a == me.head) return me.unshift(data);
            } else {
                var temp = new Node(data);
                temp.next = b;
                a.next = temp;
                return true;
            }
        }
    };

    // minmax


    LinkedList.prototype.deleteBetween = function deleteBetween(min, max) {
        var p = this.head;

        // pmin
        while (p.next && p.next.data <= min) {
            p = p.next;
        } // min
        var q = void 0;
        if (p.next) {
            q = p.next;
            // qmax
            while (q && q.data < max) {
                q = q.next;
            }p.next = q;
        }

        var last = q || p;
        while (last.next) {
            last = last.next;
        }this.tail = last;
    };

    // 


    LinkedList.prototype.deleteEqual = function deleteEqual() {
        var p = this.head;
        var q = p.next;

        while (p.next) {
            // p,q
            if (p.data !== q.data) {
                p = p.next;
                q = p.next;
            } else {
                while (q.data === p.data) {
                    q = q.next;
                } // 
                p.next = q;
                p = q;
                q = p.next;
            }
        }
    };

    LinkedList.prototype.reverse = function reverse() {
        var p = this.head;
        var q = p.next;
        var s = q.next;
        this.tail = p;
        p.next = null;

        while (s.next) {
            q.next = p;
            p = q;
            q = s;
            s = s.next;
        }

        q.next = p;
        s.next = q;
        this.head = s;
    };

    (0, _createClass3.default)(LinkedList, [{
        key: 'size',
        get: function get() {
            var current = this.head;
            var size = 0;

            while (current !== null) {
                ++size;
                current = current.next;
            }

            return size;
        }
    }]);
    return LinkedList;
}();

exports.default = LinkedList;


function compFn(a, b) {
    return a - b;
}

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(161);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(160);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(271);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(36)
var Transform = __webpack_require__(17)
var inherits = __webpack_require__(1)
var GHASH = __webpack_require__(165)
var xor = __webpack_require__(28)
inherits(StreamCipher, Transform)
module.exports = StreamCipher

function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])])
  iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])])
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  iv.copy(this._prev)
  this._mode = mode
  var h = new Buffer(4)
  h.fill(0)
  this._ghash = new GHASH(this._cipher.encryptBlock(h))
  this._authTag = null
  this._called = false
}
StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = new Buffer(rump)
      rump.fill(0)
      this._ghash.update(rump)
    }
  }
  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}
StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) {
    throw new Error('Unsupported state or unable to authenticate data')
  }
  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt) {
    if (xorTest(tag, this._authTag)) {
      throw new Error('Unsupported state or unable to authenticate data')
    }
  } else {
    this._authTag = tag
  }
  this._cipher.scrub()
}
StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
    return this._authTag
  } else {
    throw new Error('Attempting to get auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (this._decrypt) {
    this._authTag = tag
  } else {
    throw new Error('Attempting to set auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (!this._called) {
    this._ghash.update(buf)
    this._alen += buf.length
  } else {
    throw new Error('Attempting to set AAD in unsupported state')
  }
}
function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) {
    out++
  }
  var len = Math.min(a.length, b.length)
  var i = -1
  while (++i < len) {
    out += (a[i] ^ b[i])
  }
  return out
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(28)

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(28)

exports.encrypt = function (self, data, decrypt) {
  var out = new Buffer('')
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = new Buffer('')
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}
function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}
function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = new Buffer(buffer.length)
  buffer = Buffer.concat([buffer, new Buffer([value])])
  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }
  return out
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam
  self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])])
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 88 */
/***/ (function(module, exports) {

exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}
exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(28)

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(36)
var Transform = __webpack_require__(17)
var inherits = __webpack_require__(1)

inherits(StreamCipher, Transform)
module.exports = StreamCipher
function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  iv.copy(this._prev)
  this._mode = mode
}
StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}
StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 91 */
/***/ (function(module, exports) {

module.exports = {
	"sha224WithRSAEncryption": {
		"sign": "rsa",
		"hash": "sha224",
		"id": "302d300d06096086480165030402040500041c"
	},
	"RSA-SHA224": {
		"sign": "ecdsa/rsa",
		"hash": "sha224",
		"id": "302d300d06096086480165030402040500041c"
	},
	"sha256WithRSAEncryption": {
		"sign": "rsa",
		"hash": "sha256",
		"id": "3031300d060960864801650304020105000420"
	},
	"RSA-SHA256": {
		"sign": "ecdsa/rsa",
		"hash": "sha256",
		"id": "3031300d060960864801650304020105000420"
	},
	"sha384WithRSAEncryption": {
		"sign": "rsa",
		"hash": "sha384",
		"id": "3041300d060960864801650304020205000430"
	},
	"RSA-SHA384": {
		"sign": "ecdsa/rsa",
		"hash": "sha384",
		"id": "3041300d060960864801650304020205000430"
	},
	"sha512WithRSAEncryption": {
		"sign": "rsa",
		"hash": "sha512",
		"id": "3051300d060960864801650304020305000440"
	},
	"RSA-SHA512": {
		"sign": "ecdsa/rsa",
		"hash": "sha512",
		"id": "3051300d060960864801650304020305000440"
	},
	"RSA-SHA1": {
		"sign": "rsa",
		"hash": "sha1",
		"id": "3021300906052b0e03021a05000414"
	},
	"ecdsa-with-SHA1": {
		"sign": "ecdsa",
		"hash": "sha1",
		"id": ""
	},
	"sha256": {
		"sign": "ecdsa",
		"hash": "sha256",
		"id": ""
	},
	"sha224": {
		"sign": "ecdsa",
		"hash": "sha224",
		"id": ""
	},
	"sha384": {
		"sign": "ecdsa",
		"hash": "sha384",
		"id": ""
	},
	"sha512": {
		"sign": "ecdsa",
		"hash": "sha512",
		"id": ""
	},
	"DSA-SHA": {
		"sign": "dsa",
		"hash": "sha1",
		"id": ""
	},
	"DSA-SHA1": {
		"sign": "dsa",
		"hash": "sha1",
		"id": ""
	},
	"DSA": {
		"sign": "dsa",
		"hash": "sha1",
		"id": ""
	},
	"DSA-WITH-SHA224": {
		"sign": "dsa",
		"hash": "sha224",
		"id": ""
	},
	"DSA-SHA224": {
		"sign": "dsa",
		"hash": "sha224",
		"id": ""
	},
	"DSA-WITH-SHA256": {
		"sign": "dsa",
		"hash": "sha256",
		"id": ""
	},
	"DSA-SHA256": {
		"sign": "dsa",
		"hash": "sha256",
		"id": ""
	},
	"DSA-WITH-SHA384": {
		"sign": "dsa",
		"hash": "sha384",
		"id": ""
	},
	"DSA-SHA384": {
		"sign": "dsa",
		"hash": "sha384",
		"id": ""
	},
	"DSA-WITH-SHA512": {
		"sign": "dsa",
		"hash": "sha512",
		"id": ""
	},
	"DSA-SHA512": {
		"sign": "dsa",
		"hash": "sha512",
		"id": ""
	},
	"DSA-RIPEMD160": {
		"sign": "dsa",
		"hash": "rmd160",
		"id": ""
	},
	"ripemd160WithRSA": {
		"sign": "rsa",
		"hash": "rmd160",
		"id": "3021300906052b2403020105000414"
	},
	"RSA-RIPEMD160": {
		"sign": "rsa",
		"hash": "rmd160",
		"id": "3021300906052b2403020105000414"
	},
	"md5WithRSAEncryption": {
		"sign": "rsa",
		"hash": "md5",
		"id": "3020300c06082a864886f70d020505000410"
	},
	"RSA-MD5": {
		"sign": "rsa",
		"hash": "md5",
		"id": "3020300c06082a864886f70d020505000410"
	}
};

/***/ }),
/* 92 */
/***/ (function(module, exports) {

module.exports = {
	"1.3.132.0.10": "secp256k1",
	"1.3.132.0.33": "p224",
	"1.2.840.10045.3.1.1": "p192",
	"1.2.840.10045.3.1.7": "p256",
	"1.3.132.0.34": "p384",
	"1.3.132.0.35": "p521"
};

/***/ }),
/* 93 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(178);
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(31)
  , document = __webpack_require__(6).document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(8) && !__webpack_require__(39)(function(){
  return Object.defineProperty(__webpack_require__(95)('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY        = __webpack_require__(55)
  , $export        = __webpack_require__(30)
  , redefine       = __webpack_require__(102)
  , hide           = __webpack_require__(19)
  , has            = __webpack_require__(9)
  , Iterators      = __webpack_require__(54)
  , $iterCreate    = __webpack_require__(185)
  , setToStringTag = __webpack_require__(58)
  , getPrototypeOf = __webpack_require__(191)
  , ITERATOR       = __webpack_require__(20)('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var pIE            = __webpack_require__(57)
  , createDesc     = __webpack_require__(41)
  , toIObject      = __webpack_require__(11)
  , toPrimitive    = __webpack_require__(62)
  , has            = __webpack_require__(9)
  , IE8_DOM_DEFINE = __webpack_require__(96)
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(8) ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = __webpack_require__(101)
  , hiddenKeys = __webpack_require__(53).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};

/***/ }),
/* 100 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var has          = __webpack_require__(9)
  , toIObject    = __webpack_require__(11)
  , arrayIndexOf = __webpack_require__(180)(false)
  , IE_PROTO     = __webpack_require__(59)('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(19);

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = __webpack_require__(208);

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

exports.UINT32 = __webpack_require__(210)
exports.UINT64 = __webpack_require__(211)

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var randomBytes = __webpack_require__(33);
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = __webpack_require__(3);
var TWENTYFOUR = new BN(24);
var MillerRabin = __webpack_require__(107);
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}


/***/ }),
/* 106 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var bn = __webpack_require__(3);
var brorand = __webpack_require__(82);

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._rand = function _rand(n) {
  var len = n.bitLength();
  var buf = this.rand.generate(Math.ceil(len / 8));

  // Set low bits
  buf[0] |= 3;

  // Mask high bits
  var mask = len & 0x7;
  if (mask !== 0)
    buf[buf.length - 1] >>= 7 - mask;

  return new bn(buf);
}

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  var n2 = n1.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._rand(n2);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  var n2 = n1.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._rand(n2);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, Buffer) {var createHmac = __webpack_require__(65)
var checkParameters = __webpack_require__(246)

exports.pbkdf2 = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  checkParameters(iterations, keylen)
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')

  setTimeout(function () {
    callback(null, exports.pbkdf2Sync(password, salt, iterations, keylen, digest))
  })
}

var defaultEncoding
if (process.browser) {
  defaultEncoding = 'utf-8'
} else {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
}

exports.pbkdf2Sync = function (password, salt, iterations, keylen, digest) {
  if (!Buffer.isBuffer(password)) password = new Buffer(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = new Buffer(salt, defaultEncoding)

  checkParameters(iterations, keylen)

  digest = digest || 'sha1'

  var hLen
  var l = 1
  var DK = new Buffer(keylen)
  var block1 = new Buffer(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var r
  var T

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)
    var U = createHmac(digest, password).update(block1).digest()

    if (!hLen) {
      hLen = U.length
      T = new Buffer(hLen)
      l = Math.ceil(keylen / hLen)
      r = keylen - (l - 1) * hLen
    }

    U.copy(T, 0, 0, hLen)

    for (var j = 1; j < iterations; j++) {
      U = createHmac(digest, password).update(U).digest()
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    var destPos = (i - 1) * hLen
    var len = (i === l ? r : hLen)
    T.copy(DK, destPos, 0, len)
  }

  return DK
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(0).Buffer))

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(21);
module.exports = function (seed, len) {
  var t = new Buffer('');
  var  i = 0, c;
  while (t.length < len) {
    c = i2ops(i++);
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
  }
  return t.slice(0, len);
};

function i2ops(c) {
  var out = new Buffer(4);
  out.writeUInt32BE(c,0);
  return out;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(3);
function withPublic(paddedMsg, key) {
  return new Buffer(paddedMsg
    .toRed(bn.mont(key.modulus))
    .redPow(new bn(key.publicExponent))
    .fromRed()
    .toArray());
}

module.exports = withPublic;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 112 */
/***/ (function(module, exports) {

module.exports = function xor(a, b) {
  var len = a.length;
  var i = -1;
  while (++i < len) {
    a[i] ^= b[i];
  }
  return a
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(68);

/*<replacement>*/
var util = __webpack_require__(32);
util.inherits = __webpack_require__(1);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

module.exports = Readable;

/*<replacement>*/
var processNextTick = __webpack_require__(67);
/*</replacement>*/

/*<replacement>*/
var isArray = __webpack_require__(106);
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(44).EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = __webpack_require__(23);
  } catch (_) {} finally {
    if (!Stream) Stream = __webpack_require__(44).EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = __webpack_require__(0).Buffer;
/*<replacement>*/
var bufferShim = __webpack_require__(51);
/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(32);
util.inherits = __webpack_require__(1);
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(272);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(251);
var StringDecoder;

util.inherits(Readable, Stream);

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(14);

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(70).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(14);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(70).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = bufferShim.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(1)
var Hash = __webpack_require__(22)

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = new Buffer(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var inherits = __webpack_require__(1)
var Hash = __webpack_require__(22)

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = new Buffer(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.preOrderRecursive = preOrderRecursive;
exports.inOrderRecursive = inOrderRecursive;
exports.postOrderRecursive = postOrderRecursive;
/**
 * 
 */

// 
function preOrderRecursive(tree, x, visit) {
    visit(tree[x]);
    if (tree[2 * x + 1]) preOrderRecursive(tree, 2 * x + 1, visit);
    if (tree[2 * x + 2]) preOrderRecursive(tree, 2 * x + 2, visit);
};

function inOrderRecursive(tree, x, visit) {
    if (tree[2 * x + 1]) inOrderRecursive(tree, 2 * x + 1, visit);
    visit(tree[x]);
    if (tree[2 * x + 2]) inOrderRecursive(tree, 2 * x + 2, visit);
}

function postOrderRecursive(tree, x, visit) {
    if (tree[2 * x + 1]) postOrderRecursive(tree, 2 * x + 1, visit);
    if (tree[2 * x + 2]) postOrderRecursive(tree, 2 * x + 2, visit);
    visit(tree[x]);
}

var tree = [1, 2, 3, 4, 5,, 6,,, 7];

console.log('preOrder:');
preOrderRecursive(tree, 0, function (value) {
    console.log(value);
});

console.log('inOrder:');
inOrderRecursive(tree, 0, function (value) {
    console.log(value);
});

console.log('postOrder:');
postOrderRecursive(tree, 0, function (value) {
    console.log(value);
});

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = huffManCoding;
/**
 * Huffman
 *
 * 
 * 
 * 
 *
 * 
 * 1n{w1,w2,...wn}nF = {T1,T2,...Tn}Tiwi
 * 2F
 * 3FF
 * 423F
 */
/*

http://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81

A B A C C D A4A,B,C,D00,01,1011700010010101100

A,B,C,D0,00,10179000011010

4A,B,C,D4010,10,110,111.
n
 */

// 
function HuffmanNode(weight, parent, leftChild, rightChild) {
    this.weight = weight || 0;
    this.parent = parent || 0;
    this.leftChild = leftChild || 0;
    this.rightChild = rightChild || 0;
}
function huffManCoding(weights) {
    var n = weights.length;
    if (n < 1) return;

    var huffmanTree = buildHuffmanTree(weights, n);

    // 
    var hc = calcHuffmanCode(huffmanTree, n);

    return [huffmanTree, hc];
}

function calcHuffmanCode(huffmanTree, n) {
    // 
    var hc = [];
    var cd = [];
    for (var i = 0; i < n; i++) {
        var start = n - 1;
        for (var c = i, f = huffmanTree[i].parent; f != 0; c = f, f = huffmanTree[f].parent) {
            if (huffmanTree[f].leftChild == c) cd[--start] = '0';else cd[--start] = '1';
        }

        hc[i] = strCopy(cd, start);
    }

    return hc;
}

// nHuffman
function buildHuffmanTree(weights, n) {
    n = n || weights.length;
    var m = 2 * n - 1;
    var huffmanTree = [];

    // 
    var i = void 0;
    for (i = 0; i < n; i++) {
        huffmanTree[i] = new HuffmanNode(weights[i], 0, 0, 0);
    }for (; i < m; i++) {
        huffmanTree[i] = new HuffmanNode(0, 0, 0, 0);
    }for (var _i = n; _i < m; _i++) {
        // HT[1..i-1]parent0weight[s1, s2]
        var ret = select(huffmanTree, _i);
        var s1 = ret[0];
        var s2 = ret[1];
        huffmanTree[s1].parent = _i;
        huffmanTree[s2].parent = _i;
        huffmanTree[_i].leftChild = s1;
        huffmanTree[_i].rightChild = s2;
        huffmanTree[_i].weight = huffmanTree[s1].weight + huffmanTree[s2].weight;
    }

    return huffmanTree;
}

function strCopy(str, start) {
    var s = '';
    for (; str[start]; start++) {
        s += str[start];
    }
    return s;
}

function select(huffmanTree, len) {
    var ret = [];
    for (var i = 0; i < len; i++) {
        var node = huffmanTree[i];
        if (node.parent !== 0) continue;

        if (ret.length < 2) {
            ret.push(i);
        } else {
            var index = huffmanTree[ret[0]].weight > huffmanTree[ret[1]].weight ? 0 : 1;

            if (node.weight < huffmanTree[ret[index]].weight) ret[index] = i;
        }
    }

    if (ret[0] > ret[1]) {
        var temp = ret[0];
        ret[0] = ret[1];
        ret[1] = temp;
    }

    return ret;
}

console.log('-------huffman coding 1:------');
console.log(huffManCoding([5, 29, 7, 8, 14, 23, 3, 11]));

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _Queue = __webpack_require__(16);

var _Queue2 = _interopRequireDefault(_Queue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 
 *
 * Lisp
 * 
 *      LS = (a1, a2, ..., an)
 * LSnaiLSLSa1LS(a2, a3, ..., an)LS
 *
 * 
 * 1.A = () ---- A0
 * 2.B = (e) ---- BeB1
 * 3.C = (a, (b, c, d)) ---- C2a(b, c, d)
 * 4.D = (A, B, C) ---- D3,3D = ((), (e), (a, (b, c, d)))
 * 5.E = (a, E) ---- 2.EE = (a, (a, (a, ...)))
 *
 * 1
 * 2)ABCDD
 * 3E
 *
 * 
 *
 */

/*
 

 

 
 1
 2
 */

/*
 

 
 :
 LS = (a1, a2, ..., an)

 ai(i = 1, 2, ..., n)LSLSnaiaiaiLSai(i = 1, 2, ..., n)1.1.

 DEPTH(LS)
     DEPTH(LS) = 1   LS
 DEPTH(LS) = 0   LS
     DEPTH(LS) = 1 + MAX{DEPTH(ai)}  1 <= i <= n
 */

var ATOM = Symbol();
var LIST = Symbol();

var global = Function('return this')();
// 

// 
var GLNode = function () {
    function GLNode() {
        (0, _classCallCheck3.default)(this, GLNode);

        // 
        this.tag = undefined;

        // atom
        this.atom = null;
        // ptr
        this.ptr = {
            // ptr.hpptr.tp
            hp: null,
            tp: null
        };
    }

    // 


    GLNode.prototype.depth = function depth() {
        return getDepth(this);
    };

    // 


    GLNode.prototype.copyList = function copyList(gList) {
        gList.tag = this.tag;

        if (this.tag === ATOM) {
            gList.atom = this.atom;
        } else {
            if (this.ptr.hp) {
                gList.ptr.hp = new GLNode();
                this.ptr.hp.copyList(gList.ptr.hp);
            }
            if (this.ptr.tp) {
                gList.ptr.tp = new GLNode();
                this.ptr.tp.copyList(gList.ptr.tp);
            }
        }
    };

    // 


    GLNode.prototype.createGList = function createGList(string) {
        string = string.trim();

        // 
        var q = void 0;
        if (isWord(string)) {
            this.tag = ATOM;
            this.atom = string;
        } else {
            this.tag = LIST;
            var p = this;

            // 
            var sub = string.substr(1, string.length - 2);

            do {
                var hsub = void 0;
                var n = sub.length;
                var i = 0;
                var k = 0;
                var ch = void 0;

                do {
                    ch = sub[i++];
                    if (ch == '(') ++k;else if (ch == ')') --k;
                } while (i < n && (ch != ',' || k != 0));

                // i
                if (i < n) {
                    hsub = sub.substr(0, i - 1);
                    sub = sub.substr(i, n - i);

                    // 
                } else {
                    hsub = sub;
                    sub = '';
                }

                if (hsub === '()') p.ptr.hp = null;
                // 
                else {
                        p.ptr.hp = new GLNode();
                        p.ptr.hp.createGList(hsub);
                    }

                q = p;

                // 
                if (sub) {
                    p = new GLNode();
                    p.tag = LIST;
                    q.ptr.tp = p;
                }
            } while (sub);

            q.ptr.tp = null;
        }
    };

    GLNode.equal = function equal(gList1, gList2) {
        // 
        if (!gList1 && !gList2) return true;
        if (gList1.tag === ATOM && gList2.tag === ATOM && gList1.atom === gList2.atom) return true;

        if (gList1.tag === LIST && gList2.tag === LIST) {
            // 
            if (this.equal(gList1.ptr.hp, gList2.ptr.hp) && this.equal(gList1.ptr.tp, gList2.ptr.tp)) return true;
        }

        return false;
    };

    // 


    GLNode.prototype.reverse = function reverse() {
        var ptr = [];
        // A
        if (this.tag === LIST && this.ptr.tp) {
            var i = 0;
            for (var p = this; p; p = p.ptr.tp, i++) {
                // 
                if (p.ptr.hp) p.ptr.hp.reverse();

                ptr[i] = p.ptr.hp;
            }

            // 
            for (var _p = this; _p; _p = _p.ptr.tp) {
                _p.ptr.hp = ptr[--i];
            }
        }
    };

    GLNode.prototype.toString = function toString() {
        var str = '';
        if (this == global || this == null) str = '()';else if (this.tag === ATOM) str = this.atom; // 
        else {
                str += '(';

                for (var p = this; p; p = p.ptr.tp) {
                    str += this.toString.call(p.ptr.hp);
                    if (p.ptr.tp) str += ', ';
                }
                str += ')';
            }

        return str;
    };

    // 
    // 
    // 


    GLNode.prototype.orderPrint = function orderPrint() {
        var queue = new _Queue2.default();

        for (var p = this; p; p = p.ptr.tp) {
            queue.enQueue(p);
        }while (queue.size) {
            var r = queue.deQueue();
            if (r.tag === ATOM) console.log(r.atom);else {
                for (r = r.ptr.hp; r; r = r.ptr.tp) {
                    queue.enQueue(r);
                }
            }
        }
    };

    return GLNode;
}();

// 


exports.default = GLNode;

var GLNode2 = function GLNode2() {
    (0, _classCallCheck3.default)(this, GLNode2);

    // 
    this.tag = undefined;

    // 
    this.atom = null;
    // 
    this.hp = null;

    // next
    this.tp = null;
};

function getDepth(gList) {
    if (!gList) return 1;else if (gList.tag === ATOM) return 0;

    var m = getDepth(gList.ptr.hp) + 1;
    var n = getDepth(gList.ptr.tp);

    return m > n ? m : n;
}

function isWord(str) {
    return (/^[\w-]+$/.test(str)
    );
}

/*
 m

 ,m+1m
 mm
 

 
 P(x, y, z) = x(10)y(3)z(2) + 2x(6)y(3)z(2) + 3x(5)y(2)z(2) + x(4)y(4)z + 2yz + 15

 
 P(x, y, z) = ((x(10) + 2x(6))y(3) + 3x(5)y(2))z(2) + ((x(4) + 6x(3))y(4) + 2y)z + 15

 
 P = z((A, 2), (B, 1), (15, 0))
 A = y((C, 3), (D, 2))
 B = y((E, 4), (F, 1))
 C = x((1, 10), (2, 6))
 D = x((3, 5))
 E = x((1, 4), (6, 3))
 F = x((2, 0))


 */

function MPNode() {
    // 
    this.tag = undefined;
    // 
    this.exp = 0;

    // 
    this.coef = 0;
    // 
    this.hp = null;

    // next
    this.tp = null;
}

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 

 (Adjacency Multilist)

 (v,w)vw

 

   Data
  firstedge
  mark
  ivexjvex
  info
  ilinkivex
  jlinkjvex

 
 

 */

var UNVISITED = 0;
var VISITED = 1;

var EBox =
/**
 * 
 * @param {Number} mark  0 --   1 == 
 * @param {Number} ivex 
 * @param {Number} jvex 
 * @param {EBox} ilink 
 * @param {EBox} jlink 
 * @param {*} info 
 * @constructor
 */
function EBox(mark, ivex, jvex, ilink, jlink, info) {
    (0, _classCallCheck3.default)(this, EBox);

    this.mark = mark || UNVISITED;
    this.ivex = ivex || 0;
    this.jvex = jvex || 0;
    this.ilink = ilink || null;
    this.jlink = jlink || null;
    this.info = info || null;
};

var AMLVexBox =
/**
 * 
 * @param {*} data
 * @param {EBox} firstEdge 
 * @constructor
 */
function AMLVexBox(data, firstEdge) {
    (0, _classCallCheck3.default)(this, AMLVexBox);

    this.data = data || null;
    this.firstEdge = firstEdge || null;
};

var AMLGraph = function () {
    /**
     *
     * @param {Array | AMLVexBox} adjMulist
     * @param {Number} vexnum
     * @param {Number} edgenum
     * @constructor
     */
    function AMLGraph(adjMulist, vexnum, edgenum) {
        (0, _classCallCheck3.default)(this, AMLGraph);

        this.adjMulist = adjMulist || [];
        this.vexnum = vexnum || 0;
        this.edgenum = edgenum || 0;
    }

    AMLGraph.prototype.locateVex = function locateVex(v) {
        for (var i = 0; i < this.vexnum; ++i) {
            if (this.adjMulist[i].data === v) return i;
        }
        return -1;
    };

    AMLGraph.prototype.deleteArc = function deleteArc(v, w) {
        var i = this.locateVex(v);
        var j = this.locateVex(w);

        if (i < 0 || j < 0) throw new Error('Vertex not found!');

        var p;
        // i
        if (this.adjMulist[i].firstEdge.jvex === j) {
            this.adjMulist[i].firstEdge = this.adjMulist[i].firstEdge.ilink;
        } else {
            for (p = this.adjMulist[i].firstEdge; p && p.ilink.jvex !== j; p = p.ilink) {}
            if (!p) throw new Error('edge not found!');
            p.ilink = p.ilink.ilink;
        }

        // j
        if (this.adjMulist[j].firstEdge.ivex === i) {
            this.adjMulist[j].firstEdge = this.adjMulist[j].firstEdge.jlink;
        } else {
            for (p = this.adjMulist[j].firstEdge; p && p.jlink.ivex !== i; p = p.jlink) {}
            if (!p) throw new Error('edge not found!');
            p.jlink = p.jlink.jlink;
        }

        this.edgenum--;
        return true;
    };

    AMLGraph.prototype.createGraph = function createGraph() {
        var vexnum = +prompt('vexnum: ');
        this.vexnum = vexnum;
        var edgenum = +prompt('edgenum: ');
        this.edgenum = edgenum;

        for (var m = 0; m < vexnum; ++m) {
            this.adjMulist[m] = new AMLVexBox(prompt('data: '), null);
        }

        for (m = 0; m < edgenum; ++m) {
            var t = prompt('tailVex: ');
            var h = prompt('headVex: ');
            var i = this.locateVex(t);
            var j = this.locateVex(h);

            if (i < 0 || j < 0) {
                console.error('vertex not found! Try again:');
                m--;
                continue;
            }

            var p = new EBox(0, i, j, null, null);
            var q, r;

            // i
            if (!this.adjMulist[i].firstEdge) {
                this.adjMulist[i].firstEdge = p;
            } else {
                q = this.adjMulist[i].firstEdge;
                while (q) {
                    r = q;
                    if (q.ivex === i) q = q.ilink;else q = q.jlink;
                }
                if (r.ivex === i) r.ilink = p;else r.jlink = p;
            }

            // j
            if (!this.adjMulist[j].firstEdge) {
                this.adjMulist[j].firstEdge = p;
            } else {
                q = this.adjMulist[j].firstEdge;
                while (q) {
                    r = q;
                    if (q.jvex === j) q = q.jlink;else q = q.ilink;
                }
                if (r.jvex === j) r.jlink = p;else r.ilink = p;
            }
        }
    };

    return AMLGraph;
}();

//var g = new AMLGraph();
//g.createGraph();
//console.log(g);


exports.default = AMLGraph;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _index = __webpack_require__(25);

var _index2 = _interopRequireDefault(_index);

var _Queue = __webpack_require__(16);

var _Queue2 = _interopRequireDefault(_Queue);

var _BinaryTree = __webpack_require__(24);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 
var DG = 1; // 
/* Create By Luke */

var DN = 2; // 
var UDG = 3; // 
var UDN = 4; // 


/*
 

 

 iVi(Vi)

 1  

 (adjvex)Vi()(nextarc)Vi(info)

 ()(firstarc)(data) 

  

 


 2  

  
  
  Vii
  Vi()Vi()
  iVi () ()
  

 */

var ArcNode =
/**
 *
 * @param {Number} adjVex
 * @param {ArcNode} nextArc
 * @param {*} info
 * @constructor
 */
function ArcNode() {
    var adjVex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var nextArc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var info = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    (0, _classCallCheck3.default)(this, ArcNode);

    // 
    this.adjVex = adjVex;
    // 
    this.nextArc = nextArc;
    // 
    this.info = info;
};

var VexNode =
/**
 *
 * @param {*} data
 * @param {ArcNode} firstArc
 * @param {Number} indegree
 * @constructor
 */
function VexNode(data) {
    var firstArc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var indegree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    (0, _classCallCheck3.default)(this, VexNode);

    // 
    this.data = data;
    // 
    this.firstArc = firstArc;
    //  , 
    this.indegree = indegree;
};

var AdjacencyListGraph = function () {
    /**
     *
     * @param {Array | VexNode} vertices
     * @param {Number} vexnum
     * @param {Number} arcnum
     * @param {Number} kind
     * @constructor
     */
    function AdjacencyListGraph() {
        var vertices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var vexnum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var arcnum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var kind = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DG;
        (0, _classCallCheck3.default)(this, AdjacencyListGraph);

        this.vertices = vertices;
        // 
        this.vexnum = vexnum;
        this.arcnum = arcnum;
        // 
        this.kind = kind;
    }

    // 


    AdjacencyListGraph.prototype.locateVex = function locateVex(vp) {
        for (var _i = 0; _i < this.vexnum; ++_i) {
            if (this.vertices[_i].data === vp) return _i;
        }

        return -1;
    };

    // 


    AdjacencyListGraph.prototype.addVertex = function addVertex(vp) {
        if (this.locateVex(vp) !== -1) throw new Error('Vertex has existed!');

        this.vertices[this.vexnum++] = new VexNode(vp, null, 0);
        return this.vexnum;
    };

    /**
     * 
     * ,arc1arc2
     * arc1
     * @param {String} arc1
     * @param {String} arc2
     * @param {*} info
     * @returns {boolean}
     */


    AdjacencyListGraph.prototype.addArc = function addArc(arc1, arc2, info) {
        var k = this.locateVex(arc1);
        var j = this.locateVex(arc2);

        if (k === -1 || j === -1) throw new Error('Arc\'s Vertex do not existed!');

        // 
        var p = new ArcNode(k, null, info);
        // 
        var q = new ArcNode(j, null, info);

        // 
        if (this.kind === UDG || this.kind === UDN) {
            q.nextArc = this.vertices[k].firstArc;
            this.vertices[k].firstArc = q;
            p.nextArc = this.vertices[j].firstArc;
            this.vertices[j].firstArc = p;
        }
        // 
        else {
                p.nextArc = this.vertices[j].firstArc;
                this.vertices[j].firstArc = p;
            }

        ++this.arcnum;

        return true;
    };

    // TODO 


    AdjacencyListGraph.prototype.createGraph = function createGraph() {
        this.vexnum = +prompt('vexnum: ');
        this.arcnum = +prompt('arcnum: ');
        // incInfo0
        var incInfo = +prompt('incInfo: ');

        for (var _m = 0; _m < this.vexnum; ++_m) {
            this.vertices[_m] = new VexNode();
            this.vertices[_m].data = prompt('vertex: ');
        }

        for (m = 0; m < this.arcnum; ++m) {
            var h = prompt(': ');
            var t = prompt(': ');
            var _i2 = this.locateVex(t);
            var j = this.locateVex(h);

            if (_i2 < 0 || j < 0) {
                alert('');
                m--;
                continue;
            }

            var p = new ArcNode(j, null, incInfo && prompt('info: '));

            if (!this.vertices[_i2].firstArc) this.vertices[_i2].firstArc = p;else {
                for (var _q = this.vertices[_i2].firstArc; _q.nextArc; _q = _q.nextArc) {}
                q.nextArc = p;
            }
        }
    };

    // 


    AdjacencyListGraph.prototype.isPass = function isPass() {
        if (this.kind !== DG) throw new Error('graph kind should be DG');

        for (var x = 0; x < this.vexnum; ++x) {
            for (var p = this.vertices[x].firstArc; p; p = p.nextArc) {
                var y = p.adjVex;
                for (var _q2 = this.vertices[y].firstArc; _q2; _q2 = _q2.nextArc) {
                    var z = _q2.adjVex;
                    if (z !== x && this.isAdj(x, z)) return false;
                }
            }
        }

        return true;
    };

    // (m,n)


    AdjacencyListGraph.prototype.isAdj = function isAdj(m, n) {
        for (var p = this.vertices[m].firstArc; p; p = p.nextArc) {
            if (p.adjVex === n) return true;
        }
        return false;
    };

    /**
     * <b><b>ijtruefalse
     * @param {String} i
     * @param {String} j
     */


    AdjacencyListGraph.prototype.existPathDFS = function existPathDFS(i, j) {
        var visited = [];
        i = this.locateVex(i);
        j = this.locateVex(j);

        if (i < 0 || j < 0) throw new Error('vertex not found!');

        return exist_path(this, i, j);

        function exist_path(graph, i, j) {
            if (i === j) return true;

            visited[i] = true;
            for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
                var k = p.adjVex;
                if (!visited[k] && exist_path(graph, k, j)) return true;
            }

            return false;
        }
    };

    /**
     * <b><b>ijtruefalse
     * @param {String} i
     * @param {String} j
     */


    AdjacencyListGraph.prototype.existPathBFS = function existPathBFS(i, j) {
        i = this.locateVex(i);
        j = this.locateVex(j);
        var visited = [];
        var queue = new _Queue2.default();
        queue.enQueue(i);

        while (queue.rear) {
            var u = queue.deQueue();
            visited[u] = 1;

            for (var p = this.vertices[i].firstArc; p; p = p.nextArc) {
                var k = p.adjVex;
                if (k === j) return true;
                if (!visited[k]) queue.enQueue(k);
            }
        }

        return false;
    };

    /**
     * ijk
     * @param {String} i
     * @param {String} j
     * @param {Number} k
     */


    AdjacencyListGraph.prototype.existPathLen = function existPathLen(i, j, k) {
        i = this.locateVex(i);
        j = this.locateVex(j);
        var visited = [];

        return function recurse(graph, i, j, k) {
            // 
            if (i === j && k === 0) return true;else if (k > 0) {
                visited[i] = 1;
                for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
                    var l = p.adjVex;
                    if (!visited[l]) {
                        // 
                        if (recurse(graph, l, j, k - 1)) return true;
                    }
                }
                // 
                visited[i] = 0;
            }

            return false;
        }(this, i, j, k);
    };

    /**
     * uvk
     * @param {String} u
     * @param {String} v
     * @param {Number} k
     *
     * @example
     *  graph.findAllPaths('v1', 'v2', 0);
     */


    AdjacencyListGraph.prototype.findAllPaths = function findAllPaths(u, v, k) {
        u = this.locateVex(u);
        v = this.locateVex(v);
        var path = [];
        var visited = [];

        findPath(this, u, v, k);

        function findPath(graph, u, v, k) {
            // 
            path[k] = u;
            visited[u] = 1;

            // 
            if (u === v) {
                console.log('Found one path!');
                for (var _i3 = 0; path[_i3]; ++_i3) {
                    console.log(path[_i3]);
                }
            } else {
                for (var p = graph.vertices[u].firstArc; p; p = p.nextArc) {
                    var l = p.adjVex;
                    // 
                    if (!visited[l]) findPath(graph, l, v, k + 1);
                }
            }

            visited[u] = 0;
            // 
            path[k] = 0;
        }
    };

    /**
     * len
     * @param {String} i
     * @param {String} j
     * @param {Number} len
     */


    AdjacencyListGraph.prototype.getPathNum_len = function getPathNum_len(i, j, len) {
        var visited = [];

        return function recurse(graph, i, j, len) {
            if (i === j && len === 0) return 1;else if (len > 0) {
                var sum = 0;
                visited[i] = 1;
                for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
                    var l = p.adjVex;
                    if (!visited[l]) sum += recurse(l, j, len - 1);
                }
                visited[i] = 0;
                return sum;
            }
        }(this, i, j, len);
    };

    /**
     * 
     */


    AdjacencyListGraph.prototype.getRoot = function getRoot() {
        var visited = [];

        for (var _i4 = 0; _i4 < this.vexnum; ++_i4) {
            // 
            for (var _w = 0; _w < this.vexnum; ++_w) {
                visited[_w] = false;
            } // i
            dfs(this, _i4);

            var flag = true;
            for (w = 0; w < this.vexnum; ++w) {
                // i
                if (!visited[w]) flag = false;
            }

            if (flag) console.log('Found a root vertex: %d', _i4);
        }

        function dfs(graph, v) {
            visited[v] = true;

            for (var p = graph.vertices[v].firstArc; p; p = p.nextArc) {
                var _w2 = p.adjVex;
                if (!visited[_w2]) dfs(graph, _w2);
            }
        }
    };

    /**
     * 
     */


    AdjacencyListGraph.prototype.getLongestPath = function getLongestPath() {
        var mlp = [];
        var path = [];
        var visited = [];
        var maxLen = 0;

        this.countIndegree();

        for (var _i5 = 0; _i5 < this.vexnum; ++_i5) {
            for (var j = 0; j < this.vexnum; ++j) {
                visited[j] = false;
            } // 
            if (this.vertices[_i5].indegree === 0) dfs(this, _i5, 0);
        }

        console.log('Longest Path:');
        // 
        for (i = 0; mlp[i]; ++i) {
            console.log(mlp.join(','));
        }function dfs(graph, i, len) {
            visited[i] = true;
            path[len] = i;

            // 
            if (len > maxLen && !graph.vertices[i].firstArc) {
                // 
                for (var _j = 0; _j <= len; ++_j) {
                    mlp[_j] = path[_j];
                }maxLen = len;
            } else {
                for (var p = graph.vertices[i].firstArc; p; p = p.nextArc) {
                    var _w3 = p.adjVex;
                    if (!visited[_w3]) dfs(graph, _w3, len + 1);
                }
            }

            path[i] = 0;
            visited[i] = false;
        }
    };

    // 


    AdjacencyListGraph.prototype.DFSTraverse = function DFSTraverse(visitFn) {
        var visited = [];
        for (var _i6 = 0; _i6 < this.vexnum; ++_i6) {
            visited[_i6] = false;
        }for (var _i7 = 0; _i7 < this.vexnum; ++_i7) {
            if (!visited[_i7]) dfs(this, _i7);
        }

        function dfs(graph, v) {
            visited[v] = true;
            visitFn.call(graph, v);

            var p = graph.vertices[v].firstArc;
            while (p) {
                if (!visited[p.adjVex]) dfs(graph, p.adjVex);

                p = p.nextArc;
            }
        }
    };

    // 


    AdjacencyListGraph.prototype.DFSTraverse_NonRecurse = function DFSTraverse_NonRecurse(visitFn) {
        var visited = [];
        var stack = new _index2.default();
        for (var _i8 = 0; _i8 < this.vexnum; ++_i8) {
            visited[_i8] = false;
        }for (var _i9 = 0; _i9 < this.vexnum; ++_i9) {
            if (!visited[_i9]) {
                stack.push(_i9);
                visited[_i9] = true;
                visitFn.call(this, _i9);

                var v = void 0;
                while ((v = stack.peek()) != null) {
                    var p = this.vertices[v].firstArc;
                    while (p) {
                        if (!visited[p.adjVex]) {
                            visited[p.adjVex] = true;
                            visitFn.call(this, p.adjVex);
                            stack.push(p.adjVex);
                        } else stack.pop();

                        p = p.nextArc;
                    }
                }
            }
        }
    };

    // 


    AdjacencyListGraph.prototype.BFSTraverse = function BFSTraverse(visitFn) {
        var queue = new _Queue2.default();
        var visited = [];
        for (var _i10 = 0; _i10 < this.vexnum; ++_i10) {
            visited[_i10] = false;
        }for (var _i11 = 0; _i11 < this.vexnum; ++_i11) {
            if (!visited[_i11]) {
                queue.enQueue(_i11);
                visited[_i11] = true;
                visitFn.call(this, _i11);

                while (queue.rear) {
                    var _w4 = queue.deQueue();
                    var p = this.vertices[_w4].firstArc;
                    while (p) {
                        if (!visited[p.adjVex]) {
                            visited[p.adjVex] = true;
                            visitFn.call(this, p.adjVex);
                            queue.enQueue(p.adjVex);
                        }

                        p = p.nextArc;
                    }
                }
            }
        }
    };

    // 


    AdjacencyListGraph.prototype.createDFSForest = function createDFSForest() {
        var tree = null;
        var visited = [];
        for (var _i12 = 0; _i12 < this.vexnum; ++_i12) {
            visited[_i12] = false;
        }var q = void 0;
        for (var _i13 = 0; _i13 < this.vexnum; ++_i13) {
            if (!visited[_i13]) {
                // 
                var p = new _BinaryTree.ChildSiblingTree(this.vertices[_i13].data);

                // 
                if (!tree) tree = p;
                // 
                else q.nextSibling = p;

                // q
                q = p;
                // p
                DFSTree(this, _i13, p);
            }
        }

        return tree;

        // vtree
        function DFSTree(graph, v, tree) {
            visited[v] = true;
            var first = true;
            var w = graph.vertices[v].firstArc;
            var q = void 0;

            while (w) {
                if (!visited[w.adjVex]) {
                    visited[w.adjVex] = true;
                    var _p = new _BinaryTree.ChildSiblingTree(graph.vertices[w.adjVex].data);

                    // wv
                    if (first) {
                        tree.firstChild = _p;
                        first = false;
                    }
                    // wv
                    else q.nextSibling = _p;

                    q = _p;

                    DFSTree(graph, w.adjVex, q);
                }

                w = w.nextArc;
            }
        }
    };

    AdjacencyListGraph.prototype.createBFSForest = function createBFSForest() {
        var tree = null;
        var visited = [];
        var queue = new _Queue2.default();
        for (var _i14 = 0; _i14 < this.vexnum; ++_i14) {
            visited[_i14] = false;
        }var q = void 0;
        for (var _i15 = 0; _i15 < this.vexnum; ++_i15) {
            if (!visited[_i15]) {
                visited[_i15] = true;
                queue.enQueue(_i15);

                var node = new _BinaryTree.ChildSiblingTree(this.vertices[_i15].data);
                if (!tree) tree = node;else q.nextSibling = node;

                q = node;

                while (queue.rear) {
                    var _w5 = queue.deQueue();
                    var p = this.vertices[_w5].firstArc;
                    var first = true;
                    var pre = void 0;

                    while (p) {
                        if (!visited[p.adjVex]) {
                            visited[p.adjVex] = true;
                            queue.enQueue(p.adjVex);

                            var node2 = new _BinaryTree.ChildSiblingTree(this.vertices[p.adjVex].data);

                            if (first) {
                                node.firstChild = node2;
                                first = false;
                            } else pre.nextSibling = node2;

                            pre = node2;
                        }
                        p = p.nextArc;
                    }
                }
            }
        }

        return tree;
    };

    AdjacencyListGraph.prototype.findArticul = function findArticul() {
        var visited = [];
        var count = 1;
        var low = [];
        low[0] = count;
        visited[0] = 1;
        for (var _i16 = 1; _i16 < this.vexnum; ++_i16) {
            visited[_i16] = 0;
        }var p = this.vertices[0].firstArc;
        var v = p.adjVex;

        DFSArticul(this, v);
        if (count < this.vexnum) {
            console.log(0 + '  ' + this.vertices[0].data);
            while (p.nextArc) {
                p = p.nextArc;
                v = p.adjVex;
                if (visited[v] === 0) DFSArticul(this, v);
            }
        }

        function DFSArticul(graph, v0) {
            var min = visited[v0] = ++count;
            for (var _p2 = graph.vertices[v0].firstArc; _p2; _p2 = _p2.nextArc) {
                var _w6 = _p2.adjVex;
                if (visited[_w6] === 0) {
                    DFSArticul(graph, _w6);
                    if (low[_w6] < min) min = low[_w6];
                    if (low[_w6] >= visited[v0]) console.log(v0 + '  ' + graph.vertices[v0].data);
                } else if (visited[_w6] < min) min = visited[_w6];
            }
            low[v0] = min;
        }
    };

    // 


    AdjacencyListGraph.prototype.countIndegree = function countIndegree() {
        for (var k = 0; k < this.vexnum; ++k) {
            this.vertices[k].indegree = 0;
        }for (var _k = 0; _k < this.vexnum; ++_k) {
            for (var p = this.vertices[_k].firstArc; p; p = p.nextArc) {
                ++this.vertices[p.adjVex].indegree;
            }
        }
    };

    // 


    AdjacencyListGraph.prototype.topologicSort = function topologicSort() {
        var stack = new _index2.default();
        this.topologicalOrder = [];
        this.countIndegree();

        for (var _i17 = 0; _i17 < this.vexnum; ++_i17) {
            if (this.vertices[_i17].indegree === 0) stack.push(_i17);
        }

        var count = 0;
        while (stack.length) {
            var _i18 = stack.pop();
            this.topologicalOrder.push(_i18);
            console.log(this.vertices[_i18].data);
            ++count;
            for (var p = this.vertices[_i18].firstArc; p; p = p.nextArc) {
                var k = p.adjVex;
                if (--this.vertices[k].indegree === 0) stack.push(k);
            }
        }

        return count >= this.vexnum;
    };

    // 


    AdjacencyListGraph.prototype.criticalPath = function criticalPath() {
        if (!this.topologicSort()) throw new Error('AOE');

        var ve = [];
        // 
        for (var j = 0; j < this.vexnum; ++j) {
            ve[j] = 0;
        } // ve
        for (var _m2 = 0; _m2 < this.vexnum; ++_m2) {
            var _j2 = this.topologicalOrder[_m2];
            for (var p = this.vertices[_j2].firstArc; p; p = p.nextArc) {
                var k = p.adjVex;
                if (ve[_j2] + p.info > ve[k]) ve[k] = ve[_j2] + p.info;
            }
        }
        var vl = [];
        // 
        for (var _j3 = 0; _j3 < this.vexnum; ++_j3) {
            vl[_j3] = ve[this.vexnum - 1];
        } // vl
        for (var _m3 = this.vexnum - 1; _m3 >= 0; --_m3) {
            var _j4 = this.topologicalOrder[_m3];
            for (var _p3 = this.vertices[_j4].firstArc; _p3; _p3 = _p3.nextArc) {
                var _k2 = _p3.adjVex;
                if (vl[_k2] - _p3.info < vl[_j4]) vl[_j4] = vl[_k2] - _p3.info;
            }
        }
        // 
        for (var _m4 = 0; _m4 < this.vexnum; ++_m4) {
            for (var _p4 = this.vertices[_m4].firstArc; _p4; _p4 = _p4.nextArc) {
                var _k3 = _p4.adjVex;
                if (ve[_m4] + _p4.info === vl[_k3]) console.log('<%d, %d>', _m4, _k3);
            }
        }
    };

    AdjacencyListGraph.prototype.shortestPath_Dijkstra = function shortestPath_Dijkstra(v0) {
        var dist = [];
        var pre = [];
        var final = [];
        var w = void 0;

        for (var _v = 0; _v < this.vexnum; ++_v) {
            dist[_v] = Infinity;
        }for (var p = this.vertices[v0].firstArc; p; p = p.nextArc) {
            dist[p.adjVex] = p.info;
        }var v = void 0;
        for (v = 0; v < this.vexnum; ++v) {
            final[v] = false;
            pre[v] = pre[v] || [];
            for (w = 0; w < this.vexnum; ++w) {
                pre[v][w] = false;
            }if (dist[v] < Infinity) {
                pre[v][v0] = true;
                pre[v][v] = true;
            }
        }

        dist[v0] = 0;
        final[v0] = true;

        for (var _i19 = 1; _i19 < this.vexnum; ++_i19) {
            var min = Infinity;
            for (w = 0; w < this.vexnum; ++w) {
                if (!final[w] && dist[w] < min) {
                    v = w;
                    min = dist[w];
                }
            }

            final[v] = true;

            for (var _p5 = this.vertices[v].firstArc; _p5; _p5 = _p5.nextArc) {
                w = _p5.adjVex;
                if (!final[w] && min + _p5.info < dist[w]) {
                    dist[w] = min + _p5.info;
                    pre[w] = pre[v];
                    pre[w][w] = true;
                }
            }
        }

        console.log(final);
        console.log(pre);
        console.log(dist);

        return {
            final: final,
            pre: pre,
            dist: dist
        };
    };

    return AdjacencyListGraph;
}();

// 


exports.default = AdjacencyListGraph;
var adjListGraph = new AdjacencyListGraph([], 0, 0, UDG);
adjListGraph.addVertex('v1');
adjListGraph.addVertex('v2');
adjListGraph.addVertex('v3');
adjListGraph.addVertex('v4');
adjListGraph.addVertex('v5');

adjListGraph.addArc('v1', 'v2');
adjListGraph.addArc('v1', 'v3');
adjListGraph.addArc('v1', 'v4');
adjListGraph.addArc('v2', 'v3');
adjListGraph.addArc('v3', 'v4');
adjListGraph.addArc('v3', 'v5');
adjListGraph.addArc('v4', 'v5');

console.log(adjListGraph);

// 
var g = new AdjacencyListGraph([], 0, 0, DG);
g.addVertex('v1');
g.addVertex('v2');
g.addVertex('v3');
g.addVertex('v4');
g.addVertex('v5');

g.addArc('v1', 'v2');
g.addArc('v1', 'v4');
g.addArc('v3', 'v2');
g.addArc('v3', 'v1');
g.addArc('v4', 'v3');
g.addArc('v3', 'v5');
g.addArc('v5', 'v4');

console.log(g);

// 
var g = new AdjacencyListGraph([], 0, 0, DG);
g.addVertex('v1');
g.addVertex('v2');
g.addVertex('v3');
g.addVertex('v4');
g.addVertex('v5');

g.addArc('v2', 'v1');
g.addArc('v4', 'v1');
g.addArc('v2', 'v3');
g.addArc('v1', 'v3');
g.addArc('v3', 'v4');
g.addArc('v5', 'v3');
g.addArc('v4', 'v5');

console.log(g);

console.log('adjListGraph DFSTraverse: ');
var adjListGraph = new AdjacencyListGraph([], 0, 0, UDG);
adjListGraph.addVertex('v1');
adjListGraph.addVertex('v2');
adjListGraph.addVertex('v3');
adjListGraph.addVertex('v4');
adjListGraph.addVertex('v5');

adjListGraph.addArc('v5', 'v4');
adjListGraph.addArc('v3', 'v2');
adjListGraph.addArc('v2', 'v1');
adjListGraph.addArc('v3', 'v1');

adjListGraph.DFSTraverse(function (v) {
    console.log(this.vertices[v].data);
});

console.log('adjListGraph DFSTraverse_NonRecurse: ');
adjListGraph.DFSTraverse_NonRecurse(function (v) {
    console.log(this.vertices[v].data);
});

console.log('adjListGraph BFSTraverse: ');
var g2 = new AdjacencyListGraph([], 0, 0, DG);
g2.addVertex('v1');
g2.addVertex('v2');
g2.addVertex('v3');
g2.addVertex('v4');
g2.addVertex('v5');

g2.addArc('v4', 'v1');
g2.addArc('v2', 'v1');
g2.addArc('v5', 'v3');
g2.addArc('v2', 'v3');
g2.addArc('v1', 'v3');
g2.addArc('v3', 'v4');
g2.addArc('v4', 'v5');

g2.BFSTraverse(function (v) {
    console.log(this.vertices[v].data);
});

console.log('DFS: expect false: ' + adjListGraph.existPathDFS('v1', 'v4'));
console.log('DFS: expect true: ' + adjListGraph.existPathDFS('v1', 'v2'));

console.log('BFS : expect false: ' + adjListGraph.existPathBFS('v1', 'v4'));
console.log('BFS :expect true: ' + adjListGraph.existPathBFS('v1', 'v2'));

/*
 

 

 1 
 
  
  

  G=(V,E) V(G) E(G) G E(G)
 T(G) 
 B(G) 
  E(G)=T(G)B(G) T(G)B(G)=
 G=(V, T(G))GGGG
 DFSGBFSG

   G=(V,E)V1(G) ,V2(G) ,,Vn(G)T1(G) ,T2(G) , ,Tn(G) 
 Gi=(Vi(G),Ti(G))
 (1in)

 


 2  

 DFS(BFS)DFS
 VVV V

 */

console.log(adjListGraph.createDFSForest());

console.log(adjListGraph.createBFSForest());

/*
 VVV
 kK
 K
 */

var articulTest = new AdjacencyListGraph([], 0, 0, UDG);
articulTest.addVertex('A');
articulTest.addVertex('B');
articulTest.addVertex('C');
articulTest.addVertex('D');
articulTest.addVertex('E');
articulTest.addVertex('F');
articulTest.addVertex('G');
articulTest.addVertex('H');
articulTest.addVertex('I');
articulTest.addVertex('J');
articulTest.addVertex('K');
articulTest.addVertex('L');
articulTest.addVertex('M');

articulTest.addArc('A', 'B');
articulTest.addArc('A', 'C');
articulTest.addArc('A', 'F');
articulTest.addArc('A', 'L');
articulTest.addArc('C', 'B');
articulTest.addArc('D', 'B');
articulTest.addArc('G', 'B');
articulTest.addArc('H', 'B');
articulTest.addArc('M', 'B');
articulTest.addArc('D', 'E');
articulTest.addArc('G', 'H');
articulTest.addArc('G', 'I');
articulTest.addArc('G', 'K');
articulTest.addArc('H', 'K');
articulTest.addArc('J', 'L');
articulTest.addArc('J', 'M');
articulTest.addArc('L', 'M');

articulTest.findArticul();

/*
 

 (Directed Acycling Graph)()

 (project)(active)()()
  ??
  ?

 (Activity On Vertex Network AOV) 


 

 1 
 (Topological Sort) 

  AAA(AA) 
  aA(aa)RAR
  abA (ab)R(ba)R AR
  abA (ab)R(ba)R ARabA a=b(ab)R(ba)R AR
  abcA(ab)R(bc)R (ac)R AR
  ARRA
  RAabAaRbbRa RA

 
 AOV<i, j>ijjiijijji
 AOV
 
 AOV(v1,v2, ,vn)()

 2 
 

  AOV
  AOV()() 
  ()()

 3  
  AOV
  0
  1

 O(n+e) 

 */

var topologicTest = new AdjacencyListGraph([], 0, 0, DG);
topologicTest.addVertex('v1');
topologicTest.addVertex('v2');
topologicTest.addVertex('v3');
topologicTest.addVertex('v4');
topologicTest.addVertex('v5');
topologicTest.addVertex('v6');

topologicTest.addArc('v2', 'v1');
topologicTest.addArc('v4', 'v1');
topologicTest.addArc('v3', 'v1');
topologicTest.addArc('v2', 'v3');
topologicTest.addArc('v5', 'v3');
topologicTest.addArc('v4', 'v6');
topologicTest.addArc('v5', 'v4');
topologicTest.addArc('v5', 'v6');

console.log('topologicSort: ');
console.log(topologicTest.topologicSort());

/*
 (Critical Path)

 AOVAOE(Activity On Edge) 7-24(Event)

 1 AOE
  ?
  ()?
 () 
 v0v0vivivi
 ai<j, k>dut(<j, k>)
  e(i)ai
  l(i)ai l(i)-e(i)ail(i)-e(i)=0ai
  ve(i)vivi
  vl(i)vi
 e(i)=ve(j)
 l(i)= vl(k)-dut(<j, k>)
 0    j=0vj
 ve(j)=
 Max{ve(i)+dut(<i, j>)|<vi, vj>}

 0vjvjvjvive(i)ve(j) 
 
 ve(n-1)    j=n-1vj
 vl(j)=
 Min{vl(k)-dut(<j, k>)|<vj, vk>}
 vjvkvl(k)vl(j) 
 


 2 AOE
  
  AOE
   ()ve(i) 
   ()vl(i) 

 AOEne
  O(n+e) 
  vevlO(n+e) 
  vevlO(n+e) 
 O(n+e) 

 */

var criticalPathTest = new AdjacencyListGraph([], 0, 0, DG);
criticalPathTest.addVertex('v0');
criticalPathTest.addVertex('v1');
criticalPathTest.addVertex('v2');
criticalPathTest.addVertex('v3');
criticalPathTest.addVertex('v4');
criticalPathTest.addVertex('v5');
criticalPathTest.addVertex('v6');
criticalPathTest.addVertex('v7');
criticalPathTest.addVertex('v8');

criticalPathTest.addArc('v1', 'v0', 3);
criticalPathTest.addArc('v2', 'v0', 10);
criticalPathTest.addArc('v4', 'v1', 13);
criticalPathTest.addArc('v4', 'v2', 12);
criticalPathTest.addArc('v3', 'v1', 9);
criticalPathTest.addArc('v5', 'v2', 7);
criticalPathTest.addArc('v7', 'v4', 6);
criticalPathTest.addArc('v7', 'v3', 4);
criticalPathTest.addArc('v7', 'v5', 11);
criticalPathTest.addArc('v6', 'v3', 8);
criticalPathTest.addArc('v8', 'v7', 5);
criticalPathTest.addArc('v8', 'v6', 2);

criticalPathTest.criticalPath();

var dijTest = new AdjacencyListGraph([], [], 0, 0, DN);

dijTest.addVertex('0');
dijTest.addVertex('1');
dijTest.addVertex('2');
dijTest.addVertex('3');
dijTest.addVertex('4');
dijTest.addVertex('5');

dijTest.addArc('1', '0', 20);
dijTest.addArc('4', '0', 10);
dijTest.addArc('2', '0', 60);
dijTest.addArc('5', '0', 65);
dijTest.addArc('2', '1', 30);
dijTest.addArc('3', '2', 40);
dijTest.addArc('2', '5', 15);
dijTest.addArc('5', '4', 20);
dijTest.addArc('4', '3', 35);
dijTest.addArc('3', '1', 70);

dijTest.shortestPath_Dijkstra(0);

(function () {
    /**
     * 
     */
    function niBoLan_DAG(graph) {
        graph.countIndegree();
        for (var _i20 = 0; _i20 < graph.vexnum; ++_i20) {
            // 
            if (graph.vertices[_i20].indegree === 0) {
                printNiBoLan(graph, _i20);
                break;
            }
        }

        return false;
    }

    function printNiBoLan(graph, i) {
        var c = graph.vertices[i].data;
        var p = graph.vertices[i].firstArc;

        // 
        if (p) {
            printNiBoLan(graph, p.adjVex);
            printNiBoLan(graph, p.nextArc.adjVex);
        }

        console.log(c + '');
    }

    /**
     * 
     */
    function evaluate_DAG(graph) {
        graph.countIndegree();
        for (var _i21 = 0; _i21 < graph.vexnum; ++_i21) {
            if (!graph.vertices[_i21].indegree) return evaluate_imp(graph, _i21);
        }
    }

    function evaluate_imp(g, i) {
        if (/^\d+$/.test(g.vertices[i].data)) return g.vertices[i].data;else {
            var p = g.vertices[i].firstArc;
            var v1 = evaluate_imp(g, p.adjVex);
            var v2 = evaluate_imp(g, p.nextArc.adjVex);
            return calculate(v1, g.vertices[i].data, v2);
        }
    }

    function calculate(a, operation, b) {
        // ..
        return eval(a + operation + b);
    }

    // ((1 + 2) * (2 * (3 + 4)) + (3 + 4) * 5) * ((3 + 4) * 5)
    var dag = new AdjacencyListGraph([], 0, 0, DG);

    var a1 = new String('*');
    var a2 = new String('+');
    var a3 = new String('*');
    var a4 = new String('*');
    var a5 = new String('+');
    var a6 = new String('*');
    var a7 = new String('+');

    // 12
    dag.addVertex(a1);
    dag.addVertex(a2);
    dag.addVertex(a3);
    dag.addVertex(a4);
    dag.addVertex(a5);
    dag.addVertex(a6);
    dag.addVertex(a7);
    dag.addVertex(1);
    dag.addVertex(2);
    dag.addVertex(3);
    dag.addVertex(4);
    dag.addVertex(5);

    // 14
    dag.addArc(a2, a1);
    dag.addArc(a4, a1);
    dag.addArc(a3, a2);
    dag.addArc(a4, a2);
    dag.addArc(a5, a3);
    dag.addArc(a6, a3);
    dag.addArc(a7, a6);
    dag.addArc(a7, a4);
    dag.addArc(5, a4);
    dag.addArc(1, a5);
    dag.addArc(2, a5);
    dag.addArc(2, a6);
    dag.addArc(3, a7);
    dag.addArc(4, a7);

    console.log('niBoLan_DAG: ');
    niBoLan_DAG(dag);
    console.log('evaluate_DAG: ' + evaluate_DAG(dag)); // 2695
})();

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _index = __webpack_require__(25);

var _index2 = _interopRequireDefault(_index);

var _Queue = __webpack_require__(16);

var _Queue2 = _interopRequireDefault(_Queue);

var _BinaryTree = __webpack_require__(24);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 
var DG = 1; // 
/* create by Luke */
/**
 * (Graph)
 *
 * (Graph)
 *
 * 
 *
 * ()0()
 *
 * 
 *
 * 
 *
 * 
 *
 * (G)(V,E) G=(V,E)  V(Vertex)V(G)EV&VE(G) (Arc)
 * 
 G=(V E)
 V={v|vdata object}
 E={<v,w>| v,wVp(v,w)}
 P(v,w)vw
 *
 * (Arc) vw<v,w>
 * (Digraph) GE(G)<v,w>vwG
 *    <v,w>E(G) vw v(tail)(initial node)w(head)(terminal node) 
 * (Undigraph) GE(G)<v,w>vwG
 *   <v,w>E(G) <w,v>E(G) E(G)(v,w) vw(Edge)(v,w) (w,v)
 *
 * 1G1G2
 G1=(V1 E1)
 V1={a,b,c,d,e}
 E1={<a,b>,<a,c>, <a,e>,<c,d>,<c,e> ,<d,a>,<d,b>,<e,d>}
 G2=(V2 E2)
 V2={a,b,c,d}
 E2={(a,b), (a,c), (a,d), (b,d), (b,c), (c,d)}
 *
 * n ee [0n(n-1)/2] n(n-1)/2
 
 * G=(VE)vivj V vivj(vi ,vj)E
 *
 * n ee[0n(n-1)] n(n-1)
 
 * G=(VE)vivjV vi vj<vi ,vj>E<vj , vi >E 
 *
 * e<nn
 * (Weight)
 *
 * G=(VE)G=(VE)VVEE GGV=VEEGG
 * (Adjacent)G=(VE)(v,w)Evw vw(v,w)(incident)vw 
 * G=(V E)<v,w>Ev ww v <v,w> vw  
 *
 * G=(VE) viVGvivi(degree)TD(vi)
 2    TD(vi)=2e      i=1, 2, , n e
 G=(VE)vi V Gvi()vi(Outdegree)OD(vi) vi()vi(Indegree)ID(vi) viviTD(vi) 
 TD(vi)=OD(vi)+ID(vi)
 *
 * (Path)(Cycle) G=(VE)vivjvivjvivj
 G=(VE)vivjvi()vj
 G
 Path=vi0vi1vim vijV(vij-1, vij)E   j=1,2, ,m
 
 Path=vi0vi1 vim vijV<vij-1, vij>E  j=1,2, ,m
 ()
 ()()
 *
 * G=(VE)vi vj VvivjGGG
 G=(VE)vi vj Vvi vj vjviGGG
 G
 ()nn-1
 
  nn-1
  nn-1
  n-1
  n-1

 
 0 1

 *
 * ()()
 */

/**
 * 
 *
 
  
  
 
 */

/*
 ()

 nvexs[n]A[n][n]vexsA[i][j]ij

 1  

 (1)  
 G=(VE)n(n1)n
            -- 1   (vi , vj)Evi , vj
 A[i][j]=
             -- 0   (vi , vj)Evi , vj

 (2)  
 G=(VE) 
            -- Wij    (vi , vj)Evi , vjwij
 A[i][j]=

            --    (vi , vj)Evi , vj

 (3)  
  
  vii0
  ()0

 2  

 (1)  
 G=(VE)n(n1)n
            -- 1   <vi, vj>Evivj
 A[i][j]=
            -- 0   <vi , vj>E  vivj 

 (2)  
 G=(VE)
            -- wij    <vi,vj>Evi , vjwij
 A[i][j]=
               <vi,vj>Evi , vj

  
  vii0OD(vi)i0ID(vi) 
  0

 3  

 ()() 

 */

var DN = 2; // 
var UDG = 3; // 
var UDN = 4; // 


var ArcCell =
/**
 *
 * @param {Number} adj
 * @param {*} info
 * @constructor
 */
function ArcCell(adj) {
    var info = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _classCallCheck3.default)(this, ArcCell);

    // 10
    this.adj = typeof adj === 'number' ? adj : Infinity;
    // 
    this.info = info;
};

var AdjacencyMatrixGraph = function () {
    /**
     *
     * @param {Array} vexs 
     * @param {Array | ArcCell} arcs 
     * @param {Number} vexnum
     * @param {Number} arcnum
     * @param {Number} kind
     * @constructor
     */
    function AdjacencyMatrixGraph() {
        var vexs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var arcs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var vexnum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var arcnum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var kind = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DG;
        (0, _classCallCheck3.default)(this, AdjacencyMatrixGraph);

        // 
        this.vexs = vexs;
        // 
        this.arcs = arcs;
        // 
        this.vexnum = vexnum;
        // 
        this.arcnum = arcnum;
        // 
        this.kind = kind;
    }

    AdjacencyMatrixGraph.prototype.createGraph = function createGraph() {
        switch (this.kind) {
            case DG:
                return createDG(this); // 
            case DN:
                return createDN(this); // 
            case UDG:
                return createUDG(this); // 
            case UDN:
                return createUDN(this); // 
            default:
                throw new Error('');
        }
    };

    /**
     * 
     * @param {*} vp 
     * @returns {number}
     */


    AdjacencyMatrixGraph.prototype.locateVex = function locateVex(vp) {
        for (var i = 0; i < this.vexnum; ++i) {
            if (this.vexs[i] === vp) return i;
        }

        return -1;
    };

    /**
     * 
     * @param {*} vp 
     */


    AdjacencyMatrixGraph.prototype.addVertex = function addVertex(vp) {
        if (this.locateVex(vp) !== -1) throw new Error('Vertex has existed!');

        var k = this.vexnum;
        this.vexs[this.vexnum++] = vp;

        var value = this.kind === DG || this.kind === UDG ? 0 : Infinity;
        for (var j = 0; j < this.vexnum; ++j) {
            this.arcs[j] = this.arcs[j] || [];
            this.arcs[k] = this.arcs[k] || [];
            this.arcs[j][k] = this.arcs[j][k] || new ArcCell();
            this.arcs[k][j] = this.arcs[k][j] || new ArcCell();
            this.arcs[j][k].adj = this.arcs[k][j].adj = value;
        }
    };

    /**
     * 
     * @param {*} vex1 1
     * @param {*} vex2 2
     * @param {ArcCell} arc
     * @returns {boolean}
     */


    AdjacencyMatrixGraph.prototype.addArc = function addArc(vex1, vex2, arc) {
        arc = arc || new ArcCell(this.kind === DG || this.kind === UDG ? 1 : 'weight');
        var k = this.locateVex(vex1);
        var j = this.locateVex(vex2);

        if (k === -1 || j === -1) throw new Error('Arc\'s Vertex do not existed!');

        this.arcs[k][j].adj = arc.adj;
        this.arcs[k][j].info = arc.info;
        // 
        if (this.kind === UDG || this.kind === UDN) {
            this.arcs[j][k].adj = arc.adj;
            this.arcs[j][k].info = arc.info;
        }

        ++this.arcnum;

        return true;
    };

    /**
     * 
     * @param {String} vex 
     */


    AdjacencyMatrixGraph.prototype.deleteVex = function deleteVex(vex) {
        var n = this.vexnum - 1;
        var m = this.locateVex(vex);

        if (m < 0) return false;

        // 
        var temp = this.vexs[m];
        this.vexs[m] = this.vexs[n];
        this.vexs[n] = temp;

        // 
        for (var i = 0; i <= n; ++i) {
            this.arcs[i][m] = this.arcs[i][n];
            this.arcs[m][i] = this.arcs[n][i];
        }

        this.arcs[m][m].adj = 0;
        this.vexs.length = --this.vexnum;
        return true;
    };

    /**
     * (v, w)
     * @param {String} v
     * @param {String} w
     * @returns {boolean}
     */


    AdjacencyMatrixGraph.prototype.deleteArc = function deleteArc(v, w) {
        var i = this.locateVex(v);
        var j = this.locateVex(w);

        if (i < 0 || j < 0) return false;

        if (this.arcs[i][j].adj) {
            this.arcs[i][j].adj = 0;
            this.arcnum--;
        }

        return true;
    };

    // 


    AdjacencyMatrixGraph.prototype.isPass = function isPass() {
        if (this.kind !== DG) throw new Error('graph kind should be DG');

        for (var x = 0; x < this.vexnum; ++x) {
            for (var y = 0; y < this.vexnum; ++y) {
                if (this.arcs[x][y]) {
                    for (var z = 0; z < this.vexnum; ++z) {
                        if (z !== x && this.arcs[y][z] && !this.arcs[x][z]) return false;
                    }
                }
            }
        }

        return true;
    };

    AdjacencyMatrixGraph.prototype.firstAdjVex = function firstAdjVex(v) {
        for (var i = 0; i < this.vexnum; ++i) {
            if (this.arcs[v][i].adj !== 0 && this.arcs[v][i].adj !== Infinity) return i;
        }

        return -1;
    };

    AdjacencyMatrixGraph.prototype.nextAdjVex = function nextAdjVex(v, w) {
        for (var i = w + 1; i < this.vexnum; ++i) {
            if (this.arcs[v][i].adj !== 0 && this.arcs[v][i].adj !== Infinity) return i;
        }

        return -1;
    };

    // 


    AdjacencyMatrixGraph.prototype.DFSTraverse = function DFSTraverse(visitFn) {
        var visited = [];
        // 
        for (var i = 0; i < this.vexnum; ++i) {
            visited[i] = false;
        }for (var _i = 0; _i < this.vexnum; ++_i) {
            if (!visited[_i]) dfs(this, _i);
        }

        function dfs(graph, vertex) {
            visited[vertex] = true;
            visitFn.call(graph, vertex);

            for (var j = 0; j < graph.vexnum; ++j) {
                if (graph.arcs[vertex][j].adj !== 0 && graph.arcs[vertex][j].adj !== Infinity && !visited[j]) dfs(graph, j);
            }
        }
    };

    // 


    AdjacencyMatrixGraph.prototype.DFSTraverse_NonRecurse = function DFSTraverse_NonRecurse(visitFn) {
        var visited = [];
        var stack = new _index2.default();
        var me = this;
        // 
        for (var i = 0; i < this.vexnum; ++i) {
            visited[i] = false;
        }for (var _i2 = 0; _i2 < this.vexnum; ++_i2) {
            if (!visited[_i2]) {
                stack.push(_i2);
                visited[_i2] = true;
                visitFn.call(me, _i2);

                var vertex = void 0;
                while ((vertex = stack.peek()) != null) {
                    for (var j = 0; j < this.vexnum; ++j) {
                        if (this.arcs[vertex][j].adj !== 0 && this.arcs[vertex][j].adj !== Infinity && !visited[j]) {
                            visitFn.call(me, j);
                            visited[j] = true;
                            stack.push(j);
                        } else stack.pop();
                    }
                }
            }
        }
    };

    // 


    AdjacencyMatrixGraph.prototype.BFSTraverse = function BFSTraverse(visitFn) {
        var visited = [];
        var queue = new _Queue2.default();

        for (var i = 0; i < this.vexnum; ++i) {
            visited[i] = false;
        }for (var _i3 = 0; _i3 < this.vexnum; ++_i3) {
            if (!visited[_i3]) {
                visited[_i3] = true;
                visitFn.call(this, _i3);
                queue.enQueue(_i3);

                while (queue.rear) {
                    var u = queue.deQueue();

                    for (var j = 0; j < this.vexnum; ++j) {
                        if (this.arcs[u][j].adj !== 0 && this.arcs[u][j].adj !== Infinity && !visited[j]) {
                            visited[j] = true;
                            visitFn.call(this, j);
                            queue.enQueue(j);
                        }
                    }
                }
            }
        }
    };

    AdjacencyMatrixGraph.prototype.minSpanTree_PRIM = function minSpanTree_PRIM(u) {
        var closedge = [];

        // 
        for (var j = 0; j < this.vexnum; ++j) {
            closedge[j] = { adjvex: u, lowcost: +this.arcs[j][u].adj };
        }
        closedge[u].lowcost = 0;

        var te = [];
        // this.vexnum - 1
        for (var _j = 0; _j < this.vexnum - 1; ++_j) {
            var min = Infinity;
            var k = void 0;
            for (var v = 0; v < this.vexnum; ++v) {
                if (closedge[v].lowcost !== 0 && closedge[v].lowcost < min) {
                    min = closedge[v].lowcost;
                    k = v;
                }
            }

            te[_j] = {
                vex1: closedge[k].adjvex,
                vex2: k,
                weight: closedge[k].lowcost
            };
            closedge[k].lowcost = 0;
            for (var _v = 0; _v < this.vexnum; ++_v) {
                if (this.arcs[_v][k].adj < closedge[_v].lowcost) {
                    closedge[_v].lowcost = this.arcs[_v][k].adj;
                    closedge[_v].adjvex = k;
                }
            }
        }

        return te;
    };

    AdjacencyMatrixGraph.prototype.minSpanTree_Kruskal = function minSpanTree_Kruskal() {
        var set = [];
        var te = [];

        for (var i = 0; i < this.vexnum; ++i) {
            set[i] = i;
        }var k = 0;
        var min = Infinity;
        var a = 0;
        var b = 0;
        while (k < this.vexnum - 1) {
            for (var _i4 = 0; _i4 < this.vexnum; ++_i4) {
                for (var j = _i4 + 1; j < this.vexnum; ++j) {
                    if (this.arcs[_i4][j].adj < min) {
                        min = this.arcs[_i4][j].adj;
                        a = _i4;
                        b = j;
                    }
                }
            }

            if (set[a] !== set[b]) {
                te[k++] = {
                    vex1: a,
                    vex2: b,
                    weight: this.arcs[a][b].adj
                };

                for (var _i5 = 0; _i5 < this.vexnum; ++_i5) {
                    if (set[_i5] === set[b] && _i5 !== b) set[_i5] = set[a];
                }
                set[b] = set[a];
            }

            min = this.arcs[a][b].adj = Infinity;
        }

        return te;
    };

    /**
     * Dijkstrav0vpre[v]dist[v]
     * pre[v][w]truewv0v
     * final[v]truevSv0v
     * @param v0
     */


    AdjacencyMatrixGraph.prototype.shortestPath_Dijkstra = function shortestPath_Dijkstra(v0) {
        var pre = [];
        var dist = [];
        var final = [];
        var w = void 0,
            v = void 0;

        for (var _v2 = 0; _v2 < this.vexnum; ++_v2) {
            final[_v2] = false;
            dist[_v2] = this.arcs[v0][_v2].adj;
            pre[_v2] = pre[_v2] || [];
            // 
            for (w = 0; w < this.vexnum; ++w) {
                pre[_v2][w] = false;
            }if (dist[_v2] < Infinity) {
                pre[_v2][v0] = true;
                pre[_v2][_v2] = true;
            }
        }

        // v0S
        dist[v0] = 0;
        final[v0] = true;

        // v0vvS

        // 
        for (var i = 1; i < this.vexnum; ++i) {
            var min = Infinity;
            // v0
            for (w = 0; w < this.vexnum; ++w) {
                // wV - S
                // wv0
                if (!final[w] && dist[w] < min) {
                    v = w;
                    min = dist[w];
                }
            }

            // v0vS
            final[v] = true;
            // 
            for (w = 0; w < this.vexnum; ++w) {
                if (!final[w] && min + this.arcs[v][w].adj < dist[w]) {
                    dist[w] = min + this.arcs[v][w].adj;
                    pre[w] = pre[v];
                    pre[w][w] = true;
                }
            }
        }

        console.log(final);
        console.log(pre);
        console.log(dist);

        return {
            final: final,
            pre: pre,
            dist: dist
        };
    };

    AdjacencyMatrixGraph.prototype.shortestPath_FLOYD = function shortestPath_FLOYD() {
        var a = [];
        var path = [];

        for (var j = 0; j < this.vexnum; ++j) {
            a[j] = a[j] || [];
            path[j] = path[j] || [];
            for (var k = 0; k < this.vexnum; ++k) {
                if (j === k) a[j][k] = 0;else a[j][k] = this.arcs[j][k].adj;
                path[j][k] = -1;
            }
        }

        for (var m = 0; m < this.vexnum; ++m) {
            for (var _j2 = 0; _j2 < this.vexnum; ++_j2) {
                for (var _k = 0; _k < this.vexnum; ++_k) {
                    if (a[_j2][m] + a[m][_k] < a[_j2][_k]) {
                        a[_j2][_k] = a[_j2][m] + a[m][_k];
                        path[_j2][_k] = m;
                    }
                }
            }
        }

        for (var _j3 = 0; _j3 < this.vexnum; ++_j3) {
            for (var _k2 = 0; _k2 < this.vexnum; ++_k2) {
                if (_j3 !== _k2) {
                    console.log('%d%d', _j3, _k2);
                    console.log('%d ', _j3);prn_pass(_j3, _k2);
                    console.log('%d ', _k2);
                    console.log(' %d', a[_j3][_k2]);
                }
            }
        }

        function prn_pass(j, k) {
            if (path[j][k] !== -1) {
                prn_pass(j, path[j][k]);
                console.log(', %d', path[j][k]);
                prn_pass(path[j][k], k);
            }
        }
    };

    return AdjacencyMatrixGraph;
}();

exports.default = AdjacencyMatrixGraph;


var createDG = createGraph(DG);
var createDN = createGraph(DN);
var createUDG = createGraph(UDG);
var createUDN = createGraph(UDN);

function createGraph(kind) {
    var adj = void 0;
    var setMatrixValue = void 0;

    if (kind === 2 || kind === 4) {
        adj = Infinity;
        setMatrixValue = function setMatrixValue() {
            return prompt('weight: ');
        };
    } else {
        adj = 0;
        setMatrixValue = function setMatrixValue() {
            return 1;
        };
    }

    return function (AdjacencyMatrixGraph) {
        AdjacencyMatrixGraph.vexnum = parseInt(prompt('vexnum: '), 10);
        AdjacencyMatrixGraph.arcnum = parseInt(prompt('arcnum: '), 10);
        // incInfo0
        var incInfo = parseInt(prompt('incInfo: '), 10);

        // 
        var i = void 0,
            j = void 0;
        for (i = 0; i < AdjacencyMatrixGraph.vexnum; ++i) {
            AdjacencyMatrixGraph.vexs[i] = prompt('vex: ');
        } // 
        for (i = 0; i < AdjacencyMatrixGraph.vexnum; ++i) {
            for (j = 0; j < AdjacencyMatrixGraph.vexnum; ++j) {
                AdjacencyMatrixGraph.arcs[i] = AdjacencyMatrixGraph.arcs[i] || [];
                AdjacencyMatrixGraph.arcs[i][j] = new ArcCell(adj, null);
            }
        }

        // 
        for (var k = 0; k < AdjacencyMatrixGraph.arcnum; ++k) {
            // 
            var v1 = prompt('v1: ');
            var v2 = prompt('v2: ');

            // v1v2G
            i = AdjacencyMatrixGraph.locateVex(v1);
            j = AdjacencyMatrixGraph.locateVex(v2);

            var w = setMatrixValue();
            // <v1, v2>
            AdjacencyMatrixGraph.arcs[i][j].adj = w;
            if (incInfo) AdjacencyMatrixGraph.arcs[i][j].info = prompt('info: ');
            if (kind === 3 || kind === 4) AdjacencyMatrixGraph.arcs[j][i] = AdjacencyMatrixGraph.arcs[i][j];
        }
    };
}

// 
var vexs = ['a', 'b', 'c', 'd', 'e'];
var arcs = [[{ "adj": Infinity, "info": null }, { "adj": "6", "info": null }, { "adj": "2", "info": null }, { "adj": Infinity, "info": null }, { "adj": Infinity, "info": null }], [{ "adj": "6", "info": null }, { "adj": Infinity, "info": null }, { "adj": "3", "info": null }, { "adj": "4", "info": null }, { "adj": "3", "info": null }], [{ "adj": "2", "info": null }, { "adj": "3", "info": null }, { "adj": Infinity, "info": null }, { "adj": "1", "info": null }, { "adj": Infinity, "info": null }], [{ "adj": Infinity, "info": null }, { "adj": "4", "info": null }, { "adj": "1", "info": null }, { "adj": Infinity, "info": null }, { "adj": "5", "info": null }], [{ "adj": Infinity, "info": null }, { "adj": "3", "info": null }, { "adj": Infinity, "info": null }, { "adj": "5", "info": null }, { "adj": Infinity, "info": null }]];
var udn = new AdjacencyMatrixGraph(vexs, arcs, 5, 7, 4);

// 
var dn = new AdjacencyMatrixGraph([], [], 0, 0, 2);
dn.addVertex('a');
dn.addVertex('b');
dn.addVertex('c');
dn.addVertex('d');
dn.addVertex('e');

dn.addArc('a', 'b', {
    adj: 6
});
dn.addArc('a', 'c', {
    adj: 2
});
dn.addArc('c', 'b', {
    adj: 3
});
dn.addArc('c', 'd', {
    adj: 1
});
dn.addArc('d', 'b', {
    adj: 4
});
dn.addArc('b', 'e', {
    adj: 3
});
dn.addArc('d', 'e', {
    adj: 5
});

console.log(dn);

/*

 // 
 let g = new AdjacencyMatrixGraph();
 g.kind = DN;
 g.createGraph();
 console.log(g);

 */

/*
 

 (Travering Graph)

  
  Visited[1n](n)0viVisited[i]1
 

 (Depth First Search--DFS)

 
 
  vivivivi1 
 vi1vi1
  vi
  vj(1)


 (Breadth First Search--BFS)

 
 
  vivi
 vivi1vi2vim
 vi1vi2 vimvij(1jm)vi 
  vk

 .
 */

console.log('DFSTraverse: udn');

var g1 = new AdjacencyMatrixGraph([], [], 0, 0, UDG);
g1.addVertex('v1');
g1.addVertex('v3');
g1.addVertex('v2');
g1.addVertex('v4');
g1.addVertex('v5');

g1.addArc('v5', 'v4');
g1.addArc('v3', 'v1');
g1.addArc('v2', 'v1');
g1.addArc('v3', 'v2');

g1.DFSTraverse(function (v) {
    console.log(this.vexs[v]);
});

console.log('DFSTraverse_NonRecurse: udn');
g1.DFSTraverse_NonRecurse(function (v) {
    console.log(this.vexs[v]);
});

console.log('BFSTraverse: ');
var bsfG = new AdjacencyMatrixGraph([], [], 0, 0, DG);
bsfG.addVertex('v1');
bsfG.addVertex('v2');
bsfG.addVertex('v3');
bsfG.addVertex('v4');
bsfG.addVertex('v5');

bsfG.addArc('v1', 'v4');
bsfG.addArc('v1', 'v2');
bsfG.addArc('v3', 'v5');
bsfG.addArc('v3', 'v2');
bsfG.addArc('v3', 'v1');
bsfG.addArc('v4', 'v3');
bsfG.addArc('v5', 'v4');

bsfG.BFSTraverse(function (v) {
    console.log(this.vexs[v]);
});

/*
 

 

 (Minimum Spanning Tree) 

 nn(n-1)/2n-1?

 
  
  n-1
 MST
 G=(VE)UVuU vV-U(u, v)UV-U(u, v)

  
 G(u,v)TGTuv(u,,v)(u,v)T(u, ,v)(u,v) uU vV-U (u,v) T
 (u,v)UV-U(u,v)(u,v)TT T(u,v) 

 */

/*
 (Prim)

 

 N=(UE)T=(UTE) 

 1 
   v0U={v0}TE={}
  (uv)uUvV-UU= U{v}TE=TE{(uv)} 
   U=VTEn-1 T=(UTE)

 2.
 closedge[n]V- UU
 closedge[j].adjvex=k(vj, vk)V-UvjUvkU closedge[j].lowcost
 vs
 Closedge[s].lowcost=0 vsU
 Closedge[k].adjvex=s Closedge[k].lowcost=cost(k, s)
 V-UU(ks) cost(k, s)(vk, vs) 

 3.
   closedge(0)(vk, vj) 
  closedge[k].lowcost0 vkU
   vkclosedge
 viV-U cost(i, k)colsedge[i].lowcostUvk (vi, vk)viU
 Closedge[i].lowcost=cost(i, k)
 Closedge[i].adjvex=k
   n-1

 
 n closedgen-1 closedgen O(n2)

 */

udn = new AdjacencyMatrixGraph([], [], 0, 0, 4);
udn.addVertex('v1');
udn.addVertex('v2');
udn.addVertex('v3');
udn.addVertex('v4');
udn.addVertex('v5');
udn.addVertex('v6');

udn.addArc('v1', 'v2', { adj: 6 });
udn.addArc('v1', 'v3', { adj: 1 });
udn.addArc('v1', 'v4', { adj: 5 });
udn.addArc('v2', 'v3', { adj: 5 });
udn.addArc('v2', 'v5', { adj: 3 });
udn.addArc('v3', 'v4', { adj: 5 });
udn.addArc('v3', 'v5', { adj: 6 });
udn.addArc('v3', 'v6', { adj: 4 });
udn.addArc('v4', 'v6', { adj: 2 });
udn.addArc('v5', 'v6', { adj: 6 });

console.log('minSpanTree_PRIM: ');
console.log(udn.minSpanTree_PRIM(0));

/*
 (Kruskal)

 

 1 
 G=(V, E)nT=(U, TE)U=VTE={} 
 G
    (vivj)(vivj)TE((vivj) TETE=TE{(vivj)} 
   TEn-1
 7-22

 2 
 KruskalTE?
 Vset[n] T
  Vset[i]=i()
  T(vivj) Vset[i]Vset[j]
  Vset[i]=Vset[j]vivj
  Vset[i]Vset[j]
  

 */

console.log('minSpanTree_Kruskal: ');
console.log(udn.minSpanTree_Kruskal());

/*
 

 () 
  ?
  ?
 
 


 

 G=(VE)VsVsG
 Dijkstra(Dijkstra)

 1 
 
 

 2 
 VsSS={Vs} (Vs Vi)S{VsVi} 
 Vj Vj
   <VsVj>
  Vs Vj SSSVj 
 dist[n]dist[i]Vs SViVjS
 dist[i]=Min{ dist[k]| VkV-S }
 

 3  
  S={Vs} Vi
 0    i =s
 dist[i] =   Wsi     is<vs,vi>E wsi
    is<vs,vi>E
  Vj 
 dist[j]=Min{ dist[k]| VkV-S }
 VjVj SS=S{Vj} 
  V-SVk dist[k]
 dist[j]+Wjk<dist[k]
 dist[k]=dist[j]+Wjk (VkV-S )
  S=V

 4 
  PrimDijkstraPrimVklowcostdist[k]
   pre[n]Vspre[i]=kVs ViViVk(Vs , , Vk  , Vi) 
  final[n]S

 5  
 Dijkstra
  O(n) 
  O(n2) 
 O(n2) 

 */

var dijTest = new AdjacencyMatrixGraph([], [], 0, 0, DN);

dijTest.addVertex('0');
dijTest.addVertex('1');
dijTest.addVertex('2');
dijTest.addVertex('3');
dijTest.addVertex('4');
dijTest.addVertex('5');

dijTest.addArc('0', '1', { adj: 20 });
dijTest.addArc('0', '4', { adj: 10 });
dijTest.addArc('0', '2', { adj: 60 });
dijTest.addArc('0', '5', { adj: 65 });
dijTest.addArc('1', '2', { adj: 30 });
dijTest.addArc('2', '3', { adj: 40 });
dijTest.addArc('5', '2', { adj: 15 });
dijTest.addArc('4', '5', { adj: 20 });
dijTest.addArc('3', '4', { adj: 35 });
dijTest.addArc('1', '3', { adj: 70 });

dijTest.shortestPath_Dijkstra(0);

/*
 

 DijkstraG=(VE)DijkstraO(n3) 

 (Floyd)O(n3)  

 1 

 S()AA[i][j]ViSVj
  S={ }  A[i][j]
 0    i =j
 A[i][j]=    Wij     ij<vi,vj>E wij
    ij<vi,vj>E
  Vk SA[i][j]
 A[i][j]=Min{A[i][j] , (A[i][k]+A[k][j]) }
  VjS(Vk)VjVk
  GS

 2 

   Path[n][n](n) Path[i][j]ViVj
  Path[i][j]=kViVj Vk (Vi , , Vk , , Vj) (Vi , , Vk)(Vk , , Vj)ViVkVkVj Path[i][k]Path[k][j]
  Path[i][j]=-1ViVj (S)VkSA[i][j]Path[i][j]=k


 */

var floyd = new AdjacencyMatrixGraph([], [], 0, 0, DN);
floyd.addVertex('v0');
floyd.addVertex('v1');
floyd.addVertex('v2');
floyd.addArc('v0', 'v2', { adj: 8 });
floyd.addArc('v0', 'v1', { adj: 2 });
floyd.addArc('v1', 'v2', { adj: 4 });
floyd.addArc('v2', 'v0', { adj: 5 });

floyd.shortestPath_FLOYD();

// http://blog.csdn.net/hguisu/article/details/7719428
// -

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = OLGraph;
/*
 

 (Orthogonal List)

 ()()

   data
  firstin
  firstout
  tailvex
  headvex
  hlink
  tlink
  Info

 firstouttlinkfirstinhlink

 */

/**
 *
 * @param {Number} headVex 
 * @param {Number} tailVex 
 * @param {ArcBox} hLink 
 * @param {ArcBox} tLink 
 * @param {*} info
 * @constructor
 */
function ArcBox(tailVex, headVex, hLink, tLink, info) {
    this.headVex = headVex || 0;
    this.tailVex = tailVex || 0;
    this.hLink = hLink || null;
    this.tLink = tLink || null;
    this.info = info || null;
}

/**
 *
 * @param {*} data
 * @param {ArcBox} firstIn 
 * @param {ArcBox} firstOut 
 * @constructor
 */
function OLVexNode(data, firstIn, firstOut) {
    this.data = data || null;
    this.firstIn = firstIn || null;
    this.firstOut = firstOut || null;
}

/**
 *
 * @param {Array | OLVexNode} xList 
 * @param {Number} vexnum 
 * @param {Number} arcnum 
 * @constructor
 */
function OLGraph(xList, vexnum, arcnum) {
    this.xList = xList || [];
    this.vexnum = vexnum || 0;
    this.arcnum = arcnum || 0;
}
OLGraph.prototype = {
    constructor: OLGraph,

    locateVex: function locateVex(vp) {
        for (var i = 0; i < this.vexnum; ++i) {
            if (this.xList[i].data === vp) return i;
        }

        return -1;
    },

    // 
    deleteVertex: function deleteVertex(v) {
        var m = this.locateVex(v);

        if (m < 0) throw new Error('vertex not found!');

        var n = this.vexnum;
        var q, i, p;
        // v
        for (i = 0; i < n; ++i) {
            // 
            if (this.xList[i].firstIn.tailVex === m) {
                q = this.xList[i].firstIn;
                this.xList[i].firstIn = q.hLink;
                this.arcnum--;
            } else {
                for (p = this.xList[i].firstIn; p && p.hLink.tailVex !== m; p = p.hLink) {}
                if (p) {
                    q = p.hLink;
                    p.hLink = q.hLink;
                    this.arcnum--;
                }
            }
        }

        // v
        for (i = 0; i < n; ++i) {
            // 
            if (this.xList[i].firstOut.headVex === m) {
                q = this.xList[i].firstOut;
                this.xList[i].firstOut = q.tLink;
                this.arcnum--;
            } else {
                for (p = this.xList[i].firstOut; p && p.tLink.headVex !== m; p = p.tLink) {}
                if (p) {
                    q = p.tLink;
                    p.tLink = q.tLink;
                    this.arcnum--;
                }
            }
        }

        // m
        for (i = m; i < n; ++i) {
            // 
            this.xList[i] = this.xList[i + 1];
            for (p = this.xList[i].firstIn; p; p = p.hLink) {
                p.headVex--;
            }for (p = this.xList[i].firstOut; p; p = p.tLink) {
                p.tailVex--;
            }
        }

        this.vexnum--;
        return true;
    },

    createDG: function createDG() {
        this.vexnum = prompt('Vexnum: ');
        this.arcnum = prompt('Arcnum: ');
        // IncInfo0
        var incInfo = +prompt('IncInfo: ');

        // 
        for (var i = 0; i < this.vexnum; ++i) {
            this.xList[i] = new OLVexNode(prompt('data: '), null, null);
        }

        for (var k = 0; k < this.arcnum; ++k) {
            var v1 = prompt('v1: ');
            var v2 = prompt('v2: ');

            i = this.locateVex(v1);
            var j = this.locateVex(v2);

            if (i === -1 || j === -1) {
                alert('!');
                k--;
                continue;
            }

            var p = new ArcBox(i, j, this.xList[j].firstIn, this.xList[i].firstOut, incInfo && prompt('info: '));
            this.xList[j].firstIn = this.xList[i].firstOut = p;
        }
    },

    /**
     * 
     */
    getSGraph: function getSGraph() {
        var visited = [];
        var finished = [];
        var count = 0;

        for (var i = 0; i < this.vexnum; ++i) {
            visited[i] = false;
        } // finished
        for (i = 0; i < this.vexnum; ++i) {
            if (!visited[i]) dfs1(this, i);
        }
        // visited
        for (i = 0; i < this.vexnum; ++i) {
            visited[i] = false;
        } // 
        for (var len = this.vexnum - 1; len >= 0; --len) {
            i = finished[i];
            if (!visited[i]) dfs2(this, i);
        }

        function dfs1(graph, v) {
            visited[v] = true;
            for (var p = graph.xList[v].firstOut; p; p = p.tLink) {
                var w = p.headVex;
                if (!visited[w]) dfs1(graph, w);
            }
            finished[++count] = v;
        }

        function dfs2(graph, v) {
            visited[v] = true;
            console.log('%d', v);
            for (var p = graph.xList[v].firstIn; p; p = p.hLink) {
                var w = p.tailVex;
                if (!visited[w]) dfs2(graph, w);
            }
        }
    }
};

//var g = new OLGraph();
//g.createDG();
//console.log(g);


/*
 

  VGVV

 V (V)T1(G)V (V)T2(G)V T1(G)T2(G) 

 G
  GGT
   T
   GG
   GGG
    G

 in_order[n]vDFSin_order[n]

 */

// todo to be tested
OLGraph.prototype.connected_DG = function () {
    var visited = [];
    var in_order = [];
    var count = 0;

    for (var i = 0; i < this.vexnum; ++i) {
        visited[i] = false;
    } // 
    for (i = 0; i < this.vexnum; ++i) {
        if (!visited[i]) {
            dfs(this, i, in_order);
        }
    }

    for (i = 0; i < this.vexnum; ++i) {
        visited[i] = false;
    } // 
    var k = 1;
    for (var j = this.vexnum - 1; j >= 0; --j) {
        var v = in_order[j];
        if (!visited[v]) {
            console.log('' + k++ + '');
            rev_dfs(this, v);
        }
    }

    function dfs(graph, v) {
        visited[v] = true;

        for (var p = graph.xList[v].firstOut; p; p = p.tLink) {
            if (!visited[p.headVex]) {
                dfs(graph, p.headVex);
            }
        }

        in_order[count++] = v;
    }

    function rev_dfs(graph, v) {
        visited[v] = true;
        console.log('' + v);

        for (var p = graph.xList[v].firstIn; p; p = p.hLink) {
            if (!visited[p.tailVex]) {
                rev_dfs(graph, p.tailVex);
            }
        }
    }
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

var _DoubleLinkedList = __webpack_require__(72);

var _DoubleLinkedList2 = _interopRequireDefault(_DoubleLinkedList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LIMIT = 20; /**
                 * LRU( Least recently used )
                 */

var LRUCache = function () {
    function LRUCache(sqList) {
        var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LIMIT;
        (0, _classCallCheck3.default)(this, LRUCache);

        this.limit = limit;
        sqList = sqList && sqList.length ? sqList && sqList.slice(0, this.limit) : [];
        this.__cache = new _DoubleLinkedList2.default(sqList, function (a, b) {
            return a.key === b.key;
        });
    }

    LRUCache.prototype[Symbol.iterator] = function () {
        return this.__cache[Symbol.iterator]();
    };

    LRUCache.prototype.remove = function remove(key) {
        return this.__cache.remove({ key: key });
    };

    LRUCache.prototype.clear = function clear() {
        return this.___cache.clear();
    };

    LRUCache.prototype.get = function get(key) {
        var index = this.__cache.indexOf({ key: key });

        if (index >= 0) {
            var data = this.__cache.findByIndex(index);
            this.__cache.remove(data);
            this.__cache.unshift(data);

            return data;
        }

        return false;
    };

    LRUCache.prototype.add = function add(key, value) {
        var data = this.get(key);
        if (data) {
            data.value = value;
        } else {
            if (this.size === this.limit) {
                this.__cache.pop();
            }

            this.__cache.unshift({
                key: key,
                value: value
            });
        }
    };

    LRUCache.prototype.toString = function toString() {
        var arr = [];
        this.__cache.forEach(function (data) {
            arr.push(data.key + ':' + data.value);
        });

        return arr.join(' > ');
    };

    LRUCache.prototype.toJSON = function toJSON() {
        return this.__cache.toJSON();
    };

    (0, _createClass3.default)(LRUCache, [{
        key: 'size',
        get: function get() {
            return this.__cache.size;
        }
    }]);
    return LRUCache;
}();

exports.default = LRUCache;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.union = union;
exports.mergeList = mergeList;
exports.insert = insert;
exports.del = del;
exports.listComp = listComp;
exports.reverse = reverse;
exports.intersect = intersect;
exports.intersect_true = intersect_true;
exports.intersect_delete = intersect_delete;
/**
 * 
 */

// 
// baa

var a = [1, 2, 3, 4, 5];
var b = [1, 3, 5, 7, 9];

function union(a, b) {
    var elem, equal;

    for (var i = 0, bLen = b.length; i < bLen; i++) {
        elem = b[i];
        equal = false;

        for (var j = 0, aLen = a.length; j < aLen; j++) {
            if (elem === a[j]) {
                equal = true;
                break;
            }
        }

        if (!equal) a.push(elem);
    }
}

union(a, b);
console.log(a);
// [1, 2, 3, 4, 5, 7, 9]

// O(aLen * bLen)

// ab
// abcc
var a = [3, 5, 8, 11];
var b = [2, 6, 8, 9, 11, 15, 20];

function mergeList(a, b) {
    var c = [],
        aElem,
        bElem;
    var i = 0,
        j = 0,
        k = 0;
    var aLen = a.length;
    var bLen = b.length;

    while (i < aLen && j < bLen) {
        aElem = a[i];
        bElem = b[j];

        if (aElem < bElem) {
            c[k++] = aElem;
            i++;
        } else {
            c[k++] = bElem;
            j++;
        }
    }

    while (i < aLen) {
        c[k++] = a[i++];
    }

    while (j < bLen) {
        c[k++] = b[j++];
    }

    return c;
}

var c = mergeList(a, b);
console.log(c);
// [2, 3, 5, 6, 8, 8, 9, 11, 11, 15, 20]

//  O(aLen + bLen)

// 
// 
var a = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5 };
a.length = 6;

function insert(a, i, elem) {
    if (!elem) return;

    var len = a.length;
    if (i >= len) {
        while (len < i) {
            a[len++] = undefined;
            a.length++;
        }
        a[i] = elem;
    } else {
        while (len > i) {
            a[len--] = a[len];
        }
        a[i] = elem;
    }
    a.length++;
}

insert(a, 3, 8);
insert(a, 10, 10);
console.log(a);

// 

function del(a, i) {
    var temp = a[i];
    var j = i + 1;
    var len = a.length;

    while (j < len) {
        a[j - 1] = a[j++];
    }
    a.length--;
    delete a[len - 1];

    return temp;
}

del(a, 3);
console.log(a);
del(a, 10);
console.log(a);

//  O(a.length)

// AB1A>B-1A<B0A=B
function listComp(aList, bList) {
    for (var i = 0; i < aList.length && i < bList.length; i++) {
        if (aList[i] !== bList[i]) return aList[i] > bList[i] ? 1 : -1;
    }

    if (aList.length == bList.length) return 0;

    return aList.length > bList.length ? 1 : -1;
}

function reverse(list) {
    for (var i = 0, j = list.length - 1; i <= j; i++, j--) {
        var temp = list[i];
        list[i] = list[j];
        list[j] = temp;
    }
}

// ABC
function intersect(aList, bList) {
    var cList = [];
    var i = 0,
        j = 0,
        k = 0;

    while (aList[i] && bList[j]) {
        if (aList[i] < bList[j]) i++;else if (aList[i] > bList[j]) j++;else {
            cList[k++] = aList[i];
            i++;
            j++;
        }
    }

    return cList;
}

console.log(intersect([1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');

// ABa
function intersect_true(a, b) {
    var i = 0,
        j = 0,
        k = 0;

    while (a[i] && b[j]) {
        if (a[i] < b[j]) i++;else if (a[i] > b[j]) j++;else {
            a[k++] = a[i];
            i++;
            j++;
        }
    }

    while (a[k]) {
        a.splice(k, 1);
    }return a;
}

console.log(intersect_true([1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');

// abc
// abc
function intersect_delete(a, b, c) {
    var i = 0,
        j = 0,
        k = 0,
        m = 0;

    while (i < a.length && j < b.length && k < c.length) {
        if (b[j] < c[k]) j++;else if (b[j] > c[k]) k++;else {
            // same
            var same = b[j];

            // jk
            while (b[j] === same) {
                j++;
            }while (c[k] === same) {
                k++;
            } // 
            while (i < a.length && a[i] < same) {
                a[m++] = a[i++];
            } // 
            while (i < a.length && a[i] === same) {
                i++;
            }
        }
    }

    // a
    while (i < a.length) {
        a[m++] = a[i++];
    }a.length = m;

    return a;
}

console.log(intersect_delete([1, 2, 3, 4, 5, 6, 9], [1, 3, 5, 7, 9], [1, 5, 9, 13, 17]) + '');

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Created by ldp on 2015/1/19.
 */

/**
 * 
 * 
 * 
 * ""Circular Queue
 * 
 * @export
 * @class CycleQueue
 */
var CycleQueue = function () {
    function CycleQueue() {
        var maxsize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
        (0, _classCallCheck3.default)(this, CycleQueue);

        this.base = {};
        this.front = this.rear = 0;
        this.MAXQSIZE = maxsize;
    }

    CycleQueue.prototype.enQueue = function enQueue(data) {
        if ((this.rear + 1) % this.MAXQSIZE === 0) throw new Error('cycleQueue is already full!');

        this.base[this.rear] = data;
        this.rear = (this.rear + 1) % this.MAXQSIZE;
    };

    CycleQueue.prototype.deQueue = function deQueue() {
        if (this.front === this.rear) throw new Error('cycleQueue is already empty');

        var elem = this.base[this.front];
        this.front = (this.front + 1) % this.MAXQSIZE;

        return elem;
    };

    CycleQueue.prototype.clear = function clear() {
        this.base = {};
        this.front = this.rear = 0;
    };

    CycleQueue.prototype.peekAt = function peekAt() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        index = (index + this.MAXQSIZE) % this.MAXQSIZE;

        return this.base[index + this.front] || null;
    };

    CycleQueue.prototype.getHead = function getHead() {
        var elem = this.base[this.front];
        return elem ? elem : null;
    };

    CycleQueue.prototype.queueTraverse = function queueTraverse(iterator) {
        for (var i = this.front, len = this.rear = this.front; i < len; i++) {
            if (iterator(this.base[i], i)) break;
        }
    };

    CycleQueue.prototype.toString = function toString() {
        var base = [].slice.call(this.base);

        return base.slice(this.front, this.rear - this.front);
    };

    (0, _createClass3.default)(CycleQueue, [{
        key: 'size',
        get: function get() {
            return (this.rear - this.front + this.MAXQSIZE) % this.MAXQSIZE;
        }
    }]);
    return CycleQueue;
}();

exports.default = CycleQueue;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

var _Heap = __webpack_require__(71);

var _Heap2 = _interopRequireDefault(_Heap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 
 * 
 * @export
 * @class PriorityQueue
 */
var PriorityQueue = function () {
    function PriorityQueue() {
        (0, _classCallCheck3.default)(this, PriorityQueue);

        this.heap = new _Heap2.default(function (a, b) {
            return a.priority - b.priority;
        });
    }

    PriorityQueue.prototype.enQueue = function enQueue(value) {
        var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (typeof value === 'undefined') throw new Error('argument required');

        // 
        this.heap.add({
            value: value,
            priority: priority
        });
    };

    PriorityQueue.prototype.deQueue = function deQueue() {
        return this.heap.remove();
    };

    PriorityQueue.prototype.clear = function clear() {
        this.heap.clear();
    };

    (0, _createClass3.default)(PriorityQueue, [{
        key: 'size',
        get: function get() {
            return this.heap.arr.length;
        }
    }]);
    return PriorityQueue;
}(); /**
      * Created by Luke on 2015/2/26.
      */

/*
(priority queue)

 largest-infirst-out

0,,1) ;2) ;3) .(min priorityq u e u e),,;(max priority queue),,.,.




O(lgN)



 */

exports.default = PriorityQueue;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * AVL TREE Class
 *
 * @author Brice Chevalier
 *
 *
 * @desc
 *
 *    Method                Time Complexity
 *    ___________________________________
 *
 *    add                    O(log2(n))
 *    remove                O(log2(n))
 *    getFirst            O(1)
 *    getLast                O(1)
 *    getCount            O(1)
 *    apply                O(n)
 *    clear                O(n)
 *
 *    Memory Complexity in O(n)
 */

function Node(obj) {
    this.object = obj;
    this.height = 1;
    this.left = null;
    this.right = null;
    this.previous = null;
    this.next = null;
    this.parent = null;
}

function AvlTree() {
    this.count = 0;
    this.root = null;
    this.first = null;
    this.last = null;
}
AvlTree.cmp = function (a, b) {
    if (a > b) return 1;else if (a < b) return -1;else return 0;
};

AvlTree.prototype._addLeft = function (node, parent) {
    node.previous = parent.previous;
    node.next = parent;
    node.parent = parent;

    parent.left = node;
    parent.previous = node;

    if (node.previous) {
        node.previous.next = node;
    }

    if (parent === this.first) {
        this.first = node;
    }
};

AvlTree.prototype._addRight = function (node, parent) {
    node.previous = parent;
    node.next = parent.next;
    node.parent = parent;

    parent.right = node;
    parent.next = node;

    if (node.next) {
        node.next.previous = node;
    }

    if (parent === this.last) {
        this.last = node;
    }
};

AvlTree.prototype.add = function (obj) {
    this.count += 1;
    var newNode = new Node(obj);

    if (this.root === null) {
        this.root = newNode;
        this.first = this.root;
        this.last = this.root;
        return newNode;
    }

    var current = this.root;

    while (true) {

        var cmp = AvlTree.cmp(obj, current.object);
        if (cmp < 0) {
            // Adding to the left
            if (current.left === null) {
                this._addLeft(newNode, current);
                break;
            } else {
                current = current.left;
            }
        } else if (cmp > 0) {
            // Adding to the right
            if (current.right === null) {
                this._addRight(newNode, current);
                break;
            } else {
                current = current.right;
            }
        } else {
            if (current.left === null) {
                this._addLeft(newNode, current);
                break;
            } else if (current.right === null) {
                this._addRight(newNode, current);
                break;
            } else {
                if (current.right.height < current.left.height) {
                    current = current.right;
                } else {
                    current = current.left;
                }
            }
        }
    }

    this._balance(newNode.parent);

    return newNode;
};

AvlTree.prototype._balanceLeftRight = function (node) {
    var left = node.left;
    var a = left.left;
    var b = left.right.left;

    left.right.left = left;
    node.left = left.right;
    left = node.left;
    left.parent = node;

    var leftLeft = left.left;
    leftLeft.parent = left;
    leftLeft.left = a;
    leftLeft.right = b;
    if (a !== null) {
        a.parent = leftLeft;
    }
    if (b !== null) {
        b.parent = leftLeft;
    }

    left.height = leftLeft.height + 1;
};

AvlTree.prototype._balanceLeftLeft = function (node) {
    var left = node.left;
    var c = left.right;

    if (node === this.root) {
        this.root = left;
    } else {
        if (node.parent.right === node) {
            node.parent.right = left;
        } else {
            node.parent.left = left;
        }
    }

    left.right = node;
    left.parent = node.parent;
    node.parent = left;
    node.left = c;
    if (c !== null) {
        c.parent = node;
    }

    node.height = node.height - 1;
};

AvlTree.prototype._balanceRightLeft = function (node) {
    var right = node.right;
    var a = right.right;
    var b = right.left.right;

    right.left.right = right;
    node.right = right.left;
    right = node.right;
    right.parent = node;

    var rightRight = right.right;
    rightRight.parent = right;
    rightRight.right = a;
    rightRight.left = b;
    if (a !== null) {
        a.parent = rightRight;
    }
    if (b !== null) {
        b.parent = rightRight;
    }

    node.right.height = rightRight.height + 1;
};

AvlTree.prototype._balanceRightRight = function (node) {
    var right = node.right;
    var c = right.left;

    if (node === this.root) {
        this.root = right;
    } else {
        if (node.parent.left === node) {
            node.parent.left = right;
        } else {
            node.parent.right = right;
        }
    }

    right.left = node;
    right.parent = node.parent;
    node.parent = right;
    node.right = c;
    if (c !== null) {
        c.parent = node;
    }

    node.height = node.height - 1;
};

AvlTree.prototype._balance = function (node) {
    // Balancing the tree
    var current = node;
    while (current !== null) {
        var leftHeight = current.left === null ? 0 : current.left.height;
        var rightHeight = current.right === null ? 0 : current.right.height;
        var newHeight = 1 + Math.max(leftHeight, rightHeight);

        if (newHeight > current.height) {
            current.height = newHeight;
            if (leftHeight - rightHeight > 1) {

                // Left case
                if (current.left.right !== null && (current.left.left === null || current.left.left.height < current.left.right.height)) {
                    // Left Right Case
                    this._balanceLeftRight(current);
                }

                // Left Left Case
                this._balanceLeftLeft(current);

                // The tree has been balanced
                break;
            } else if (rightHeight - leftHeight > 1) {

                // Right case
                if (current.right.left !== null && (current.right.right === null || current.right.right.height < current.right.left.height)) {
                    // Right Left Case
                    this._balanceRightLeft(current);
                }

                // Right Right Case
                this._balanceRightRight(current);

                // The tree has been balanced
                break;
            } else {
                // Node is balanced
                current = current.parent;
            }
        } else {
            break;
        }
    }
};

AvlTree.prototype.remove = function (obj) {
    this._remove(obj, this.root);
};

AvlTree.prototype._remove = function (obj, node) {
    var current = node;

    while (current !== null) {
        var cmp = AvlTree.cmp(obj, current.object);
        if (cmp < 0) {
            current = current.left;
        } else if (cmp > 0) {
            current = current.right;
        } else {
            if (obj === current.object) {

                // Node removal
                this.count -= 1;

                if (current.previous === null) {
                    this.first = current.next;
                } else {
                    current.previous.next = current.next;
                }
                if (current.next === null) {
                    this.last = current.previous;
                } else {
                    current.next.previous = current.previous;
                }

                // Replacing the node by the smallest element greater than it
                var parent = current.parent;
                var left = current.left;
                var right = current.right;

                if (current.right === null) {
                    if (parent === null) {
                        this.root = left;
                    } else {
                        if (parent.right === current) {
                            parent.right = left;
                        } else {
                            parent.left = left;
                        }
                    }

                    if (left !== null) {
                        left.parent = parent;
                    }

                    this._balance(parent);
                    return 1;
                }

                var replacement = current.right;
                var balanceFrom;

                if (replacement.left === null) {
                    balanceFrom = replacement;

                    if (left !== null) {
                        left.parent = replacement;
                    }
                    replacement.left = left;

                    if (parent === null) {
                        this.root = replacement;
                    } else {
                        if (parent.right === current) {
                            parent.right = replacement;
                        } else {
                            parent.left = replacement;
                        }
                    }
                    replacement.parent = parent;

                    this._balance(balanceFrom);

                    return 1;
                }

                replacement = replacement.left;
                while (replacement.left !== null) {
                    replacement = replacement.left;
                }

                if (replacement.right !== null) {
                    replacement.right.parent = replacement.parent;
                }
                replacement.parent.left = replacement.right;

                if (right !== null) {
                    right.parent = replacement;
                }
                replacement.right = right;

                balanceFrom = replacement.parent;

                if (left !== null) {
                    left.parent = replacement;
                }
                replacement.left = left;

                if (parent === null) {
                    this.root = replacement;
                } else {
                    if (parent.right === current) {
                        parent.right = replacement;
                    } else {
                        parent.left = replacement;
                    }
                }
                replacement.parent = parent;

                this._balance(balanceFrom);

                return 1;
            } else {
                if (!this._remove(obj, current.left)) {
                    this._remove(obj, current.right);
                }
            }
        }
    }

    return 0;
};

AvlTree.prototype.removeByRef = function (node) {
    // Node removal
    this.count -= 1;

    if (node.previous === null) {
        this.first = node.next;
    } else {
        node.previous.next = node.next;
    }
    if (node.next === null) {
        this.last = node.previous;
    } else {
        node.next.previous = node.previous;
    }

    // Replacing the node by the smallest element greater than it
    var parent = node.parent;
    var left = node.left;
    var right = node.right;

    if (node.right === null) {
        if (parent === null) {
            this.root = left;
        } else {
            if (parent.right === node) {
                parent.right = left;
            } else {
                parent.left = left;
            }
        }

        if (left !== null) {
            left.parent = parent;
        }

        this._balance(parent);
        return 1;
    }

    var replacement = node.right;
    var balanceFrom;

    if (replacement.left === null) {
        balanceFrom = replacement;

        if (left !== null) {
            left.parent = replacement;
        }
        replacement.left = left;

        if (parent === null) {
            this.root = replacement;
        } else {
            if (parent.right === node) {
                parent.right = replacement;
            } else {
                parent.left = replacement;
            }
        }
        replacement.parent = parent;

        this._balance(balanceFrom);

        return 1;
    }

    replacement = replacement.left;
    while (replacement.left !== null) {
        replacement = replacement.left;
    }

    if (replacement.right !== null) {
        replacement.right.parent = replacement.parent;
    }
    replacement.parent.left = replacement.right;

    if (right !== null) {
        right.parent = replacement;
    }
    replacement.right = right;

    balanceFrom = replacement.parent;

    if (left !== null) {
        left.parent = replacement;
    }
    replacement.left = left;

    if (parent === null) {
        this.root = replacement;
    } else {
        if (parent.right === node) {
            parent.right = replacement;
        } else {
            parent.left = replacement;
        }
    }
    replacement.parent = parent;

    this._balance(balanceFrom);

    return 1;
};

AvlTree.prototype.getFirst = function () {
    return this.first;
};

AvlTree.prototype.getLast = function () {
    return this.last;
};

AvlTree.prototype.getHeight = function () {
    return this.root.height;
};

AvlTree.prototype.getRoot = function () {
    return this.root;
};

AvlTree.prototype.getCount = function () {
    return this.count;
};

AvlTree.prototype.forEach = function (processingFunc, params) {
    for (var current = this.first; current; current = current.next) {
        processingFunc(current.object, params);
    }
};

AvlTree.prototype.forEachReverse = function (processingFunc, params) {
    for (var current = this.last; current; current = current.previous) {
        processingFunc(current.object, params);
    }
};

AvlTree.prototype.clear = function () {
    this.count = 0;
    this.root = null;
    this.first = null;
    this.last = null;
};

module.exports = AvlTree;

console.log('\nAVL tree insert2: ');
var test = new AvlTree();
test.add(3);
test.add(14);
test.add(25);
test.add(81);
test.add(44);

/*
 14
 /    \
 3       44
 /   \
 25     81
 */

console.log('remove_Recursive 2:');

test.remove(81);
test.remove(3);
test.remove(14);
test.remove(25);
test.remove(44);

var str = 'cknobfjtlpqaegrmdhs';
//var str = 'ckbfjlaegmdh';


test = new AvlTree();
for (var i = 0; i < str.length; ++i) {
    test.add(str[i]);
}

test.remove('e');
test.remove('h');
test.remove('b');
test.remove('l');
test.remove('f');
test.remove('j');
test.remove('g');
test.remove('d');
test.remove('k');
test.remove('a');
test.remove('m');
test.remove('n');
test.remove('o');
test.remove('p');
test.remove('q');
test.remove('r');
test.remove('s');
test.remove('t');
test.remove('c');

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*
 MIT License
 Copyright (c) 2012 Santanu Basu
 Copyright (c) 2013 Daniel Wirtz
 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to deal in the Software without restriction, including
 without limitation the rights to use, copy, modify, merge, publish,
 distribute, sublicense, and/or sell copies of the Software, and to
 permit persons to whom the Software is furnished to do so, subject to
 the following conditions:
 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// Based on Santanu Basu's BPlusJS
// https://github.com/santanubasu/BPlusJS
// Modified for stand-alone use

/**
 * @license BTree.js
 * Released under the MIT License
 * see: https://github.com/dcodeIO/BTree.js for details
 */
(function (global) {

    function isDefined(v) {
        return typeof v != 'undefined';
    }

    var Node = function Node(options) {
        options = options || {};
        this.order = options.order || 100;
        this.mergeThreshold = options.mergeThreshold || 40;
        this.data = [];
    };

    Node.prototype.getLeftPeer = function () {
        return this.leftPeer;
    };

    Node.prototype.setLeftPeer = function (leftPeer) {
        this.leftPeer = leftPeer;
    };

    Node.prototype.getRightPeer = function () {
        return this.rightPeer;
    };

    Node.prototype.setRightPeer = function (rightPeer) {
        this.rightPeer = rightPeer;
    };

    Node.prototype.getData = function () {
        return this.data;
    };

    Node.prototype.getSurplus = function () {
        return Math.max(0, Math.floor((this.data.length - this.mergeThreshold) / 2));
    };

    Node.prototype.getRightSurplusData = function () {
        var surplus = this.getSurplus();
        return this.data.splice(this.data.length - surplus);
    };

    Node.prototype.getLeftSurplusData = function () {
        var surplus = this.getSurplus();
        return this.data.splice(0, surplus);
    };

    var InternalNode = function InternalNode(options) {
        Node.call(this, options);
        this.data = options.data;
        this.leftPeer = options.leftPeer;
        this.rightPeer = options.rightPeer;
    };

    InternalNode.prototype = Object.create(Node.prototype);

    InternalNode.prototype.findIndex = function (key) {
        var data = this.data;
        var left = 0;
        var right = data.length - 1;
        var mid = left + Math.floor((right - left) / 2);
        var found = false;
        do {
            mid = left + Math.floor((right - left) / 2);
            if (data[mid].key < key) {
                left = mid + 1;
            } else if (data[mid].key > key) {
                right = mid;
            } else {
                found = true;
            }
        } while (left < right && !found);
        if (found) {
            return mid;
        } else {
            return right;
        }
    };

    InternalNode.prototype.findChild = function (key) {
        var index = this.findIndex(key);
        var element = this.data[index];
        var child;
        if (element.key <= key) {
            child = element.right;
        } else {
            child = element.left;
        }
        return child;
    };

    InternalNode.prototype.insert = function (key, value, clobber) {
        var index = this.findIndex(key);
        var element = this.data[index];
        var child;
        var newNodes, leftElement, rightElement;
        if (element.key <= key) {
            child = element.right;
            newNodes = child.insert(key, value, clobber);
            if (newNodes.length == 3) {
                leftElement = {
                    key: element.key,
                    left: element.left,
                    right: newNodes[0]
                };
                rightElement = {
                    key: newNodes[1],
                    left: newNodes[0],
                    right: newNodes[2]
                };
                this.data.splice(index, 1, leftElement, rightElement);
                return this.split();
            }
        } else {
            child = element.left;
            newNodes = child.insert(key, value, clobber);
            if (newNodes.length == 3) {
                leftElement = {
                    key: newNodes[1],
                    left: newNodes[0],
                    right: newNodes[2]
                };
                rightElement = {
                    key: element.key,
                    left: newNodes[2],
                    right: element.right
                };
                this.data.splice(index, 1, leftElement, rightElement);
                return this.split();
            }
        }
        return newNodes;
    };

    InternalNode.prototype.split = function () {
        if (this.data.length < this.order) {
            return [];
        }
        var splitIndex = Math.floor(this.data.length / 2);
        var leftNode = new InternalNode({
            data: this.data.slice(0, splitIndex),
            leftPeer: this.leftPeer,
            order: this.order,
            mergeThreshold: this.mergeThreshold
        });
        var rightNode = new InternalNode({
            data: this.data.slice(splitIndex + 1, this.data.length),
            rightPeer: this.rightPeer,
            order: this.order,
            mergeThreshold: this.mergeThreshold
        });
        leftNode.setRightPeer(rightNode);
        rightNode.setLeftPeer(leftNode);
        if (isDefined(this.leftPeer)) {
            this.leftPeer.setRightPeer(leftNode);
        }
        if (isDefined(this.rightPeer)) {
            this.rightPeer.setLeftPeer(rightNode);
        }
        return [leftNode, this.data[splitIndex].key, rightNode];
    };

    InternalNode.prototype.remove = function (key, leftMergeOption, rightMergeOption) {
        var index = this.findIndex(key);
        var element = this.data[index];
        var mergeIndex = -1;
        var child;
        var retval;
        if (element.key <= key) {
            child = element.right;
            retval = child.remove(key, element.left, index < this.data.length - 1 ? child.getRightPeer() : undefined);
            if (this.data.length == 1 && retval.length == 4) {
                return [retval[0], retval[3]];
            }
            if (retval.length > 1) {
                if (retval[1] == 1) {
                    mergeIndex = index + 1;
                } else {
                    mergeIndex = index;
                }
            }
        } else {
            child = element.left;
            retval = child.remove(key, index > 0 ? child.getLeftPeer() : undefined, element.right);
            if (this.data.length == 1 && retval.length == 4) {
                return [retval[0], retval[3]];
            }
            if (retval.length > 1) {
                if (retval[1] == 1) {
                    mergeIndex = index;
                } else {
                    mergeIndex = index - 1;
                }
            }
        }
        if (mergeIndex >= 0) {
            var mergeElement = this.data[mergeIndex];
            if (retval.length == 5) {
                mergeElement.key = retval[3];
                return [retval[0]];
            } else {
                if (mergeIndex > 0) {
                    this.data[mergeIndex - 1].right = retval[3];
                }
                if (mergeIndex < this.data.length - 1) {
                    this.data[mergeIndex + 1].left = retval[3];
                }
                this.data.splice(mergeIndex, 1);
                return [retval[0]].concat(this.merge(leftMergeOption, rightMergeOption));
            }
        } else {
            return [retval[0]];
        }
    };

    InternalNode.prototype.merge = function (leftMergeOption, rightMergeOption) {
        if (this.data.length > this.mergeThreshold) {
            return [];
        }
        if (!isDefined(leftMergeOption) && !isDefined(rightMergeOption)) {
            return [];
        }
        var retval = [];
        // var deficit = true;
        var leftSurplus = 0;
        var leftData;
        var rightSurplus = 0;
        var rightData;
        var leftPeer = this.leftPeer;
        var rightPeer = this.rightPeer;
        if (isDefined(leftMergeOption)) {
            leftData = leftMergeOption.getData();
            leftSurplus = leftMergeOption.getSurplus();
        }
        if (isDefined(rightMergeOption)) {
            rightData = rightMergeOption.getData();
            rightSurplus = rightMergeOption.getSurplus();
        }
        if (leftSurplus > rightSurplus) {
            var leftSurplusData = leftMergeOption.getRightSurplusData();
            this.data = leftSurplusData.slice(1).concat([{
                key: this.data[0].left.getData()[0].key,
                left: leftSurplusData[leftSurplusData.length - 1].right,
                right: this.data[0].left
            }], this.data);
            retval[0] = -1;
            retval[1] = leftMergeOption;
            retval[2] = leftSurplusData[0].key;
            retval[3] = this;
        } else if (rightSurplus > leftSurplus) {
            var rightSurplusData = rightMergeOption.getLeftSurplusData();
            this.data = this.data.concat([{
                key: rightSurplusData[0].left.getData()[0].key,
                left: this.data[this.data.length - 1].right,
                right: rightSurplusData[0].left
            }], rightSurplusData.slice(0, rightSurplusData.length - 1));
            retval[0] = 1;
            retval[1] = this;
            retval[2] = rightSurplusData[rightSurplusData.length - 1].key;
            retval[3] = rightMergeOption;
        } else {
            var mergedInternalNode;
            if (!isDefined(leftData)) {
                mergedInternalNode = new InternalNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: this.data.concat([{
                        key: rightData[0].left.getData()[0].key,
                        left: this.data[this.data.length - 1].right,
                        right: rightData[0].left
                    }], rightData)
                });
                retval[0] = 1;
                retval[1] = mergedInternalNode.getData()[0].key;
                retval[2] = mergedInternalNode;
                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
                    rightPeer.getRightPeer().setLeftPeer(mergedInternalNode);
                    mergedInternalNode.setRightPeer(rightPeer.getRightPeer());
                }
                if (isDefined(leftPeer)) {
                    leftPeer.setRightPeer(mergedInternalNode);
                    mergedInternalNode.setLeftPeer(leftPeer);
                }
            } else if (!isDefined(rightData)) {
                mergedInternalNode = new InternalNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: leftData.concat([{
                        key: this.data[0].left.getData()[0].key,
                        left: leftData[leftData.length - 1].right,
                        right: this.data[0].left
                    }], this.data)
                });
                retval[0] = -1;
                retval[1] = mergedInternalNode.getData()[0].key;
                retval[2] = mergedInternalNode;
                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
                    leftPeer.getLeftPeer().setRightPeer(mergedInternalNode);
                    mergedInternalNode.setLeftPeer(leftPeer.getLeftPeer());
                }
                if (isDefined(rightPeer)) {
                    rightPeer.setLeftPeer(mergedInternalNode);
                    mergedInternalNode.setRightPeer(rightPeer);
                }
            } else if (rightData.length < leftData.length) {
                mergedInternalNode = new InternalNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: this.data.concat([{
                        key: rightData[0].left.getData()[0].key,
                        left: this.data[this.data.length - 1].right,
                        right: rightData[0].left
                    }], rightData)
                });
                retval[0] = 1;
                retval[1] = mergedInternalNode.getData()[0].key;
                retval[2] = mergedInternalNode;
                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
                    rightPeer.getRightPeer().setLeftPeer(mergedInternalNode);
                    mergedInternalNode.setRightPeer(rightPeer.getRightPeer());
                }
                if (isDefined(leftPeer)) {
                    leftPeer.setRightPeer(mergedInternalNode);
                    mergedInternalNode.setLeftPeer(leftPeer);
                }
            } else {
                mergedInternalNode = new InternalNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: leftData.concat([{
                        key: this.data[0].left.getData()[0].key,
                        left: leftData[leftData.length - 1].right,
                        right: this.data[0].left
                    }], this.data)
                });
                retval[0] = -1;
                retval[1] = mergedInternalNode.getData()[0].key;
                retval[2] = mergedInternalNode;
                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
                    leftPeer.getLeftPeer().setRightPeer(mergedInternalNode);
                    mergedInternalNode.setLeftPeer(leftPeer.getLeftPeer());
                }
                if (isDefined(rightPeer)) {
                    rightPeer.setLeftPeer(mergedInternalNode);
                    mergedInternalNode.setRightPeer(rightPeer);
                }
            }
        }
        return retval;
    };

    InternalNode.prototype.find = function (key) {
        return this.findChild(key).find(key);
    };

    InternalNode.prototype.range = function (start, end) {
        return this.findChild(start).range(start, end);
    };

    InternalNode.prototype.toString = function (indent) {
        return this.data.map(function (element) {
            return [indent + "[key=" + element.key, "\n" + indent + "    LEFT\n" + element.left.toString(indent + "    "), "\n" + indent + "    RIGHT\n" + element.right.toString(indent + "    ") + "\n" + indent + "]"];
        }).join(",\n");
    };

    var LeafNode = function LeafNode(options) {
        Node.call(this, options);
        this.data = options.data;
        this.leftPeer = options.leftPeer;
        this.rightPeer = options.rightPeer;
    };

    LeafNode.prototype = Object.create(Node.prototype);

    LeafNode.prototype.findIndex = function (key) {
        var data = this.data;
        if (data.length == 0) {
            return 0;
        }
        var left = 0;
        var right = data.length;
        var mid = left + Math.floor((right - left) / 2);
        var found = false;
        do {
            mid = left + Math.floor((right - left) / 2);
            if (data[mid].key < key) {
                left = mid + 1;
            } else if (data[mid].key > key) {
                right = mid;
            } else {
                found = true;
            }
        } while (left !== right && !found);
        if (found) {
            return mid;
        } else {
            return left;
        }
    };

    LeafNode.prototype.insert = function (key, value, clobber) {
        var index = this.findIndex(key);
        var element = this.data[index];
        if (index == this.data.length) {
            this.data.push({
                key: key,
                value: value
            });
        } else if (element.key === key) {
            if (clobber) {
                element.value = value;
            } else {
                return [element.value];
            }
            // This condition may never occur, given the way findIndex is written
        } else if (element.key < key) {
            this.data.splice(index + 1, 0, {
                key: key,
                value: value
            });
        } else {
            this.data.splice(index, 0, {
                key: key,
                value: value
            });
        }
        return this.split();
    };

    LeafNode.prototype.split = function () {
        if (this.data.length < this.order) {
            return [];
        }
        var splitIndex = Math.floor(this.data.length / 2);
        var leftNode = new LeafNode({
            data: this.data.slice(0, splitIndex),
            leftPeer: this.leftPeer,
            order: this.order,
            mergeThreshold: this.mergeThreshold
        });
        var rightNode = new LeafNode({
            data: this.data.slice(splitIndex, this.data.length),
            rightPeer: this.rightPeer,
            order: this.order,
            mergeThreshold: this.mergeThreshold
        });
        leftNode.setRightPeer(rightNode);
        rightNode.setLeftPeer(leftNode);
        if (isDefined(this.leftPeer)) {
            this.leftPeer.setRightPeer(leftNode);
        }
        if (isDefined(this.rightPeer)) {
            this.rightPeer.setLeftPeer(rightNode);
        }
        return [leftNode, this.data[splitIndex].key, rightNode];
    };

    LeafNode.prototype.remove = function (key, leftMergeOption, rightMergeOption) {
        var index = this.findIndex(key);
        var element = this.data[index];
        if (index < this.data.length && element.key === key) {
            this.data.splice(index, 1);
            return [element.value].concat(this.merge(leftMergeOption, rightMergeOption));
        } else {
            return [undefined];
        }
    };

    LeafNode.prototype.merge = function (leftMergeOption, rightMergeOption) {
        if (this.data.length > this.mergeThreshold) {
            return [];
        }
        if (!isDefined(leftMergeOption) && !isDefined(rightMergeOption)) {
            return [];
        }
        var retval = [];
        // var deficit = true;
        var leftSurplus = 0;
        var leftData;
        var rightSurplus = 0;
        var rightData;
        var leftPeer = this.leftPeer;
        var rightPeer = this.rightPeer;
        if (isDefined(leftMergeOption)) {
            leftData = leftMergeOption.getData();
            leftSurplus = leftMergeOption.getSurplus();
        }
        if (isDefined(rightMergeOption)) {
            rightData = rightMergeOption.getData();
            rightSurplus = rightMergeOption.getSurplus();
        }
        if (leftSurplus > rightSurplus) {
            var leftSurplusData = leftMergeOption.getRightSurplusData();
            this.data = leftSurplusData.concat(this.data);
            retval[0] = -1;
            retval[1] = leftMergeOption;
            retval[2] = this.data[0].key;
            retval[3] = this;
        } else if (rightSurplus > leftSurplus) {
            var rightSurplusData = rightMergeOption.getLeftSurplusData();
            this.data = this.data.concat(rightSurplusData);
            retval[0] = 1;
            retval[1] = this;
            retval[2] = rightMergeOption.getData()[0].key;
            retval[3] = rightMergeOption;
        } else {
            var mergedLeafNode;
            if (!isDefined(leftData)) {
                mergedLeafNode = new LeafNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: this.data.concat(rightData)
                });
                retval[0] = 1;
                retval[1] = mergedLeafNode.getData()[0].key;
                retval[2] = mergedLeafNode;
                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
                    rightPeer.getRightPeer().setLeftPeer(mergedLeafNode);
                    mergedLeafNode.setRightPeer(rightPeer.getRightPeer());
                }
                if (isDefined(leftPeer)) {
                    leftPeer.setRightPeer(mergedLeafNode);
                    mergedLeafNode.setLeftPeer(leftPeer);
                }
            } else if (!isDefined(rightData)) {
                mergedLeafNode = new LeafNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: leftData.concat(this.data)
                });
                retval[0] = -1;
                retval[1] = mergedLeafNode.getData()[0].key;
                retval[2] = mergedLeafNode;
                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
                    leftPeer.getLeftPeer().setRightPeer(mergedLeafNode);
                    mergedLeafNode.setLeftPeer(leftPeer.getLeftPeer());
                }
                if (isDefined(rightPeer)) {
                    rightPeer.setLeftPeer(mergedLeafNode);
                    mergedLeafNode.setRightPeer(rightPeer);
                }
            } else if (rightData.length < leftData.length) {
                mergedLeafNode = new LeafNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: this.data.concat(rightData)
                });
                retval[0] = 1;
                retval[1] = mergedLeafNode.getData()[0].key;
                retval[2] = mergedLeafNode;
                if (isDefined(rightPeer) && isDefined(rightPeer.getRightPeer())) {
                    rightPeer.getRightPeer().setLeftPeer(mergedLeafNode);
                    mergedLeafNode.setRightPeer(rightPeer.getRightPeer());
                }
                if (isDefined(leftPeer)) {
                    leftPeer.setRightPeer(mergedLeafNode);
                    mergedLeafNode.setLeftPeer(leftPeer);
                }
            } else {
                mergedLeafNode = new LeafNode({
                    order: this.order,
                    mergeThreshold: this.mergeThreshold,
                    data: leftData.concat(this.data)
                });
                retval[0] = -1;
                retval[1] = mergedLeafNode.getData()[0].key;
                retval[2] = mergedLeafNode;
                if (isDefined(leftPeer) && isDefined(leftPeer.getLeftPeer())) {
                    leftPeer.getLeftPeer().setRightPeer(mergedLeafNode);
                    mergedLeafNode.setLeftPeer(leftPeer.getLeftPeer());
                }
                if (isDefined(rightPeer)) {
                    rightPeer.setLeftPeer(mergedLeafNode);
                    mergedLeafNode.setRightPeer(rightPeer);
                }
            }
        }
        return retval;
    };

    LeafNode.prototype.find = function (key) {
        var index = this.findIndex(key);
        var element = this.data[index];
        if (index < this.data.length && element.key === key) {
            return element.value;
        }
    };

    LeafNode.prototype.range = function (start, end) {
        var node = this;
        var range = [];
        while (isDefined(node)) {
            var startIndex = node.findIndex(start);
            var endIndex = node.findIndex(end);
            var nodeData = node.getData();
            if (startIndex < nodeData.length) {
                for (var i = startIndex; i < endIndex; i++) {
                    range.push(nodeData[i].value);
                }
            }
            if (endIndex == nodeData.length) {
                node = node.getRightPeer();
            } else {
                break;
            }
        }
        return range;
    };

    LeafNode.prototype.toString = function (indent) {
        return indent + "[" + this.data.map(function (element) {
            return element.key;
        }).toString() + "]";
    };

    var Tree = function Tree(options) {
        options = options || {};
        this.order = options.order || 100;
        this.mergeThreshold = options.mergeThreshold || 40;
        this.root = new LeafNode({
            order: this.order,
            mergeThreshold: this.mergeThreshold,
            data: []
        });
    };

    Tree.prototype.toString = function () {
        return this.root.toString("");
    };

    Tree.prototype.insert = function (key, value, clobber) {
        var newNodes = this.root.insert(key, value, clobber);
        if (newNodes.length == 3) {
            this.root = new InternalNode({
                order: this.order,
                mergeThreshold: this.mergeThreshold,
                data: [{
                    key: newNodes[1],
                    left: newNodes[0],
                    right: newNodes[2]
                }]
            });
        } else if (newNodes.length == 1) {
            return newNodes[0];
        }
        return value;
    };

    Tree.prototype.remove = function (key) {
        var retval = this.root.remove(key);
        if (retval.length == 2) {
            this.root = retval[1];
        }
        return retval[0];
    };

    Tree.prototype.find = function (key) {
        return this.root.find(key);
    };

    Tree.prototype.range = function (start, end) {
        return this.root.range(start, end);
    };

    // Expose all types on top
    Tree.Node = Node;
    Tree.InternalNode = InternalNode;
    Tree.LeafNode = LeafNode;

    // Enable module loading if available
    if (typeof module != 'undefined' && module["exports"]) {
        // CommonJS
        module["exports"] = Tree;
    } else if (true) {
        // AMD
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return Tree;
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        // Shim
        if (!global["dcodeIO"]) {
            global["dcodeIO"] = {};
        }
        global["dcodeIO"]["BPlusTree"] = Tree;
    }
})(undefined);

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license btree.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: http://github.com/dcodeIO/btree.js for details
 */
(function (module, console) {
    'use strict';

    /**
     * Concatenates multiple arrays into a new one.
     * @param {...[Array]} var_args
     * @returns {Array}
     * @private
     */

    function concat(var_args) {
        // Array#concat behaves strangely for empty arrays, so...
        var a = [];
        for (var i = 0; i < arguments.length; i++) {
            Array.prototype.push.apply(a, arguments[i]);
        }
        return a;
    }

    /**
     * Searches an array for the specified value.
     * @param {Array} a
     * @param {*} v
     * @returns {number} Index or -1 if not found
     * @private
     */
    function asearch(a, v) {
        // This is faster than Array#indexOf because it's raw. However, we
        // cannot use binary search because nodes do not have a comparable
        // key. If the compiler is smart, it will inline this.
        for (var i = 0; i < a.length; i++) {
            if (a[i] === v) return i;
        }
        return -i;
    }

    /**
     * btree namespace.
     * @type {Object.<string,*>}
     */
    var btree = {};

    /**
     * Strictly compares two strings, character by character. No locales, no number extension.
     * @param {string} a
     * @param {string} b
     * @returns {number} -1 if a < b, 1 if a > b, 0 otherwise
     * @expose
     */
    btree.strcmp = function strcmp(a, b) {
        /** @type {number} */
        var ac;
        /** @type {number} */
        var bc;
        for (var i = 0; i < a.length; i++) {
            if (i >= b.length) {
                return 1;
            }
            if ((ac = a.charCodeAt(i)) < (bc = b.charCodeAt(i))) {
                return -1;
            } else if (ac > bc) {
                return 1;
            }
            // If same, continue
        }
        return a.length == b.length ? 0 : -1;
    };

    /**
     * Compares two numbers.
     * @param {number} a
     * @param {number} b
     * @returns {number} -1 if a < b, 1 if a > b, 0 otherwise
     * @expose
     */
    btree.numcmp = function intcmp(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    };

    /**
     * Creates a BTree class using the given order.
     * Note that this method returns a class, not an instance.
     * @param {number=} order Defaults to 2
     * @param {function(?, ?):number=} compare Compare implementation to use on keys
     * @returns {Function}
     * @expose
     */
    btree.create = function (order, compare) {

        // Validate order
        if (typeof order == 'undefined') {
            order = 52; // Benchmarks proofed that this is close to the optimum
        } else if (typeof order == 'number') {
            order = Math.floor(order);
        } else {
            order = parseInt(order, 10);
        }
        if (order < 1) order = 1;
        var minOrder = order > 1 ? Math.floor(order / 2) : 1;

        // Use numcmp by default
        if (typeof compare != 'function') {
            compare = btree.numcmp;
        }

        /**
         * Validates a node and prints debugging info if something went wrong.
         * @param {!TreeNode|!Tree} node
         * @private
         */
        function validate(node) {
            // This function will be stripped by the compiler
            if (node instanceof Tree) return;
            if (node.leaves.length + 1 != node.nodes.length) {
                console.log("ERROR: Illegal leaf/node count in " + node + ": " + node.leaves.length + "/" + node.nodes.length);
            }
            for (var i = 0; i < node.leaves.length; i++) {
                if (!node.leaves[i]) {
                    console.log("ERROR: Illegal leaf in " + node + " at " + i + ": " + node.leaves[i]);
                }
            }
            for (i = 0; i < node.nodes.length; i++) {
                if (typeof node.nodes[i] == 'undefined') {
                    console.log("ERROR: Illegal node in " + node + " at " + i + ": undefined");
                }
            }
        }

        /**
         * Constructs a new TreeNode.
         * @class A TreeNode.
         * @param {!(TreeNode|Tree)} parent Parent node
         * @param {Array.<!Leaf>=} leaves Leaf nodes
         * @param {Array.<TreeNode>=} nodes Child nodes
         * @constructor
         */
        var TreeNode = function TreeNode(parent, leaves, nodes) {

            /**
             * Parent node.
             * @type {!TreeNode|!Tree}
             */
            this.parent = parent;

            /**
             * Leaf nodes (max. order).
             * @type {!Array.<!Leaf>}
             */
            this.leaves = leaves || [];
            this.leaves.forEach(function (leaf) {
                leaf.parent = this;
            }, this);

            /**
             * Child nodes (max. order+1).
             * @type {!Array.<TreeNode>}
             */
            this.nodes = nodes || [null];
            this.nodes.forEach(function (node) {
                if (node !== null) node.parent = this;
            }, this);
        };

        /**
         * Searches for the node that would contain the specified key.
         * @param {!*} key
         * @returns {{leaf: !Leaf, index: number}|{node: !TreeNode, index: number}} Leaf if the key exists, else the insertion node
         */
        TreeNode.prototype.search = function (key) {
            if (this.leaves.length > 0) {
                var a = this.leaves[0];
                if (compare(a.key, key) == 0) return { leaf: a, index: 0 };
                if (compare(key, a.key) < 0) {
                    if (this.nodes[0] !== null) {
                        return this.nodes[0].search(key); // Left
                    }
                    return { node: this, index: 0 };
                }
                for (var i = 1; i < this.leaves.length; i++) {
                    var b = this.leaves[i];
                    if (compare(b.key, key) == 0) return { leaf: b, index: i };
                    if (compare(key, b.key) < 0) {
                        if (this.nodes[i] !== null) {
                            return this.nodes[i].search(key); // Inner
                        }
                        return { node: this, index: i };
                    }
                    a = b;
                }
                if (this.nodes[i] !== null) {
                    return this.nodes[i].search(key); // Right
                }
                return { node: this, index: i };
            }
            return { node: this, index: 0 };
        };

        /**
         * Gets the value for the given key.
         * @param {!*} key
         * @returns {*|undefined} If there is no such key, undefined is returned
         */
        TreeNode.prototype.get = function (key) {
            var result = this.search(key);
            if (result.leaf) return result.leaf.value;
            return undefined;
        };

        /**
         * Inserts a key/value pair into this node.
         * @param {!*} key
         * @param {*} value
         * @param {boolean=} overwrite Whether to overwrite existing values, defaults to `true`
         * @returns {boolean} true if successfully set, false if already present and overwrite is `false`
         */
        TreeNode.prototype.put = function (key, value, overwrite) {
            var result = this.search(key);
            if (result.leaf) {
                if (typeof overwrite !== 'undefined' && !overwrite) {
                    return false;
                }
                result.leaf.value = value;
                return true;
            } // Key already exists
            var node = result.node,
                index = result.index;
            node.leaves.splice(index, 0, new Leaf(node, key, value));
            node.nodes.splice(index + 1, 0, null);
            if (node.leaves.length > order) {
                // Rebalance
                node.split();
            }
            return true;
        };

        /**
         * Deletes a key from this node.
         * @param {!*} key
         * @returns {boolean} true if the key has been deleted, false if the key does not exist
         */
        TreeNode.prototype.del = function (key) {
            var result = this.search(key);
            if (!result.leaf) return false;
            var leaf = result.leaf,
                node = leaf.parent,
                index = result.index,
                left = node.nodes[index];
            if (left === null) {
                node.leaves.splice(index, 1);
                node.nodes.splice(index, 1);
                node.balance();
            } else {
                var max = left.leaves[left.leaves.length - 1];
                left.del(max.key);
                max.parent = node;
                node.leaves.splice(index, 1, max);
            }
            return true;
        };

        /**
         * Balances this node to fulfill all conditions.
         */
        TreeNode.prototype.balance = function () {
            if (this.parent instanceof Tree) {
                // Special case: Root has just a single child and no leaves
                if (this.leaves.length == 0 && this.nodes[0] !== null) {
                    this.parent.root = this.nodes[0];
                    this.parent.root.parent = this.parent;
                }
                return;
            }
            if (this.leaves.length >= minOrder) {
                return;
            }
            var index = asearch(this.parent.nodes, this),
                left = index > 0 ? this.parent.nodes[index - 1] : null,
                right = this.parent.nodes.length > index + 1 ? this.parent.nodes[index + 1] : null;
            var sep, leaf, rest;
            if (right !== null && right.leaves.length > minOrder) {
                // Append the seperator from parent to this
                sep = this.parent.leaves[index];
                sep.parent = this;
                this.leaves.push(sep);
                // Replace the blank with the first right leaf
                leaf = right.leaves.shift();
                leaf.parent = this.parent;
                this.parent.leaves[index] = leaf;
                // Append the right rest to this
                rest = right.nodes.shift();
                if (rest !== null) rest.parent = this;
                this.nodes.push(rest);
            } else if (left !== null && left.leaves.length > minOrder) {
                // Prepend the seperator from parent to this
                sep = this.parent.leaves[index - 1];
                sep.parent = this;
                this.leaves.unshift(sep);
                // Replace the blank with the last left leaf
                leaf = left.leaves.pop();
                leaf.parent = this.parent;
                this.parent.leaves[index - 1] = leaf;
                // Prepend the left rest to this
                rest = left.nodes.pop();
                if (rest !== null) rest.parent = this;
                this.nodes.unshift(rest);
            } else {
                var subst;
                if (right !== null) {
                    // Combine this + seperator from the parent + right
                    sep = this.parent.leaves[index];
                    subst = new TreeNode(this.parent, concat(this.leaves, [sep], right.leaves), concat(this.nodes, right.nodes));
                    // Remove the seperator from the parent
                    this.parent.leaves.splice(index, 1);
                    // And replace the nodes it seperated with subst
                    this.parent.nodes.splice(index, 2, subst);
                } else if (left !== null) {
                    // Combine left + seperator from parent + this
                    sep = this.parent.leaves[index - 1];
                    subst = new TreeNode(this.parent, concat(left.leaves, [sep], this.leaves), concat(left.nodes, this.nodes));
                    // Remove the seperator from the parent
                    this.parent.leaves.splice(index - 1, 1);
                    // And replace the nodes it seperated with subst
                    this.parent.nodes.splice(index - 1, 2, subst);
                } else {
                    // We should never end here
                    throw new Error("Internal error: " + this.toString(true) + " has neither a left nor a right sibling");
                }
                this.parent.balance();
            }
            // validate(this);
            // validate(this.parent);
        };

        /**
         * Unsplits a child.
         * @param {!Leaf} leaf
         * @param {!TreeNode} rest
         */
        TreeNode.prototype.unsplit = function (leaf, rest) {
            leaf.parent = this;
            rest.parent = this;
            var a = this.leaves[0];
            if (compare(leaf.key, a.key) < 0) {
                this.leaves.unshift(leaf);
                this.nodes.splice(1, 0, rest);
            } else {
                for (var i = 1; i < this.leaves.length; i++) {
                    var b = this.leaves[i];
                    if (compare(leaf.key, b.key) < 0) {
                        this.leaves.splice(i, 0, leaf);
                        this.nodes.splice(i + 1, 0, rest);
                        break;
                    }
                }
                if (i == this.leaves.length) {
                    this.leaves.push(leaf);
                    this.nodes.push(rest);
                }
            }
            if (this.leaves.length > order) {
                this.split();
            }
        };

        /**
         * Splits this node.
         */
        TreeNode.prototype.split = function () {
            var index = Math.floor(this.leaves.length / 2);
            if (this.parent instanceof Tree) {
                this.nodes = [new TreeNode(this, this.leaves.slice(0, index), this.nodes.slice(0, index + 1)), new TreeNode(this, this.leaves.slice(index + 1), this.nodes.slice(index + 1))];
                this.leaves = [this.leaves[index]];
            } else {
                var leaf = this.leaves[index];
                var rest = new TreeNode(this.parent, this.leaves.slice(index + 1), this.nodes.slice(index + 1));
                this.leaves = this.leaves.slice(0, index);
                this.nodes = this.nodes.slice(0, index + 1);
                this.parent.unsplit(leaf, rest);
            }
        };

        /**
         * Returns a string representation of this node.
         * @param {boolean=} includeNodes Whether to include sub-nodes or not
         * @returns {string}
         */
        TreeNode.prototype.toString = function (includeNodes) {
            var val = [];
            for (var i = 0; i < this.leaves.length; i++) {
                val.push(this.leaves[i].key);
            }
            var s = "[" + val.toString() + "]" + (this.parent instanceof Tree ? ":*" : ":" + this.parent);
            if (includeNodes) {
                for (i = 0; i < this.nodes.length; i++) {
                    s += " -> " + this.nodes[i];
                }
            }
            return s;
        };

        /**
         * Prints out the nodes leaves and nodes.
         * @param {number} indent
         */
        TreeNode.prototype.print = function (indent) {
            var space = "";
            for (var i = 0; i < indent; i++) {
                space += " ";
            }for (i = this.leaves.length - 1; i >= 0; i--) {
                if (this.nodes[i + 1] !== null) this.nodes[i + 1].print(indent + 2);
                console.log(space + this.leaves[i].key + (this.parent instanceof Tree ? "*" : ""));
            }
            if (this.nodes[0] !== null) this.nodes[0].print(indent + 2);
        };

        /**
         * Constructs a new Leaf containing a value.
         * @class A Leaf.
         * @param {!TreeNode} parent
         * @param {!*} key
         * @param {*} value
         * @constructor
         */
        var Leaf = function Leaf(parent, key, value) {

            /**
             * Parent node.
             * @type {!TreeNode}
             */
            this.parent = parent;

            /**
             * Key.
             * @type {!*}
             */
            this.key = key;

            /**
             * Value.
             * @type {*}
             */
            this.value = value;
        };

        /**
         * Returns a string representation of this instance.
         * @returns {string}
         */
        Leaf.prototype.toString = function () {
            return "" + this.key;
        };

        /**
         * Constructs a new Tree.
         * @class A Tree.
         * @constructor
         */
        function Tree() {
            this.root = new TreeNode(this);
        }

        /**
         * Inserts a key/value pair into the tree.
         * @param {!*} key
         * @param {*} value
         * @param {boolean=} overwrite Whether to overwrite existing values, defaults to `true`
         * @returns {boolean} true if set, false if already present and overwrite is `false`
         * @throws {Error} If the key is undefined or null or the value is undefined
         * @expose
         */
        Tree.prototype.put = function (key, value, overwrite) {
            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
            if (typeof value === 'undefined') throw new Error("Illegal value: " + value);
            return this.root.put(key, value, overwrite);
        };

        /**
         * Gets the value of the specified key.
         * @param {!*} key
         * @returns {*|undefined} If there is no such key, undefined is returned
         * @throws {Error} If the key is undefined or null
         * @expose
         */
        Tree.prototype.get = function (key) {
            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
            return this.root.get(key);
        };

        /**
         * Deletes a key from the tree.
         * @param {!*} key
         * @returns {boolean} true if the key has been deleted, false if the key does not exist
         * @expose
         */
        Tree.prototype.del = function (key) {
            if (typeof key === 'undefined' || key === null) throw new Error("Illegal key: " + key);
            return this.root.del(key);
        };

        /**
         * Walks through all keys [minKey, ..., maxKey] in ascending order.
         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or NULL, starts at the beginning
         * @param {(*|function(*, *):(boolean|undefined))=} maxKey If omitted or NULL, walks till the end
         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
         *  parameters. May explicitly return true to stop the loop.
         * @expose
         */
        Tree.prototype.walkAsc = function (minKey, maxKey, callback) {
            if (this.root.leaves.length == 0) {
                return;
            }
            if (typeof minKey == 'function') {
                callback = minKey;
                minKey = maxKey = null;
            } else if (typeof maxKey == 'function') {
                callback = maxKey;
                maxKey = null;
            }
            minKey = typeof minKey != 'undefined' ? minKey : null;
            maxKey = typeof maxKey != 'undefined' ? maxKey : null;
            var ptr, index;
            if (minKey === null) {
                // If there is no minimum limit
                ptr = this.root; // set ptr to the outer left node
                while (ptr.nodes[0] !== null) {
                    ptr = ptr.nodes[0];
                }
                index = 0; // and start at its first leaf
            } else {
                // Else lookup
                var result = this.root.search(minKey);
                if (result.leaf) {
                    // If the minimum key itself exists
                    ptr = result.leaf.parent; // set ptr to the containing node
                    index = asearch(ptr.leaves, result.leaf); // and start at its index
                } else {
                    // If the key does not exist
                    ptr = result.node; // set ptr to the insertion node
                    index = result.index; // and start at the insertion index (key > minKey)
                    if (index >= ptr.leaves.length) {
                        // on overrun, begin at the separator in the parent
                        if (ptr.parent instanceof Tree) {
                            return; // empty range
                        }
                        index = asearch(ptr.parent.nodes, ptr);
                        if (index >= ptr.parent.leaves.length) {
                            return; // empty range
                        }
                        ptr = ptr.parent;
                    }
                }
            }
            // ptr/index now points at our first result
            while (true) {
                if (maxKey !== null && compare(ptr.leaves[index].key, maxKey) > 0) {
                    break; // if there are no more keys less than maxKey
                }
                if (callback(ptr.leaves[index].key, ptr.leaves[index].value)) {
                    break; // if the user explicitly breaks the loop by returning true
                }
                if (ptr.nodes[index + 1] !== null) {
                    // Descend
                    ptr = ptr.nodes[index + 1];
                    index = 0;
                    while (ptr.nodes[0] !== null) {
                        ptr = ptr.nodes[0];
                    }
                } else if (ptr.leaves.length > index + 1) {
                    // Next
                    index++;
                } else {
                    // Ascend
                    do {
                        if (ptr.parent instanceof Tree) {
                            return;
                        }
                        index = asearch(ptr.parent.nodes, ptr);
                        ptr = ptr.parent;
                    } while (index >= ptr.leaves.length);
                }
            }
        };

        /**
         * Alias of {@link Tree#walkAsc}.
         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or NULL, starts at the beginning
         * @param {(*|(function(*, *):(boolean|undefined)))=} maxKey If omitted or NULL, walks till the end
         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
         *  parameters. May explicitly return true to stop the loop.
         * @expose
         */
        Tree.prototype.walk = Tree.prototype.walkAsc;

        /**
         * Walks through all keys [minKey, ..., maxKey] in descending order.
         * @param {*|function(*, *):(boolean|undefined)} minKey If omitted or null, walks till the beginning
         * @param {(*|function(*, *):(boolean|undefined))=} maxKey If omitted or null, starts at the end
         * @param {function(*, *):(boolean|undefined)=} callback Callback receiving the key and the corresponding value as its
         *  parameters. May explicitly return true to stop the loop.
         * @expose
         */
        Tree.prototype.walkDesc = function (minKey, maxKey, callback) {
            if (typeof minKey == 'function') {
                callback = minKey;
                minKey = maxKey = null;
            } else if (typeof maxKey == 'function') {
                callback = maxKey;
                maxKey = null;
            }
            minKey = typeof minKey != 'undefined' ? minKey : null;
            maxKey = typeof maxKey != 'undefined' ? maxKey : null;
            var ptr, index;
            if (maxKey === null) {
                // If there is no maximum limit
                ptr = this.root; // set ptr to the outer right node
                while (ptr.nodes[ptr.nodes.length - 1] !== null) {
                    ptr = ptr.nodes[ptr.nodes.length - 1];
                }
                index = ptr.leaves.length - 1; // and start at its last leaf
            } else {
                // Else lookup
                var result = this.root.search(maxKey);
                if (result.leaf) {
                    // If the maximum key itself exists
                    ptr = result.leaf.parent; // set ptr to the containing node
                    index = asearch(ptr.leaves, result.leaf); // and start at its index
                } else {
                    // If the key does not exist
                    ptr = result.node; // set ptr to the insertion node
                    index = result.index - 1; // and start at the insertion index-1 (key < maxKey)
                    while (index < 0) {
                        // on underrun, begin at the separator in the parent
                        if (ptr.parent instanceof Tree) {
                            return; // empty range
                        }
                        index = asearch(ptr.parent.nodes, ptr) - 1;
                        if (index < 0) {
                            return; // empty range
                        }
                        ptr = ptr.parent;
                    }
                }
            }
            // ptr/index now points at our first result
            while (true) {
                if (minKey !== null && compare(ptr.leaves[index].key, minKey) < 0) {
                    break; // if there are no more keys bigger than minKey
                }
                if (callback(ptr.leaves[index].key, ptr.leaves[index].value)) {
                    break; // if the user explicitly breaks the loop by returning true
                }
                if (ptr.nodes[index] !== null) {
                    // Descend
                    ptr = ptr.nodes[index];
                    while (ptr.nodes[ptr.nodes.length - 1] !== null) {
                        ptr = ptr.nodes[ptr.nodes.length - 1];
                    }
                    index = ptr.leaves.length - 1;
                } else if (index > 0) {
                    // Next
                    index--;
                } else {
                    // Ascend
                    do {
                        if (ptr.parent instanceof Tree) {
                            return;
                        }
                        index = asearch(ptr.parent.nodes, ptr) - 1;
                        ptr = ptr.parent;
                    } while (index < 0);
                }
            }
        };

        /**
         * Counts the number of keys between minKey and maxKey (both inclusive).
         * @param {*=} minKey If omitted, counts from the start
         * @param {*=} maxKey If omitted, counts till the end
         * @returns {number}
         * @expose
         */
        Tree.prototype.count = function (minKey, maxKey) {
            var n = 0;
            this.walk(typeof minKey != 'undefined' ? minKey : null, typeof maxKey != 'undefined' ? maxKey : null, function (key, value) {
                n++;
            });
            return n;
        };

        /**
         * Prints out all nodes in the tree.
         * @expose
         */
        Tree.prototype.print = function () {
            this.root.print(0);
        };

        /**
         * Returns a string representation of this instance.
         * @returns {string}
         */
        Tree.prototype.toString = function () {
            return "Tree(" + order + ") " + this.root.toString();
        };

        return Tree;
    };

    module.exports = btree;
})(module, console);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(117)(module)))

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.binarySearch = binarySearch;
exports.binarySearchRecursive = binarySearchRecursive;
/*
 (Binary Search)

 
 () 
 ()

 1  
 LowHighMidLow=0High=n - 1
   MidMid=Math.floor((Low+High)/2)
   K
    
    High=Mid-1 
   Low=Mid+1 
 (Low>High)

 2  
   
  
  
  
 (Decision Tree)
   Math.floor(Math.log(2, n))+1h= Math.floor(Math.log(2, n + 1)) 
   i Math.pow(2, i-1)(i<=h) Pi=1/nASL
 (n+1)/n*Math.log(2,n+1)-1
 n (n>50) ASL Math.log(2,n+1)-1


 O(logn)
 */

// 
function binarySearch(sTable, key) {
    var low = 0;
    var high = sTable.length - 1;

    while (low <= high) {
        var mid = low + high >> 1;
        var elem = sTable[mid];

        if (elem === key) return mid;else if (elem < key) low = mid + 1;else high = mid - 1;
    }

    return -1;
}

console.log('binarySearch: ');
console.log(binarySearch([1, 2, 3, 4, 5], 1)); // 0

// 
function binarySearchRecursive(sTable, key) {
    var low = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var high = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sTable.length - 1;

    if (low > high) return -1;

    var mid = low + high >> 1;
    var elem = sTable[mid];

    if (elem === key) return mid;else if (elem < key) return binarySearchRecursive(sTable, key, mid + 1, high);else return binarySearchRecursive(sTable, key, low, mid - 1);
}

console.log('binarySearchRecursive: ');
console.log(binarySearchRecursive([1, 2, 3, 4, 5], 1)); // 0
console.log(binarySearchRecursive([1, 2, 3, 4, 5], 6)); // -1

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(48);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(47);

var _inherits3 = _interopRequireDefault(_inherits2);

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _xxhashjs = __webpack_require__(268);

var _crypto = __webpack_require__(209);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 Bloom FilterBloom Filterfalse positiveBloom FilterBloom Filter

 Bloom Filter

 Bloom Filter
 mBitSet0kistrhistrhistr0m-1 

 (1) 
 strBitSet
 strh1strh2str hkstrBitSeth1strh2str hkstr1

 (2) 
 strBitSet
 strh1strh2str hkstrBitSeth1strh2str hkstr11str1str
 Bit1Bloom Filter1
 Bit1100%Bloom Filterfalse positive

 (3) 
 Counting bloomfilter(CBF)Bloom FilterCBFBloom FilterBit

 Bloom FilterBit-MapBloom Filterkkbit

 Bloom Filter
 (1)
 Bitkk

 (2) m,n,k
 
 False Positive
 False Negative

 kmnk10mn20false positive0.0000889 10919000

 Bloomfilter 
 1.
 IPEmailkeyhash
 

 2.URL
 URLURL
 

 3.
 
 

 4.
 key
 

 5.CDNsquid
 cache cachecachebloomfiltercacheurlurl
  URL

 Thanks to:
 http://allenkim67.github.io/2016/05/17/nodejs-buffer-tutorial.html
 https://github.com/ceejbot/xx-bloom
 https://github.com/pierrec/js-xxhash
 */

var LN2_SQUARED = Math.LN2 * Math.LN2;

var BloomFilter = function () {
    function BloomFilter() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck3.default)(this, BloomFilter);

        this.init(options);
    }

    BloomFilter.prototype.init = function init(options) {
        if (options.seeds) {
            this.seeds = options.seeds;
            this.hashes = options.seeds.length;
        } else {
            this.seeds = [];
            this.hashes = options.hashes || 0;

            this._generateSeeds();
        }

        this.bits = options.bits || 1024;
        this.buffer = Buffer.alloc(Math.ceil(this.bits / 8));

        this.clear();
    };

    BloomFilter.optimize = function optimize(itemCount) {
        var errorRate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.005;

        var bits = Math.round(-1 * itemCount * Math.log(errorRate) / LN2_SQUARED);
        var hashes = Math.round(bits / itemCount * Math.LN2);

        return {
            bits: bits,
            hashes: hashes
        };
    };

    BloomFilter.createOptimal = function createOptimal(itemCount, errorRate) {
        var opts = this.optimize(itemCount, errorRate);

        return new this(opts);
    };

    BloomFilter.prototype.clear = function clear() {
        //  buf.fill(0) to initialize a Buffer to zeroes
        this.buffer.fill(0);
    };

    BloomFilter.prototype._generateSeeds = function _generateSeeds() {
        if (!this.seeds) this.seeds = [];

        for (var i = 0; i < this.hashes; ++i) {
            // Generates cryptographically strong pseudo-random data. Generate 4 bytes.
            var buf = (0, _crypto.randomBytes)(4);
            // Reads an unsigned 32-bit integer from the Buffer from index 0
            this.seeds[i] = buf.readUInt32LE(0);

            // Make sure we don't end up with two identical seeds,
            // which is unlikely but possible.
            for (var j = 0; j < i; ++j) {
                if (this.seeds[i] === this.seeds[j]) {
                    --i;
                    break;
                }
            }
        }
    };

    BloomFilter.prototype.add = function add(buf) {
        if (Array.isArray(buf)) {
            for (var _iterator = buf, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var item = _ref;

                this.add(item);
            }
        } else {
            buf = Buffer.from(buf);

            for (var i = 0; i < this.hashes; ++i) {
                var hash = (0, _xxhashjs.h32)(buf, this.seeds[i]).toString();
                var bit = hash % this.bits;
                this._setBit(bit);
            }
        }
    };

    BloomFilter.prototype.has = function has(item) {
        item = Buffer.from(item);

        for (var i = 0; i < this.hashes; ++i) {
            var hash = (0, _xxhashjs.h32)(item, this.seeds[i]).toString();
            var bit = hash % this.bits;

            var isInSet = this._getBit(bit);
            if (!isInSet) return false;
        }

        return true;
    };

    BloomFilter.prototype._setBit = function _setBit(bit) {
        var pos = Math.floor(bit / 8);
        var shift = bit % 8;

        var bitField = this.buffer[pos];
        bitField |= 0x1 << shift;
        this.buffer[pos] = bitField;
    };

    BloomFilter.prototype._getBit = function _getBit(bit) {
        var pos = Math.floor(bit / 8);
        var shift = bit % 8;

        var bitField = this.buffer[pos];

        return (bitField & 0x1 << shift) !== 0;
    };

    return BloomFilter;
}();

exports.default = BloomFilter;


var filter = new BloomFilter({ hashes: 8, bits: 1024 });
filter.add(['cat', 'dog', 'coati', 'red panda']);
console.log(filter.has('cat'));
console.log(filter.has('coat'));
console.log(filter.has('null'));

var CountingBloomFilter = function (_BloomFilter) {
    (0, _inherits3.default)(CountingBloomFilter, _BloomFilter);

    function CountingBloomFilter() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck3.default)(this, CountingBloomFilter);
        return (0, _possibleConstructorReturn3.default)(this, _BloomFilter.call(this, opts));
    }

    CountingBloomFilter.prototype.init = function init(opts) {
        if (opts.seeds) {
            this.seeds = opts.seeds;
            this.hashes = opts.seeds.length;
        } else {
            this.hashes = opts.hashes || 8;
            this._generateSeeds();
        }

        this.bits = opts.bits || 1024;
        this.buffer = Buffer.alloc(this.bits);

        this.clear();
    };

    CountingBloomFilter.createOptimal = function createOptimal(itemCount, errorRate) {
        var opts = BloomFilter.optimize(itemCount, errorRate);
        return new this(opts);
    };

    CountingBloomFilter.prototype.clear = function clear() {
        _BloomFilter.prototype.clear.call(this);

        this.overflow = 0;
    };

    CountingBloomFilter.prototype._setBit = function _setBit(bit) {
        // no-op at overflow
        if (this.buffer[bit] === 255) {
            ++this.overflow;
            return;
        }

        ++this.buffer[bit];
    };

    CountingBloomFilter.prototype._unSetBit = function _unSetBit(bit) {
        if (this.buffer[bit] === 255 || this.buffer[bit] === 0) return;

        --this.buffer[bit];
    };

    CountingBloomFilter.prototype._getBit = function _getBit(bit) {
        return this.buffer[bit] !== 0;
    };

    CountingBloomFilter.prototype.remove = function remove(item) {
        if (!Buffer.isBuffer(item)) item = Buffer.from(item);

        for (var i = 0; i < this.seeds.length; ++i) {
            var hash = (0, _xxhashjs.h32)(item, this.seeds[i]).toString();
            var bit = hash % this.bits;

            this._unSetBit(bit);
        }
    };

    (0, _createClass3.default)(CountingBloomFilter, [{
        key: 'hasOverflowed',
        get: function get() {
            return this.overflow > 0;
        }
    }]);
    return CountingBloomFilter;
}(BloomFilter);

console.log('CountingBloomFilter');
var filter = new CountingBloomFilter({ hashes: 8, bits: 1024 });
filter.add(['cat', 'dog', 'coati', 'red panda']);
console.log(filter.has('cat'));
filter.remove('cat');
console.log(filter.has('cat'));
console.log(filter.has('coat'));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TrieTree = exports.DoubleLinkedTree = undefined;

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Created by Luke on 2015/1/11.
 */

/*

 keyword treedigital search tree

 

 keyword treedigital search treeDigital Search Tree)Trie(trieretrieve4) A,B,C,....Z,A,B,C,...Z, ....

 

 $


 
 1
 2) 


 

 Trie
 1 
 trie
 
 @  N 
 @  robproblem

 2
 Trietrie
 
 @ N Q 
 OfflineLeast Common AncestorLCA
 
 1. Disjoint SetTarjan 
 2. Euler Sequence Range Minimum QueryRMQ
 TarjanRMQ

 3
 Trie
 
 @ N 

 4 
 AC
 */

/*
 

 
 symbol
 first
 next

 firstinfoptr
 
 
 
 symbolnextinfoptrfirst


 

 K.ch(0..num-1), K.ch[0] K.ch[num-2]num-1 K.ch[num-1]$
 firstK.ch[0]symbolfirstnext
 

 // 
 http://www.cnblogs.com/rollenholt/archive/2012/04/24/2468932.html
 http://blog.csdn.net/v_july_v/article/details/6897097
 http://www.raychase.net/1783
 */

var LEAF = 'leaf';
var BRANCH = 'branch';
var TERMINAL = new String('$');

var DoubleLinkedTree = exports.DoubleLinkedTree = function () {
    function DoubleLinkedTree() {
        var symbol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'root';
        var kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BRANCH;
        var info = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        (0, _classCallCheck3.default)(this, DoubleLinkedTree);

        this.symbol = symbol;
        this.next = null;
        this.kind = kind;
        this.info = info;
        this.first = null;
    }

    DoubleLinkedTree.prototype.synoSearch = function synoSearch(key) {
        var p = this.first;

        for (var i = 0; p && i < key.length; ++i) {
            if (p && p.kind === LEAF) break;
            while (p && p.symbol < key[i]) {
                p = p.next;
            }if (p && p.symbol === key[i]) p = p.first;else p = null;
        }

        return p && p.kind === LEAF ? p.info : null;
    };

    DoubleLinkedTree.prototype.search = function search(key) {
        var p = this.first;

        for (var i = 0; p && i < key.length; ++i) {
            while (p && p.symbol < key[i]) {
                p = p.next;
            }if (p && p.symbol === key[i]) p = p.first;else p = null;
        }

        return p && p.kind === LEAF ? p.info : null;
    };

    DoubleLinkedTree.prototype.insert = function insert(key, value) {
        key += '';
        var cur = this;

        for (var i = 0; i < key.length; ++i) {
            var c = key[i];
            var p = cur;
            cur = cur.first;
            var node = new DoubleLinkedTree(c, BRANCH);

            // 
            if (!cur) {
                p.first = node;
                node.parent = p;
                cur = node;
            } else {
                // 
                if (c < cur.symbol) {
                    node.parent = cur.parent;
                    node.next = cur;
                    node.parent.first = node;
                    cur = node;
                } else if (c > cur.symbol) {
                    var b = void 0;
                    while (cur) {
                        // 
                        if (c === cur.symbol) break;
                        // 
                        else if (c < cur.symbol) {
                                node.parent = cur.parent;
                                node.next = cur;
                                b.next = node;
                                cur = node;
                                break;
                            } else {
                                b = cur;
                                cur = cur.next;
                            }
                    }

                    // 
                    if (!cur) {
                        b.next = node;
                        node.parent = b.parent;
                        cur = node;
                    }
                }
            }
        }

        // 
        var success = false;
        if (cur.kind === BRANCH) {
            var child = cur.first;

            // 
            if (!(child && child.symbol === TERMINAL)) {
                cur.first = new DoubleLinkedTree(TERMINAL, LEAF, value != null ? value : key);
                cur.first.parent = cur;
                cur.first.next = child;
                success = true;
            }
        }

        return success;
    };

    DoubleLinkedTree.prototype.remove = function remove(key) {
        var p = this.first;
        var i = 0;

        while (p && i < key.length) {
            while (p && p.symbol < key[i]) {
                p = p.next;
            }if (p && p.symbol === key[i]) {
                p = p.first;
                ++i;
            } else return false;
        }

        var data = p.info;
        while (!p.next && p.parent) {
            p = p.parent;
        }var top = p;

        if (top == this) {
            this.first = null;
            return data;
        }

        p = top.parent;
        if (p) {
            p = p.first;
            while (p) {
                var pre = void 0;
                if (p == top) {
                    // first
                    if (!pre) top.parent.first = top.parent.first.next;
                    // next
                    else pre.next = pre.next.next;

                    return data;
                } else {
                    pre = p;
                    p = p.next;
                }
            }
        }

        return false;
    };

    return DoubleLinkedTree;
}();

var test = new DoubleLinkedTree();
test.insert('CAI');
test.insert('LAN');
test.insert('CAO');
test.insert('CHA');
test.insert('CHANG');
test.insert('CHAO');
test.insert('CHEN');
test.insert('LI');
test.insert('LIU');
test.insert('ZHAO');
test.insert('ZHAO');

console.log('\nsearch: ');
console.log(test.search('CAI'));
console.log(test.search('CHA'));
console.log(test.search('CHANG'));
console.log(test.search('ZHAOx'));

console.log('\nremove:');
console.log(test.remove('CAI'));
console.log(test.remove('CAI'));
console.log(test.remove('LAN'));
console.log(test.remove('CAO'));
console.log(test.remove('CHA'));
console.log(test.remove('CHANG'));
console.log(test.remove('CHAO'));
console.log(test.remove('CHEN'));
console.log(test.remove('LI'));
console.log(test.remove('LIU'));
console.log(test.remove('ZHAO'));

/*
 

 dTrie
 Trieretrievetry
 
 Trie
 d
 


 Trie

 


 Trie

 Trie
 */
// 
function order(c) {
    return c ? c.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0) + 1 : 0;
}

// Trie
function removeNode(trieNode, order, clear) {
    trieNode.branch.nodes[order] = null;
    --trieNode.branch.num;

    if (!clear) return;

    var nodes = trieNode.branch.nodes;
    var parent = trieNode.parent;
    var pre = trieNode;

    while (parent) {
        for (var i in nodes) {
            if (nodes.hasOwnProperty(i) && nodes[i]) return;
        }

        var index = void 0;
        var parentNodes = parent.branch.nodes;
        for (var _i in parentNodes) {
            if (parentNodes.hasOwnProperty(_i) && parentNodes[_i] && parentNodes[_i] == pre) index = _i;
        }
        parent.branch.nodes[index] = null;
        --parent.branch.num;

        pre = parent;
        nodes = parent.branch.nodes;
        parent = parent.parent;
    }
}

var TrieTree = exports.TrieTree = function () {
    function TrieTree() {
        var kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : BRANCH;
        (0, _classCallCheck3.default)(this, TrieTree);

        this.kind = kind;
        this.parent = null;

        if (kind === LEAF) {
            this.leaf = {
                key: null,
                info: null
            };
        } else {
            this.branch = {
                // $26
                nodes: new Array(27),
                num: 0
            };
        }
    }

    TrieTree.prototype.search = function search(key) {
        var p = this,
            i = 0;
        for (; p && p.kind === BRANCH && i < key.length; p = p.branch.nodes[order(key[i])], ++i) {}

        if (p) {
            if (p.kind === LEAF && p.leaf.key === key) return p.leaf.info;
            // 
            else if (p.kind === BRANCH) {
                    p = p.branch.nodes[0];
                    if (p && p.leaf.key === key) return p.leaf.info;
                }
        }

        return null;
    };

    TrieTree.prototype.insert = function insert(key, value) {
        // 
        var q = new TrieTree(LEAF);
        q.leaf.key = key;
        q.leaf.info = value;

        // 
        var last = void 0;
        var p = this,
            i = 0;
        for (; p && p.kind === BRANCH && i < key.length && p.branch.nodes[order(key[i])]; p = p.branch.nodes[order(key[i])], ++i) {
            last = p;
        } // 
        // 
        if (p.kind === BRANCH) {
            p.branch.nodes[order(key[i])] = q;
            q.parent = p;
            ++p.branch.num;
        }
        // 
        else {
                if (p.leaf.key === key) return false;

                // 
                var r = new TrieTree(BRANCH);
                // 
                last.branch.nodes[order(key[i - 1])] = r;
                r.parent = last;
                r.branch.num = 2;
                r.branch.nodes[order(key[i])] = q;
                q.parent = r;
                // 
                r.branch.nodes[order(p.leaf.key[i])] = p;
                p.parent = r;
            }

        return true;
    };

    /**
     *
     * @param key
     * @param {Boolean} clear 
     * @returns {*} infofalse
     */


    TrieTree.prototype.remove = function remove(key, clear) {
        var last = void 0;
        var p = this,
            i = 0;
        // 
        for (; p && p.kind === BRANCH && i < key.length; p = p.branch.nodes[order(key[i])], ++i) {
            last = p;
        }if (!p) return false;

        clear = typeof clear !== 'undefined' ? clear : true;
        var data = null;

        if (p.kind === LEAF && p.leaf.key === key) {
            data = p.leaf.info;
            removeNode(last, order(key[i - 1]), clear);
            return data;
        } else if (p.kind === BRANCH) {
            p = p.branch.nodes[0];
            if (p && p.leaf.key === key) {
                data = p.leaf.info;
                removeNode(p.parent, 0, clear);
                return data;
            }
        }

        return false;
    };

    return TrieTree;
}();

var test = new TrieTree();

test.insert('CHA');
test.insert('CHA');
test.insert('CHANG');
test.insert('CAI');
test.insert('CHEN');
test.insert('CAO');
test.insert('CHAO');
test.insert('LONG');
test.insert('LI');
test.insert('LAN');
test.insert('LIU');
test.insert('WANG');
test.insert('WEN');
test.insert('WU');
test.insert('YANG');
test.insert('YUN');
test.insert('ZHAO');

console.log('\nsearch: ');
console.log(test.search('YUN'));
console.log(test.search('ZHAO'));
console.log(test.search('CHA'));

test.remove('LAN');
test.remove('LIU');
test.remove('WANG');
test.remove('WEN');
test.remove('WU');
test.remove('YANG');
test.remove('YUN');
test.remove('ZHAO');
test.remove('CHA');
test.remove('CHANG');
test.remove('CAI');
test.remove('CHEN');
test.remove('CAO');
test.remove('CHAO');
test.remove('LONG');
test.remove('LI');

test.insert('LI');
test.insert('LAN');
test.insert('LIU');

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LinkedListHashTable = exports.HashTable = undefined;

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _LinkedList = __webpack_require__(80);

var _LinkedList2 = _interopRequireDefault(_LinkedList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hashSize = buildHashSize(977, 20); /**
                                        * HashTable
                                        * Created by Luke on 2014/12/30.
                                        */

/**
()






addr(ai)=H(ki) iaddr(ai)ai kiai



()

kikjkikjH(ki)=H(kj)(collision) 



  
  ()
  





 
 (uniform)

1  
H(key)=key       H(key)=akey+b(a,b)


2  


 8082
           
8  1  3  4  6  5  3  2
8  1  3  7  2  2  4  2
8  1  3  8  7  4  2  2
8  1  3  0  1  3  6  7
8  1  3  2  2  8  1  7
8  1  3  3  8  9  6  7
8  1  3  6  8  5  3  7
8  1  4  1  9  3  5  5
  8
       1
       34
       275
      


3  



4  
()

 
 

 04422058644 
    5864                        5864
    4220                        0224
      04                   04           
 ---------                  -------------
   10088                        6091

5  
mpH(key)=key MOD p     (p<=m)

ppp
  p=2i(p<=m)
 p=q*f(qfp<=m)qfqf
 pp=q*f(qf20p<=m)

6  
H(key)=random(key)





 
 
 
 
 






1  
()
Hi(key)=(H(key)+di)  MOD mi=1, 2, , k(k<=m-1)

H(key)m
dii
Hi(key) i

  
T[0 m-1]
di=1, 2, 3, , m-1
hT[h+1]T[h+2]T[m-1]T[0]T[1]T[h-1]
 
 
 T[h]

1 715, 14, 28, 26, 56, 23H(key)=key   MOD  7
H(15)=15  MOD 7=1
H(14)=14  MOD 7=0
H(28)=28  MOD 7=0     H1(28)=1  
H2(28)=2           H(26)=26  MOD 7=5
H(56)=56  MOD 7=0           H1(56)=1     
H2(56)=2       H3(56)=3
H(23)=23  MOD 7=2           H1(23)=3     
H3(23)=4

0     1      2      3      4       5     6
14    15     28     56     23      26


 
 ()

  
di=1,-1,2,-2,3,k  (k<=m/2)


H(15)=15  MOD 7=1         H(14)=14  MOD 7=0
H(28)=28  MOD 7=0           H1(28)=1     
H2(28)=4
H(26)=26  MOD 7=5
H(56)=56  MOD 7=0           H1(56)=1     
H2(56)=0       H3(56)=4    
H4(56)=2
H(23)=23  MOD 7=2      
H1(23)=3


 
 

   
[1m-1]

2  11176029H(key)=key  MOD  11  438

(1)  H(38)=38 MOD 11=5    
     H1=(5+1) MOD 11=6    
     H2=(5+2) MOD 11=7    
     H3=(5+3) MOD 11=8    
(2)  H(38)=38 MOD 11=5      
     H1=(5+1) MOD 11=6    
     H2=(5-1) MOD 11=4     
(3)  H(38)=38 MOD 11=5    
     9H1=(5+9) MOD 11=3 


2  
Hi=RHi(key)     i=1, 2, , k
RHi RH1RH2Hi
  
  


3  
()
m
RecNode *linkhash[m]RecNodeklinkhash[k]

 (19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79) H(key)=key MOD 13:

 0
 1  --> 14 -> 1 -> 27 -> 79
 2
 3  --> 68 -> 55
 4
 5
 6  --> 19 -> 84
 7  --> 20
 8
 9
 10 --> 23 -> 10
 11 --> 11
 12

 


 4  
 
 mhashtable[m]overtable[m]

  (15, 4, 18, 7, 37, 47) 7 H(key)=key MOD 7
                        0     1     2     3     4     5     6
 Hashtable
                         7     15    37          4     47

                        0     1     2     3     4     5     6
 overtable
                         18




 

 1   
 

 K



 

 ASL
 
  
  
   

  =  / 


 ASL

    
 S  1 / 2 * (1 + 1 / (1 - ))
 S  1 / 2 * (1 + 1 / (1 - ) * (1 - ))

    
 S  -1 /  * ln(1 - )
 S  1 / (1 - )

    
 S  1 +  / 2
 S   + e-


 */

var HashTable = exports.HashTable = function () {
    function HashTable() {
        (0, _classCallCheck3.default)(this, HashTable);

        this.data = [];
        // ;
        this.count = 0;
        // 
        this.sizeIndex = 0;
    }

    // 


    HashTable.prototype.search = function search(key) {
        var max = hashSize[this.sizeIndex];
        var p = hash(key, max);
        var c = 0;

        while (p < max && this.data[p] != null && key !== this.data[p]) {
            p = collision(key, ++c, max);
        }

        return {
            success: key === this.data[p],
            collisionTimes: c,
            index: p
        };
    };

    HashTable.prototype.insert = function insert(key) {
        var max = hashSize[this.sizeIndex];
        if (this.count >= max) return { success: false, errormsg: 'table overflowed' };

        var ret = this.search(key);
        var p = ret.index;
        var c = ret.collisionTimes;

        if (ret.success) return false;else if (c < hashSize[this.sizeIndex] / 2) {
            this.data[p] = key;
            ++this.count;
            return true;
        } else {
            this.recreateHashTable();
            return false;
        }
    };

    HashTable.prototype.remove = function remove(key) {
        if (!this.count) return false;

        var max = hashSize[this.sizeIndex];
        var p = hash(key, max);
        var c = 0;

        while (key !== this.data[p]) {
            p = collision(key, ++c, max);
        }if (key === this.data[p]) {
            var data = this.data[p];
            this.data.splice(p, 1);
            --this.count;

            return data;
        }

        return false;
    };

    HashTable.prototype.recreateHashTable = function recreateHashTable() {
        return ++this.sizeIndex < hashSize.length;
    };

    return HashTable;
}();

;

// ELFhash
function hash(str, max) {
    var hash = 0;
    for (var i = 0; i < str.length; i++) {
        hash = (hash << 5) + hash + str.charCodeAt(i);
        hash = hash & hash; // Convert to 32bit integer
        hash = Math.abs(hash);
    }
    return hash % max;
}

function collision(key, times, max) {
    // 
    return (hash(key, max) + times) % max;
}

function isPrime(n) {
    if (n <= 3) return n > 1;
    if (n % 2 === 0 || n % 3 === 0) return false;
    for (var i = 5; i * i <= n; i += 6) {
        if (n % i === 0 || n % (i + 2) === 0) return false;
    }

    return true;
}

function buildHashSize(begin, length) {
    var hashSize = [];

    while (1) {
        if (hashSize.length >= length) break;
        if (isPrime(begin)) hashSize.push(begin);
        ++begin;
    }

    return hashSize;
}

// 
//hashSize = [5, 7]; // for test. will be deleted
var test = new HashTable();
test.insert('17');
test.insert('60');
test.insert('29');
test.insert('38');
test.insert('39');
test.insert('40');

test.remove('17');
test.remove('60');
test.remove('29');
test.remove('38');
test.remove('39');
test.remove('40');

// 

var LinkedListHashTable = exports.LinkedListHashTable = function () {
    function LinkedListHashTable() {
        (0, _classCallCheck3.default)(this, LinkedListHashTable);

        // ;
        this.count = 0;
        // 
        this.sizeIndex = 0;
        this.hNodes = [];
    }

    LinkedListHashTable.prototype.search = function search(key) {
        var max = hashSize[this.sizeIndex];
        var i = hash(key, max);
        var t = this.hNodes;

        if (t[i] == null) return { success: false, index: i };

        var p = t[i];
        var data = null;

        p.forEach(function (node) {
            if (node.data === key) {
                data = node.data;
                return true;
            }
        });

        return { success: data === key, index: i };
    };

    LinkedListHashTable.prototype.insert = function insert(key) {
        var max = hashSize[this.sizeIndex];
        if (this.count >= max) return { success: false, errormsg: 'table overflowed' };

        var ret = this.search(key);
        var index = ret.index;

        if (ret.success) return false;

        if (!this.hNodes[index]) this.hNodes[index] = new _LinkedList2.default();

        if (this.hNodes[index].size < hashSize[this.sizeIndex] / 2) {
            this.hNodes[index].orderInsert(key);
            ++this.count;
            return true;
        } else {
            this.recreateHashTable();
            return false;
        }
    };

    LinkedListHashTable.prototype.remove = function remove(key) {
        if (!this.count) return false;

        var ret = this.search(key);

        if (ret.success) {
            var index = ret.index;
            var data = ret.data;
            this.hNodes[index]['remove'](key);
            --this.count;
            return data;
        }

        return false;
    };

    LinkedListHashTable.prototype.recreateHashTable = function recreateHashTable() {
        return ++this.sizeIndex < hashSize.length;
    };

    return LinkedListHashTable;
}();

;

var test2 = new LinkedListHashTable();
test2.insert('17');
test2.insert('60');
test2.insert('29');
test2.insert('38');
test2.insert('39');
test2.insert('40');

test2.remove('17');
test2.remove('60');
test2.remove('29');
test2.remove('38');
test2.remove('39');
test2.remove('40');

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(48);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(47);

var _inherits3 = _interopRequireDefault(_inherits2);

var _BinarySortedTree = __webpack_require__(74);

var _BinarySortedTree2 = _interopRequireDefault(_BinarySortedTree);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RED = 'red'; /**
                  * Red Black Tree
                  * Created by Luke on 2014/12/30.
                  */
/*
 http://blog.csdn.net/v_july_v/article/details/6105630

 RedBlack
 

 O(log n)

 5
 1.
 2.
 3.NILNULL
 4.
 5.NIL

 5nlognO(log n)


 










224
3
 1


12

 2,

23

 3,



34534534N345




542

++5

 
 a)+
 
 b)+ 

 
 1+()
 2
 3+
 4-
 RB-DELETE-FIXUP(T, x)

 4

 1+()
 5(5)

 2
 5

 3+
 45

 4-
 


 1~434,
*/

var BLACK = 'black';

var RedBlackNode = function (_BSTNode) {
    (0, _inherits3.default)(RedBlackNode, _BSTNode);

    function RedBlackNode() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        (0, _classCallCheck3.default)(this, RedBlackNode);

        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            rest[_key - 1] = arguments[_key];
        }

        var _this = (0, _possibleConstructorReturn3.default)(this, _BSTNode.call.apply(_BSTNode, [this, data].concat(rest)));

        _this.leftChild = null;
        _this.rightChild = null;
        _this.parent = null;

        _this.color = RED;
        _this.data = data;
        return _this;
    }

    return RedBlackNode;
}(_BinarySortedTree2.default);

var RedBlackLeaf = function RedBlackLeaf() {
    (0, _classCallCheck3.default)(this, RedBlackLeaf);

    this.color = BLACK;
    this.leftChild = this;
    this.rightChild = this;
};

var RedBlackTree = function () {
    function RedBlackTree() {
        (0, _classCallCheck3.default)(this, RedBlackTree);

        // 
        this.nil = new RedBlackLeaf();
        this.root = this.nil;
    }

    /**
     * 
     * @param data
     */


    RedBlackTree.prototype.find = function find(data) {
        var z = this.root;
        var me = this;

        return function find(z, data) {
            if (z == me.nil || data === z.data) return z;

            if (data < z.data) return find(z.leftChild, data);else return find(z.rightChild, data);
        }(z, data);
    };

    /**
     * 
     * @param {*} data
     */


    RedBlackTree.prototype.add = function add(data) {
        var z = new RedBlackNode(data);
        z.leftChild = this.nil;
        z.rightChild = this.nil;
        var y = this.nil;
        var x = this.root;

        // y
        while (x != this.nil) {
            y = x;

            if (z.data < x.data) x = x.leftChild;else x = x.rightChild;
        }

        z.parent = y;

        // y
        if (y != this.nil) {
            if (z.data < y.data) y.leftChild = z;else y.rightChild = z;
        }
        // 
        else this.root = z == this.nil ? null : z;

        // 
        this._addFixup(z);
    };

    /**
     * 
     * @param {RedBlackNode} z 
     * @private
     */


    RedBlackTree.prototype._addFixup = function _addFixup(z) {

        while (z != this.root && z.parent.color === RED) {
            if (z.parent == z.parent.parent.leftChild) leftAddFixup(this, z);else rightAddFixup(this, z);
        }

        // 
        this.root.color = BLACK;
    };

    /**
     * 
     * @param {RedBlackNode} z 
     */


    RedBlackTree.prototype.removeNode = function removeNode(z) {
        var x = void 0,
            y = void 0;

        // 
        if (z.leftChild == this.nil || z.rightChild == this.nil) y = z;else y = this.successor(z);

        if (y.leftChild != this.nil) x = y.leftChild;else x = y.rightChild;

        x.parent = y.parent;

        // 
        if (y.parent == this.nil) this.root = x;else if (y == y.parent.leftChild) y.parent.leftChild = x;else y.parent.rightChild = x;

        if (y != z) z.data = y.data;

        // 
        if (y.color === BLACK) this._removeFixup(x);
    };

    // 


    RedBlackTree.prototype.removeNode2 = function removeNode2(z) {
        var y = z;
        var originalYColor = y.color;
        var x = void 0;

        if (z.leftChild == this.nil) {
            x = z.rightChild;
            this._transplant(z, z.rightChild);
        } else if (z.rightChild == this.nil) {
            x = z.leftChild;
            this._transplant(z, z.leftChild);
        } else {
            y = this.min(z.rightChild);
            originalYColor = y.color;
            x = y.rightChild;

            if (y.parent == z) x.parent = y;else {
                this._transplant(y, y.rightChild);
                y.rightChild = z.rightChild;
                y.rightChild.parent = y;
            }

            this._transplant(z, y);
            y.leftChild = z.leftChild;
            y.leftChild.parent = y;
            y.color = z.color;
        }

        if (originalYColor === BLACK) this._removeFixup(x);
    };

    RedBlackTree.prototype._transplant = function _transplant(u, v) {
        if (u.parent == this.nil) this.root = v;else if (u == u.parent.leftChild) u.parent.leftChild = v;else u.parent.rightChild = v;

        v.parent = u.parent;
    };

    /**
     * 
     * @param {RedBlackNode} z
     * @private
     */


    RedBlackTree.prototype._removeFixup = function _removeFixup(z) {
        while (z !== this.root && z.color === BLACK) {
            if (z == z.parent.leftChild) leftRemoveFixup(this, z);else rightRemoveFixup(this, z);
        }

        z.color = BLACK;
    };

    RedBlackTree.prototype.successor = function successor(z) {
        if (z.rightChild != this.nil) return this.min(z.rightChild);

        var y = z.parent;

        while (y != this.nil && z == y.rightChild) {
            z = y;
            y = y.parent;
        }

        return y;
    };

    RedBlackTree.prototype.min = function min(z) {
        while (z.leftChild != this.nil) {
            z = z.leftChild;
        }

        return z;
    };

    /**
     * key
     * @param {*} key
     * @returns {*}
     */


    RedBlackTree.prototype.remove = function remove(key) {
        var z = this.find(key);

        if (z == this.nil) return false;

        return this.removeNode(z);
    };

    return RedBlackTree;
}();

exports.default = RedBlackTree;


RedBlackTree.prototype._rotateLeft = rotate('left');
RedBlackTree.prototype._rotateRight = rotate('right');

function rotate(dir) {
    var c1 = void 0,
        c2 = void 0;
    if (dir === 'left') {
        c1 = 'rightChild';
        c2 = 'leftChild';
    } else {
        c1 = 'leftChild';
        c2 = 'rightChild';
    }

    return function (x) {
        var y = x[c1];
        x[c1] = y[c2];

        if (y[c2] != this.nil) y[c2].parent = x;
        y.parent = x.parent;

        if (x.parent == this.nil) this.root = y;else if (x == x.parent[c2]) x.parent[c2] = y;else x.parent[c1] = y;

        y[c2] = x;
        x.parent = y;
    };
}

function addFixup(dir) {
    var c1 = void 0,
        c2 = void 0,
        rotate1 = void 0,
        rotate2 = void 0;
    if (dir === 'left') {
        c1 = 'rightChild';
        c2 = 'leftChild';
        rotate1 = '_rotateLeft';
        rotate2 = '_rotateRight';
    } else {
        c1 = 'leftChild';
        c2 = 'rightChild';
        rotate1 = '_rotateRight';
        rotate2 = '_rotateLeft';
    }

    return function (tree, z) {
        // note: 

        // 
        var y = z.parent.parent[c1];

        // 1
        // 
        if (y.color === RED) {
            z.parent.color = BLACK;
            y.color = BLACK;
            z.parent.parent.color = RED;
            z = z.parent.parent;
        } else {
            // 2,
            // 
            // 23
            if (z === z.parent[c1]) {
                z = z.parent;
                tree[rotate1](z);
            }

            // 3,
            // 
            z.parent.color = BLACK;
            z.parent.parent.color = RED;
            tree[rotate2](z.parent.parent);
        }
    };
}

var leftAddFixup = addFixup('left');
var rightAddFixup = addFixup('right');
var leftRemoveFixup = removeFixup('left');
var rightRemoveFixup = removeFixup('right');

function removeFixup(dir) {
    var c1 = void 0,
        c2 = void 0,
        r1 = void 0,
        r2 = void 0;
    if (dir === 'left') {
        c1 = 'rightChild';
        c2 = 'leftChild';
        r1 = '_rotateLeft';
        r2 = '_rotateRight';
    } else {
        c1 = 'leftChild';
        c2 = 'rightChild';
        r1 = '_rotateRight';
        r2 = '_rotateLeft';
    }

    return function (tree, z) {
        // note: 

        // 
        var w = z.parent[c1];

        // 1+()
        // 
        if (w.color === RED) {
            w.color = BLACK;
            z.parent.color = RED;
            tree[r1](z.parent);
            w = z.parent[c1];
        }

        // 2
        // 
        if (w[c2].color === BLACK && w[c1].color === BLACK) {
            w.color = RED;
            z = z.parent;
        } else {
            // 3+
            // 
            if (w[c1].color === BLACK) {
                w[c2].color = BLACK;
                w.color = RED;
                tree[r2](w);
                w = z.parent[c1];
            }

            // 4-
            // 
            w.color = z.parent.color;
            z.parent.color = BLACK;
            w[c1].color = BLACK;
            tree[r1](z.parent);
            z = tree.root;
        }
    };
}

var test = new RedBlackTree();
test.add(13);
test.add(8);
test.add(17);
test.add(1);
test.add(6);
test.add(11);
test.add(15);
test.add(22);
test.add(25);
test.add(27);

test.remove(13);
test.remove(8);
test.remove(17);
test.remove(1);
test.remove(6);
test.remove(11);
test.remove(15);
test.remove(22);
test.remove(25);
test.remove(27);

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.secondOptimal = secondOptimal;
exports.createSOSTree = createSOSTree;

var _BinaryTree = __webpack_require__(24);

/**
 * sTable[low..high]weights
 * @param {BinaryTree} tree
 * @param {Array} sTable
 * @param {Array} sWeights
 * @param {Number} low
 * @param {Number} high
 */
function secondOptimal(tree, sTable, sWeights, low, high) {
    var i = low;
    var min = Math.abs(sWeights[high] - sWeights[low]);
    var dw = sWeights[high] + (sWeights[low - 1] || 0);

    // Pi
    for (var j = low + 1; j <= high; ++j) {
        var t = Math.abs(dw - sWeights[j] - sWeights[j - 1]);
        if (t < min) {
            i = j;
            min = t;
        }
    }

    // 
    var a = 0,
        b = void 0,
        c = 0;
    if (i - 1 >= low) b = sWeights[i] - sWeights[i - 1];
    if (i - 2 >= low) a = sWeights[i - 1] - sWeights[i - 2];
    if (i + 1 < high) c = sWeights[i + 1] - sWeights[i];
    if (typeof b === 'number') {
        if (a > c && a > b) --i;else if (a < c && c > b) ++i;
    }

    tree.data = sTable[i];
    //
    if (i === low) tree.leftChild = null;else {
        tree.leftChild = new _BinaryTree.BinaryTree();
        secondOptimal(tree.leftChild, sTable, sWeights, low, i - 1);
    }
    // 
    if (i === high) tree.rightChild = null;else {
        tree.rightChild = new _BinaryTree.BinaryTree();
        secondOptimal(tree.rightChild, sTable, sWeights, i + 1, high);
    }
} /*
   
  
   
  
   
   1
   2
  
  
   PH = wihi   n hi  i wi = cpic pi  i 
  
  
   static optimal search treenearly optimal search tree1%~2%3%
  
   
  
    wl,wl+1,,wh i 
   pi =   wj - wj    pi = Min {pj }
    {rl,rl+1,,ri-1}  {ri+1,ri+2,,rh} 
   */


var tree = new _BinaryTree.BinaryTree();
secondOptimal(tree, ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'], [1, 2, 4, 9, 12, 16, 20, 23, 28], 0, 8);
console.log(tree);

/**
 * 
 * @param {Object} obj weight
 */
function createSOSTree(obj) {
    var tree = void 0;
    if (obj.elems.length === 0) tree = null;else {
        // 
        var sw = findSW(obj.weights);
        tree = new _BinaryTree.BinaryTree();
        secondOptimal(tree, obj.elems, sw, 0, obj.elems.length - 1);
    }

    return tree;
}

function findSW(sTable) {
    var sw = [sTable[0]];

    for (var i = 1; i < sTable.length; ++i) {
        sw[i] = sw[i - 1] + sTable[i];
    }

    return sw;
}

var sosTree = createSOSTree({
    elems: ['A', 'B', 'C', 'D', 'E'],
    weights: [1, 30, 2, 29, 3]
});
sosTree.inOrderRecursive(function (value) {
    console.log('inOrder: ' + value);
});

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass2 = __webpack_require__(5);

var _createClass3 = _interopRequireDefault(_createClass2);

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
DNA

Tries

Tries/*ABCABC*wildcardABC*DEFABC**DEF



LCSLongest Common SubstringLCSO(N*M)DNAO(N*M)O(N)



1. Pattern  Text 
     Text  Trie  Pattern  Pattern  Text  Pattern  Text 
2. Pattern  Text 
     Text+'$'  Pattern  Pattern  Text  c  Text  c  Pattern 
3. Text 
     Text+'$'  Pattern  root 
4. Text1  Text2 
     Text1+'#' + Text2+'$'  '#'  '$'
5. Text 
"abcdefgfed"  "defgfed"
 "defgfed"  "defg"  4 "g"
     Text  Text2 "abcdefgfed" => "defgfedcba" Text+'#' + Text2+'$'  Text  Text1 

http://www.cnblogs.com/gaochundong/p/suffix_tree.html
http://vickyqi.com/2015/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E6%A0%91Java%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81/
*/

var Node = function () {
    function Node() {
        (0, _classCallCheck3.default)(this, Node);

        // the index of a node with a matching suffix, representing a suffix link.
        // -1 indicates this node has no suffix link.
        this.suffixNode = -1;
    }

    Node.prototype.toString = function toString() {
        return 'Node(suffix link: ' + this.suffixNode + ')';
    };

    return Node;
}();

var Edge = function () {
    /**
     * Creates an instance of Edge.
     * @param {any} firstCharIndex  index of start of string part represented by this edge
     * @param {any} lastCharIndex index of end of string part represented by this edge
     * @param {any} sourceNodeIndex ndex of source node of edge
     * @param {any} destNodeIndex index of destination node of edge
     * 
     * @memberOf Edge
     */
    function Edge(firstCharIndex, lastCharIndex, sourceNodeIndex, destNodeIndex) {
        (0, _classCallCheck3.default)(this, Edge);

        this.firstCharIndex = firstCharIndex;
        this.lastCharIndex = lastCharIndex;
        this.sourceNodeIndex = sourceNodeIndex;
        this.destNodeIndex = destNodeIndex;
    }

    Edge.prototype.toString = function toString() {
        return 'Edge(' + this.sourceNodeIndex + ', ' + this.destNodeIndex + ', ' + this.firstCharIndex + ', ' + this.lastCharIndex + ')';
    };

    (0, _createClass3.default)(Edge, [{
        key: 'length',
        get: function get() {
            return this.lastCharIndex - this.firstCharIndex;
        }
    }]);
    return Edge;
}();
/**
 * Represents a suffix from first_char_index to last_char_index.
 * 
 * @class Suffix
 */


var Suffix = function () {
    /**
     * Creates an instance of Suffix.
     * @param {any} sourceNodeIndex index of node where this suffix starts
     * @param {any} firstCharIndex index of start of suffix in string
      * @param {any} lastCharIndex index of end of suffix in string
     * 
     * @memberOf Suffix
     */
    function Suffix(sourceNodeIndex, firstCharIndex, lastCharIndex) {
        (0, _classCallCheck3.default)(this, Suffix);

        this.sourceNodeIndex = sourceNodeIndex;
        this.firstCharIndex = firstCharIndex;
        this.lastCharIndex = lastCharIndex;
    }

    (0, _createClass3.default)(Suffix, [{
        key: 'length',
        get: function get() {
            return this.lastCharIndex - this.firstCharIndex;
        }
    }, {
        key: 'explicit',
        get: function get() {
            return this.firstCharIndex > this.lastCharIndex;
        }
    }, {
        key: 'implicit',
        get: function get() {
            return this.lastCharIndex >= this.firstCharIndex;
        }
    }]);
    return Suffix;
}();

/**
 * A suffix tree for string matching. Uses Ukkonen's algorithm
    for construction.
 * 
 * @class SuffixTree
 */


var SuffixTree = function () {
    function SuffixTree(string, caseInsensitive) {
        (0, _classCallCheck3.default)(this, SuffixTree);

        this.string = string;
        this.caseInsensitive = caseInsensitive;
        this.N = string.length - 1;
        this.nodes = [new Node()];
        this.edges = {};
        this.active = new Suffix(0, 0, -1);

        if (caseInsensitive) {
            this.string = string.toLowerCase();
        }

        for (var i = 0; i < string.length; ++i) {
            this.addPrefix(i);
        }
    }

    /**
     * Lists edges in the suffix tree
     * 
     * @returns 
     * 
     * @memberOf SuffixTree
     */


    SuffixTree.prototype.toString = function toString() {
        var currentIndex = this.N;
        var s = '\tStart \tEnd \tSuf \tFirst \tLast \tString\n';
        var values = Object.values(this.edges);
        values.sort(function (a, b) {
            return a.sourceNodeIndex - b.sourceNodeIndex;
        });

        for (var _iterator = values, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var edge = _ref;

            if (edge.sourceNodeIndex === -1) continue;

            s += '\t' + edge.sourceNodeIndex + ' \t' + edge.destNodeIndex + ' \t' + this.nodes[edge.destNodeIndex].suffixNode + ' \t' + edge.firstCharIndex + ' \t' + edge.lastCharIndex + ' \t';

            var top = Math.min(currentIndex, edge.lastCharIndex);
            s += this.string.substring(edge.firstCharIndex, top + 1) + '\n';
        }

        return s;
    };

    /**
     * The core construction method.
     * 
     * @param {any} lastCharIndex 
     * 
     * @memberOf SuffixTree
     */


    SuffixTree.prototype.addPrefix = function addPrefix(lastCharIndex) {
        var lastParentNode = -1;
        var e = null;
        var parentNode = -1;

        while (true) {
            parentNode = this.active.sourceNodeIndex;

            if (this.active.explicit) {
                // prefix is already in tree
                if (this.edges[this.active.sourceNodeIndex + '-' + this.string[lastCharIndex]]) break;
            } else {
                e = this.edges[this.active.sourceNodeIndex + '-' + this.string[this.active.firstCharIndex]];

                // prefix is already in tree
                if (this.string[e.firstCharIndex + this.active.length + 1] === this.string[lastCharIndex]) break;

                parentNode = this._splitEdge(e, this.active);;
            }

            this.nodes.push(new Node());
            e = new Edge(lastCharIndex, this.N, parentNode, this.nodes.length - 1);
            this._insertEdge(e);

            if (lastParentNode > 0) {
                this.nodes[lastParentNode].suffixNode = parentNode;
            }
            lastParentNode = parentNode;

            if (this.active.sourceNodeIndex === 0) {
                this.active.firstCharIndex += 1;
            } else {
                this.active.sourceNodeIndex = this.nodes[this.active.sourceNodeIndex].suffixNode;
            }

            this._canonizeSuffix(this.active);
        }

        if (lastParentNode > 0) {
            this.nodes[lastParentNode].suffixNode = parentNode;
        }

        this.active.lastCharIndex += 1;
        this._canonizeSuffix(this.active);
    };

    SuffixTree.prototype._insertEdge = function _insertEdge(edge) {
        this.edges[edge.sourceNodeIndex + '-' + this.string[edge.firstCharIndex]] = edge;
    };

    SuffixTree.prototype._removeEdge = function _removeEdge(edge) {
        delete this.edges[edge.sourceNodeIndex + '-' + this.string[edge.firstCharIndex]];
    };

    SuffixTree.prototype._splitEdge = function _splitEdge(edge, suffix) {
        this.nodes.push(new Node());
        var e = new Edge(edge.firstCharIndex, edge.firstCharIndex + suffix.length, suffix.sourceNodeIndex, this.nodes.length - 1);

        this._removeEdge(edge);
        this._insertEdge(e);

        // need to add node for each edge
        this.nodes[e.destNodeIndex].suffixNode = suffix.sourceNodeIndex;
        edge.firstCharIndex += suffix.length + 1;
        edge.sourceNodeIndex = e.destNodeIndex;

        this._insertEdge(edge);

        return e.destNodeIndex;
    };

    /**
     * This canonizes the suffix, walking along its suffix string until it 
        is explicit or there are no more matched nodes
     * 
     * @param {any} suffix 
     * 
     * @memberOf SuffixTree
     */


    SuffixTree.prototype._canonizeSuffix = function _canonizeSuffix(suffix) {
        if (!suffix.explicit) {
            var e = this.edges[suffix.sourceNodeIndex + '-' + this.string[suffix.firstCharIndex]];
            if (e.length <= suffix.length) {
                suffix.firstCharIndex += e.length + 1;
                suffix.sourceNodeIndex = e.destNodeIndex;
                this._canonizeSuffix(suffix);
            }
        }
    };

    /**
     * Returns the index of substring in string or -1 if it
        is not found.
     * 
     * @param {any} substr 
     * 
     * @memberOf SuffixTree
     */


    SuffixTree.prototype.find = function find(substr) {
        if (!substr) return -1;

        if (this.caseInsensitive) substr = substr.toLowerCase();

        var currentNode = 0;
        var i = 0;
        var ln = 0;
        var edge = null;

        while (i < substr.length) {
            edge = this.edges[currentNode + '-' + substr[i]];

            if (!edge) return -1;

            ln = Math.min(edge.length + 1, substr.length - i);

            if (substr.substring(i, i + ln) !== this.string.substring(edge.firstCharIndex, edge.firstCharIndex + ln)) return -1;

            i += edge.length + 1;
            currentNode = edge.destNodeIndex;
        }

        return edge.firstCharIndex - substr.length + ln;
    };

    return SuffixTree;
}();

exports.default = SuffixTree;


var str = 'I need to be searched';
var tree = new SuffixTree(str);
console.log(tree.find('sear'));
console.log(tree + '');

var tree2 = new SuffixTree('mississippi');
console.log(tree2 + '');
console.log(tree2.find('pp'));

var tree3 = new SuffixTree('abcabxabcd');
console.log(tree3 + '');

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = fibonacciSearch;
/*
 Fibonacci

 FibonacciFibonacciFibonacci
 F(0)=0F(1)=1F(j)=F(j-1)+F(j-2) 

 1  
 Fibonacci1n=F(j)-1LowHighMidLow=0High=n - 1
    MidMid=F(j-1) 
    K
   
   (F(j-1)-1) High=Mid-1 
   (F(j-2)-1)Low=Mid+1 (Low>High)

 2  
 Fibonaccif1f2Fibonacci

 3  
 FibonacciFibonacci

 */

function fib(n) {
    if (n === 0) return 0;
    if (n === 1) return 1;
    var f = void 0;
    var f0 = 0;
    var f1 = 1;
    for (var i = 2; i <= n; ++i) {
        f = f0 + f1;
        f0 = f1;
        f1 = f;
    }
    return f;
}

/**
 * STFibonaccikey
 * @param sTable
 * @param key
 * @param n
 */
function fibonacciSearch(sTable, key) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sTable.length;

    var low = 0;
    var high = n - 1;
    var f1 = fib(n);
    var f2 = fib(n - 1);

    while (low <= high) {
        var mid = low + f1 - 1;
        if (sTable[mid] === key) return mid;else if (key < sTable[mid]) {
            high = mid - 1;
            f2 = f1 - f2;
            f1 = f1 - f2;
        } else {
            low = mid + 1;
            f1 = f1 - f2;
            f2 = f2 - f1;
        }
    }
    return -1;
}

console.log('fibonacciSearch: ');
console.log(fibonacciSearch([1, 2, 3, 4, 5], 5)); // 4
console.log(fibonacciSearch([1, 2, 3, 4, 5], 6)); // -1

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sequentialSearch;
/*
 

 

 (Sequential Search)
 1  
 KK

 2  
 Pi=1/niCi=n-i
  ASL(n+1)/2
  nPi=1/(2n)ASL3n+1/4
 */

function sequentialSearch(sTable, key) {
  for (var i = sTable.length - 1; i >= 0 && sTable[i] !== key; --i) {}
  return i;
}

console.log(sequentialSearch([1, 2, 3, 4, 5], 6)); // -1

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.countSort = countSort;
exports.radixSort = radixSort;

var _index = __webpack_require__(75);

/*
 

 Counting sortCiAiCA

 

 n0k(n + k)
 C10100
 108AA91
 1.
 2.iCi
 3.C
 4.iC(i)C(i)1
 
 
 1.
 2.
 3. O(n)
 4.
 */

function maxElem(arr) {
    var max = arr[0];

    for (var i = 1, len = arr.length; i < len; ++i) {
        if (max < arr[i]) max = arr[i];
    }return max;
}

/**
 *
 * @param {Array} sqList 
 * @param {Number} k 
 * @returns {Array}
 */
/**
 * Created by ldp on 2015/2/18.
 */

function countSort() {
    var sqList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : maxElem(sqList);

    var len = sqList.length;
    var c = [];
    var b = [];

    // 
    for (var i = 0; i <= k; ++i) {
        c[i] = 0;
    } // AC
    for (var _i = 0; _i < len; ++_i) {
        c[sqList[_i]]++;
    } // AC
    for (var _i2 = 1; _i2 <= k; ++_i2) {
        c[_i2] += c[_i2 - 1];
    }for (var _i3 = len - 1; _i3 >= 0; --_i3) {
        b[c[sqList[_i3]] - 1] = sqList[_i3];
        --c[sqList[_i3]];
    }

    for (var _i4 = 0; _i4 < len; ++_i4) {
        sqList[_i4] = b[_i4];
    }
}

var arr = [100, 93, 97, 92, 96, 99, 92, 89, 93, 97, 90, 94, 92, 95];
countSort(arr, 100);
console.log(arr + '');

/*
 

 Radix sort1887Tabulation Machine
 
 LSDLeast significant digitalMSDMost significant digitalLSDMSD

 

 O(kn)nkO(nlog(n))kkn
 nBBk = logB(N)NBBn
 klogB(N)
 T
 T= logB(N)n
 logn
 Bklogn

 (a,b)abMSD(Most Significant Dight)LSD(Least Significant Dight)LSDMSDLSD

 d ()   On),  d N O(n) nn   
 */

// 
function maxBit(arr) {
    var d = 1;
    var p = 10;

    for (var i = 0, n = arr.length; i < n; ++i) {
        while (arr[i] >= p) {
            p *= 10;
            ++d;
        }
    }

    return d;
}

function radixSort() {
    var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var d = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : maxBit(arr);

    var n = arr.length;
    var temp = [];
    // 
    var count = [];
    var radix = 1;

    // d
    for (var i = 1; i <= d; ++i) {
        // 
        for (var j = 0; j < 10; ++j) {
            count[j] = 0;
        } // 
        for (var _j = 0; _j < n; ++_j) {
            var k = Math.floor(arr[_j] / radix) % 10;
            ++count[k];
        }
        for (var _j2 = 1; _j2 < 10; ++_j2) {
            count[_j2] += count[_j2 - 1];
        } // tmp
        for (var _j3 = n - 1; _j3 >= 0; --_j3) {
            var _k = Math.floor(arr[_j3] / radix) % 10;
            temp[--count[_k]] = arr[_j3];
        }
        //arr
        for (var _j4 = 0; _j4 < n; ++_j4) {
            arr[_j4] = temp[_j4];
        }radix *= 10;
    }
}

var arr = [100, 93, 97, 92, 96, 99, 92, 89, 93, 97, 90, 94, 92, 95];
radixSort(arr, 100);
console.log(arr + '');

/*
 

 Bucket sort(n)O(n log n)

 

 NK[1....n]M()  ki(B i) kB[i](B[i]N/M)B[i]()B[0]....B[M]
 K= {49 38  35 97  76 73  27 49 }110010f(k)=k/10494(49/10=4)

 

 f(k)()
 N
     (1) O(N)
     (2)   O(Ni*logNi) Ni i
 (2)(O(N*logN))
     (1) f(k)NM[N/M]
     (2)  f(k)

 NM[N/M]
 O(N)+O(M*(N/M)*log(N/M))=O(N+N*(logN-logM))=O(N+N*logN-N*logM)
 N=MO(N)

  O(N+C)C=N*(logN-logM)NMO(N)  O(N+M)
 */

var BUCKETSNUM = 10;

function bucketSort(sqList) {
    var n = sqList.length;
    var bucketA = [];
    var b = [];

    // 
    for (var i = 0; i < BUCKETSNUM; ++i) {
        b[i] = [];
        bucketA[i] = 0;

        for (var j = 0; j < n; ++j) {
            b[i][j] = Infinity;
        }
    }

    // 
    for (var _i5 = 0; _i5 < n; ++_i5) {
        var data = sqList[_i5];
        // noto: 1-100
        var bucket = Math.floor(data / BUCKETSNUM);
        b[bucket][bucketA[bucket]] = data;
        ++bucketA[bucket];
    }

    // 
    for (var _i6 = 0; _i6 < BUCKETSNUM; ++_i6) {
        if (bucketA[_i6] !== 0) {
            (0, _index.quickSort)(b[_i6], 0, bucketA[_i6] - 1);
            //for(let j = 1; j < bucketA[i]; ++j){
            //    let p = b[i][j];
            //    let k;
            //    for(k = j - 1; k >= 0 && p < b[i][k]; --k){
            //        b[i][k + 1] = b[i][k];
            //    }
            //    b[i][k + 1] = p;
            //}
        }
    }

    //console.log(b);
    //console.log(bucketA);

    // 
    var num = 0;
    for (var _i7 = 0; _i7 < BUCKETSNUM; ++_i7) {
        if (bucketA[_i7] !== 0) {
            for (var _j5 = 0; _j5 < bucketA[_i7]; ++_j5) {
                sqList[num++] = b[_i7][_j5];
            }
        }
    }
}
exports.bucketSort = bucketSort;

var arr = [51.2, 93, 1, 92.2, 8, 99.5, 92.0, 89, 93, 97, 90, 94, 92.1, 95];
bucketSort(arr);
console.log(arr + '');

var arr = [51.2, 93, 1, 92.2, 8, 99.5, 92.0, 89, 93, 97, 90, 94, 92.1, 95, Infinity, Infinity, Infinity];
(0, _index.quickSort)(arr);
console.log(arr + '');

/*
 
 O(N)O(N)dO(d*2N) dNO(N+M)MN>>MN
 
 */

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.straightInsertSort = straightInsertSort;
exports.binaryInsertSort = binaryInsertSort;
exports.path2InsertSort = path2InsertSort;
exports.staticLinkedListInsertSort = staticLinkedListInsertSort;
exports.shellSort = shellSort;

var _StaticLinkedList = __webpack_require__(73);

var _StaticLinkedList2 = _interopRequireDefault(_StaticLinkedList);

var _defaultComparision = __webpack_require__(34);

var _defaultComparision2 = _interopRequireDefault(_defaultComparision);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 

  RiR1, R2 ,., Ri-1Ri

 (Straight Insertion Sort) 


 

 1  
 RiR1, R2 ,., Ri-11 
 R[1n]
  R[1i-1]
  R[in]
 R[1]

 2.

 3.
  ()12(R[i]R[0], R[0]R[j+1])
 
 n - 1           2 * (n - 1)

  ()i-1ii+1
 
  (n - 1) * (n + 1) / 2     : (n - 1) * (n + 4) / 2

 n2/4O(n2) 


 */

/**
 * Created by Luke on 2015/2/2.
 */

function straightInsertSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    for (var i = 1, len = sqList.length; i < len; ++i) {
        // , sqList[-1] = sqList[i]
        // js
        var temp = sqList[i];
        // 
        var j = i - 1;
        for (; j >= 0 && comp(temp, sqList[j]) < 0; --j) {
            sqList[j + 1] = sqList[j];
        } // 
        sqList[j + 1] = temp;
    }
}

var a = [7, 4, -2, 19, 13, 6];
straightInsertSort(a);
console.log(a + '');

/*
 

 1  
 R[i] R[1i-1]R1, R2 ,, Ri-1

 O(n2) 


 */

function binaryInsertSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    for (var i = 1, len = sqList.length; i < len; ++i) {
        var temp = sqList[i];
        var low = 0;
        var high = i - 1;

        while (low <= high) {
            var mid = low + high >> 1;

            if (comp(temp, sqList[mid]) < 0) high = mid - 1;else low = mid + 1;
        }

        for (var j = i - 1; j >= high + 1; --j) {
            sqList[j + 1] = sqList[j];
        }

        sqList[high + 1] = temp;
    }
}

var b = [30, 13, 70, 85, 39, 42, 6, 20];
binaryInsertSort(b);
console.log(b + '');

/*
 2-

 n
   dL[1]d[1]d[1]
   L[ ]id[1]
   L[i].key<d[1].key L[i]d[1]
  L[i].keyd[1].key L[i]d[1]
 dfirstfinal

 2-n2/8 L[1]2-
 */

function path2InsertSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var d = [sqList[0]];
    // firstfinald11
    var first = 0;
    var final = 0;
    var len = sqList.length;

    for (var i = 1; i < len; ++i) {
        var item = sqList[i];

        // dd[first]d
        if (comp(item, d[first]) < 0) {
            first = (first - 1) % len;
            d[first] = item;
        }
        // dd[final]d
        else if (comp(item, d[final]) > 0) {
                d[++final] = item;
            }
            // dddd
            else {
                    // d
                    var j = final++;
                    while (comp(item, d[j]) < 0) {
                        d[(j + 1) % len] = d[j];
                        j = (j - 1) % len;
                    }
                    d[(j + 1) % len] = item;
                }
    }

    // dsqList
    for (var _i = 0; _i < len; ++_i) {
        sqList[_i] = d[(_i + first) % len];
    }
}

var c = [49, 38, 65, 13, 97, 27, 76, 5, 100, 78, 15, 15, 20];
path2InsertSort(c);
console.log(c + '');

/*



0
  1()
 i=2 R[i]
  i 

2nO(n2)

.

ii

6list[1]list[6]list[1]list[1]6

ipp > ilist[i]list[p]list[i]p
ip<ip>=i
 */

// 
function staticLinkedListInsertSort(sllist) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    // 
    sllist[0].cur = 1;
    sllist[1].cur = 0;

    var p = void 0,
        q = void 0;
    for (var i = 2, len = sllist.length; i <= len; ++i) {
        p = 0;
        var x = sllist[i].data;

        while (sllist[p].cur && comp(sllist[sllist[p].cur].data, x) < 0) {
            p = sllist[p].cur;
        } // 
        q = sllist[p].cur;
        sllist[p].cur = i;
        sllist[i].cur = q;
    }
}
exports.staticLinkedListInsertSort = staticLinkedListInsertSort;

// 
function arrange(sllist) {
    var p = sllist[0].cur;

    for (var i = 1, len = sllist.length; i < len; ++i) {
        // ilisti
        // iplist
        while (p < i) {
            p = sllist[p].cur;
        } // q
        var q = sllist[p].cur;

        if (p !== i) {
            // i
            var temp = sllist[p];
            sllist[p] = sllist[i];
            sllist[i] = temp;
            // while
            sllist[i].cur = p;
        }

        // p
        p = q;
    }
}

var arr = [49, 38, 65, 97, 76, 13, 27, 52];
var d = new _StaticLinkedList2.default();
d.create(arr);
staticLinkedListInsertSort(d);
console.log(d);
arrange(d);
console.log(d);

/*


(Shell Sort)

1  
   d1(d1<n)nd1d1k(k=1, 2,   d1)R[k], R[d1+k], R[2d1+k] , 
   d2<d1di=1

2  
109, 13, 8, 2, 5, 13, 7, 1, 15, 115, 3, 1:
:    9     13     8      2      5      13      7      1      15      11
:      9     7      1      2      5      13      13     8      15      11
:      2     5      1      9      7      13      11     8      15      13
:      1     2      5      7      8      9      11     13      13      15







 nnT(n)=O(n),T(n)
 1


 1
 1

 http://wenku.baidu.com/link?url=q7kzOxXqc0BLaGUVDY43FQOh2aX1UqBHkkYd3VMwJhJo6rv4SiU686RW3kQCSqGEKytl12S8fBOpwhq-runhX_pbZcg6BeD-miYMPgDhXxK
 */

function shellInsert(sqList, dk, comp) {
    for (var i = dk, len = sqList.length; i < len; ++i) {
        var temp = sqList[i];
        if (comp(temp, sqList[i - dk]) < 0) {
            var j = i - dk;
            for (; j >= 0 && comp(temp, sqList[j]) < 0; j -= dk) {
                sqList[j + dk] = sqList[j];
            }sqList[j + dk] = temp;
        }
    }
}

function shellSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var delta = createDelta(sqList.length);
    //console.log(delta);
    for (var k = 0, t = delta.length; k < t; ++k) {
        shellInsert(sqList, delta[k], comp);
    }
}

function createDelta(n) {
    var arr = [];
    var t = Math.log(n - 1) / Math.log(2) | 0; // Math.log(n - 1) / Math.log(2), Math.log(n + 1) / Math.log(2)
    for (var k = 0; k <= t; ++k) {
        arr[k] = Math.pow(2, t - k) + 1;
    } // Math.pow(2, t - i + 1) - 1, Math.pow(2, t - i) + 1

    arr[arr.length] = 1;

    return arr;
}

console.log('\n\nShell Sort:');
var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
shellSort(arr);
console.log(arr + '');

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.linkedListNaturalMergeSort = exports.naturalMergeSort = undefined;
exports.mergeSortRecursive = mergeSortRecursive;
exports.mergeSortNonRecursive = mergeSortNonRecursive;
exports.natureMergeSort = natureMergeSort;

var _LinkedList = __webpack_require__(80);

var _LinkedList2 = _interopRequireDefault(_LinkedList);

var _Queue = __webpack_require__(16);

var _Queue2 = _interopRequireDefault(_Queue);

var _defaultComparision = __webpack_require__(34);

var _defaultComparision2 = _interopRequireDefault(_defaultComparision);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 

 (Merging) ()O(m+n) 
 
   (C1C2)(C1<C2)C2
  

 1   
   nn1
   n/221
    n

 2-
 {R[k], R[k+1], , R[m]}{R[m+1], R[m+2],, R[h]}
 {DR[l], DR[l+1], , DR[m], DR[m+1], , DR[h] }

 923, 38, 22, 45, 23, 67, 31, 15, 41
 : [23]   [38]   [22]   [45]   [23]   [67]   [31]   [15]   [41]
              |      |      |      |      |      |      |      |
              --------      --------      --------      --------
 : [23    38]    [22     45]    [23     67]    [15     31]   [41]
                 |              |             |              |
                 ---------------               ---------------
 : [22     23      38     45]    [15     23     31     67]    [41]
                        |                              |
                        --------------------------------
 : [15     22      23     23     31     38     45     67]    [41]
                                       |                                |
                                       ----------------------------------
 : [15     22      23     23     31     38     41     45     67


 2  
 d
 j=0
 R[jj+d-1]R[j+dj+2d-1]j2d
 j=j+2d
   >ddd
   d


 3.
n2nO(n)O(n2n)DRO(n)

 */

var nCount = 0; /**
                 * Created by ldp on 2015/2/7.
                 */

var nonRecursiveCount = 0;
var recursiveCount = 0;

/**
 * sr[s1..e1]sr[s2..e2]tr[s1..e2]
 * @param sr
 * @param s1
 * @param e1
 * @param e2
 */
function merge(sr, s1, e1, e2) {
    var comp = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _defaultComparision2.default;

    var temp = [];
    var i = s1;
    var j = e1 + 1;
    var k = 0;

    while (i <= e1 && j <= e2) {
        if (comp(sr[i], sr[j]) < 0) temp[k++] = sr[i++];else temp[k++] = sr[j++];
    }
    while (i <= e1) {
        temp[k++] = sr[i++];
    }while (j <= e2) {
        temp[k++] = sr[j++];
    } // 
    for (i = s1, k = 0; i <= e2; ++i, ++k) {
        sr[i] = temp[k];
    }
}

/**
 * 2-
 * @param {Array} sr
 * @param {Number} s
 * @param {Number} t
 */
function mergeSortRecursive(sr) {
    var s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sr.length - 1;
    var comp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _defaultComparision2.default;

    if (s >= t) return;

    // sr[s..t]sr[s..m]sr[m+1..t]
    var m = s + t >> 1;
    // sr[s..m]sr[s..m]
    mergeSortRecursive(sr, s, m, comp);
    // sr[m+1..t]sr[m+1..t]
    mergeSortRecursive(sr, m + 1, t, comp);
    // sr[s..m]sr[m+1..t]sr[s..t];
    merge(sr, s, m, t, comp);
}

console.log('\n\nmergeSortRecursive:');
var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
mergeSortRecursive(arr);
console.log(arr + '');

function mergeSortNonRecursive(sr) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var j = void 0,
        k = void 0;
    for (var d = 1, n = sr.length - 1; d < n; d *= 2) {
        // 
        j = 0;

        // 
        while ((k = j + 2 * d - 1) < n) {
            merge(sr, j, j + d - 1, k, comp);
            j = k + 1;
        }

        // 
        if (j + d - 1 < n) merge(sr, j, j + d - 1, n, comp);
        // 
        else merge(sr, j, n, n, comp);
    }
}

console.log('\nmergeSortNonRecursive:');
var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
mergeSortNonRecursive(arr);
console.log(arr + '');

// 
// http://www.cnblogs.com/liushang0419/archive/2011/09/19/2181476.html
// http://www.cnblogs.com/lanke/archive/2013/01/15/2860487.html
/*
.a,1,a,.
 */

// 
function pass(sqList, rec, comp) {
    var num = 0;
    rec[num++] = 0;
    var len = sqList.length;

    for (var i = 1; i < len; ++i) {
        if (comp(sqList[i], sqList[i + 1]) > 0) rec[num++] = i + 1;
    }
    rec[num++] = len;

    return num;
}

function natureMergeSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var rec = [];

    //num=2
    //pass()
    for (var num = pass(sqList, rec, comp); num !== 2; num = pass(sqList, rec, comp)) {
        for (var i = 0; i + 2 < num; i += 2) {
            merge(sqList, rec[i], rec[i + 1] - 1, rec[i + 2] - 1, comp);
        }
    }
}

console.log('\nnatureMergeSort:');
var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
natureMergeSort(arr);
console.log(arr + '');

console.log(recursiveCount);
console.log(nonRecursiveCount);
console.log(nCount);

// 
/*
,,.,,,.
 */
var naturalMergeSort = exports.naturalMergeSort = function () {
    return naturalMergeSort;

    function naturalMergeSort(a) {
        var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

        var b = [];
        var n = a.length;
        while (!mergeRuns(a, b, n, comp)) {}
    }

    function mergeRuns(a, b, n, comp) {
        var i = 0;
        var k = 0;
        var asc = true;
        var x = void 0;

        while (i < n) {
            k = i;
            // 
            do {
                x = a[i++];
            } while (i < n && comp(x, a[i]) <= 0);
            // 
            while (i < n && comp(x, a[i]) >= 0) {
                x = a[i++];
            } // 
            merge(a, b, k, i - 1, asc, comp);
            asc = !asc;
        }

        // k0a
        return k === 0;
    }

    function merge(a, b, low, high, asc, comp) {
        var k = asc ? low : high;
        var c = asc ? 1 : -1;
        var i = low;
        var j = high;

        while (i <= j) {
            if (comp(a[i], a[j]) <= 0) b[k] = a[i++];else b[k] = a[j--];
            k += c;
        }
        for (i = k = low, j = high; i <= j; ++i, ++k) {
            a[i] = b[k];
        }
    }
}();

console.log('\nnaturalMergeSort:');
var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
naturalMergeSort(arr);
console.log(arr + '');

// 
var linkedListNaturalMergeSort = exports.linkedListNaturalMergeSort = function () {
    return mergeSort;

    function mergeSort(linkedlist) {
        var needReplace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var comp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _defaultComparision2.default;

        if (!linkedlist) return linkedlist;

        var queue = new _Queue2.default();
        var list = linkedlist.head;

        if (!list || !list.next) return linkedlist;

        var u = list;
        var t = list;
        var v = void 0;
        // 
        for (; t; t = u) {
            while (u && u.next && comp(u.data, u.next.data) <= 0) {
                u = u.next;
            }v = u;
            u = u.next;
            v.next = null;
            queue.enQueue(t);
        }

        t = queue.deQueue();
        // 
        while (queue.size) {
            queue.enQueue(t);
            var a = queue.deQueue();
            var b = queue.deQueue();
            t = merge(a, b, comp);
        }

        if (needReplace) linkedlist.head = t;

        return t;
    }

    function merge(a, b, comp) {
        var c = new _LinkedList2.default();
        var head = { data: null, next: null };
        c.head = head;
        c = c.head;

        while (a && b) {
            if (comp(a.data, b.data) < 0) {
                c.next = a;
                c = a;
                a = a.next;
            } else {
                c.next = b;
                c = b;
                b = b.next;
            }
        }

        c.next = a ? a : b;

        return head.next;
    }
}();

var arr = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4];
var linkedList = new _LinkedList2.default(arr);
linkedListNaturalMergeSort(linkedList);
console.log(linkedList + '');

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.simpleSelectionSort = simpleSelectionSort;
exports.heapSort = heapSort;

var _defaultComparision = __webpack_require__(34);

var _defaultComparision2 = _interopRequireDefault(_defaultComparision);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*


(Selection Sort)




(Simple Selection Sort )n-in-i+1ii=1, 2,  n-1 
1  
7, 4, -2, 19, 13, 6
  7     4    -2     19    13    6
      -2     4     7     19    13    6
      -2     4     7     19    13    6
      -2     4     6     19    13    7
      -2     4     6     7     13    19
      -2     4     6     7     13    19
      -2     4     6     7     13    19

2.
nn-1
in-i
 n*(n - 1) / 2
T(n)=O(n2)
S(n)=O(1)


 */

function simpleSelectionSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    for (var i = 0, len = sqList.length; i < len; ++i) {
        var k = i;
        for (var j = k + 1; j < len; ++j) {
            if (comp(sqList[j], sqList[k]) < 0) k = j;
        }if (k !== i) {
            var temp = sqList[k];
            sqList[k] = sqList[i];
            sqList[i] = temp;
        }
    }
} /**
   * Created by luke on 2015/2/2.
   */

var arr = [7, 4, -2, 19, 13, 6];
simpleSelectionSort(arr);
console.log(arr + '');

/*


nn/2n/2n/4 1
n
 
n2n+1O(n2n) 

,---
 */

/*


1  
nH={k1, k2 ,  kn} 
    kik2i       2in
    kik2i+1   2i+1n

k1()

2  
    1)   k1
    2)  ()()
    3)  ()()
    4)  

()()

3  

  
  n-1
  n-1n-1()
  




  
  

4  
 




5  
R[1],R[2], ,R[n]
n/2n/2
n/21

6   


7  
nh 
   i2i-1h-i2C1(n)
C1(n)4(n-2n-1)
  in-i+12(n-i+1)+1n-1C2(n)
C2(n)<2n2n
 T(n)=O(n2n) S(n)=O(1) 




http://blog.csdn.net/zz198808/article/details/7678055
 */

/**
 * sqList[s..m]sqList[s]
 * sqList[s]sqList[s..m]
 * @param {Array} sqList
 * @param {Number} s
 * @param {Number} m
 */
function heapAdjust(sqList, s, m, comp) {
    var rc = sqList[s];

    // 
    for (var j = 2 * s + 1; j <= m; j = j * 2 + 1) {
        // j
        if (j < m && comp(sqList[j], sqList[j + 1]) < 0) ++j;
        // rcs
        if (comp(rc, sqList[j]) >= 0) break;
        sqList[s] = sqList[j];
        s = j;
    }

    sqList[s] = rc;
}

function heapSort(sqList) {
    var comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultComparision2.default;

    var len = sqList.length;
    // 
    for (var i = (len >> 1) - 1; i >= 0; --i) {
        heapAdjust(sqList, i, len - 1, comp);
    }for (var _i = len - 1; _i > 0; --_i) {
        // sqList[0..i]
        // 
        var temp = sqList[_i];
        sqList[_i] = sqList[0];
        sqList[0] = temp;

        // sqList[0..i - 1]
        heapAdjust(sqList, 0, _i - 1, comp);
    }
}

var arr = [1, 3, 4, 5, 7, 2, 6, 8, 0];
heapSort(arr);
console.log(arr + '');

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 
 *
 * ccmalloc()free()malloc()
 */

var HString = function () {
    function HString() {
        (0, _classCallCheck3.default)(this, HString);

        this.ch = {};
        this.length = 0;
    }

    // 1 <= position <= this.length.positiontHString


    HString.prototype.strInsert = function strInsert(position, tHString) {
        if (position < 1 || position > this.length + 1) throw new Error('unexpected position');

        if (tHString.length) {
            // t
            var i = this.length - 1;
            for (var len = position - 1; i >= len; --i) {
                this.ch[i + tHString.length] = this.ch[i];
            }stringCopy(this.ch, tHString.ch, position - 1, tHString.length - 1, 0);

            this.length += tHString.length;
        }
    };

    HString.prototype.strAssign = function strAssign(chars) {
        stringCopy(this.ch, chars, 0, chars.length - 1, 0);
        this.length = chars.length;
    };

    HString.prototype.strLength = function strLength() {
        return this.length;
    };

    HString.prototype.strCompare = function strCompare(tHString) {
        for (var i = 0, len = this.length; i < len && i < tHString.length; i++) {
            if (this.ch[i] !== tHString.ch[i]) return this.ch[i] - tHString.ch[i];
        }return this.length - tHString.length;
    };

    HString.prototype.clearString = function clearString() {
        this.ch = {};
        this.length = 0;
    };

    HString.prototype.concat = function concat(s) {
        var t = new HString();

        // t.ch[0..this.length - 1] = this.ch[0..this.length - 1]
        stringCopy(t.ch, this.ch, 0, this.length - 1, 0);
        t.length = this.length + s.length;
        // t.ch[this.length..t.length - 1] = s.ch[0..s.length - 1]
        stringCopy(t.ch, s.ch, this.length, s.length - 1, 0);

        return t;
    };

    HString.prototype.substring = function substring(position, len) {
        position = ~~position || 0;
        len = ~~len || this.length;
        if (position < 0 || position > this.length - 1 || len < 0 || len > this.length - position) throw new Error('unexpected parameter');

        var sub = new HString();
        stringCopy(sub.ch, this.ch, 0, len - 1, position);
        sub.length = len;

        return sub;
    };

    HString.prototype.toString = function toString() {
        var s = '';
        for (var i = 0, len = this.length; i < len; i++) {
            s += this.ch[i];
        }
        return s;
    };

    return HString;
}();

exports.default = HString;


function stringCopy(destination, target, destStart, length, targetStart) {
    destStart = destStart || 0;
    length = length || target.length;
    targetStart = targetStart || 0;

    for (var i = 0; i <= length; i++) {
        destination[destStart + i] = target[targetStart + i];
    }
}

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _index = __webpack_require__(25);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Chunk = function Chunk() {
    var chunkSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;
    (0, _classCallCheck3.default)(this, Chunk);

    this.chunkSize = chunkSize;
    this.ch = [];
    for (var i = 0; i < this.chunkSize; i++) {
        this.ch[i] = '#';
    }
    // type: Chunk
    this.next = null;
}; /**
    * 
    *
    * --
    * 44
    * head --> (a,b,c,d) --> (e,f,g,h) --> (i###)
    * 1
    * head --> (a) --> (b) --> (c) --> ... --> (i)
    *
    * 1#
    * 
    *
    * 
    * 
    *  =  / 
    *
    * 
    */


var LString = function () {
    function LString() {
        var chunkSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;
        (0, _classCallCheck3.default)(this, LString);

        // type Chunk
        this.head = null;
        // type: chunk
        this.tail = null;
        // 
        this.length = 0;
        this.chunkSize = chunkSize;
    }

    // LString


    LString.prototype.strAssign = function strAssign(chars) {
        this.head = this.tail = new Chunk(this.chunkSize);
        this.length = chars.length;

        var current = this.head;
        for (var i = 0, len = chars.length; i < len; i++) {
            current.ch[i % this.chunkSize] = chars[i];
            if (i + 1 < len && (i + 1) % this.chunkSize === 0) {
                current.next = new Chunk();
                current = current.next;
            }
        }

        this.tail = current;
    };
    // 
    // TODO chunkSize


    LString.prototype.strCompare = function strCompare(tLString) {
        var current = this.head;
        var curT = tLString.head;

        if (this.length !== tLString.length) return false;

        while (current) {
            for (var i = 0; i < this.chunkSize; i++) {
                if (current.ch[i] !== curT.ch[i]) return false;
            }

            current = current.next;
            curT = curT.next;
        }

        return true;
    };

    LString.prototype.clearString = function clearString() {
        this.head = this.tail = null;
        this.length = 0;
    };

    LString.prototype.concat = function concat(tLSting) {
        if (!tLSting.length) return;

        var ret = new LString(this.chunkSize);

        if (this.head === null) {
            copyString(ret, tLSting);
        } else {
            ret.head = ret.tail = new Chunk(this.chunkSize);
            copyString(ret, this);

            var index = ret.tail.ch.indexOf('#');
            if (index === -1) {
                copyString(ret, tLSting);
            } else {
                copyString(ret, tLSting, ret.tail, tLSting.head, index);
            }
        }

        return ret;
    };

    LString.prototype.substring = function substring(pos, len) {
        pos = ~~pos || 0;
        len = ~~len || this.length;
        if (pos < 0 || pos > this.length - 1 || len < 0 || len > this.length - pos) throw new Error('unexpected parameter');

        var sub = new LString(this.chunkSize);
        var current = findPosChunk(this, pos);
        var curS = sub.head = new Chunk(this.chunkSize);
        var i = 0;
        sub.length = len;

        outerloop: while (current) {
            for (var j = 0, size = this.chunkSize; j < size; j++) {
                if (i === len) {
                    break outerloop;
                } else {
                    curS.ch[j] = current.ch[(i + pos) % this.chunkSize];
                    i++;
                    if ((i + pos) % this.chunkSize === 0) {
                        current = current.next;
                    }
                    if (i % this.chunkSize === 0 && (current.ch[i] || current.next)) {
                        curS.next = new Chunk(this.chunkSize);
                        curS = curS.next;
                    }
                }
            }
        }

        return sub;
    };

    LString.prototype.toString = function toString() {
        var current = this.head;

        if (current === null) return '';

        var str = '';
        while (current) {
            for (var i = 0, len = this.chunkSize; i < len; i++) {
                var ch = current.ch[i];
                if (ch === '#') {
                    return str;
                } else {
                    str += current.ch[i];
                }
            }
            current = current.next;
        }

        return str;
    };

    return LString;
}();

exports.default = LString;


function findPosChunk(lString, pos) {
    var current = lString.head;
    while (current) {
        for (var i = 0, len = lString.chunkSize; i < len; i++) {
            if (pos-- === 0) return current;
        }
        current = current.next;
    }
}

function copyString(destination, target, curD, currT, offset) {
    offset = offset || 0;
    currT = currT || target.head;
    curD = curD || destination.head;
    var k = 0;

    while (currT) {
        for (var i = 0, len = target.chunkSize; i < len; i++, k++) {
            var j = k % curD.chunkSize + offset;
            curD.ch[j % curD.chunkSize] = currT.ch[i];

            if ((j + 1) % curD.chunkSize === 0 && (currT.ch[i + 1] || currT.next)) {
                curD.next = new Chunk(destination.chunkSize);
                curD = curD.next;
            }
        }

        currT = currT.next;
    }

    destination.tail = curD;
    destination.length += target.length;
}

var a = new LString();
var b = new LString();
var c = new LString();

a.strAssign('abcdefg');
console.log(a + '');
b.strAssign('hijklmno');
console.log(b + '');
c.strAssign('abcdefg');
console.log(a.strCompare(b));
console.log(a.strCompare(c));
var t = a.concat(b);
console.log(t + '');
t = t.substring(2, 5);
console.log(t + '');

// 
function palindrome(lStr) {
    var stack = new _index2.default();
    var p = lStr.head;
    var i = 0;

    for (var k = 1; k <= lStr.length; ++k) {
        if (k <= lStr.length / 2) stack.push(p.ch[i]);else if (k > (lStr.length + 1) / 2) {
            var _c = stack.pop();
            if (p.ch[i] !== _c) return false;
        }

        if (++i === lStr.chunkSize) {
            p = p.next;
            i = 0;
        }
    }

    return true;
}

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classCallCheck2 = __webpack_require__(2);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * stringnull string
 * 
 * 
 *
 * 3
 * 1.
 * 2.
 * 3.
 */

/**
 * 
 * 
 * 0
 */

var SString = function () {
    function SString(str) {
        (0, _classCallCheck3.default)(this, SString);

        this.MAXSTRLEN = 10;
        if (str) {
            this[0] = str.length;
            for (var i = 1; i <= str.length; ++i) {
                this[i] = str[i - 1];
            }
        }
    }

    // s1s2


    SString.prototype.concat = function concat(s2) {
        var t = new SString();
        // 
        if (this[0] + s2[0] <= this.MAXSTRLEN) {
            copyStr2T(this);
            copyStr2T(s2, this[0]);
            t[0] = this[0] + s2[0];

            // 
        } else if (this[0] < this.MAXSTRLEN) {
            copyStr2T(this);
            copyStr2T(s2, this[0], this.MAXSTRLEN - this[0]);
            t[0] = this.MAXSTRLEN;

            // s1
        } else {
            copyStr2T(this, 0, this.MAXSTRLEN);
            t[0] = this[0] = this.MAXSTRLEN;
        }

        return t;

        function copyStr2T(str) {
            var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : str[0];

            for (var i = 1, len = end || str[0]; i <= len; i++) {
                t[start + i] = str[i];
            }
        }
    };

    SString.prototype.substring = function substring() {
        var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[0];

        position = ~~position;
        len = ~~len;
        if (position < 0 || position > this[0] - 1 || len < 0 || len > this[0] - position) throw new Error('unexpected parameter');

        var sub = new SString();
        for (var i = 1; i <= len; i++) {
            sub[i] = this[position + i - 1];
        }
        sub[0] = len;

        return sub;
    };

    /**
     * stv
     * todo to be tested
     * @param {SString} t
     * @param {SString} v
     * @returns {number} 
     */


    SString.prototype.replace = function replace(t, v) {
        for (var _n = 0, i = 1; i <= this[0] - t[0] + 1; i++) {
            for (var j = i, _k = 1; t[_k] && this[j] === t[_k]; ++j, ++_k) {}

            // t
            if (k > t[0]) {
                var l = void 0;
                // 
                if (t[0] === v[0]) {
                    for (l = 1; l <= t[0]; ++l) {
                        this[i + l - 1] = v[l];
                    }
                }
                // 
                else if (t[0] < v[0]) {
                        for (l = this[0]; l >= i + t[0]; --l) {
                            this[l + v[0] - t[0]] = this[l];
                        }for (l = 1; l <= v[0]; ++l) {
                            this[i + l - 1] = v[l];
                        }
                    }
                    // 
                    else {
                            for (l = i + v[0]; l <= this[0] + v[0] - t[0]; ++l) {
                                this[l] = this[l - v[0] + t[0]];
                            }for (l = 1; l <= v[0]; ++l) {
                                this[i + l - 1] = v[l];
                            }
                        }

                this[0] = this[0] - t[0] + v[0];
                i += v[0];
                ++_n;
            }
        }

        return n;
    };

    SString.prototype.toString = function toString() {
        var str = '';
        for (var i = 1; this[i]; i++) {
            str += this[i];
        }
        return str;
    };
    // sstringposition


    SString.prototype.index = function index(sstring, position) {
        var i = position || 1;
        var j = 1;

        while (i <= this[0] && j <= sstring[0]) {
            if (this[i] === sstring[j]) {
                i++;
                j++;
            } else {
                i = i - j + 2;
                j = 1;
            }
        }

        return j > sstring[0] ? i - sstring[0] : -1;
    };

    SString.prototype.kmpIndex = function kmpIndex(sstring, position) {
        var i = position || 1;
        var j = 1;
        var next = getNext(sstring);

        while (i <= this[0] && j <= sstring[0]) {
            if (j === 0 || this[i] === sstring[j]) {
                ++i;
                ++j;
            } else {
                j = next[j];
            }
        }

        return j > sstring[0] ? i - sstring[0] : -1;
    };

    // str


    SString.prototype.subtract = function subtract(str) {
        var r = new SString();
        r[0] = 0;

        for (var i = 1; i <= this[0]; ++i) {
            var _c = this[i];
            // c
            var j = 1;
            for (; j < i && this[j] !== _c; ++j) {}
            if (i === j) {
                // str
                var _k2 = 1;
                for (; _k2 <= str[0] && str[_k2] !== _c; ++_k2) {}
                if (_k2 > str[0]) r[++r[0]] = _c;
            }
        }

        return r;
    };

    // todo bug exists


    SString.prototype.delete_substring = function delete_substring(str) {
        var n = 0;
        for (var i = 1; i <= this[0] - str[0] + 1; ++i) {
            var j = 1;
            for (; j <= str[0] && this[i + j - 1] === str[j]; ++j) {}
            if (j > str[0] - 1) {
                for (var _k3 = i; _k3 <= this[0] - str[0]; ++_k3) {
                    this[_k3] = this[_k3 + str[0]];
                }this[0] -= str[0];
                ++n;
            }
        }

        return n;
    };

    return SString;
}();

exports.default = SString;


function getNext(sstring) {
    var i = 1;
    var next = { 1: 0 };
    var j = 0;

    while (i < sstring[0]) {
        if (j === 0 || sstring[i] === sstring[j]) {
            if (sstring[++i] !== sstring[++j]) {
                next[i] = j;
            } else {
                next[i] = next[j];
            }
            //                next[++i] = ++j;
        } else {
            j = next[j];
        }
    }

    return next;
}

var a = new SString();
var b = new SString();
for (var i = 0; i < 4; i++) {
    a[i + 1] = i + '';
    b[i + 1] = i + '';
}
a[0] = b[0] = 4;
var t = a.concat(b);
console.log(t + ''); // 01230123

var d = new SString('acabaabaabcacaabc');
var c = new SString('abaabc');

console.log('index: ' + d.index(c));
console.log('kmpIndex: ' + d.kmpIndex(c));

a = new SString('abcdefg');
b = new SString('asdfg');
console.log(a.subtract(b) + '');

a = new SString('abcdefgh');
b = new SString('cdef');
console.log(a.delete_substring(b) + '');
console.log(a + '');

/*
 
 MAXSTRLEN
 */

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = __webpack_require__(26);
var inherits = __webpack_require__(1);

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = __webpack_require__(267).runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

var Reporter = __webpack_require__(27).Reporter;
var EncoderBuffer = __webpack_require__(27).EncoderBuffer;
var DecoderBuffer = __webpack_require__(27).DecoderBuffer;
var assert = __webpack_require__(13);

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  var result = state['default'];
  var present = true;

  var prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    var start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input, options);
    else
      result = this._decodeChoice(input, options);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
          ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
        ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be ommited only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(1);

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var constants = __webpack_require__(77);

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var decoders = exports;

decoders.der = __webpack_require__(78);
decoders.pem = __webpack_require__(153);


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(1);
var Buffer = __webpack_require__(0).Buffer;

var DERDecoder = __webpack_require__(78);

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var encoders = exports;

encoders.der = __webpack_require__(79);
encoders.pem = __webpack_require__(155);


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(1);

var DEREncoder = __webpack_require__(79);

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
    Array: {
        // CrossList: require('./Array/CrossList').default,
        // TSMatrix: require('./Array/TSMatrix').default
        // todo array algorithms
    },

    BinaryTree: {
        // BinaryThreadTree: require('./BinaryTree/BinaryThreadTree'),
        BinaryTree: __webpack_require__(24),
        huffManCoding: __webpack_require__(119).default,
        BinaryTreeArray: __webpack_require__(118)
        // MFSet: require('./BinaryTree/MFSet'),
    },

    GeneralizedList: __webpack_require__(120).default,

    Graph: {
        AdjacencyListGraph: __webpack_require__(122).default,
        AdjacencyMatrixGraph: __webpack_require__(123).default,
        AMLGraph: __webpack_require__(121).default,
        OLGraph: __webpack_require__(124).default
    },

    List: {
        DoubleLinkedList: __webpack_require__(72).default,
        LinearList: __webpack_require__(126),
        StaticLinkedList: __webpack_require__(73).default,
        LRUCache: __webpack_require__(125).default
    },

    Queue: {
        CycleQueue: __webpack_require__(127).default,
        PriorityQueue: __webpack_require__(128).default,
        Queue: __webpack_require__(16).default
    },

    Search: {
        AVLTree: __webpack_require__(129),
        binarySearch: __webpack_require__(132),
        BinarySortedTree: __webpack_require__(74).default,
        BPlusTree: __webpack_require__(130),
        BTree: __webpack_require__(131),
        DigitalSearchTree: __webpack_require__(134),
        SuffixTree: __webpack_require__(138).default,
        fibonacciSearch: __webpack_require__(139).default,
        HashTable: __webpack_require__(135),
        RedBlackTree: __webpack_require__(136).default,
        sequentialSearch: __webpack_require__(140).default,
        SOSTree: __webpack_require__(137),
        BloomFilter: __webpack_require__(133)
    },

    Sort: {
        distribution: __webpack_require__(141),
        exchange: __webpack_require__(75),
        insertion: __webpack_require__(142),
        merging: __webpack_require__(143),
        selection: __webpack_require__(144)
    },

    Stack: __webpack_require__(25).default,

    String: {
        HString: __webpack_require__(145).default,
        LString: __webpack_require__(146).default,
        SString: __webpack_require__(147).default
        // todo string algorithms
    },

    Heap: __webpack_require__(71).default
};

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(173), __esModule: true };

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(174), __esModule: true };

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(175), __esModule: true };

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(176), __esModule: true };

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(177), __esModule: true };

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(36)
var Transform = __webpack_require__(17)
var inherits = __webpack_require__(1)
var modes = __webpack_require__(37)
var StreamCipher = __webpack_require__(90)
var AuthCipher = __webpack_require__(83)
var ebtk = __webpack_require__(45)

inherits(Decipher, Transform)
function Decipher (mode, key, iv) {
  if (!(this instanceof Decipher)) {
    return new Decipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}
Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}
function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }
  return null
}
Splitter.prototype.flush = function () {
  if (this.cache.length) {
    return this.cache
  }
}
function unpad (last) {
  var padded = last[15]
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) {
    return
  }
  return last.slice(0, 16 - padded)
}

var modelist = {
  ECB: __webpack_require__(88),
  CBC: __webpack_require__(84),
  CFB: __webpack_require__(85),
  CFB8: __webpack_require__(87),
  CFB1: __webpack_require__(86),
  OFB: __webpack_require__(89),
  CTR: __webpack_require__(38),
  GCM: __webpack_require__(38)
}

function createDecipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv, true)
  }
  return new Decipher(modelist[config.mode], password, iv)
}

function createDecipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}
exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(36)
var Transform = __webpack_require__(17)
var inherits = __webpack_require__(1)
var modes = __webpack_require__(37)
var ebtk = __webpack_require__(45)
var StreamCipher = __webpack_require__(90)
var AuthCipher = __webpack_require__(83)
inherits(Cipher, Transform)
function Cipher (mode, key, iv) {
  if (!(this instanceof Cipher)) {
    return new Cipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}
Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}
Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = new Buffer(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }
  var out = Buffer.concat([this.cache, padBuff])
  return out
}
var modelist = {
  ECB: __webpack_require__(88),
  CBC: __webpack_require__(84),
  CFB: __webpack_require__(85),
  CFB8: __webpack_require__(87),
  CFB1: __webpack_require__(86),
  OFB: __webpack_require__(89),
  CTR: __webpack_require__(38),
  GCM: __webpack_require__(38)
}

function createCipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv)
  }
  return new Cipher(modelist[config.mode], password, iv)
}
function createCipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var zeros = new Buffer(16)
zeros.fill(0)
module.exports = GHASH
function GHASH (key) {
  this.h = key
  this.state = new Buffer(16)
  this.state.fill(0)
  this.cache = new Buffer('')
}
// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vh-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsb_Vi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - i % 8))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi = xor(Zi, Vi)
    }

    // Store the value of LSB(V_i)
    lsb_Vi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsb_Vi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}
GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}
GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, zeros], 16))
  }
  this.ghash(fromArray([
    0, abl,
    0, bl
  ]))
  return this.state
}

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}
function fromArray (out) {
  out = out.map(fixup_uint32)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}
var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function xor (a, b) {
  return [
    a[0] ^ b[0],
    a[1] ^ b[1],
    a[2] ^ b[2],
    a[3] ^ b[3]
  ]
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var ebtk = __webpack_require__(45)
var aes = __webpack_require__(49)
var DES = __webpack_require__(167)
var desModes = __webpack_require__(168)
var aesModes = __webpack_require__(37)
function createCipher (suite, password) {
  var keyLen, ivLen
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}
function createDecipher (suite, password) {
  var keyLen, ivLen
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    return aes.createCipheriv(suite, key, iv)
  } else if (desModes[suite]) {
    return new DES({
      key: key,
      iv: iv,
      mode: suite
    })
  } else {
    throw new TypeError('invalid suite type')
  }
}
function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    return aes.createDecipheriv(suite, key, iv)
  } else if (desModes[suite]) {
    return new DES({
      key: key,
      iv: iv,
      mode: suite,
      decrypt: true
    })
  } else {
    throw new TypeError('invalid suite type')
  }
}
exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var CipherBase = __webpack_require__(17)
var des = __webpack_require__(66)
var inherits = __webpack_require__(1)

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return new Buffer(this._des.update(data))
}
DES.prototype._final = function () {
  return new Buffer(this._des.final())
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 168 */
/***/ (function(module, exports) {

exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(91)


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(21)
var stream = __webpack_require__(23)
var inherits = __webpack_require__(1)
var sign = __webpack_require__(171)
var verify = __webpack_require__(172)

var algorithms = __webpack_require__(91)
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = new Buffer(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = new Buffer(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var createHmac = __webpack_require__(65)
var crt = __webpack_require__(50)
var EC = __webpack_require__(4).ec
var BN = __webpack_require__(3)
var parseKeys = __webpack_require__(46)
var curves = __webpack_require__(92)

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [ 0, 1 ]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return new Buffer(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [ 0 ].concat(r)
  if (s[0] & 0x80) s = [ 0 ].concat(s)

  var total = r.length + s.length + 4
  var res = [ 0x30, total, 0x02, r.length ]
  res = res.concat(r, [ 0x02, s.length ], s)
  return new Buffer(res)
}

function getKey (x, q, hash, algo) {
  x = new Buffer(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - x.length)
    zeros.fill(0)
    x = Buffer.concat([ zeros, x ])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = new Buffer(hlen)
  v.fill(1)
  var k = new Buffer(hlen)
  k.fill(0)
  k = createHmac(algo, k).update(v).update(new Buffer([ 0 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(new Buffer([ 1 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = new Buffer(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - out.length)
    zeros.fill(0)
    out = Buffer.concat([ zeros, out ])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = new Buffer(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([ t, kv.v ])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([ 0 ])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var BN = __webpack_require__(3)
var EC = __webpack_require__(4).ec
var parseKeys = __webpack_require__(46)
var curves = __webpack_require__(92)

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [ 1 ]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = new Buffer(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = new Buffer(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(198);
var $Object = __webpack_require__(18).Object;
module.exports = function create(P, D){
  return $Object.create(P, D);
};

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(199);
var $Object = __webpack_require__(18).Object;
module.exports = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(200);
module.exports = __webpack_require__(18).Object.setPrototypeOf;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(203);
__webpack_require__(201);
__webpack_require__(204);
__webpack_require__(205);
module.exports = __webpack_require__(18).Symbol;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(202);
__webpack_require__(206);
module.exports = __webpack_require__(64).f('iterator');

/***/ }),
/* 178 */
/***/ (function(module, exports) {

module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 179 */
/***/ (function(module, exports) {

module.exports = function(){ /* empty */ };

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(11)
  , toLength  = __webpack_require__(195)
  , toIndex   = __webpack_require__(194);
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(40)
  , gOPS    = __webpack_require__(100)
  , pIE     = __webpack_require__(57);
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(6).document && document.documentElement;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(93);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(93);
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create         = __webpack_require__(56)
  , descriptor     = __webpack_require__(41)
  , setToStringTag = __webpack_require__(58)
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(19)(IteratorPrototype, __webpack_require__(20)('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),
/* 186 */
/***/ (function(module, exports) {

module.exports = function(done, value){
  return {value: value, done: !!done};
};

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(40)
  , toIObject = __webpack_require__(11);
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var META     = __webpack_require__(42)('meta')
  , isObject = __webpack_require__(31)
  , has      = __webpack_require__(9)
  , setDesc  = __webpack_require__(10).f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !__webpack_require__(39)(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var dP       = __webpack_require__(10)
  , anObject = __webpack_require__(29)
  , getKeys  = __webpack_require__(40);

module.exports = __webpack_require__(8) ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(11)
  , gOPN      = __webpack_require__(99).f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = __webpack_require__(9)
  , toObject    = __webpack_require__(196)
  , IE_PROTO    = __webpack_require__(59)('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(31)
  , anObject = __webpack_require__(29);
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = __webpack_require__(94)(Function.call, __webpack_require__(98).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(61)
  , defined   = __webpack_require__(52);
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(61)
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(61)
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(52);
module.exports = function(it){
  return Object(defined(it));
};

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(179)
  , step             = __webpack_require__(186)
  , Iterators        = __webpack_require__(54)
  , toIObject        = __webpack_require__(11);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(97)(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(30)
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: __webpack_require__(56)});

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(30);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(8), 'Object', {defineProperty: __webpack_require__(10).f});

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(30);
$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(192).set});

/***/ }),
/* 201 */
/***/ (function(module, exports) {



/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at  = __webpack_require__(193)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(97)(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global         = __webpack_require__(6)
  , has            = __webpack_require__(9)
  , DESCRIPTORS    = __webpack_require__(8)
  , $export        = __webpack_require__(30)
  , redefine       = __webpack_require__(102)
  , META           = __webpack_require__(188).KEY
  , $fails         = __webpack_require__(39)
  , shared         = __webpack_require__(60)
  , setToStringTag = __webpack_require__(58)
  , uid            = __webpack_require__(42)
  , wks            = __webpack_require__(20)
  , wksExt         = __webpack_require__(64)
  , wksDefine      = __webpack_require__(63)
  , keyOf          = __webpack_require__(187)
  , enumKeys       = __webpack_require__(181)
  , isArray        = __webpack_require__(184)
  , anObject       = __webpack_require__(29)
  , toIObject      = __webpack_require__(11)
  , toPrimitive    = __webpack_require__(62)
  , createDesc     = __webpack_require__(41)
  , _create        = __webpack_require__(56)
  , gOPNExt        = __webpack_require__(190)
  , $GOPD          = __webpack_require__(98)
  , $DP            = __webpack_require__(10)
  , $keys          = __webpack_require__(40)
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  __webpack_require__(99).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(57).f  = $propertyIsEnumerable;
  __webpack_require__(100).f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !__webpack_require__(55)){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(19)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(63)('asyncIterator');

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(63)('observable');

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(197);
var global        = __webpack_require__(6)
  , hide          = __webpack_require__(19)
  , Iterators     = __webpack_require__(54)
  , TO_STRING_TAG = __webpack_require__(20)('toStringTag');

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype;
  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var elliptic = __webpack_require__(4);
var BN = __webpack_require__(3);

module.exports = function createECDH(curve) {
	return new ECDH(curve);
};

var aliases = {
	secp256k1: {
		name: 'secp256k1',
		byteLength: 32
	},
	secp224r1: {
		name: 'p224',
		byteLength: 28
	},
	prime256v1: {
		name: 'p256',
		byteLength: 32
	},
	prime192v1: {
		name: 'p192',
		byteLength: 24
	},
	ed25519: {
		name: 'ed25519',
		byteLength: 32
	},
	secp384r1: {
		name: 'p384',
		byteLength: 48
	},
	secp521r1: {
		name: 'p521',
		byteLength: 66
	}
};

aliases.p224 = aliases.secp224r1;
aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
aliases.p384 = aliases.secp384r1;
aliases.p521 = aliases.secp521r1;

function ECDH(curve) {
	this.curveType = aliases[curve];
	if (!this.curveType ) {
		this.curveType = {
			name: curve
		};
	}
	this.curve = new elliptic.ec(this.curveType.name);
	this.keys = void 0;
}

ECDH.prototype.generateKeys = function (enc, format) {
	this.keys = this.curve.genKeyPair();
	return this.getPublicKey(enc, format);
};

ECDH.prototype.computeSecret = function (other, inenc, enc) {
	inenc = inenc || 'utf8';
	if (!Buffer.isBuffer(other)) {
		other = new Buffer(other, inenc);
	}
	var otherPub = this.curve.keyFromPublic(other).getPublic();
	var out = otherPub.mul(this.keys.getPrivate()).getX();
	return formatReturnValue(out, enc, this.curveType.byteLength);
};

ECDH.prototype.getPublicKey = function (enc, format) {
	var key = this.keys.getPublic(format === 'compressed', true);
	if (format === 'hybrid') {
		if (key[key.length - 1] % 2) {
			key[0] = 7;
		} else {
			key [0] = 6;
		}
	}
	return formatReturnValue(key, enc);
};

ECDH.prototype.getPrivateKey = function (enc) {
	return formatReturnValue(this.keys.getPrivate(), enc);
};

ECDH.prototype.setPublicKey = function (pub, enc) {
	enc = enc || 'utf8';
	if (!Buffer.isBuffer(pub)) {
		pub = new Buffer(pub, enc);
	}
	this.keys._importPublic(pub);
	return this;
};

ECDH.prototype.setPrivateKey = function (priv, enc) {
	enc = enc || 'utf8';
	if (!Buffer.isBuffer(priv)) {
		priv = new Buffer(priv, enc);
	}
	var _priv = new BN(priv);
	_priv = _priv.toString(16);
	this.keys._importPrivate(_priv);
	return this;
};

function formatReturnValue(bn, enc, len) {
	if (!Array.isArray(bn)) {
		bn = bn.toArray();
	}
	var buf = new Buffer(bn);
	if (len && buf.length < len) {
		var zeros = new Buffer(len - buf.length);
		zeros.fill(0);
		buf = Buffer.concat([zeros, buf]);
	}
	if (!enc) {
		return buf;
	} else {
		return buf.toString(enc);
	}
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}
exports.hash = hash;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(33)
exports.createHash = exports.Hash = __webpack_require__(21)
exports.createHmac = exports.Hmac = __webpack_require__(65)

var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys(__webpack_require__(169)))
exports.getHashes = function () {
  return hashes
}

var p = __webpack_require__(109)
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = __webpack_require__(166)
;[
  'Cipher',
  'createCipher',
  'Cipheriv',
  'createCipheriv',
  'Decipher',
  'createDecipher',
  'Decipheriv',
  'createDecipheriv',
  'getCiphers',
  'listCiphers'
].forEach(function (key) {
  exports[key] = aes[key]
})

var dh = __webpack_require__(217)
;[
  'DiffieHellmanGroup',
  'createDiffieHellmanGroup',
  'getDiffieHellman',
  'createDiffieHellman',
  'DiffieHellman'
].forEach(function (key) {
  exports[key] = dh[key]
})

var sign = __webpack_require__(170)
;[
  'createSign',
  'Sign',
  'createVerify',
  'Verify'
].forEach(function (key) {
  exports[key] = sign[key]
})

exports.createECDH = __webpack_require__(207)

var publicEncrypt = __webpack_require__(247)

;[
  'publicEncrypt',
  'privateEncrypt',
  'publicDecrypt',
  'privateDecrypt'
].forEach(function (key) {
  exports[key] = publicEncrypt[key]
})

// the least I can do is make error messages for the rest of the node.js/crypto api.
;[
  'createCredentials'
].forEach(function (name) {
  exports[name] = function () {
    throw new Error([
      'sorry, ' + name + ' is not implemented yet',
      'we accept pull requests',
      'https://github.com/crypto-browserify/crypto-browserify'
    ].join('\n'))
  }
})


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	C-like unsigned 32 bits integers in Javascript
	Copyright (C) 2013, Pierre Curto
	MIT license
 */
;(function (root) {

	// Local cache for typical radices
	var radixPowerCache = {
		36: UINT32( Math.pow(36, 5) )
	,	16: UINT32( Math.pow(16, 7) )
	,	10: UINT32( Math.pow(10, 9) )
	,	2:  UINT32( Math.pow(2, 30) )
	}
	var radixCache = {
		36: UINT32(36)
	,	16: UINT32(16)
	,	10: UINT32(10)
	,	2:  UINT32(2)
	}

	/**
	 *	Represents an unsigned 32 bits integer
	 * @constructor
	 * @param {Number|String|Number} low bits     | integer as a string 		 | integer as a number
	 * @param {Number|Number|Undefined} high bits | radix (optional, default=10)
	 * @return 
	 */
	function UINT32 (l, h) {
		if ( !(this instanceof UINT32) )
			return new UINT32(l, h)

		this._low = 0
		this._high = 0
		this.remainder = null
		if (typeof h == 'undefined')
			return fromNumber.call(this, l)

		if (typeof l == 'string')
			return fromString.call(this, l, h)

		fromBits.call(this, l, h)
	}

	/**
	 * Set the current _UINT32_ object with its low and high bits
	 * @method fromBits
	 * @param {Number} low bits
	 * @param {Number} high bits
	 * @return ThisExpression
	 */
	function fromBits (l, h) {
		this._low = l | 0
		this._high = h | 0

		return this
	}
	UINT32.prototype.fromBits = fromBits

	/**
	 * Set the current _UINT32_ object from a number
	 * @method fromNumber
	 * @param {Number} number
	 * @return ThisExpression
	 */
	function fromNumber (value) {
		this._low = value & 0xFFFF
		this._high = value >>> 16

		return this
	}
	UINT32.prototype.fromNumber = fromNumber

	/**
	 * Set the current _UINT32_ object from a string
	 * @method fromString
	 * @param {String} integer as a string
	 * @param {Number} radix (optional, default=10)
	 * @return ThisExpression
	 */
	function fromString (s, radix) {
		var value = parseInt(s, radix || 10)

		this._low = value & 0xFFFF
		this._high = value >>> 16

		return this
	}
	UINT32.prototype.fromString = fromString

	/**
	 * Convert this _UINT32_ to a number
	 * @method toNumber
	 * @return {Number} the converted UINT32
	 */
	UINT32.prototype.toNumber = function () {
		return (this._high * 65536) + this._low
	}

	/**
	 * Convert this _UINT32_ to a string
	 * @method toString
	 * @param {Number} radix (optional, default=10)
	 * @return {String} the converted UINT32
	 */
	UINT32.prototype.toString = function (radix) {
		return this.toNumber().toString(radix || 10)
	}

	/**
	 * Add two _UINT32_. The current _UINT32_ stores the result
	 * @method add
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.add = function (other) {
		var a00 = this._low + other._low
		var a16 = a00 >>> 16

		a16 += this._high + other._high

		this._low = a00 & 0xFFFF
		this._high = a16 & 0xFFFF

		return this
	}

	/**
	 * Subtract two _UINT32_. The current _UINT32_ stores the result
	 * @method subtract
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.subtract = function (other) {
		//TODO inline
		return this.add( other.clone().negate() )
	}

	/**
	 * Multiply two _UINT32_. The current _UINT32_ stores the result
	 * @method multiply
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.multiply = function (other) {
		/*
			a = a00 + a16
			b = b00 + b16
			a*b = (a00 + a16)(b00 + b16)
				= a00b00 + a00b16 + a16b00 + a16b16

			a16b16 overflows the 32bits
		 */
		var a16 = this._high
		var a00 = this._low
		var b16 = other._high
		var b00 = other._low

/* Removed to increase speed under normal circumstances (i.e. not multiplying by 0 or 1)
		// this == 0 or other == 1: nothing to do
		if ((a00 == 0 && a16 == 0) || (b00 == 1 && b16 == 0)) return this

		// other == 0 or this == 1: this = other
		if ((b00 == 0 && b16 == 0) || (a00 == 1 && a16 == 0)) {
			this._low = other._low
			this._high = other._high
			return this
		}
*/

		var c16, c00
		c00 = a00 * b00
		c16 = c00 >>> 16

		c16 += a16 * b00
		c16 &= 0xFFFF		// Not required but improves performance
		c16 += a00 * b16

		this._low = c00 & 0xFFFF
		this._high = c16 & 0xFFFF

		return this
	}

	/**
	 * Divide two _UINT32_. The current _UINT32_ stores the result.
	 * The remainder is made available as the _remainder_ property on
	 * the _UINT32_ object. It can be null, meaning there are no remainder.
	 * @method div
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.div = function (other) {
		if ( (other._low == 0) && (other._high == 0) ) throw Error('division by zero')

		// other == 1
		if (other._high == 0 && other._low == 1) {
			this.remainder = new UINT32(0)
			return this
		}

		// other > this: 0
		if ( other.gt(this) ) {
			this.remainder = this.clone()
			this._low = 0
			this._high = 0
			return this
		}
		// other == this: 1
		if ( this.eq(other) ) {
			this.remainder = new UINT32(0)
			this._low = 1
			this._high = 0
			return this
		}

		// Shift the divisor left until it is higher than the dividend
		var _other = other.clone()
		var i = -1
		while ( !this.lt(_other) ) {
			// High bit can overflow the default 16bits
			// Its ok since we right shift after this loop
			// The overflown bit must be kept though
			_other.shiftLeft(1, true)
			i++
		}

		// Set the remainder
		this.remainder = this.clone()
		// Initialize the current result to 0
		this._low = 0
		this._high = 0
		for (; i >= 0; i--) {
			_other.shiftRight(1)
			// If shifted divisor is smaller than the dividend
			// then subtract it from the dividend
			if ( !this.remainder.lt(_other) ) {
				this.remainder.subtract(_other)
				// Update the current result
				if (i >= 16) {
					this._high |= 1 << (i - 16)
				} else {
					this._low |= 1 << i
				}
			}
		}

		return this
	}

	/**
	 * Negate the current _UINT32_
	 * @method negate
	 * @return ThisExpression
	 */
	UINT32.prototype.negate = function () {
		var v = ( ~this._low & 0xFFFF ) + 1
		this._low = v & 0xFFFF
		this._high = (~this._high + (v >>> 16)) & 0xFFFF

		return this
	}

	/**
	 * Equals
	 * @method eq
	 * @param {Object} other UINT32
	 * @return {Boolean}
	 */
	UINT32.prototype.equals = UINT32.prototype.eq = function (other) {
		return (this._low == other._low) && (this._high == other._high)
	}

	/**
	 * Greater than (strict)
	 * @method gt
	 * @param {Object} other UINT32
	 * @return {Boolean}
	 */
	UINT32.prototype.greaterThan = UINT32.prototype.gt = function (other) {
		if (this._high > other._high) return true
		if (this._high < other._high) return false
		return this._low > other._low
	}

	/**
	 * Less than (strict)
	 * @method lt
	 * @param {Object} other UINT32
	 * @return {Boolean}
	 */
	UINT32.prototype.lessThan = UINT32.prototype.lt = function (other) {
		if (this._high < other._high) return true
		if (this._high > other._high) return false
		return this._low < other._low
	}

	/**
	 * Bitwise OR
	 * @method or
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.or = function (other) {
		this._low |= other._low
		this._high |= other._high

		return this
	}

	/**
	 * Bitwise AND
	 * @method and
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.and = function (other) {
		this._low &= other._low
		this._high &= other._high

		return this
	}

	/**
	 * Bitwise NOT
	 * @method not
	 * @return ThisExpression
	 */
	UINT32.prototype.not = function() {
		this._low = ~this._low & 0xFFFF
		this._high = ~this._high & 0xFFFF

		return this
	}

	/**
	 * Bitwise XOR
	 * @method xor
	 * @param {Object} other UINT32
	 * @return ThisExpression
	 */
	UINT32.prototype.xor = function (other) {
		this._low ^= other._low
		this._high ^= other._high

		return this
	}

	/**
	 * Bitwise shift right
	 * @method shiftRight
	 * @param {Number} number of bits to shift
	 * @return ThisExpression
	 */
	UINT32.prototype.shiftRight = UINT32.prototype.shiftr = function (n) {
		if (n > 16) {
			this._low = this._high >> (n - 16)
			this._high = 0
		} else if (n == 16) {
			this._low = this._high
			this._high = 0
		} else {
			this._low = (this._low >> n) | ( (this._high << (16-n)) & 0xFFFF )
			this._high >>= n
		}

		return this
	}

	/**
	 * Bitwise shift left
	 * @method shiftLeft
	 * @param {Number} number of bits to shift
	 * @param {Boolean} allow overflow
	 * @return ThisExpression
	 */
	UINT32.prototype.shiftLeft = UINT32.prototype.shiftl = function (n, allowOverflow) {
		if (n > 16) {
			this._high = this._low << (n - 16)
			this._low = 0
			if (!allowOverflow) {
				this._high &= 0xFFFF
			}
		} else if (n == 16) {
			this._high = this._low
			this._low = 0
		} else {
			this._high = (this._high << n) | (this._low >> (16-n))
			this._low = (this._low << n) & 0xFFFF
			if (!allowOverflow) {
				// Overflow only allowed on the high bits...
				this._high &= 0xFFFF
			}
		}

		return this
	}

	/**
	 * Bitwise rotate left
	 * @method rotl
	 * @param {Number} number of bits to rotate
	 * @return ThisExpression
	 */
	UINT32.prototype.rotateLeft = UINT32.prototype.rotl = function (n) {
		var v = (this._high << 16) | this._low
		v = (v << n) | (v >>> (32 - n))
		this._low = v & 0xFFFF
		this._high = v >>> 16

		return this
	}

	/**
	 * Bitwise rotate right
	 * @method rotr
	 * @param {Number} number of bits to rotate
	 * @return ThisExpression
	 */
	UINT32.prototype.rotateRight = UINT32.prototype.rotr = function (n) {
		var v = (this._high << 16) | this._low
		v = (v >>> n) | (v << (32 - n))
		this._low = v & 0xFFFF
		this._high = v >>> 16

		return this
	}

	/**
	 * Clone the current _UINT32_
	 * @method clone
	 * @return {Object} cloned UINT32
	 */
	UINT32.prototype.clone = function () {
		return new UINT32(this._low, this._high)
	}

	if (true) {
		// AMD / RequireJS
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return UINT32
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	} else if (typeof module != 'undefined' && module.exports) {
		// Node.js
		module.exports = UINT32
	} else {
		// Browser
		root['UINT32'] = UINT32
	}

})(this)


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	C-like unsigned 64 bits integers in Javascript
	Copyright (C) 2013, Pierre Curto
	MIT license
 */
;(function (root) {

	// Local cache for typical radices
	var radixPowerCache = {
		16: UINT64( Math.pow(16, 5) )
	,	10: UINT64( Math.pow(10, 5) )
	,	2:  UINT64( Math.pow(2, 5) )
	}
	var radixCache = {
		16: UINT64(16)
	,	10: UINT64(10)
	,	2:  UINT64(2)
	}

	/**
	 *	Represents an unsigned 64 bits integer
	 * @constructor
	 * @param {Number} first low bits (8)
	 * @param {Number} second low bits (8)
	 * @param {Number} first high bits (8)
	 * @param {Number} second high bits (8)
	 * or
	 * @param {Number} low bits (32)
	 * @param {Number} high bits (32)
	 * or
	 * @param {String|Number} integer as a string 		 | integer as a number
	 * @param {Number|Undefined} radix (optional, default=10)
	 * @return 
	 */
	function UINT64 (a00, a16, a32, a48) {
		if ( !(this instanceof UINT64) )
			return new UINT64(a00, a16, a32, a48)

		this.remainder = null
		if (typeof a00 == 'string')
			return fromString.call(this, a00, a16)

		if (typeof a16 == 'undefined')
			return fromNumber.call(this, a00)

		fromBits.apply(this, arguments)
	}

	/**
	 * Set the current _UINT64_ object with its low and high bits
	 * @method fromBits
	 * @param {Number} first low bits (8)
	 * @param {Number} second low bits (8)
	 * @param {Number} first high bits (8)
	 * @param {Number} second high bits (8)
	 * or
	 * @param {Number} low bits (32)
	 * @param {Number} high bits (32)
	 * @return ThisExpression
	 */
	function fromBits (a00, a16, a32, a48) {
		if (typeof a32 == 'undefined') {
			this._a00 = a00 & 0xFFFF
			this._a16 = a00 >>> 16
			this._a32 = a16 & 0xFFFF
			this._a48 = a16 >>> 16
			return this
		}

		this._a00 = a00 | 0
		this._a16 = a16 | 0
		this._a32 = a32 | 0
		this._a48 = a48 | 0

		return this
	}
	UINT64.prototype.fromBits = fromBits

	/**
	 * Set the current _UINT64_ object from a number
	 * @method fromNumber
	 * @param {Number} number
	 * @return ThisExpression
	 */
	function fromNumber (value) {
		this._a00 = value & 0xFFFF
		this._a16 = value >>> 16
		this._a32 = 0
		this._a48 = 0

		return this
	}
	UINT64.prototype.fromNumber = fromNumber

	/**
	 * Set the current _UINT64_ object from a string
	 * @method fromString
	 * @param {String} integer as a string
	 * @param {Number} radix (optional, default=10)
	 * @return ThisExpression
	 */
	function fromString (s, radix) {
		radix = radix || 10

		this._a00 = 0
		this._a16 = 0
		this._a32 = 0
		this._a48 = 0

		/*
			In Javascript, bitwise operators only operate on the first 32 bits 
			of a number, even though parseInt() encodes numbers with a 53 bits 
			mantissa.
			Therefore UINT64(<Number>) can only work on 32 bits.
			The radix maximum value is 36 (as per ECMA specs) (26 letters + 10 digits)
			maximum input value is m = 32bits as 1 = 2^32 - 1
			So the maximum substring length n is:
			36^(n+1) - 1 = 2^32 - 1
			36^(n+1) = 2^32
			(n+1)ln(36) = 32ln(2)
			n = 32ln(2)/ln(36) - 1
			n = 5.189644915687692
			n = 5
		 */
		var radixUint = radixPowerCache[radix] || new UINT64( Math.pow(radix, 5) )

		for (var i = 0, len = s.length; i < len; i += 5) {
			var size = Math.min(5, len - i)
			var value = parseInt( s.slice(i, i + size), radix )
			this.multiply(
					size < 5
						? new UINT64( Math.pow(radix, size) )
						: radixUint
				)
				.add( new UINT64(value) )
		}

		return this
	}
	UINT64.prototype.fromString = fromString

	/**
	 * Convert this _UINT64_ to a number (last 32 bits are dropped)
	 * @method toNumber
	 * @return {Number} the converted UINT64
	 */
	UINT64.prototype.toNumber = function () {
		return (this._a16 * 65536) + this._a00
	}

	/**
	 * Convert this _UINT64_ to a string
	 * @method toString
	 * @param {Number} radix (optional, default=10)
	 * @return {String} the converted UINT64
	 */
	UINT64.prototype.toString = function (radix) {
		radix = radix || 10
		var radixUint = radixCache[radix] || new UINT64(radix)

		if ( !this.gt(radixUint) ) return this.toNumber().toString(radix)

		var self = this.clone()
		var res = new Array(64)
		for (var i = 63; i >= 0; i--) {
			self.div(radixUint)
			res[i] = self.remainder.toNumber().toString(radix)
			if ( !self.gt(radixUint) ) break
		}
		res[i-1] = self.toNumber().toString(radix)

		return res.join('')
	}

	/**
	 * Add two _UINT64_. The current _UINT64_ stores the result
	 * @method add
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.add = function (other) {
		var a00 = this._a00 + other._a00

		var a16 = a00 >>> 16
		a16 += this._a16 + other._a16

		var a32 = a16 >>> 16
		a32 += this._a32 + other._a32

		var a48 = a32 >>> 16
		a48 += this._a48 + other._a48

		this._a00 = a00 & 0xFFFF
		this._a16 = a16 & 0xFFFF
		this._a32 = a32 & 0xFFFF
		this._a48 = a48 & 0xFFFF

		return this
	}

	/**
	 * Subtract two _UINT64_. The current _UINT64_ stores the result
	 * @method subtract
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.subtract = function (other) {
		return this.add( other.clone().negate() )
	}

	/**
	 * Multiply two _UINT64_. The current _UINT64_ stores the result
	 * @method multiply
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.multiply = function (other) {
		/*
			a = a00 + a16 + a32 + a48
			b = b00 + b16 + b32 + b48
			a*b = (a00 + a16 + a32 + a48)(b00 + b16 + b32 + b48)
				= a00b00 + a00b16 + a00b32 + a00b48
				+ a16b00 + a16b16 + a16b32 + a16b48
				+ a32b00 + a32b16 + a32b32 + a32b48
				+ a48b00 + a48b16 + a48b32 + a48b48

			a16b48, a32b32, a48b16, a48b32 and a48b48 overflow the 64 bits
			so it comes down to:
			a*b	= a00b00 + a00b16 + a00b32 + a00b48
				+ a16b00 + a16b16 + a16b32
				+ a32b00 + a32b16
				+ a48b00
				= a00b00
				+ a00b16 + a16b00
				+ a00b32 + a16b16 + a32b00
				+ a00b48 + a16b32 + a32b16 + a48b00
		 */
		var a00 = this._a00
		var a16 = this._a16
		var a32 = this._a32
		var a48 = this._a48
		var b00 = other._a00
		var b16 = other._a16
		var b32 = other._a32
		var b48 = other._a48

		var c00 = a00 * b00

		var c16 = c00 >>> 16
		c16 += a00 * b16
		var c32 = c16 >>> 16
		c16 &= 0xFFFF
		c16 += a16 * b00

		c32 += c16 >>> 16
		c32 += a00 * b32
		var c48 = c32 >>> 16
		c32 &= 0xFFFF
		c32 += a16 * b16
		c48 += c32 >>> 16
		c32 &= 0xFFFF
		c32 += a32 * b00

		c48 += c32 >>> 16
		c48 += a00 * b48
		c48 &= 0xFFFF
		c48 += a16 * b32
		c48 &= 0xFFFF
		c48 += a32 * b16
		c48 &= 0xFFFF
		c48 += a48 * b00

		this._a00 = c00 & 0xFFFF
		this._a16 = c16 & 0xFFFF
		this._a32 = c32 & 0xFFFF
		this._a48 = c48 & 0xFFFF

		return this
	}

	/**
	 * Divide two _UINT64_. The current _UINT64_ stores the result.
	 * The remainder is made available as the _remainder_ property on
	 * the _UINT64_ object. It can be null, meaning there are no remainder.
	 * @method div
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.div = function (other) {
		if ( (other._a16 == 0) && (other._a32 == 0) && (other._a48 == 0) ) {
			if (other._a00 == 0) throw Error('division by zero')

			// other == 1: this
			if (other._a00 == 1) {
				this.remainder = new UINT64(0)
				return this
			}
		}

		// other > this: 0
		if ( other.gt(this) ) {
			this.remainder = this.clone()
			this._a00 = 0
			this._a16 = 0
			this._a32 = 0
			this._a48 = 0
			return this
		}
		// other == this: 1
		if ( this.eq(other) ) {
			this.remainder = new UINT64(0)
			this._a00 = 1
			this._a16 = 0
			this._a32 = 0
			this._a48 = 0
			return this
		}

		// Shift the divisor left until it is higher than the dividend
		var _other = other.clone()
		var i = -1
		while ( !this.lt(_other) ) {
			// High bit can overflow the default 16bits
			// Its ok since we right shift after this loop
			// The overflown bit must be kept though
			_other.shiftLeft(1, true)
			i++
		}

		// Set the remainder
		this.remainder = this.clone()
		// Initialize the current result to 0
		this._a00 = 0
		this._a16 = 0
		this._a32 = 0
		this._a48 = 0
		for (; i >= 0; i--) {
			_other.shiftRight(1)
			// If shifted divisor is smaller than the dividend
			// then subtract it from the dividend
			if ( !this.remainder.lt(_other) ) {
				this.remainder.subtract(_other)
				// Update the current result
				if (i >= 48) {
					this._a48 |= 1 << (i - 48)
				} else if (i >= 32) {
					this._a32 |= 1 << (i - 32)
				} else if (i >= 16) {
					this._a16 |= 1 << (i - 16)
				} else {
					this._a00 |= 1 << i
				}
			}
		}

		return this
	}

	/**
	 * Negate the current _UINT64_
	 * @method negate
	 * @return ThisExpression
	 */
	UINT64.prototype.negate = function () {
		var v = ( ~this._a00 & 0xFFFF ) + 1
		this._a00 = v & 0xFFFF
		v = (~this._a16 & 0xFFFF) + (v >>> 16)
		this._a16 = v & 0xFFFF
		v = (~this._a32 & 0xFFFF) + (v >>> 16)
		this._a32 = v & 0xFFFF
		this._a48 = (~this._a48 + (v >>> 16)) & 0xFFFF

		return this
	}

	/**

	 * @method eq
	 * @param {Object} other UINT64
	 * @return {Boolean}
	 */
	UINT64.prototype.equals = UINT64.prototype.eq = function (other) {
		return (this._a48 == other._a48) && (this._a00 == other._a00)
			 && (this._a32 == other._a32) && (this._a16 == other._a16)
	}

	/**
	 * Greater than (strict)
	 * @method gt
	 * @param {Object} other UINT64
	 * @return {Boolean}
	 */
	UINT64.prototype.greaterThan = UINT64.prototype.gt = function (other) {
		if (this._a48 > other._a48) return true
		if (this._a48 < other._a48) return false
		if (this._a32 > other._a32) return true
		if (this._a32 < other._a32) return false
		if (this._a16 > other._a16) return true
		if (this._a16 < other._a16) return false
		return this._a00 > other._a00
	}

	/**
	 * Less than (strict)
	 * @method lt
	 * @param {Object} other UINT64
	 * @return {Boolean}
	 */
	UINT64.prototype.lessThan = UINT64.prototype.lt = function (other) {
		if (this._a48 < other._a48) return true
		if (this._a48 > other._a48) return false
		if (this._a32 < other._a32) return true
		if (this._a32 > other._a32) return false
		if (this._a16 < other._a16) return true
		if (this._a16 > other._a16) return false
		return this._a00 < other._a00
	}

	/**
	 * Bitwise OR
	 * @method or
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.or = function (other) {
		this._a00 |= other._a00
		this._a16 |= other._a16
		this._a32 |= other._a32
		this._a48 |= other._a48

		return this
	}

	/**
	 * Bitwise AND
	 * @method and
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.and = function (other) {
		this._a00 &= other._a00
		this._a16 &= other._a16
		this._a32 &= other._a32
		this._a48 &= other._a48

		return this
	}

	/**
	 * Bitwise XOR
	 * @method xor
	 * @param {Object} other UINT64
	 * @return ThisExpression
	 */
	UINT64.prototype.xor = function (other) {
		this._a00 ^= other._a00
		this._a16 ^= other._a16
		this._a32 ^= other._a32
		this._a48 ^= other._a48

		return this
	}

	/**
	 * Bitwise NOT
	 * @method not
	 * @return ThisExpression
	 */
	UINT64.prototype.not = function() {
		this._a00 = ~this._a00 & 0xFFFF
		this._a16 = ~this._a16 & 0xFFFF
		this._a32 = ~this._a32 & 0xFFFF
		this._a48 = ~this._a48 & 0xFFFF

		return this
	}

	/**
	 * Bitwise shift right
	 * @method shiftRight
	 * @param {Number} number of bits to shift
	 * @return ThisExpression
	 */
	UINT64.prototype.shiftRight = UINT64.prototype.shiftr = function (n) {
		n %= 64
		if (n >= 48) {
			this._a00 = this._a48 >> (n - 48)
			this._a16 = 0
			this._a32 = 0
			this._a48 = 0
		} else if (n >= 32) {
			n -= 32
			this._a00 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF
			this._a16 = (this._a48 >> n) & 0xFFFF
			this._a32 = 0
			this._a48 = 0
		} else if (n >= 16) {
			n -= 16
			this._a00 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF
			this._a16 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF
			this._a32 = (this._a48 >> n) & 0xFFFF
			this._a48 = 0
		} else {
			this._a00 = ( (this._a00 >> n) | (this._a16 << (16-n)) ) & 0xFFFF
			this._a16 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF
			this._a32 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF
			this._a48 = (this._a48 >> n) & 0xFFFF
		}

		return this
	}

	/**
	 * Bitwise shift left
	 * @method shiftLeft
	 * @param {Number} number of bits to shift
	 * @param {Boolean} allow overflow
	 * @return ThisExpression
	 */
	UINT64.prototype.shiftLeft = UINT64.prototype.shiftl = function (n, allowOverflow) {
		n %= 64
		if (n >= 48) {
			this._a48 = this._a00 << (n - 48)
			this._a32 = 0
			this._a16 = 0
			this._a00 = 0
		} else if (n >= 32) {
			n -= 32
			this._a48 = (this._a16 << n) | (this._a00 >> (16-n))
			this._a32 = (this._a00 << n) & 0xFFFF
			this._a16 = 0
			this._a00 = 0
		} else if (n >= 16) {
			n -= 16
			this._a48 = (this._a32 << n) | (this._a16 >> (16-n))
			this._a32 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF
			this._a16 = (this._a00 << n) & 0xFFFF
			this._a00 = 0
		} else {
			this._a48 = (this._a48 << n) | (this._a32 >> (16-n))
			this._a32 = ( (this._a32 << n) | (this._a16 >> (16-n)) ) & 0xFFFF
			this._a16 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF
			this._a00 = (this._a00 << n) & 0xFFFF
		}
		if (!allowOverflow) {
			this._a48 &= 0xFFFF
		}

		return this
	}

	/**
	 * Bitwise rotate left
	 * @method rotl
	 * @param {Number} number of bits to rotate
	 * @return ThisExpression
	 */
	UINT64.prototype.rotateLeft = UINT64.prototype.rotl = function (n) {
		n %= 64
		if (n == 0) return this
		if (n >= 32) {
			// A.B.C.D
			// B.C.D.A rotl(16)
			// C.D.A.B rotl(32)
			var v = this._a00
			this._a00 = this._a32
			this._a32 = v
			v = this._a48
			this._a48 = this._a16
			this._a16 = v
			if (n == 32) return this
			n -= 32
		}

		var high = (this._a48 << 16) | this._a32
		var low = (this._a16 << 16) | this._a00

		var _high = (high << n) | (low >>> (32 - n))
		var _low = (low << n) | (high >>> (32 - n))

		this._a00 = _low & 0xFFFF
		this._a16 = _low >>> 16
		this._a32 = _high & 0xFFFF
		this._a48 = _high >>> 16

		return this
	}

	/**
	 * Bitwise rotate right
	 * @method rotr
	 * @param {Number} number of bits to rotate
	 * @return ThisExpression
	 */
	UINT64.prototype.rotateRight = UINT64.prototype.rotr = function (n) {
		n %= 64
		if (n == 0) return this
		if (n >= 32) {
			// A.B.C.D
			// D.A.B.C rotr(16)
			// C.D.A.B rotr(32)
			var v = this._a00
			this._a00 = this._a32
			this._a32 = v
			v = this._a48
			this._a48 = this._a16
			this._a16 = v
			if (n == 32) return this
			n -= 32
		}

		var high = (this._a48 << 16) | this._a32
		var low = (this._a16 << 16) | this._a00

		var _high = (high >>> n) | (low << (32 - n))
		var _low = (low >>> n) | (high << (32 - n))

		this._a00 = _low & 0xFFFF
		this._a16 = _low >>> 16
		this._a32 = _high & 0xFFFF
		this._a48 = _high >>> 16

		return this
	}

	/**
	 * Clone the current _UINT64_
	 * @method clone
	 * @return {Object} cloned UINT64
	 */
	UINT64.prototype.clone = function () {
		return new UINT64(this._a00, this._a16, this._a32, this._a48)
	}

	if (true) {
		// AMD / RequireJS
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return UINT64
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	} else if (typeof module != 'undefined' && module.exports) {
		// Node.js
		module.exports = UINT64
	} else {
		// Browser
		root['UINT64'] = UINT64
	}

})(this)


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(13);
var inherits = __webpack_require__(1);

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(13);

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(13);
var inherits = __webpack_require__(1);

var des = __webpack_require__(66);
var utils = des.utils;
var Cipher = des.Cipher;

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(13);
var inherits = __webpack_require__(1);

var des = __webpack_require__(66);
var Cipher = des.Cipher;
var DES = des.DES;

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var generatePrime = __webpack_require__(105)
var primes = __webpack_require__(219)

var DH = __webpack_require__(218)

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var BN = __webpack_require__(3);
var MillerRabin = __webpack_require__(107);
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = __webpack_require__(105);
var randomBytes = __webpack_require__(33);
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 219 */
/***/ (function(module, exports) {

module.exports = {
	"modp1": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
	},
	"modp2": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
	},
	"modp5": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
	},
	"modp14": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
	},
	"modp15": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
	},
	"modp16": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
	},
	"modp17": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
	},
	"modp18": {
		"gen": "02",
		"prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
	}
};

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(3);
var elliptic = __webpack_require__(4);
var utils = elliptic.utils;
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len,
                                                       jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
                          bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(43);
var elliptic = __webpack_require__(4);
var BN = __webpack_require__(3);
var inherits = __webpack_require__(1);
var Base = curve.base;

var assert = elliptic.utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - 1) / (d y^2 + 1)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.one);
  var rhs = y2.redMul(this.d).redAdd(this.one);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
         this.y.cmp(this.z) === 0;
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
  return false;
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(43);
var BN = __webpack_require__(3);
var inherits = __webpack_require__(1);
var Base = curve.base;

var elliptic = __webpack_require__(4);
var utils = elliptic.utils;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(43);
var elliptic = __webpack_require__(4);
var BN = __webpack_require__(3);
var inherits = __webpack_require__(1);
var Base = curve.base;

var assert = elliptic.utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);

  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
  return false;
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curves = exports;

var hash = __webpack_require__(12);
var elliptic = __webpack_require__(4);

var assert = elliptic.utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new elliptic.curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new elliptic.curve.edwards(options);
  else
    this.curve = new elliptic.curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = __webpack_require__(231);
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(3);
var HmacDRBG = __webpack_require__(239);
var elliptic = __webpack_require__(4);
var utils = elliptic.utils;
var assert = utils.assert;

var KeyPair = __webpack_require__(226);
var Signature = __webpack_require__(227);

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = elliptic.curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof elliptic.curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  do {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; true; iter++) {
    var k = options.k ?
        options.k(iter) :
        new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  if (!this.curve._maxwellTrick) {
    var p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(3);
var elliptic = __webpack_require__(4);
var utils = elliptic.utils;
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(3);

var elliptic = __webpack_require__(4);
var utils = elliptic.utils;
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(12);
var elliptic = __webpack_require__(4);
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __webpack_require__(229);
var Signature = __webpack_require__(230);

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = elliptic.curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = __webpack_require__(4);
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(3);
var elliptic = __webpack_require__(4);
var utils = elliptic.utils;
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),
/* 231 */
/***/ (function(module, exports) {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;
var BN = __webpack_require__(3);
var minAssert = __webpack_require__(13);
var minUtils = __webpack_require__(108);

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.iushrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),
/* 233 */
/***/ (function(module, exports) {

module.exports = {
	"_args": [
		[
			{
				"raw": "elliptic@^6.0.0",
				"scope": null,
				"escapedName": "elliptic",
				"name": "elliptic",
				"rawSpec": "^6.0.0",
				"spec": ">=6.0.0 <7.0.0",
				"type": "range"
			},
			"/Users/devicalin/Desktop/workspace/js-stl/node_modules/browserify-sign"
		]
	],
	"_from": "elliptic@>=6.0.0 <7.0.0",
	"_id": "elliptic@6.4.0",
	"_inCache": true,
	"_location": "/elliptic",
	"_nodeVersion": "7.0.0",
	"_npmOperationalInternal": {
		"host": "packages-18-east.internal.npmjs.com",
		"tmp": "tmp/elliptic-6.4.0.tgz_1487798866428_0.30510620190761983"
	},
	"_npmUser": {
		"name": "indutny",
		"email": "fedor@indutny.com"
	},
	"_npmVersion": "3.10.8",
	"_phantomChildren": {},
	"_requested": {
		"raw": "elliptic@^6.0.0",
		"scope": null,
		"escapedName": "elliptic",
		"name": "elliptic",
		"rawSpec": "^6.0.0",
		"spec": ">=6.0.0 <7.0.0",
		"type": "range"
	},
	"_requiredBy": [
		"/browserify-sign",
		"/create-ecdh"
	],
	"_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.4.0.tgz",
	"_shasum": "cac9af8762c85836187003c8dfe193e5e2eae5df",
	"_shrinkwrap": null,
	"_spec": "elliptic@^6.0.0",
	"_where": "/Users/devicalin/Desktop/workspace/js-stl/node_modules/browserify-sign",
	"author": {
		"name": "Fedor Indutny",
		"email": "fedor@indutny.com"
	},
	"bugs": {
		"url": "https://github.com/indutny/elliptic/issues"
	},
	"dependencies": {
		"bn.js": "^4.4.0",
		"brorand": "^1.0.1",
		"hash.js": "^1.0.0",
		"hmac-drbg": "^1.0.0",
		"inherits": "^2.0.1",
		"minimalistic-assert": "^1.0.0",
		"minimalistic-crypto-utils": "^1.0.0"
	},
	"description": "EC cryptography",
	"devDependencies": {
		"brfs": "^1.4.3",
		"coveralls": "^2.11.3",
		"grunt": "^0.4.5",
		"grunt-browserify": "^5.0.0",
		"grunt-cli": "^1.2.0",
		"grunt-contrib-connect": "^1.0.0",
		"grunt-contrib-copy": "^1.0.0",
		"grunt-contrib-uglify": "^1.0.1",
		"grunt-mocha-istanbul": "^3.0.1",
		"grunt-saucelabs": "^8.6.2",
		"istanbul": "^0.4.2",
		"jscs": "^2.9.0",
		"jshint": "^2.6.0",
		"mocha": "^2.1.0"
	},
	"directories": {},
	"dist": {
		"shasum": "cac9af8762c85836187003c8dfe193e5e2eae5df",
		"tarball": "https://registry.npmjs.org/elliptic/-/elliptic-6.4.0.tgz"
	},
	"files": [
		"lib"
	],
	"gitHead": "6b0d2b76caae91471649c8e21f0b1d3ba0f96090",
	"homepage": "https://github.com/indutny/elliptic",
	"keywords": [
		"EC",
		"Elliptic",
		"curve",
		"Cryptography"
	],
	"license": "MIT",
	"main": "lib/elliptic.js",
	"maintainers": [
		{
			"name": "indutny",
			"email": "fedor@indutny.com"
		}
	],
	"name": "elliptic",
	"optionalDependencies": {},
	"readme": "ERROR: No README data found!",
	"repository": {
		"type": "git",
		"url": "git+ssh://git@github.com/indutny/elliptic.git"
	},
	"scripts": {
		"jscs": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
		"jshint": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
		"lint": "npm run jscs && npm run jshint",
		"test": "npm run lint && npm run unit",
		"unit": "istanbul test _mocha --reporter=spec test/index.js",
		"version": "grunt dist && git add dist/"
	},
	"version": "6.4.0"
};

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var hash = __webpack_require__(12);
var utils = hash.utils;
var assert = utils.assert;

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var hmac = exports;

var hash = __webpack_require__(12);
var utils = hash.utils;
var assert = utils.assert;

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (var i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (var i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var hash = __webpack_require__(12);
var utils = hash.utils;

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = hash.common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var hash = __webpack_require__(12);
var utils = hash.utils;
var assert = utils.assert;

var rotr32 = utils.rotr32;
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = hash.common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
exports.sha256 = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [ 0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
             0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
exports.sha224 = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [ 0x6a09e667, 0xf3bcc908,
             0xbb67ae85, 0x84caa73b,
             0x3c6ef372, 0xfe94f82b,
             0xa54ff53a, 0x5f1d36f1,
             0x510e527f, 0xade682d1,
             0x9b05688c, 0x2b3e6c1f,
             0x1f83d9ab, 0xfb41bd6b,
             0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
exports.sha512 = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(c0_hi, c0_lo,
                      c1_hi, c1_lo,
                      c2_hi, c2_lo,
                      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(c0_hi, c0_lo,
                          c1_hi, c1_lo,
                          c2_hi, c2_lo,
                          c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);

    var c0_hi = s0_512_hi(ah, al);
    var c0_lo = s0_512_lo(ah, al);
    var c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    var c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [ 0xcbbb9d5d, 0xc1059ed8,
             0x629a292a, 0x367cd507,
             0x9159015a, 0x3070dd17,
             0x152fecd8, 0xf70e5939,
             0x67332667, 0xffc00b31,
             0x8eb44a87, 0x68581511,
             0xdb0c2e0d, 0x64f98fa7,
             0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
exports.sha384 = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe,
             0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
exports.sha1 = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (var i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}

function p32(x, y, z) {
  return x ^ y ^ z;
}

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}

function ch64_hi(xh, xl, yh, yl, zh, zl) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh, zl) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var utils = exports;
var inherits = __webpack_require__(1);

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
utils.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
utils.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
utils.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
utils.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
utils.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
utils.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
utils.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
utils.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
utils.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
utils.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
utils.sum32_5 = sum32_5;

function assert(cond, msg) {
  if (!cond)
    throw new Error(msg || 'Assertion failed');
}
utils.assert = assert;

utils.inherits = inherits;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
};
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
};
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
};
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
};
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
};
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
};
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
};
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
};
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
};
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
};
exports.shr64_lo = shr64_lo;


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(12);
var utils = __webpack_require__(108);
var assert = __webpack_require__(13);

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),
/* 240 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 241 */
/***/ (function(module, exports) {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),
/* 242 */
/***/ (function(module, exports) {

module.exports = {
	"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
	"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
	"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
	"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
	"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
	"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
	"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
	"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
	"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
	"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
	"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
	"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.


var asn1 = __webpack_require__(26)

exports.certificate = __webpack_require__(244)

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen



var asn = __webpack_require__(26)

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED\n\r?DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\n\r?\n\r?([0-9A-z\n\r\+\/\=]+)\n\r?/m
var startRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----\n/m
var fullRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----\n\r?([0-9A-z\n\r\+\/\=]+)\n\r?-----END \1-----$/m
var evp = __webpack_require__(45)
var ciphers = __webpack_require__(49)
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = new Buffer(match[2], 'hex')
    var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 246 */
/***/ (function(module, exports) {

var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs
module.exports = function (iterations, keylen) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

exports.publicEncrypt = __webpack_require__(249);
exports.privateDecrypt = __webpack_require__(248);

exports.privateEncrypt = function privateEncrypt(key, buf) {
  return exports.publicEncrypt(key, buf, true);
};

exports.publicDecrypt = function publicDecrypt(key, buf) {
  return exports.privateDecrypt(key, buf, true);
};

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var parseKeys = __webpack_require__(46);
var mgf = __webpack_require__(110);
var xor = __webpack_require__(112);
var bn = __webpack_require__(3);
var crt = __webpack_require__(50);
var createHash = __webpack_require__(21);
var withPublic = __webpack_require__(111);
module.exports = function privateDecrypt(private_key, enc, reverse) {
  var padding;
  if (private_key.padding) {
    padding = private_key.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }
  
  var key = parseKeys(private_key);
  var k = key.modulus.byteLength();
  if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error');
  }
  var msg;
  if (reverse) {
    msg = withPublic(new bn(enc), key);
  } else {
    msg = crt(enc, key);
  }
  var zBuffer = new Buffer(k - msg.length);
  zBuffer.fill(0);
  msg = Buffer.concat([zBuffer, msg], k);
  if (padding === 4) {
    return oaep(key, msg);
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    return msg;
  } else {
    throw new Error('unknown padding');
  }
};

function oaep(key, msg){
  var n = key.modulus;
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (msg[0] !== 0) {
    throw new Error('decryption error');
  }
  var maskedSeed = msg.slice(1, hLen + 1);
  var maskedDb =  msg.slice(hLen + 1);
  var seed = xor(maskedSeed, mgf(maskedDb, hLen));
  var db = xor(maskedDb, mgf(seed, k - hLen - 1));
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error');
  }
  var i = hLen;
  while (db[i] === 0) {
    i++;
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error');
  }
  return db.slice(i);
}

function pkcs1(key, msg, reverse){
  var p1 = msg.slice(0, 2);
  var i = 2;
  var status = 0;
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++;
      break;
    }
  }
  var ps = msg.slice(2, i - 1);
  var p2 = msg.slice(i - 1, i);

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)){
    status++;
  }
  if (ps.length < 8) {
    status++;
  }
  if (status) {
    throw new Error('decryption error');
  }
  return  msg.slice(i);
}
function compare(a, b){
  a = new Buffer(a);
  b = new Buffer(b);
  var dif = 0;
  var len = a.length;
  if (a.length !== b.length) {
    dif++;
    len = Math.min(a.length, b.length);
  }
  var i = -1;
  while (++i < len) {
    dif += (a[i] ^ b[i]);
  }
  return dif;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var parseKeys = __webpack_require__(46);
var randomBytes = __webpack_require__(33);
var createHash = __webpack_require__(21);
var mgf = __webpack_require__(110);
var xor = __webpack_require__(112);
var bn = __webpack_require__(3);
var withPublic = __webpack_require__(111);
var crt = __webpack_require__(50);

var constants = {
  RSA_PKCS1_OAEP_PADDING: 4,
  RSA_PKCS1_PADDIN: 1,
  RSA_NO_PADDING: 3
};

module.exports = function publicEncrypt(public_key, msg, reverse) {
  var padding;
  if (public_key.padding) {
    padding = public_key.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }
  var key = parseKeys(public_key);
  var paddedMsg;
  if (padding === 4) {
    paddedMsg = oaep(key, msg);
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    paddedMsg = new bn(msg);
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus');
    }
  } else {
    throw new Error('unknown padding');
  }
  if (reverse) {
    return crt(paddedMsg, key);
  } else {
    return withPublic(paddedMsg, key);
  }
};

function oaep(key, msg){
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long');
  }
  var ps = new Buffer(k - mLen - hLen2 - 2);
  ps.fill(0);
  var dblen = k - hLen - 1;
  var seed = randomBytes(hLen);
  var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));
  var maskedSeed = xor(seed, mgf(maskedDb, hLen));
  return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
}
function pkcs1(key, msg, reverse){
  var mLen = msg.length;
  var k = key.modulus.byteLength();
  if (mLen > k - 11) {
    throw new Error('message too long');
  }
  var ps;
  if (reverse) {
    ps = new Buffer(k - mLen - 3);
    ps.fill(0xff);
  } else {
    ps = nonZero(k - mLen - 3);
  }
  return new bn(Buffer.concat([new Buffer([0, reverse?1:2]), ps, new Buffer([0]), msg], k));
}
function nonZero(len, crypto) {
  var out = new Buffer(len);
  var i = 0;
  var cache = randomBytes(len*2);
  var cur = 0;
  var num;
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len*2);
      cur = 0;
    }
    num = cache[cur++];
    if (num) {
      out[i++] = num;
    }
  }
  return out;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(14)


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Buffer = __webpack_require__(0).Buffer;
/*<replacement>*/
var bufferShim = __webpack_require__(51);
/*</replacement>*/

module.exports = BufferList;

function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}

BufferList.prototype.push = function (v) {
  var entry = { data: v, next: null };
  if (this.length > 0) this.tail.next = entry;else this.head = entry;
  this.tail = entry;
  ++this.length;
};

BufferList.prototype.unshift = function (v) {
  var entry = { data: v, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};

BufferList.prototype.shift = function () {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
  --this.length;
  return ret;
};

BufferList.prototype.clear = function () {
  this.head = this.tail = null;
  this.length = 0;
};

BufferList.prototype.join = function (s) {
  if (this.length === 0) return '';
  var p = this.head;
  var ret = '' + p.data;
  while (p = p.next) {
    ret += s + p.data;
  }return ret;
};

BufferList.prototype.concat = function (n) {
  if (this.length === 0) return bufferShim.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = bufferShim.allocUnsafe(n >>> 0);
  var p = this.head;
  var i = 0;
  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }
  return ret;
};

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(113)


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var Stream = (function (){
  try {
    return __webpack_require__(23); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = __webpack_require__(114);
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(69);
exports.Duplex = __webpack_require__(14);
exports.Transform = __webpack_require__(68);
exports.PassThrough = __webpack_require__(113);

if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(68)


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(69)


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g =
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this;

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(257);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15), __webpack_require__(7)))

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/** @preserve
(c) 2012 by Cdric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// constants table
var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]
var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]

function bytesToWords (bytes) {
  var words = []
  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
    words[b >>> 5] |= bytes[i] << (24 - b % 32)
  }
  return words
}

function wordsToBytes (words) {
  var bytes = []
  for (var b = 0; b < words.length * 32; b += 8) {
    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF)
  }
  return bytes
}

function processBlock (H, M, offset) {
  // swap endian
  for (var i = 0; i < 16; i++) {
    var offset_i = offset + i
    var M_offset_i = M[offset_i]

    // Swap
    M[offset_i] = (
      (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
      (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)
    )
  }

  // Working variables
  var al, bl, cl, dl, el
  var ar, br, cr, dr, er

  ar = al = H[0]
  br = bl = H[1]
  cr = cl = H[2]
  dr = dl = H[3]
  er = el = H[4]

  // computation
  var t
  for (i = 0; i < 80; i += 1) {
    t = (al + M[offset + zl[i]]) | 0
    if (i < 16) {
      t += f1(bl, cl, dl) + hl[0]
    } else if (i < 32) {
      t += f2(bl, cl, dl) + hl[1]
    } else if (i < 48) {
      t += f3(bl, cl, dl) + hl[2]
    } else if (i < 64) {
      t += f4(bl, cl, dl) + hl[3]
    } else {// if (i<80) {
      t += f5(bl, cl, dl) + hl[4]
    }
    t = t | 0
    t = rotl(t, sl[i])
    t = (t + el) | 0
    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = t

    t = (ar + M[offset + zr[i]]) | 0
    if (i < 16) {
      t += f5(br, cr, dr) + hr[0]
    } else if (i < 32) {
      t += f4(br, cr, dr) + hr[1]
    } else if (i < 48) {
      t += f3(br, cr, dr) + hr[2]
    } else if (i < 64) {
      t += f2(br, cr, dr) + hr[3]
    } else {// if (i<80) {
      t += f1(br, cr, dr) + hr[4]
    }

    t = t | 0
    t = rotl(t, sr[i])
    t = (t + er) | 0
    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = t
  }

  // intermediate hash value
  t = (H[1] + cl + dr) | 0
  H[1] = (H[2] + dl + er) | 0
  H[2] = (H[3] + el + ar) | 0
  H[3] = (H[4] + al + br) | 0
  H[4] = (H[0] + bl + cr) | 0
  H[0] = t
}

function f1 (x, y, z) {
  return ((x) ^ (y) ^ (z))
}

function f2 (x, y, z) {
  return (((x) & (y)) | ((~x) & (z)))
}

function f3 (x, y, z) {
  return (((x) | (~(y))) ^ (z))
}

function f4 (x, y, z) {
  return (((x) & (z)) | ((y) & (~(z))))
}

function f5 (x, y, z) {
  return ((x) ^ ((y) | (~(z))))
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function ripemd160 (message) {
  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

  if (typeof message === 'string') {
    message = new Buffer(message, 'utf8')
  }

  var m = bytesToWords(message)

  var nBitsLeft = message.length * 8
  var nBitsTotal = message.length * 8

  // Add padding
  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32)
  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
    (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |
    (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00)
  )

  for (var i = 0; i < m.length; i += 16) {
    processBlock(H, m, i)
  }

  // swap endian
  for (i = 0; i < 5; i++) {
    // shortcut
    var H_i = H[i]

    // Swap
    H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
      (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00)
  }

  var digestbytes = wordsToBytes(H)
  return new Buffer(digestbytes)
}

module.exports = ripemd160

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15), __webpack_require__(7)))

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = __webpack_require__(261)
exports.sha1 = __webpack_require__(262)
exports.sha224 = __webpack_require__(263)
exports.sha256 = __webpack_require__(115)
exports.sha384 = __webpack_require__(264)
exports.sha512 = __webpack_require__(116)


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = __webpack_require__(1)
var Hash = __webpack_require__(22)

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(1)
var Hash = __webpack_require__(22)

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(1)
var Sha256 = __webpack_require__(115)
var Hash = __webpack_require__(22)

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = new Buffer(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var inherits = __webpack_require__(1)
var SHA512 = __webpack_require__(116)
var Hash = __webpack_require__(22)

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = new Buffer(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(259);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

var indexOf = __webpack_require__(241);

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
	h32: __webpack_require__(269)
,	h64: __webpack_require__(270)
}


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
xxHash implementation in pure Javascript

Copyright (C) 2013, Pierre Curto
MIT license
*/
var UINT32 = __webpack_require__(104).UINT32

/*
	Merged this sequence of method calls as it speeds up
	the calculations by a factor of 2
 */
// this.v1.add( other.multiply(PRIME32_2) ).rotl(13).multiply(PRIME32_1);
UINT32.prototype.xxh_update = function (low, high) {
	var b00 = PRIME32_2._low
	var b16 = PRIME32_2._high

	var c16, c00
	c00 = low * b00
	c16 = c00 >>> 16

	c16 += high * b00
	c16 &= 0xFFFF		// Not required but improves performance
	c16 += low * b16

	var a00 = this._low + (c00 & 0xFFFF)
	var a16 = a00 >>> 16

	a16 += this._high + (c16 & 0xFFFF)

	var v = (a16 << 16) | (a00 & 0xFFFF)
	v = (v << 13) | (v >>> 19)

	a00 = v & 0xFFFF
	a16 = v >>> 16

	b00 = PRIME32_1._low
	b16 = PRIME32_1._high

	c00 = a00 * b00
	c16 = c00 >>> 16

	c16 += a16 * b00
	c16 &= 0xFFFF		// Not required but improves performance
	c16 += a00 * b16

	this._low = c00 & 0xFFFF
	this._high = c16 & 0xFFFF
}

/*
 * Constants
 */
var PRIME32_1 = UINT32( '2654435761' )
var PRIME32_2 = UINT32( '2246822519' )
var PRIME32_3 = UINT32( '3266489917' )
var PRIME32_4 = UINT32(  '668265263' )
var PRIME32_5 = UINT32(  '374761393' )

/**
* Convert string to proper UTF-8 array
* @param str Input string
* @returns {Uint8Array} UTF8 array is returned as uint8 array
*/
function toUTF8Array (str) {
	var utf8 = []
	for (var i=0, n=str.length; i < n; i++) {
		var charcode = str.charCodeAt(i)
		if (charcode < 0x80) utf8.push(charcode)
		else if (charcode < 0x800) {
			utf8.push(0xc0 | (charcode >> 6),
			0x80 | (charcode & 0x3f))
		}
		else if (charcode < 0xd800 || charcode >= 0xe000) {
			utf8.push(0xe0 | (charcode >> 12),
			0x80 | ((charcode>>6) & 0x3f),
			0x80 | (charcode & 0x3f))
		}
		// surrogate pair
		else {
			i++;
			// UTF-16 encodes 0x10000-0x10FFFF by
			// subtracting 0x10000 and splitting the
			// 20 bits of 0x0-0xFFFFF into two halves
			charcode = 0x10000 + (((charcode & 0x3ff)<<10)
			| (str.charCodeAt(i) & 0x3ff))
			utf8.push(0xf0 | (charcode >>18),
			0x80 | ((charcode>>12) & 0x3f),
			0x80 | ((charcode>>6) & 0x3f),
			0x80 | (charcode & 0x3f))
		}
	}

	return new Uint8Array(utf8)
}

/**
 * XXH object used as a constructor or a function
 * @constructor
 * or
 * @param {Object|String} input data
 * @param {Number|UINT32} seed
 * @return ThisExpression
 * or
 * @return {UINT32} xxHash
 */
function XXH () {
	if (arguments.length == 2)
		return new XXH( arguments[1] ).update( arguments[0] ).digest()

	if (!(this instanceof XXH))
		return new XXH( arguments[0] )

	init.call(this, arguments[0])
}

/**
 * Initialize the XXH instance with the given seed
 * @method init
 * @param {Number|Object} seed as a number or an unsigned 32 bits integer
 * @return ThisExpression
 */
 function init (seed) {
	this.seed = seed instanceof UINT32 ? seed.clone() : UINT32(seed)
	this.v1 = this.seed.clone().add(PRIME32_1).add(PRIME32_2)
	this.v2 = this.seed.clone().add(PRIME32_2)
	this.v3 = this.seed.clone()
	this.v4 = this.seed.clone().subtract(PRIME32_1)
	this.total_len = 0
	this.memsize = 0
	this.memory = null

	return this
}
XXH.prototype.init = init

/**
 * Add data to be computed for the XXH hash
 * @method update
 * @param {String|Buffer|ArrayBuffer} input as a string or nodejs Buffer or ArrayBuffer
 * @return ThisExpression
 */
XXH.prototype.update = function (input) {
	var isString = typeof input == 'string'
	var isArrayBuffer

	// Convert all strings to utf-8 first (issue #5)
	if (isString) {
		input = toUTF8Array(input)
		isString = false
		isArrayBuffer = true
	}

	if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer)
	{
		isArrayBuffer = true
		input = new Uint8Array(input);
	}

	var p = 0
	var len = input.length
	var bEnd = p + len

	if (len == 0) return this

	this.total_len += len

	if (this.memsize == 0)
	{
		if (isString) {
			this.memory = ''
		} else if (isArrayBuffer) {
			this.memory = new Uint8Array(16)
		} else {
			this.memory = new Buffer(16)
		}
	}

	if (this.memsize + len < 16)   // fill in tmp buffer
	{
		// XXH_memcpy(this.memory + this.memsize, input, len)
		if (isString) {
			this.memory += input
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(0, len), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, 0, len )
		}

		this.memsize += len
		return this
	}

	if (this.memsize > 0)   // some data left from previous update
	{
		// XXH_memcpy(this.memory + this.memsize, input, 16-this.memsize);
		if (isString) {
			this.memory += input.slice(0, 16 - this.memsize)
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(0, 16 - this.memsize), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, 0, 16 - this.memsize )
		}

		var p32 = 0
		if (isString) {
			this.v1.xxh_update(
				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
			)
			p32 += 4
			this.v2.xxh_update(
				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
			)
			p32 += 4
			this.v3.xxh_update(
				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
			)
			p32 += 4
			this.v4.xxh_update(
				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
			)
		} else {
			this.v1.xxh_update(
				(this.memory[p32+1] << 8) | this.memory[p32]
			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
			)
			p32 += 4
			this.v2.xxh_update(
				(this.memory[p32+1] << 8) | this.memory[p32]
			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
			)
			p32 += 4
			this.v3.xxh_update(
				(this.memory[p32+1] << 8) | this.memory[p32]
			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
			)
			p32 += 4
			this.v4.xxh_update(
				(this.memory[p32+1] << 8) | this.memory[p32]
			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
			)
		}

		p += 16 - this.memsize
		this.memsize = 0
		if (isString) this.memory = ''
	}

	if (p <= bEnd - 16)
	{
		var limit = bEnd - 16

		do
		{
			if (isString) {
				this.v1.xxh_update(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				)
				p += 4
				this.v2.xxh_update(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				)
				p += 4
				this.v3.xxh_update(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				)
				p += 4
				this.v4.xxh_update(
					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
				)
			} else {
				this.v1.xxh_update(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				)
				p += 4
				this.v2.xxh_update(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				)
				p += 4
				this.v3.xxh_update(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				)
				p += 4
				this.v4.xxh_update(
					(input[p+1] << 8) | input[p]
				,	(input[p+3] << 8) | input[p+2]
				)
			}
			p += 4
		} while (p <= limit)
	}

	if (p < bEnd)
	{
		// XXH_memcpy(this.memory, p, bEnd-p);
		if (isString) {
			this.memory += input.slice(p)
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(p, bEnd), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, p, bEnd )
		}

		this.memsize = bEnd - p
	}

	return this
}

/**
 * Finalize the XXH computation. The XXH instance is ready for reuse for the given seed
 * @method digest
 * @return {UINT32} xxHash
 */
XXH.prototype.digest = function () {
	var input = this.memory
	var isString = typeof input == 'string'
	var p = 0
	var bEnd = this.memsize
	var h32, h
	var u = new UINT32

	if (this.total_len >= 16)
	{
		h32 = this.v1.rotl(1).add( this.v2.rotl(7).add( this.v3.rotl(12).add( this.v4.rotl(18) ) ) )
	}
	else
	{
		h32  = this.seed.clone().add( PRIME32_5 )
	}

	h32.add( u.fromNumber(this.total_len) )

	while (p <= bEnd - 4)
	{
		if (isString) {
			u.fromBits(
				(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
			,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
			)
		} else {
			u.fromBits(
				(input[p+1] << 8) | input[p]
			,	(input[p+3] << 8) | input[p+2]
			)
		}
		h32
			.add( u.multiply(PRIME32_3) )
			.rotl(17)
			.multiply( PRIME32_4 )
		p += 4
	}

	while (p < bEnd)
	{
		u.fromBits( isString ? input.charCodeAt(p++) : input[p++], 0 )
		h32
			.add( u.multiply(PRIME32_5) )
			.rotl(11)
			.multiply(PRIME32_1)
	}

	h = h32.clone().shiftRight(15)
	h32.xor(h).multiply(PRIME32_2)

	h = h32.clone().shiftRight(13)
	h32.xor(h).multiply(PRIME32_3)

	h = h32.clone().shiftRight(16)
	h32.xor(h)

	// Reset the state
	this.init( this.seed )

	return h32
}

module.exports = XXH

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
xxHash64 implementation in pure Javascript

Copyright (C) 2016, Pierre Curto
MIT license
*/
var UINT64 = __webpack_require__(104).UINT64

/*
 * Constants
 */
var PRIME64_1 = UINT64( '11400714785074694791' )
var PRIME64_2 = UINT64( '14029467366897019727' )
var PRIME64_3 = UINT64(  '1609587929392839161' )
var PRIME64_4 = UINT64(  '9650029242287828579' )
var PRIME64_5 = UINT64(  '2870177450012600261' )

/**
* Convert string to proper UTF-8 array
* @param str Input string
* @returns {Uint8Array} UTF8 array is returned as uint8 array
*/
function toUTF8Array (str) {
	var utf8 = []
	for (var i=0, n=str.length; i < n; i++) {
		var charcode = str.charCodeAt(i)
		if (charcode < 0x80) utf8.push(charcode)
		else if (charcode < 0x800) {
			utf8.push(0xc0 | (charcode >> 6),
			0x80 | (charcode & 0x3f))
		}
		else if (charcode < 0xd800 || charcode >= 0xe000) {
			utf8.push(0xe0 | (charcode >> 12),
			0x80 | ((charcode>>6) & 0x3f),
			0x80 | (charcode & 0x3f))
		}
		// surrogate pair
		else {
			i++;
			// UTF-16 encodes 0x10000-0x10FFFF by
			// subtracting 0x10000 and splitting the
			// 20 bits of 0x0-0xFFFFF into two halves
			charcode = 0x10000 + (((charcode & 0x3ff)<<10)
			| (str.charCodeAt(i) & 0x3ff))
			utf8.push(0xf0 | (charcode >>18),
			0x80 | ((charcode>>12) & 0x3f),
			0x80 | ((charcode>>6) & 0x3f),
			0x80 | (charcode & 0x3f))
		}
	}

	return new Uint8Array(utf8)
}

/**
 * XXH64 object used as a constructor or a function
 * @constructor
 * or
 * @param {Object|String} input data
 * @param {Number|UINT64} seed
 * @return ThisExpression
 * or
 * @return {UINT64} xxHash
 */
function XXH64 () {
	if (arguments.length == 2)
		return new XXH64( arguments[1] ).update( arguments[0] ).digest()

	if (!(this instanceof XXH64))
		return new XXH64( arguments[0] )

	init.call(this, arguments[0])
}

/**
 * Initialize the XXH64 instance with the given seed
 * @method init
 * @param {Number|Object} seed as a number or an unsigned 32 bits integer
 * @return ThisExpression
 */
 function init (seed) {
	this.seed = seed instanceof UINT64 ? seed.clone() : UINT64(seed)
	this.v1 = this.seed.clone().add(PRIME64_1).add(PRIME64_2)
	this.v2 = this.seed.clone().add(PRIME64_2)
	this.v3 = this.seed.clone()
	this.v4 = this.seed.clone().subtract(PRIME64_1)
	this.total_len = 0
	this.memsize = 0
	this.memory = null

	return this
}
XXH64.prototype.init = init

/**
 * Add data to be computed for the XXH64 hash
 * @method update
 * @param {String|Buffer|ArrayBuffer} input as a string or nodejs Buffer or ArrayBuffer
 * @return ThisExpression
 */
XXH64.prototype.update = function (input) {
	var isString = typeof input == 'string'
	var isArrayBuffer

	// Convert all strings to utf-8 first (issue #5)
	if (isString) {
		input = toUTF8Array(input)
		isString = false
		isArrayBuffer = true
	}

	if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer)
	{
		isArrayBuffer = true
		input = new Uint8Array(input);
	}

	var p = 0
	var len = input.length
	var bEnd = p + len

	if (len == 0) return this

	this.total_len += len

	if (this.memsize == 0)
	{
		if (isString) {
			this.memory = ''
		} else if (isArrayBuffer) {
			this.memory = new Uint8Array(32)
		} else {
			this.memory = new Buffer(32)
		}
	}

	if (this.memsize + len < 32)   // fill in tmp buffer
	{
		// XXH64_memcpy(this.memory + this.memsize, input, len)
		if (isString) {
			this.memory += input
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(0, len), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, 0, len )
		}

		this.memsize += len
		return this
	}

	if (this.memsize > 0)   // some data left from previous update
	{
		// XXH64_memcpy(this.memory + this.memsize, input, 16-this.memsize);
		if (isString) {
			this.memory += input.slice(0, 32 - this.memsize)
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(0, 32 - this.memsize), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, 0, 32 - this.memsize )
		}

		var p64 = 0
		if (isString) {
			var other
			other = UINT64(
					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
				)
			this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
				)
			this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
				)
			this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
				)
			this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
		} else {
			var other
			other = UINT64(
					(this.memory[p64+1] << 8) | this.memory[p64]
				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
				)
			this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory[p64+1] << 8) | this.memory[p64]
				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
				)
			this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory[p64+1] << 8) | this.memory[p64]
				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
				)
			this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			p64 += 8
			other = UINT64(
					(this.memory[p64+1] << 8) | this.memory[p64]
				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
				)
			this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
		}

		p += 32 - this.memsize
		this.memsize = 0
		if (isString) this.memory = ''
	}

	if (p <= bEnd - 32)
	{
		var limit = bEnd - 32

		do
		{
			if (isString) {
				var other
				other = UINT64(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
					)
				this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
					)
				this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
					)
				this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
					)
				this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			} else {
				var other
				other = UINT64(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					,	(input[p+5] << 8) | input[p+4]
					,	(input[p+7] << 8) | input[p+6]
					)
				this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					,	(input[p+5] << 8) | input[p+4]
					,	(input[p+7] << 8) | input[p+6]
					)
				this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					,	(input[p+5] << 8) | input[p+4]
					,	(input[p+7] << 8) | input[p+6]
					)
				this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
				p += 8
				other = UINT64(
						(input[p+1] << 8) | input[p]
					,	(input[p+3] << 8) | input[p+2]
					,	(input[p+5] << 8) | input[p+4]
					,	(input[p+7] << 8) | input[p+6]
					)
				this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
			}
			p += 8
		} while (p <= limit)
	}

	if (p < bEnd)
	{
		// XXH64_memcpy(this.memory, p, bEnd-p);
		if (isString) {
			this.memory += input.slice(p)
		} else if (isArrayBuffer) {
			this.memory.set( input.subarray(p, bEnd), this.memsize )
		} else {
			input.copy( this.memory, this.memsize, p, bEnd )
		}

		this.memsize = bEnd - p
	}

	return this
}

/**
 * Finalize the XXH64 computation. The XXH64 instance is ready for reuse for the given seed
 * @method digest
 * @return {UINT64} xxHash
 */
XXH64.prototype.digest = function () {
	var input = this.memory
	var isString = typeof input == 'string'
	var p = 0
	var bEnd = this.memsize
	var h64, h
	var u = new UINT64

	if (this.total_len >= 32)
	{
		h64 = this.v1.clone().rotl(1)
		h64.add( this.v2.clone().rotl(7) )
		h64.add( this.v3.clone().rotl(12) )
		h64.add( this.v4.clone().rotl(18) )

		h64.xor( this.v1.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
		h64.multiply(PRIME64_1).add(PRIME64_4)

		h64.xor( this.v2.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
		h64.multiply(PRIME64_1).add(PRIME64_4)

		h64.xor( this.v3.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
		h64.multiply(PRIME64_1).add(PRIME64_4)

		h64.xor( this.v4.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) )
		h64.multiply(PRIME64_1).add(PRIME64_4)
	}
	else
	{
		h64  = this.seed.clone().add( PRIME64_5 )
	}

	h64.add( u.fromNumber(this.total_len) )

	while (p <= bEnd - 8)
	{
		if (isString) {
			u.fromBits(
				(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
			,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
			,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
			,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
			)
		} else {
			u.fromBits(
				(input[p+1] << 8) | input[p]
			,	(input[p+3] << 8) | input[p+2]
			,	(input[p+5] << 8) | input[p+4]
			,	(input[p+7] << 8) | input[p+6]
			)
		}
		u.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1)
		h64
			.xor(u)
			.rotl(27)
			.multiply( PRIME64_1 )
			.add( PRIME64_4 )
		p += 8
	}

	if (p + 4 <= bEnd) {
		if (isString) {
			u.fromBits(
				(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
			,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
			,	0
			,	0
			)
		} else {
			u.fromBits(
				(input[p+1] << 8) | input[p]
			,	(input[p+3] << 8) | input[p+2]
			,	0
			,	0
			)
		}
		h64
			.xor( u.multiply(PRIME64_1) )
			.rotl(23)
			.multiply( PRIME64_2 )
			.add( PRIME64_3 )
		p += 4
	}

	while (p < bEnd)
	{
		u.fromBits( isString ? input.charCodeAt(p++) : input[p++], 0, 0, 0 )
		h64
			.xor( u.multiply(PRIME64_5) )
			.rotl(11)
			.multiply(PRIME64_1)
	}

	h = h64.clone().shiftRight(33)
	h64.xor(h).multiply(PRIME64_2)

	h = h64.clone().shiftRight(29)
	h64.xor(h).multiply(PRIME64_3)

	h = h64.clone().shiftRight(32)
	h64.xor(h)

	// Reset the state
	this.init( this.seed )

	return h64
}

module.exports = XXH64

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0).Buffer))

/***/ }),
/* 271 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 272 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAwZWI0NGY3NDNkN2M1N2EwNDhlYSIsIndlYnBhY2s6Ly8vLi9+L2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9ibi5qcy9saWIvYm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hhc2guanMvbGliL2hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9taW5pbWFsaXN0aWMtYXNzZXJ0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9RdWV1ZS9RdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NpcGhlci1iYXNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jcmVhdGUtaGFzaC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vc2hhLmpzL2hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvQmluYXJ5VHJlZS9CaW5hcnlUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TdGFjay9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FzbjEuanMvbGliL2FzbjEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hc24xLmpzL2xpYi9hc24xL2Jhc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9idWZmZXIteG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL34vcmFuZG9tYnl0ZXMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU29ydC9kZWZhdWx0Q29tcGFyaXNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1hZXMvYWVzLmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jdHIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL34vZXZwX2J5dGVzdG9rZXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZS1hc24xL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LWFlcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1yc2EvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9idWZmZXItc2hpbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jcmVhdGUtaG1hYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZGVzLmpzL2xpYi9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvSGVhcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTGlzdC9Eb3VibGVMaW5rZWRMaXN0LmpzIiwid2VicGFjazovLy8uL3NyYy9MaXN0L1N0YXRpY0xpbmtlZExpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9CaW5hcnlTb3J0ZWRUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9Tb3J0L2V4Y2hhbmdlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYXNuMS5qcy9saWIvYXNuMS9iYXNlL2J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FzbjEuanMvbGliL2FzbjEvY29uc3RhbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2Rlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvTGlzdC9MaW5rZWRMaXN0LmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3JhbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LWFlcy9hdXRoQ2lwaGVyLmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2JjLmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiLmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiMS5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXJpZnktYWVzL21vZGVzL2NmYjguanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LWFlcy9tb2Rlcy9lY2IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LWFlcy9tb2Rlcy9vZmIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LWFlcy9zdHJlYW1DaXBoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9hbGdvcml0aG1zLmpzb24iLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9jdXJ2ZXMuanNvbiIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jcmVhdGUtaGFzaC9tZDUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jdWludC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2RpZmZpZS1oZWxsbWFuL2xpYi9nZW5lcmF0ZVByaW1lLmpzIiwid2VicGFjazovLy8uL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L21pbGxlci1yYWJpbi9saWIvbXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9taW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3Bia2RmMi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcHVibGljLWVuY3J5cHQvbWdmLmpzIiwid2VicGFjazovLy8uL34vcHVibGljLWVuY3J5cHQvd2l0aFB1YmxpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3B1YmxpYy1lbmNyeXB0L3hvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NoYS5qcy9zaGEyNTYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaGEuanMvc2hhNTEyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0JpbmFyeVRyZWUvQmluYXJ5VHJlZUFycmF5LmpzIiwid2VicGFjazovLy8uL3NyYy9CaW5hcnlUcmVlL2h1ZmZNYW5Db2RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0dlbmVyYWxpemVkTGlzdC9HTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR3JhcGgvQU1MR3JhcGguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0dyYXBoL0FkamFjZW5jeUxpc3RHcmFwaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR3JhcGgvQWRqYWNlbmN5TWF0cml4R3JhcGguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0dyYXBoL09MR3JhcGguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0xpc3QvTFJVLmpzIiwid2VicGFjazovLy8uL3NyYy9MaXN0L0xpbmVhckxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1F1ZXVlL0N5Y2xlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1F1ZXVlL1ByaW9yaXR5UXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9BVkxUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvQlBsdXNUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvQlRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9CaW5hcnlTZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9CbG9vbUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL0RpZ2l0YWxTZWFyY2hUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvSGFzaFRhYmxlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvUmVkQmxhY2tUcmVlLmpzIiwid2VicGFjazovLy8uL3NyYy9TZWFyY2gvU09TVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU2VhcmNoL1N1ZmZpeFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9maWJvbmFjY2lTZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NlYXJjaC9zZXF1ZW50aWFsU2VhcmNoLmpzIiwid2VicGFjazovLy8uL3NyYy9Tb3J0L2Rpc3RyaWJ1dGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU29ydC9pbnNlcnRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NvcnQvbWVyZ2luZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU29ydC9zZWxlY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1N0cmluZy9IU3RyaW5nLmpzIiwid2VicGFjazovLy8uL3NyYy9TdHJpbmcvTFN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU3RyaW5nL1NTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hc24xLmpzL2xpYi9hc24xL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FzbjEuanMvbGliL2FzbjEvYmFzZS9ub2RlLmpzIiwid2VicGFjazovLy8uL34vYXNuMS5qcy9saWIvYXNuMS9iYXNlL3JlcG9ydGVyLmpzIiwid2VicGFjazovLy8uL34vYXNuMS5qcy9saWIvYXNuMS9jb25zdGFudHMvZGVyLmpzIiwid2VicGFjazovLy8uL34vYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvcGVtLmpzIiwid2VicGFjazovLy8uL34vYXNuMS5qcy9saWIvYXNuMS9lbmNvZGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FzbjEuanMvbGliL2FzbjEvZW5jb2RlcnMvcGVtLmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXJpZnktYWVzL2RlY3J5cHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXJpZnktYWVzL2VuY3J5cHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXJpZnktYWVzL2doYXNoLmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1jaXBoZXIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXJpZnktZGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYnJvd3NlcmlmeS1kZXMvbW9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LXNpZ24vYWxnb3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXJpZnktc2lnbi9icm93c2VyL3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci92ZXJpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fa2V5b2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vY3JlYXRlLWVjZGgvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NyZWF0ZS1oYXNoL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2N1aW50L2xpYi91aW50MzIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jdWludC9saWIvdWludDY0LmpzIiwid2VicGFjazovLy8uL34vZGVzLmpzL2xpYi9kZXMvY2JjLmpzIiwid2VicGFjazovLy8uL34vZGVzLmpzL2xpYi9kZXMvY2lwaGVyLmpzIiwid2VicGFjazovLy8uL34vZGVzLmpzL2xpYi9kZXMvZGVzLmpzIiwid2VicGFjazovLy8uL34vZGVzLmpzL2xpYi9kZXMvZWRlLmpzIiwid2VicGFjazovLy8uL34vZGVzLmpzL2xpYi9kZXMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kaWZmaWUtaGVsbG1hbi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZGlmZmllLWhlbGxtYW4vbGliL2RoLmpzIiwid2VicGFjazovLy8uL34vZGlmZmllLWhlbGxtYW4vbGliL3ByaW1lcy5qc29uIiwid2VicGFjazovLy8uL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvZWR3YXJkcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9tb250LmpzIiwid2VicGFjazovLy8uL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL3Nob3J0LmpzIiwid2VicGFjazovLy8uL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMvc2lnbmF0dXJlLmpzIiwid2VicGFjazovLy8uL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL2tleS5qcyIsIndlYnBhY2s6Ly8vLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lZGRzYS9zaWduYXR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvcHJlY29tcHV0ZWQvc2VjcDI1NmsxLmpzIiwid2VicGFjazovLy8uL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL3V0aWxzLmpzIiwid2VicGFjazovLy8uL34vZWxsaXB0aWMvcGFja2FnZS5qc29uIiwid2VicGFjazovLy8uL34vaGFzaC5qcy9saWIvaGFzaC9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9oYXNoLmpzL2xpYi9oYXNoL2htYWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oYXNoLmpzL2xpYi9oYXNoL3JpcGVtZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2hhc2guanMvbGliL2hhc2gvc2hhLmpzIiwid2VicGFjazovLy8uL34vaGFzaC5qcy9saWIvaGFzaC91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2htYWMtZHJiZy9saWIvaG1hYy1kcmJnLmpzIiwid2VicGFjazovLy8uL34vaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2luZGV4b2YvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZS1hc24xL2Flc2lkLmpzb24iLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZS1hc24xL2FzbjEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYXJzZS1hc24xL2NlcnRpZmljYXRlLmpzIiwid2VicGFjazovLy8uL34vcGFyc2UtYXNuMS9maXhQcm9jLmpzIiwid2VicGFjazovLy8uL34vcGJrZGYyL3ByZWNvbmRpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3B1YmxpYy1lbmNyeXB0L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wdWJsaWMtZW5jcnlwdC9wcml2YXRlRGVjcnlwdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3B1YmxpYy1lbmNyeXB0L3B1YmxpY0VuY3J5cHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL34vcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzIiwid2VicGFjazovLy8uL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JpcGVtZDE2MC9saWIvcmlwZW1kMTYwLmpzIiwid2VicGFjazovLy8uL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NoYS5qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NoYS5qcy9zaGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaGEuanMvc2hhMS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NoYS5qcy9zaGEyMjQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaGEuanMvc2hhMzg0LmpzIiwid2VicGFjazovLy8uL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi92bS1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34veHhoYXNoanMvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34veHhoYXNoanMvbGliL3h4aGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3h4aGFzaGpzL2xpYi94eGhhc2g2NC5qcyIsIndlYnBhY2s6Ly8vY3J5cHRvIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCkiXSwibmFtZXMiOlsiUXVldWUiLCJyZWFyIiwiZnJvbnQiLCJzaXplIiwiaXNFbXB0eSIsImNsZWFyIiwiZ2V0SGVhZCIsImRhdGEiLCJlblF1ZXVlIiwiZWxlbSIsIm5leHQiLCJwIiwiZGVRdWV1ZSIsImZvckVhY2giLCJpdGVyYXRvciIsIkVycm9yIiwiY3VycmVudCIsIlN5bWJvbCIsInBlZWtBdCIsImluZGV4IiwiaSIsInRvU3RyaW5nIiwiYXJyIiwibGVuIiwiQmluYXJ5VHJlZSIsImxlZnRDaGlsZCIsInJpZ2h0Q2hpbGQiLCJpc1NpbWlsYXIiLCJ0cmVlIiwiY3JlYXRlQmluYXJ5VHJlZSIsInByZU9yZGVyUmVjdXJzaXZlIiwibm9kZSIsIngiLCJ2aXNpdCIsInBhcmVudE5vZGUiLCJ2YWx1ZSIsIml0ZXJhdG9yVHlwZSIsInByZU9yZGVyTm9uUmVjdXJzaXZlIiwic3RhY2siLCJsZW5ndGgiLCJwdXNoIiwicG9wIiwiaW5PcmRlck5vblJlY3Vyc2l2ZSIsInBvc3RPcmRlck5vblJlY3Vyc2l2ZSIsImEiLCJpbk9yZGVyUmVjdXJzaXZlIiwicG9zdE9yZGVyUmVjdXJzaXZlIiwibGV2ZWxPcmRlclRyYXZlcnNlIiwicXVldWUiLCJnZXRQcmVTZXF1ZW5jZSIsImsiLCJjb3VudCIsInJlY3Vyc2UiLCJjb3VudExlYXZlcyIsInJldm9sdXRlQmluYXJ5VHJlZSIsInJldm9sdXRlTm9uUmVjdXJzaXZlIiwiZ2V0U3ViRGVwdGgiLCJnZXREZXB0aCIsIm0iLCJuIiwiZGVsU3ViWCIsImNvcHkiLCJjYiIsInN0YWNrMSIsInN0YWNrMiIsIkNzdHIiLCJjb25zdHJ1Y3RvciIsIm5ld1RyZWUiLCJxIiwicGVlayIsImZpbmROZWFyQW5jaWVudCIsInBOb2RlIiwicU5vZGUiLCJwYXRoUCIsImZpbmRQYXRoIiwicGF0aFEiLCJsdXNoRGVncmVlIiwiY291bnRBcnIiLCJsYXllciIsInIiLCJoZWlnaHQiLCJtYXgiLCJkZXNjTnVtIiwiZCIsImlzRnVsbEJpbmFyeVRyZWUiLCJmbGFnIiwicGF0aCIsImZvdW5kIiwiZ2xvYmFsIiwiRnVuY3Rpb24iLCJwcmludFBhdGhfbWF4RGVwdGhTMSIsIm1heGgiLCJmaW5kX2giLCJoIiwicyIsImNvbnNvbGUiLCJsb2ciLCJ0ZXN0IiwiUGFyZW50VHJlZSIsIm5vZGVzIiwibWF4RGVwdGgiLCJkZXAiLCJqIiwicGFyZW50IiwiUGFyZW50VHJlZU5vZGUiLCJwdCIsIkNoaWxkVHJlZSIsInNlbGYiLCJzdWJEZXB0aCIsInJvb3RJbmRleCIsInNkIiwiY2hpbGQiLCJDaGlsZFRyZWVCb3giLCJmaXJzdENoaWxkIiwiQ2hpbGRUcmVlTm9kZSIsIkNoaWxkU2libGluZ1RyZWUiLCJuZXh0U2libGluZyIsInByaW50IiwibGVhZkNvdW50IiwiZ2V0RGVncmVlIiwiZGVncmVlIiwibWF4ZCIsIlN0YWNrIiwidG9wIiwib3V0IiwiZGVmYXVsdENvbXBhcmUiLCJiIiwiSGVhcCIsImNvbXBhcmUiLCJkZWZhdWx0Q29tcHJlIiwiYWRkIiwiX3VwSGVhcEFkanVzdCIsInJlbW92ZSIsImhlYXAiLCJfZG93bkhlYXBBZGp1c3QiLCJ0ZW1wIiwiTWF0aCIsImNlaWwiLCJOb2RlIiwicHJldiIsIkRvdWJsZUxpbmtlZExpc3QiLCJzcUxpc3QiLCJoZWFkIiwidGFpbCIsIml0ZW0iLCJ1bnNoaWZ0Iiwic2hpZnQiLCJ1cGRhdGUiLCJmaW5kQnlJbmRleCIsImluZGV4T2YiLCJyZXR1cm5Ob2RlIiwidG9KU09OIiwibGlzdCIsIlN0YXRpY0xpbmtlZExpc3QiLCJNQVhTSVpFIiwiY3VyIiwiZmluZCIsImluaXQiLCJtYWxsb2MiLCJmcmVlIiwiY3JlYXRlIiwiZGlmZmVyZW5jZSIsInNsbGlzdCIsImFycjEiLCJhcnIyIiwic2wiLCJyZXQiLCJCU1ROb2RlIiwiYXJnIiwic2VhcmNoIiwia2V5Iiwic2VhcmNoTm9uUmVjdXJzaXZlIiwiaW5zZXJ0IiwiaW5zZXJ0Tm9uUmVjdXJzaXZlIiwiY3JlYXRlQlNUIiwidXNlTm9uUmVjdXJzaXZlIiwiZGVsZXRlTm9kZSIsInJlbW92ZU5vblJlY3Vyc2l2ZSIsImYiLCJmaW5kTmVpZ2hib3JFbGVtIiwibGFzdCIsIkluZmluaXR5IiwibWVyZ2UiLCJic3QiLCJpbnNlcnROb2RlIiwic3BsaXQiLCJpc0JTVFRyZWUiLCJwb3MiLCJic3QyIiwicHJpbnROb3RMZXNzVGhhbiIsImExIiwiYTIiLCJidWJibGVTb3J0IiwiYnViYmxlU29ydDIiLCJjb2NrVGFpbFNvcnQiLCJjb2NrVGFpbFNvcnQyIiwicXVpY2tTb3J0UmVjdXJzaXZlIiwicXVpY2tTb3J0UmVjdXJzaXZlMiIsInF1aWNrU29ydE5vblJlY3Vyc2l2ZSIsInF1aWNrU29ydCIsIm9kZEV2ZW5Tb3J0IiwiY29tcCIsImNoYW5nZSIsImMiLCJsb3ciLCJoaWdoIiwicGFydGl0aW9uMSIsInBhcnRpdGlvbjIiLCJyYW5kIiwiZmxvb3IiLCJyYW5kb20iLCJwaXZvdCIsInBhcnRpdGlvbiIsImVhc3lTb3J0IiwiUkVEIiwiV0hJVEUiLCJCTFVFIiwiZmxhZ0FycmFuZ2UiLCJjb2xvcnMiLCJMaW5rZWRMaXN0IiwibWVyZ2VMaXN0IiwiY29tcEZuIiwiaGEiLCJoYiIsInBhIiwicGIiLCJkYXRhMSIsImRhdGEyIiwiYXBwZW5kIiwicHJldmlvdXMiLCJpbnNlcnRBZnRlciIsInRhcmdldCIsImNhbGxiYWNrIiwic3RyIiwib3JkZXJJbnNlcnQiLCJjbXAiLCJtZSIsImluc2VydEJldHdlZW4iLCJkZWxldGVCZXR3ZWVuIiwibWluIiwiZGVsZXRlRXF1YWwiLCJyZXZlcnNlIiwiaHVmZk1hbkNvZGluZyIsIkh1ZmZtYW5Ob2RlIiwid2VpZ2h0Iiwid2VpZ2h0cyIsImh1ZmZtYW5UcmVlIiwiYnVpbGRIdWZmbWFuVHJlZSIsImhjIiwiY2FsY0h1ZmZtYW5Db2RlIiwiY2QiLCJzdGFydCIsInN0ckNvcHkiLCJzZWxlY3QiLCJzMSIsInMyIiwiQVRPTSIsIkxJU1QiLCJHTE5vZGUiLCJ0YWciLCJ1bmRlZmluZWQiLCJhdG9tIiwicHRyIiwiaHAiLCJ0cCIsImRlcHRoIiwiY29weUxpc3QiLCJnTGlzdCIsImNyZWF0ZUdMaXN0Iiwic3RyaW5nIiwidHJpbSIsImlzV29yZCIsInN1YiIsInN1YnN0ciIsImhzdWIiLCJjaCIsImVxdWFsIiwiZ0xpc3QxIiwiZ0xpc3QyIiwiY2FsbCIsIm9yZGVyUHJpbnQiLCJHTE5vZGUyIiwiTVBOb2RlIiwiZXhwIiwiY29lZiIsIlVOVklTSVRFRCIsIlZJU0lURUQiLCJFQm94IiwibWFyayIsIml2ZXgiLCJqdmV4IiwiaWxpbmsiLCJqbGluayIsImluZm8iLCJBTUxWZXhCb3giLCJmaXJzdEVkZ2UiLCJBTUxHcmFwaCIsImFkak11bGlzdCIsInZleG51bSIsImVkZ2VudW0iLCJsb2NhdGVWZXgiLCJ2IiwiZGVsZXRlQXJjIiwidyIsImNyZWF0ZUdyYXBoIiwicHJvbXB0IiwidCIsImVycm9yIiwiREciLCJETiIsIlVERyIsIlVETiIsIkFyY05vZGUiLCJhZGpWZXgiLCJuZXh0QXJjIiwiVmV4Tm9kZSIsImZpcnN0QXJjIiwiaW5kZWdyZWUiLCJBZGphY2VuY3lMaXN0R3JhcGgiLCJ2ZXJ0aWNlcyIsImFyY251bSIsImtpbmQiLCJ2cCIsImFkZFZlcnRleCIsImFkZEFyYyIsImFyYzEiLCJhcmMyIiwiaW5jSW5mbyIsImFsZXJ0IiwiaXNQYXNzIiwieSIsInoiLCJpc0FkaiIsImV4aXN0UGF0aERGUyIsInZpc2l0ZWQiLCJleGlzdF9wYXRoIiwiZ3JhcGgiLCJleGlzdFBhdGhCRlMiLCJ1IiwiZXhpc3RQYXRoTGVuIiwibCIsImZpbmRBbGxQYXRocyIsImdldFBhdGhOdW1fbGVuIiwic3VtIiwiZ2V0Um9vdCIsImRmcyIsImdldExvbmdlc3RQYXRoIiwibWxwIiwibWF4TGVuIiwiY291bnRJbmRlZ3JlZSIsImpvaW4iLCJERlNUcmF2ZXJzZSIsInZpc2l0Rm4iLCJERlNUcmF2ZXJzZV9Ob25SZWN1cnNlIiwiQkZTVHJhdmVyc2UiLCJjcmVhdGVERlNGb3Jlc3QiLCJERlNUcmVlIiwiZmlyc3QiLCJjcmVhdGVCRlNGb3Jlc3QiLCJwcmUiLCJub2RlMiIsImZpbmRBcnRpY3VsIiwiREZTQXJ0aWN1bCIsInYwIiwidG9wb2xvZ2ljU29ydCIsInRvcG9sb2dpY2FsT3JkZXIiLCJjcml0aWNhbFBhdGgiLCJ2ZSIsInZsIiwic2hvcnRlc3RQYXRoX0RpamtzdHJhIiwiZGlzdCIsImZpbmFsIiwiYWRqTGlzdEdyYXBoIiwiZyIsImcyIiwiYXJ0aWN1bFRlc3QiLCJ0b3BvbG9naWNUZXN0IiwiY3JpdGljYWxQYXRoVGVzdCIsImRpalRlc3QiLCJuaUJvTGFuX0RBRyIsInByaW50TmlCb0xhbiIsImV2YWx1YXRlX0RBRyIsImV2YWx1YXRlX2ltcCIsInYxIiwidjIiLCJjYWxjdWxhdGUiLCJvcGVyYXRpb24iLCJldmFsIiwiZGFnIiwiU3RyaW5nIiwiYTMiLCJhNCIsImE1IiwiYTYiLCJhNyIsIkFyY0NlbGwiLCJhZGoiLCJBZGphY2VuY3lNYXRyaXhHcmFwaCIsInZleHMiLCJhcmNzIiwiY3JlYXRlREciLCJjcmVhdGVETiIsImNyZWF0ZVVERyIsImNyZWF0ZVVETiIsInZleDEiLCJ2ZXgyIiwiYXJjIiwiZGVsZXRlVmV4IiwidmV4IiwiZmlyc3RBZGpWZXgiLCJuZXh0QWRqVmV4IiwidmVydGV4IiwibWluU3BhblRyZWVfUFJJTSIsImNsb3NlZGdlIiwiYWRqdmV4IiwibG93Y29zdCIsInRlIiwibWluU3BhblRyZWVfS3J1c2thbCIsInNldCIsInNob3J0ZXN0UGF0aF9GTE9ZRCIsInBybl9wYXNzIiwic2V0TWF0cml4VmFsdWUiLCJwYXJzZUludCIsInVkbiIsImRuIiwiZzEiLCJic2ZHIiwiZmxveWQiLCJPTEdyYXBoIiwiQXJjQm94IiwidGFpbFZleCIsImhlYWRWZXgiLCJoTGluayIsInRMaW5rIiwiT0xWZXhOb2RlIiwiZmlyc3RJbiIsImZpcnN0T3V0IiwieExpc3QiLCJwcm90b3R5cGUiLCJkZWxldGVWZXJ0ZXgiLCJnZXRTR3JhcGgiLCJmaW5pc2hlZCIsImRmczEiLCJkZnMyIiwiY29ubmVjdGVkX0RHIiwiaW5fb3JkZXIiLCJyZXZfZGZzIiwiTElNSVQiLCJMUlVDYWNoZSIsImxpbWl0Iiwic2xpY2UiLCJfX2NhY2hlIiwiX19fY2FjaGUiLCJnZXQiLCJ1bmlvbiIsImRlbCIsImxpc3RDb21wIiwiaW50ZXJzZWN0IiwiaW50ZXJzZWN0X3RydWUiLCJpbnRlcnNlY3RfZGVsZXRlIiwiYkxlbiIsImFMZW4iLCJhRWxlbSIsImJFbGVtIiwiYUxpc3QiLCJiTGlzdCIsImNMaXN0Iiwic3BsaWNlIiwic2FtZSIsIkN5Y2xlUXVldWUiLCJtYXhzaXplIiwiYmFzZSIsIk1BWFFTSVpFIiwicXVldWVUcmF2ZXJzZSIsIlByaW9yaXR5UXVldWUiLCJwcmlvcml0eSIsIm9iaiIsIm9iamVjdCIsImxlZnQiLCJyaWdodCIsIkF2bFRyZWUiLCJyb290IiwiX2FkZExlZnQiLCJfYWRkUmlnaHQiLCJuZXdOb2RlIiwiX2JhbGFuY2UiLCJfYmFsYW5jZUxlZnRSaWdodCIsImxlZnRMZWZ0IiwiX2JhbGFuY2VMZWZ0TGVmdCIsIl9iYWxhbmNlUmlnaHRMZWZ0IiwicmlnaHRSaWdodCIsIl9iYWxhbmNlUmlnaHRSaWdodCIsImxlZnRIZWlnaHQiLCJyaWdodEhlaWdodCIsIm5ld0hlaWdodCIsIl9yZW1vdmUiLCJyZXBsYWNlbWVudCIsImJhbGFuY2VGcm9tIiwicmVtb3ZlQnlSZWYiLCJnZXRGaXJzdCIsImdldExhc3QiLCJnZXRIZWlnaHQiLCJnZXRDb3VudCIsInByb2Nlc3NpbmdGdW5jIiwicGFyYW1zIiwiZm9yRWFjaFJldmVyc2UiLCJtb2R1bGUiLCJleHBvcnRzIiwiaXNEZWZpbmVkIiwib3B0aW9ucyIsIm9yZGVyIiwibWVyZ2VUaHJlc2hvbGQiLCJnZXRMZWZ0UGVlciIsImxlZnRQZWVyIiwic2V0TGVmdFBlZXIiLCJnZXRSaWdodFBlZXIiLCJyaWdodFBlZXIiLCJzZXRSaWdodFBlZXIiLCJnZXREYXRhIiwiZ2V0U3VycGx1cyIsImdldFJpZ2h0U3VycGx1c0RhdGEiLCJzdXJwbHVzIiwiZ2V0TGVmdFN1cnBsdXNEYXRhIiwiSW50ZXJuYWxOb2RlIiwiT2JqZWN0IiwiZmluZEluZGV4IiwibWlkIiwiZmluZENoaWxkIiwiZWxlbWVudCIsImNsb2JiZXIiLCJuZXdOb2RlcyIsImxlZnRFbGVtZW50IiwicmlnaHRFbGVtZW50Iiwic3BsaXRJbmRleCIsImxlZnROb2RlIiwicmlnaHROb2RlIiwibGVmdE1lcmdlT3B0aW9uIiwicmlnaHRNZXJnZU9wdGlvbiIsIm1lcmdlSW5kZXgiLCJyZXR2YWwiLCJtZXJnZUVsZW1lbnQiLCJjb25jYXQiLCJsZWZ0U3VycGx1cyIsImxlZnREYXRhIiwicmlnaHRTdXJwbHVzIiwicmlnaHREYXRhIiwibGVmdFN1cnBsdXNEYXRhIiwicmlnaHRTdXJwbHVzRGF0YSIsIm1lcmdlZEludGVybmFsTm9kZSIsInJhbmdlIiwiZW5kIiwiaW5kZW50IiwibWFwIiwiTGVhZk5vZGUiLCJtZXJnZWRMZWFmTm9kZSIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsIm5vZGVEYXRhIiwiVHJlZSIsImRlZmluZSIsInZhcl9hcmdzIiwiYXJndW1lbnRzIiwiQXJyYXkiLCJhcHBseSIsImFzZWFyY2giLCJidHJlZSIsInN0cmNtcCIsImFjIiwiYmMiLCJjaGFyQ29kZUF0IiwibnVtY21wIiwiaW50Y21wIiwibWluT3JkZXIiLCJ2YWxpZGF0ZSIsImxlYXZlcyIsIlRyZWVOb2RlIiwibGVhZiIsInJlc3VsdCIsInB1dCIsIm92ZXJ3cml0ZSIsIkxlYWYiLCJiYWxhbmNlIiwic2VwIiwicmVzdCIsInN1YnN0IiwidW5zcGxpdCIsImluY2x1ZGVOb2RlcyIsInZhbCIsInNwYWNlIiwid2Fsa0FzYyIsIm1pbktleSIsIm1heEtleSIsIndhbGsiLCJ3YWxrRGVzYyIsImJpbmFyeVNlYXJjaCIsImJpbmFyeVNlYXJjaFJlY3Vyc2l2ZSIsInNUYWJsZSIsIkxOMl9TUVVBUkVEIiwiTE4yIiwiQmxvb21GaWx0ZXIiLCJzZWVkcyIsImhhc2hlcyIsIl9nZW5lcmF0ZVNlZWRzIiwiYml0cyIsImJ1ZmZlciIsIkJ1ZmZlciIsImFsbG9jIiwib3B0aW1pemUiLCJpdGVtQ291bnQiLCJlcnJvclJhdGUiLCJyb3VuZCIsImNyZWF0ZU9wdGltYWwiLCJvcHRzIiwiZmlsbCIsImJ1ZiIsInJlYWRVSW50MzJMRSIsImlzQXJyYXkiLCJmcm9tIiwiaGFzaCIsImJpdCIsIl9zZXRCaXQiLCJoYXMiLCJpc0luU2V0IiwiX2dldEJpdCIsImJpdEZpZWxkIiwiZmlsdGVyIiwiQ291bnRpbmdCbG9vbUZpbHRlciIsIm92ZXJmbG93IiwiX3VuU2V0Qml0IiwiaXNCdWZmZXIiLCJMRUFGIiwiQlJBTkNIIiwiVEVSTUlOQUwiLCJEb3VibGVMaW5rZWRUcmVlIiwic3ltYm9sIiwic3lub1NlYXJjaCIsInN1Y2Nlc3MiLCJ0b0xvd2VyQ2FzZSIsInJlbW92ZU5vZGUiLCJ0cmllTm9kZSIsImJyYW5jaCIsIm51bSIsImhhc093blByb3BlcnR5IiwicGFyZW50Tm9kZXMiLCJUcmllVHJlZSIsImhhc2hTaXplIiwiYnVpbGRIYXNoU2l6ZSIsIkhhc2hUYWJsZSIsInNpemVJbmRleCIsImNvbGxpc2lvbiIsImNvbGxpc2lvblRpbWVzIiwiZXJyb3Jtc2ciLCJyZWNyZWF0ZUhhc2hUYWJsZSIsImFicyIsInRpbWVzIiwiaXNQcmltZSIsImJlZ2luIiwiTGlua2VkTGlzdEhhc2hUYWJsZSIsImhOb2RlcyIsInRlc3QyIiwiQkxBQ0siLCJSZWRCbGFja05vZGUiLCJjb2xvciIsIlJlZEJsYWNrTGVhZiIsIlJlZEJsYWNrVHJlZSIsIm5pbCIsIl9hZGRGaXh1cCIsImxlZnRBZGRGaXh1cCIsInJpZ2h0QWRkRml4dXAiLCJzdWNjZXNzb3IiLCJfcmVtb3ZlRml4dXAiLCJyZW1vdmVOb2RlMiIsIm9yaWdpbmFsWUNvbG9yIiwiX3RyYW5zcGxhbnQiLCJsZWZ0UmVtb3ZlRml4dXAiLCJyaWdodFJlbW92ZUZpeHVwIiwiX3JvdGF0ZUxlZnQiLCJyb3RhdGUiLCJfcm90YXRlUmlnaHQiLCJkaXIiLCJjMSIsImMyIiwiYWRkRml4dXAiLCJyb3RhdGUxIiwicm90YXRlMiIsInJlbW92ZUZpeHVwIiwicjEiLCJyMiIsInNlY29uZE9wdGltYWwiLCJjcmVhdGVTT1NUcmVlIiwic1dlaWdodHMiLCJkdyIsImVsZW1zIiwic3ciLCJmaW5kU1ciLCJzb3NUcmVlIiwic3VmZml4Tm9kZSIsIkVkZ2UiLCJmaXJzdENoYXJJbmRleCIsImxhc3RDaGFySW5kZXgiLCJzb3VyY2VOb2RlSW5kZXgiLCJkZXN0Tm9kZUluZGV4IiwiU3VmZml4IiwiU3VmZml4VHJlZSIsImNhc2VJbnNlbnNpdGl2ZSIsIk4iLCJlZGdlcyIsImFjdGl2ZSIsImFkZFByZWZpeCIsImN1cnJlbnRJbmRleCIsInZhbHVlcyIsInNvcnQiLCJlZGdlIiwic3Vic3RyaW5nIiwibGFzdFBhcmVudE5vZGUiLCJlIiwiZXhwbGljaXQiLCJfc3BsaXRFZGdlIiwiX2luc2VydEVkZ2UiLCJfY2Fub25pemVTdWZmaXgiLCJfcmVtb3ZlRWRnZSIsInN1ZmZpeCIsImN1cnJlbnROb2RlIiwibG4iLCJ0cmVlMiIsInRyZWUzIiwiZmlib25hY2NpU2VhcmNoIiwiZmliIiwiZjAiLCJmMSIsImYyIiwic2VxdWVudGlhbFNlYXJjaCIsImNvdW50U29ydCIsInJhZGl4U29ydCIsIm1heEVsZW0iLCJtYXhCaXQiLCJyYWRpeCIsIkJVQ0tFVFNOVU0iLCJidWNrZXRTb3J0IiwiYnVja2V0QSIsImJ1Y2tldCIsInN0cmFpZ2h0SW5zZXJ0U29ydCIsImJpbmFyeUluc2VydFNvcnQiLCJwYXRoMkluc2VydFNvcnQiLCJzdGF0aWNMaW5rZWRMaXN0SW5zZXJ0U29ydCIsInNoZWxsU29ydCIsImFycmFuZ2UiLCJzaGVsbEluc2VydCIsImRrIiwiZGVsdGEiLCJjcmVhdGVEZWx0YSIsInBvdyIsIm1lcmdlU29ydFJlY3Vyc2l2ZSIsIm1lcmdlU29ydE5vblJlY3Vyc2l2ZSIsIm5hdHVyZU1lcmdlU29ydCIsIm5Db3VudCIsIm5vblJlY3Vyc2l2ZUNvdW50IiwicmVjdXJzaXZlQ291bnQiLCJzciIsImUxIiwiZTIiLCJwYXNzIiwicmVjIiwibmF0dXJhbE1lcmdlU29ydCIsIm1lcmdlUnVucyIsImFzYyIsImxpbmtlZExpc3ROYXR1cmFsTWVyZ2VTb3J0IiwibWVyZ2VTb3J0IiwibGlua2VkbGlzdCIsIm5lZWRSZXBsYWNlIiwibGlua2VkTGlzdCIsInNpbXBsZVNlbGVjdGlvblNvcnQiLCJoZWFwU29ydCIsImhlYXBBZGp1c3QiLCJyYyIsIkhTdHJpbmciLCJzdHJJbnNlcnQiLCJwb3NpdGlvbiIsInRIU3RyaW5nIiwic3RyaW5nQ29weSIsInN0ckFzc2lnbiIsImNoYXJzIiwic3RyTGVuZ3RoIiwic3RyQ29tcGFyZSIsImNsZWFyU3RyaW5nIiwiZGVzdGluYXRpb24iLCJkZXN0U3RhcnQiLCJ0YXJnZXRTdGFydCIsIkNodW5rIiwiY2h1bmtTaXplIiwiTFN0cmluZyIsInRMU3RyaW5nIiwiY3VyVCIsInRMU3RpbmciLCJjb3B5U3RyaW5nIiwiZmluZFBvc0NodW5rIiwiY3VyUyIsIm91dGVybG9vcCIsImxTdHJpbmciLCJjdXJEIiwiY3VyclQiLCJvZmZzZXQiLCJwYWxpbmRyb21lIiwibFN0ciIsIlNTdHJpbmciLCJNQVhTVFJMRU4iLCJjb3B5U3RyMlQiLCJyZXBsYWNlIiwic3N0cmluZyIsImttcEluZGV4IiwiZ2V0TmV4dCIsInN1YnRyYWN0IiwiZGVsZXRlX3N1YnN0cmluZyIsInJlcXVpcmUiLCJkZWZhdWx0IiwiQmluYXJ5VHJlZUFycmF5IiwiR2VuZXJhbGl6ZWRMaXN0IiwiR3JhcGgiLCJMaXN0IiwiTGluZWFyTGlzdCIsIlNlYXJjaCIsIkFWTFRyZWUiLCJCaW5hcnlTb3J0ZWRUcmVlIiwiQlBsdXNUcmVlIiwiQlRyZWUiLCJEaWdpdGFsU2VhcmNoVHJlZSIsIlNPU1RyZWUiLCJTb3J0IiwiZGlzdHJpYnV0aW9uIiwiZXhjaGFuZ2UiLCJpbnNlcnRpb24iLCJtZXJnaW5nIiwic2VsZWN0aW9uIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBMkMsY0FBYzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFBbUQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQzV2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdEJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDUkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7O0FBRUEsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTs7QUFFQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjs7QUFFQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLG1DQUFtQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGdDQUFnQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7QUNsMkdEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ1pBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHOzs7Ozs7QUMxQkQ7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdDOzs7Ozs7QUNIdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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OztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFF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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEU7Ozs7OztBQ05BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7QUNKQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNILG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDekdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEU7Ozs7Ozs7QUNoQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRTs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OzhDQ3ZDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsQzs7Ozs7OztBQ3JMQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxhQUFhO0FBQ2hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7O0FDdGlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOzs7Ozs7O0FDbEJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNuVUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQzs7QUFF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QUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2hCQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDUEEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsRTs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDTkE7QUFD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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxhQUFhO0FBQ2hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLDZFQUE2RTtBQUN4SjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsbURBQW1ELGlFQUFpRTtBQUNwSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7OztBQzU2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsUUFBUTtBQUN6QixRQUFRLFFBQVE7O0FBRWhCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNySUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNsUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN6bkJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7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QUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdkJBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtB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QUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFD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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ3REQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEIsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBOzs7Ozs7O0FDL1BBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7Ozs7OztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7QUNqQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0WEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ2hiQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLHVDQUF1QztBQUN2QyxlQUFlOztBQUVmLHFCQUFxQixpQkFBaUI7QUFDdEM7O0FBRUEsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDbkxBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssZUFBZTtBQUNwQixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDejZCQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUM1TUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQiwyQ0FBMkM7QUFDckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZOztBQUVaLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdEhBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0SUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCLFVBQVUscUJBQXFCO0FBQy9CLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQ0FBaUM7QUFDOUQ7O0FBRUE7QUFDQSxVQUFVLE1BQU07QUFDaEIsVUFBVSx1QkFBdUI7QUFDakMsVUFBVSwyQkFBMkI7QUFDckMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ3JIQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCLFVBQVUsT0FBTztBQUNqQjtBQUNBLFVBQVUsWUFBWTtBQUN0QixVQUFVLE1BQU07QUFDaEIsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUMvRkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCLFVBQVUsb0JBQW9CO0FBQzlCLFVBQVUsbUJBQW1CO0FBQzdCLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsYUFBYTtBQUN2QixVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzN3QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFOzs7Ozs7QUN6SEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDMUZBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5Qzs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQy9DQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQy9JQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxRQUFRLGNBQWM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLFFBQVEsY0FBYztBQUN0Qiw4Q0FBOEM7QUFDOUM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekI7O0FBRUEsT0FBTyxjQUFjO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaFFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsUUFBUSxVQUFVOztBQUVsQjtBQUNBOzs7Ozs7OztBQ2xGQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FDekhEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTs7Ozs7OztBQ2pCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7OztBQzlGQTs7Ozs7Ozs7QUNBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDL0RBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBLG1DQUFrQztBQUNsQyxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTs7Ozs7OztBQ0FBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtB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S0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUN6TEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsUUFBUTtBQUN6QixRQUFRLFFBQVE7O0FBRWhCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsUUFBUTtBQUN6QixRQUFRLFFBQVE7O0FBRWhCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDbkRBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDdkRBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkRBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIs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O0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDcFlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDM2JBLGU7Ozs7OztBQ0FBLGUiLCJmaWxlIjoiLi9EUy1kZWJ1Zy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkRTXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkRTXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTU2KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAwZWI0NGY3NDNkN2M1N2EwNDhlYSIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idWZmZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVXRpbHNcbiAgZnVuY3Rpb24gYXNzZXJ0ICh2YWwsIG1zZykge1xuICAgIGlmICghdmFsKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cblxuICAvLyBDb3VsZCB1c2UgYGluaGVyaXRzYCBtb2R1bGUsIGJ1dCBkb24ndCB3YW50IHRvIG1vdmUgZnJvbSBzaW5nbGUgZmlsZVxuICAvLyBhcmNoaXRlY3R1cmUgeWV0LlxuICBmdW5jdGlvbiBpbmhlcml0cyAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgfVxuXG4gIC8vIEJOXG5cbiAgZnVuY3Rpb24gQk4gKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKEJOLmlzQk4obnVtYmVyKSkge1xuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB0aGlzLndvcmRzID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBSZWR1Y3Rpb24gY29udGV4dFxuICAgIHRoaXMucmVkID0gbnVsbDtcblxuICAgIGlmIChudW1iZXIgIT09IG51bGwpIHtcbiAgICAgIGlmIChiYXNlID09PSAnbGUnIHx8IGJhc2UgPT09ICdiZScpIHtcbiAgICAgICAgZW5kaWFuID0gYmFzZTtcbiAgICAgICAgYmFzZSA9IDEwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0KG51bWJlciB8fCAwLCBiYXNlIHx8IDEwLCBlbmRpYW4gfHwgJ2JlJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gQk47XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CTiA9IEJOO1xuICB9XG5cbiAgQk4uQk4gPSBCTjtcbiAgQk4ud29yZFNpemUgPSAyNjtcblxuICB2YXIgQnVmZmVyO1xuICB0cnkge1xuICAgIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZicgKyAnZmVyJykuQnVmZmVyO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cblxuICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnICYmXG4gICAgICBudW0uY29uc3RydWN0b3Iud29yZFNpemUgPT09IEJOLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkobnVtLndvcmRzKTtcbiAgfTtcblxuICBCTi5tYXggPSBmdW5jdGlvbiBtYXggKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA+IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5taW4gPSBmdW5jdGlvbiBtaW4gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBiYXNlID0gMTY7XG4gICAgfVxuICAgIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuICAgIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAxNikge1xuICAgICAgdGhpcy5fcGFyc2VIZXgobnVtYmVyLCBzdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhcnNlQmFzZShudW1iZXIsIGJhc2UsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuc3RyaXAoKTtcblxuICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXROdW1iZXIgPSBmdW5jdGlvbiBfaW5pdE51bWJlciAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICBudW1iZXIgPSAtbnVtYmVyO1xuICAgIH1cbiAgICBpZiAobnVtYmVyIDwgMHg0MDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWyBudW1iZXIgJiAweDNmZmZmZmYgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmZcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxuICAgICAgICAxXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAzO1xuICAgIH1cblxuICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuICAgIC8vIFJldmVyc2UgdGhlIGJ5dGVzXG4gICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24gX2luaXRBcnJheSAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICAvLyBQZXJoYXBzIGEgVWludDhBcnJheVxuICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuICAgIGlmIChudW1iZXIubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbIDAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBqLCB3O1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgKyAxXSA8PCA4KSB8IChudW1iZXJbaSArIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlSGV4IChzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgICAgciA8PD0gNDtcblxuICAgICAgLy8gJ2EnIC0gJ2YnXG4gICAgICBpZiAoYyA+PSA0OSAmJiBjIDw9IDU0KSB7XG4gICAgICAgIHIgfD0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQScgLSAnRidcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNyAmJiBjIDw9IDIyKSB7XG4gICAgICAgIHIgfD0gYyAtIDE3ICsgMHhhO1xuXG4gICAgICAvLyAnMCcgLSAnOSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgfD0gYyAmIDB4ZjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4IChudW1iZXIsIHN0YXJ0KSB7XG4gICAgLy8gQ3JlYXRlIHBvc3NpYmx5IGJpZ2dlciBhcnJheSB0byBlbnN1cmUgdGhhdCBpdCBmaXRzIHRoZSBudW1iZXJcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGosIHc7XG4gICAgLy8gU2NhbiAyNC1iaXQgY2h1bmtzIGFuZCBhZGQgdGhlbSB0byB0aGUgbnVtYmVyXG4gICAgdmFyIG9mZiA9IDA7XG4gICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDYsIGogPSAwOyBpID49IHN0YXJ0OyBpIC09IDYpIHtcbiAgICAgIHcgPSBwYXJzZUhleChudW1iZXIsIGksIGkgKyA2KTtcbiAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgIC8vIE5PVEU6IGAweDNmZmZmZmAgaXMgaW50ZW50aW9uYWwgaGVyZSwgMjZiaXRzIG1heCBzaGlmdCArIDI0Yml0IGhleCBsaW1iXG4gICAgICB0aGlzLndvcmRzW2ogKyAxXSB8PSB3ID4+PiAoMjYgLSBvZmYpICYgMHgzZmZmZmY7XG4gICAgICBvZmYgKz0gMjQ7XG4gICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSArIDYgIT09IHN0YXJ0KSB7XG4gICAgICB3ID0gcGFyc2VIZXgobnVtYmVyLCBzdGFydCwgaSArIDYpO1xuICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuICAgIH1cbiAgICB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VCYXNlIChzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByICo9IG11bDtcblxuICAgICAgLy8gJ2EnXG4gICAgICBpZiAoYyA+PSA0OSkge1xuICAgICAgICByICs9IGMgLSA0OSArIDB4YTtcblxuICAgICAgLy8gJ0EnXG4gICAgICB9IGVsc2UgaWYgKGMgPj0gMTcpIHtcbiAgICAgICAgciArPSBjIC0gMTcgKyAweGE7XG5cbiAgICAgIC8vICcwJyAtICc5J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciArPSBjO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VCYXNlID0gZnVuY3Rpb24gX3BhcnNlQmFzZSAobnVtYmVyLCBiYXNlLCBzdGFydCkge1xuICAgIC8vIEluaXRpYWxpemUgYXMgemVyb1xuICAgIHRoaXMud29yZHMgPSBbIDAgXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgICAvLyBGaW5kIGxlbmd0aCBvZiBsaW1iIGluIGJhc2VcbiAgICBmb3IgKHZhciBsaW1iTGVuID0gMCwgbGltYlBvdyA9IDE7IGxpbWJQb3cgPD0gMHgzZmZmZmZmOyBsaW1iUG93ICo9IGJhc2UpIHtcbiAgICAgIGxpbWJMZW4rKztcbiAgICB9XG4gICAgbGltYkxlbi0tO1xuICAgIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuICAgIHZhciB0b3RhbCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICB2YXIgbW9kID0gdG90YWwgJSBsaW1iTGVuO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cbiAgICB2YXIgd29yZCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGxpbWJMZW4pIHtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cbiAgICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZCAhPT0gMCkge1xuICAgICAgdmFyIHBvdyA9IDE7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2Q7IGkrKykge1xuICAgICAgICBwb3cgKj0gYmFzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbXVsbihwb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRlc3QpIHtcbiAgICBkZXN0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgIH1cbiAgICBkZXN0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSB0aGlzLm5lZ2F0aXZlO1xuICAgIGRlc3QucmVkID0gdGhpcy5yZWQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciByID0gbmV3IEJOKG51bGwpO1xuICAgIHRoaXMuY29weShyKTtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uIF9leHBhbmQgKHNpemUpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBzaXplKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGxlYWRpbmcgYDBgIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdHJpcCA9IGZ1bmN0aW9uIHN0cmlwICgpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPiAxICYmIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbiAoKSB7XG4gICAgLy8gLTAgPSAwXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIHJldHVybiAodGhpcy5yZWQgPyAnPEJOLVI6ICcgOiAnPEJOOiAnKSArIHRoaXMudG9TdHJpbmcoMTYpICsgJz4nO1xuICB9O1xuXG4gIC8qXG5cbiAgdmFyIHplcm9zID0gW107XG4gIHZhciBncm91cFNpemVzID0gW107XG4gIHZhciBncm91cEJhc2VzID0gW107XG5cbiAgdmFyIHMgPSAnJztcbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IEJOLndvcmRTaXplKSB7XG4gICAgemVyb3NbaV0gPSBzO1xuICAgIHMgKz0gJzAnO1xuICB9XG4gIGdyb3VwU2l6ZXNbMF0gPSAwO1xuICBncm91cFNpemVzWzFdID0gMDtcbiAgZ3JvdXBCYXNlc1swXSA9IDA7XG4gIGdyb3VwQmFzZXNbMV0gPSAwO1xuICB2YXIgYmFzZSA9IDIgLSAxO1xuICB3aGlsZSAoKytiYXNlIDwgMzYgKyAxKSB7XG4gICAgdmFyIGdyb3VwU2l6ZSA9IDA7XG4gICAgdmFyIGdyb3VwQmFzZSA9IDE7XG4gICAgd2hpbGUgKGdyb3VwQmFzZSA8ICgxIDw8IEJOLndvcmRTaXplKSAvIGJhc2UpIHtcbiAgICAgIGdyb3VwQmFzZSAqPSBiYXNlO1xuICAgICAgZ3JvdXBTaXplICs9IDE7XG4gICAgfVxuICAgIGdyb3VwU2l6ZXNbYmFzZV0gPSBncm91cFNpemU7XG4gICAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcbiAgfVxuXG4gICovXG5cbiAgdmFyIHplcm9zID0gW1xuICAgICcnLFxuICAgICcwJyxcbiAgICAnMDAnLFxuICAgICcwMDAnLFxuICAgICcwMDAwJyxcbiAgICAnMDAwMDAnLFxuICAgICcwMDAwMDAnLFxuICAgICcwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICBdO1xuXG4gIHZhciBncm91cFNpemVzID0gW1xuICAgIDAsIDAsXG4gICAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxuICAgIDgsIDcsIDcsIDcsIDcsIDYsIDYsXG4gICAgNiwgNiwgNiwgNiwgNiwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDVcbiAgXTtcblxuICB2YXIgZ3JvdXBCYXNlcyA9IFtcbiAgICAwLCAwLFxuICAgIDMzNTU0NDMyLCA0MzA0NjcyMSwgMTY3NzcyMTYsIDQ4ODI4MTI1LCA2MDQ2NjE3NiwgNDAzNTM2MDcsIDE2Nzc3MjE2LFxuICAgIDQzMDQ2NzIxLCAxMDAwMDAwMCwgMTk0ODcxNzEsIDM1ODMxODA4LCA2Mjc0ODUxNywgNzUyOTUzNiwgMTEzOTA2MjUsXG4gICAgMTY3NzcyMTYsIDI0MTM3NTY5LCAzNDAxMjIyNCwgNDcwNDU4ODEsIDY0MDAwMDAwLCA0MDg0MTAxLCA1MTUzNjMyLFxuICAgIDY0MzYzNDMsIDc5NjI2MjQsIDk3NjU2MjUsIDExODgxMzc2LCAxNDM0ODkwNywgMTcyMTAzNjgsIDIwNTExMTQ5LFxuICAgIDI0MzAwMDAwLCAyODYyOTE1MSwgMzM1NTQ0MzIsIDM5MTM1MzkzLCA0NTQzNTQyNCwgNTI1MjE4NzUsIDYwNDY2MTc2XG4gIF07XG5cbiAgQk4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGJhc2UsIHBhZGRpbmcpIHtcbiAgICBiYXNlID0gYmFzZSB8fCAxMDtcbiAgICBwYWRkaW5nID0gcGFkZGluZyB8IDAgfHwgMTtcblxuICAgIHZhciBvdXQ7XG4gICAgaWYgKGJhc2UgPT09IDE2IHx8IGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG4gICAgICAgIHZhciB3b3JkID0gKCgodyA8PCBvZmYpIHwgY2FycnkpICYgMHhmZmZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgY2FycnkgPSAodyA+Pj4gKDI0IC0gb2ZmKSkgJiAweGZmZmZmZjtcbiAgICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgb2ZmICs9IDI7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgb3V0ID0gY2FycnkudG9TdHJpbmcoMTYpICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcbiAgICAgIC8vIHZhciBncm91cFNpemUgPSBNYXRoLmZsb29yKEJOLndvcmRTaXplICogTWF0aC5MTjIgLyBNYXRoLmxvZyhiYXNlKSk7XG4gICAgICB2YXIgZ3JvdXBTaXplID0gZ3JvdXBTaXplc1tiYXNlXTtcbiAgICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuICAgICAgdmFyIGdyb3VwQmFzZSA9IGdyb3VwQmFzZXNbYmFzZV07XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuICAgICAgYy5uZWdhdGl2ZSA9IDA7XG4gICAgICB3aGlsZSAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgdmFyIHIgPSBjLm1vZG4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuICAgICAgICBpZiAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1tncm91cFNpemUgLSByLmxlbmd0aF0gKyByICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHIgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGFzc2VydChmYWxzZSwgJ0Jhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzYnKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlciAoKSB7XG4gICAgdmFyIHJldCA9IHRoaXMud29yZHNbMF07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXQgKz0gdGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAzICYmIHRoaXMud29yZHNbMl0gPT09IDB4MDEpIHtcbiAgICAgIC8vIE5PVEU6IGF0IHRoaXMgc3RhZ2UgaXQgaXMga25vd24gdGhhdCB0aGUgdG9wIGJpdCBpcyBzZXRcbiAgICAgIHJldCArPSAweDEwMDAwMDAwMDAwMDAwICsgKHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLm5lZ2F0aXZlICE9PSAwKSA/IC1yZXQgOiByZXQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoMTYpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyIChlbmRpYW4sIGxlbmd0aCkge1xuICAgIGFzc2VydCh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyk7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQnVmZmVyLCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5IChlbmRpYW4sIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEFycmF5LCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24gdG9BcnJheUxpa2UgKEFycmF5VHlwZSwgZW5kaWFuLCBsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRoaXMuYnl0ZUxlbmd0aCgpO1xuICAgIHZhciByZXFMZW5ndGggPSBsZW5ndGggfHwgTWF0aC5tYXgoMSwgYnl0ZUxlbmd0aCk7XG4gICAgYXNzZXJ0KGJ5dGVMZW5ndGggPD0gcmVxTGVuZ3RoLCAnYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aCcpO1xuICAgIGFzc2VydChyZXFMZW5ndGggPiAwLCAnUmVxdWVzdGVkIGFycmF5IGxlbmd0aCA8PSAwJyk7XG5cbiAgICB0aGlzLnN0cmlwKCk7XG4gICAgdmFyIGxpdHRsZUVuZGlhbiA9IGVuZGlhbiA9PT0gJ2xlJztcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5VHlwZShyZXFMZW5ndGgpO1xuXG4gICAgdmFyIGIsIGk7XG4gICAgdmFyIHEgPSB0aGlzLmNsb25lKCk7XG4gICAgaWYgKCFsaXR0bGVFbmRpYW4pIHtcbiAgICAgIC8vIEFzc3VtZSBiaWctZW5kaWFuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcmVxTGVuZ3RoIC0gYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcbiAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICAgIHJlc1tyZXFMZW5ndGggLSBpIC0gMV0gPSBiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyAhcS5pc1plcm8oKTsgaSsrKSB7XG4gICAgICAgIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgICBxLml1c2hybig4KTtcblxuICAgICAgICByZXNbaV0gPSBiO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgaSA8IHJlcUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBpZiAoTWF0aC5jbHozMikge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih3KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgdmFyIHQgPSB3O1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgaWYgKHQgPj0gMHgxMDAwKSB7XG4gICAgICAgIHIgKz0gMTM7XG4gICAgICAgIHQgPj4+PSAxMztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4NDApIHtcbiAgICAgICAgciArPSA3O1xuICAgICAgICB0ID4+Pj0gNztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4OCkge1xuICAgICAgICByICs9IDQ7XG4gICAgICAgIHQgPj4+PSA0O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHgwMikge1xuICAgICAgICByICs9IDI7XG4gICAgICAgIHQgPj4+PSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIgKyB0O1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzICh3KSB7XG4gICAgLy8gU2hvcnQtY3V0XG4gICAgaWYgKHcgPT09IDApIHJldHVybiAyNjtcblxuICAgIHZhciB0ID0gdztcbiAgICB2YXIgciA9IDA7XG4gICAgaWYgKCh0ICYgMHgxZmZmKSA9PT0gMCkge1xuICAgICAgciArPSAxMztcbiAgICAgIHQgPj4+PSAxMztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNztcbiAgICAgIHQgPj4+PSA3O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweGYpID09PSAwKSB7XG4gICAgICByICs9IDQ7XG4gICAgICB0ID4+Pj0gNDtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgzKSA9PT0gMCkge1xuICAgICAgciArPSAyO1xuICAgICAgdCA+Pj49IDI7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MSkgPT09IDApIHtcbiAgICAgIHIrKztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG51bWJlciBvZiB1c2VkIGJpdHMgaW4gYSBCTlxuICBCTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoICgpIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG4gICAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyBoaTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0JpdEFycmF5IChudW0pIHtcbiAgICB2YXIgdyA9IG5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO1xuXG4gICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgdy5sZW5ndGg7IGJpdCsrKSB7XG4gICAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgICB3W2JpdF0gPSAobnVtLndvcmRzW29mZl0gJiAoMSA8PCB3Yml0KSkgPj4+IHdiaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cblxuICAvLyBOdW1iZXIgb2YgdHJhaWxpbmcgemVybyBiaXRzXG4gIEJOLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uIHplcm9CaXRzICgpIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIDA7XG5cbiAgICB2YXIgciA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYiA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbaV0pO1xuICAgICAgciArPSBiO1xuICAgICAgaWYgKGIgIT09IDI2KSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYml0TGVuZ3RoKCkgLyA4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24gdG9Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnMoKS5pbm90bih3aWR0aCkuaWFkZG4oMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24gZnJvbVR3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMudGVzdG4od2lkdGggLSAxKSkge1xuICAgICAgcmV0dXJuIHRoaXMubm90bih3aWR0aCkuaWFkZG4oMSkuaW5lZygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uIGlzTmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMDtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbmVnID0gZnVuY3Rpb24gaW5lZyAoKSB7XG4gICAgaWYgKCF0aGlzLmlzWmVybygpKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbiBpdW9yIChudW0pIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gfCBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdW9yKG51bSk7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW9yID0gZnVuY3Rpb24gdW9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVvcih0aGlzKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1YW5kID0gZnVuY3Rpb24gaXVhbmQgKG51bSkge1xuICAgIC8vIGIgPSBtaW4tbGVuZ3RoKG51bSwgdGhpcylcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZCAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVhbmQobnVtKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbiB1YW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1YW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1YW5kKHRoaXMpO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbiBpdXhvciAobnVtKSB7XG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuICAgIH1cblxuICAgIGlmICh0aGlzICE9PSBhKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXhvcihudW0pO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXhvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uIHV4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXV4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXV4b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gTm90IGBgdGhpc2BgIHdpdGggYGB3aWR0aGBgIGJpdHdpZHRoXG4gIEJOLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uIGlub3RuICh3aWR0aCkge1xuICAgIGFzc2VydCh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInICYmIHdpZHRoID49IDApO1xuXG4gICAgdmFyIGJ5dGVzTmVlZGVkID0gTWF0aC5jZWlsKHdpZHRoIC8gMjYpIHwgMDtcbiAgICB2YXIgYml0c0xlZnQgPSB3aWR0aCAlIDI2O1xuXG4gICAgLy8gRXh0ZW5kIHRoZSBidWZmZXIgd2l0aCBsZWFkaW5nIHplcm9lc1xuICAgIHRoaXMuX2V4cGFuZChieXRlc05lZWRlZCk7XG5cbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICBieXRlc05lZWRlZC0tO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBjb21wbGV0ZSB3b3Jkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXNOZWVkZWQ7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgcmVzaWR1ZVxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmICgweDNmZmZmZmYgPj4gKDI2IC0gYml0c0xlZnQpKTtcbiAgICB9XG5cbiAgICAvLyBBbmQgcmVtb3ZlIGxlYWRpbmcgemVyb2VzXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubm90biA9IGZ1bmN0aW9uIG5vdG4gKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCk7XG4gIH07XG5cbiAgLy8gU2V0IGBiaXRgIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4gKGJpdCwgdmFsKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblxuICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgdGhpcy5fZXhwYW5kKG9mZiArIDEpO1xuXG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSAmIH4oMSA8PCB3Yml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChudW0pIHtcbiAgICB2YXIgcjtcblxuICAgIC8vIG5lZ2F0aXZlICsgcG9zaXRpdmVcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cbiAgICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChudW0pIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IHRoaXMuc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmIChudW0ubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSBudW0uc3ViKHRoaXMpO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZChudW0pO1xuXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChudW0pIHtcbiAgICAvLyB0aGlzIC0gKC1udW0pID0gdGhpcyArIG51bVxuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZChudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmVcbiAgICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuICAgIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gYSA+IGJcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoY21wID4gMCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApIC0gKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcbiAgICBpZiAoY2FycnkgPT09IDAgJiYgaSA8IGEubGVuZ3RoICYmIGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuICAgIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNtYWxsTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICB2YXIgbGVuID0gKHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aCkgfCAwO1xuICAgIG91dC5sZW5ndGggPSBsZW47XG4gICAgbGVuID0gKGxlbiAtIDEpIHwgMDtcblxuICAgIC8vIFBlZWwgb25lIGl0ZXJhdGlvbiAoY29tcGlsZXIgY2FuJ3QgZG8gaXQsIGJlY2F1c2Ugb2YgY29kZSBjb21wbGV4aXR5KVxuICAgIHZhciBhID0gc2VsZi53b3Jkc1swXSB8IDA7XG4gICAgdmFyIGIgPSBudW0ud29yZHNbMF0gfCAwO1xuICAgIHZhciByID0gYSAqIGI7XG5cbiAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgIHZhciBjYXJyeSA9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgb3V0LndvcmRzWzBdID0gbG87XG5cbiAgICBmb3IgKHZhciBrID0gMTsgayA8IGxlbjsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGNhcnJ5ID4+PiAyNjtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gKGsgLSBqKSB8IDA7XG4gICAgICAgIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHIgPSBhICogYiArIHJ3b3JkO1xuICAgICAgICBuY2FycnkgKz0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgICAgcndvcmQgPSByICYgMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQgfCAwO1xuICAgICAgY2FycnkgPSBuY2FycnkgfCAwO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5IHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfVxuXG4gIC8vIFRPRE8oaW5kdXRueSk6IGl0IG1heSBiZSByZWFzb25hYmxlIHRvIG9taXQgaXQgZm9yIHVzZXJzIHdobyBkb24ndCBuZWVkXG4gIC8vIHRvIHdvcmsgd2l0aCAyNTYtYml0IG51bWJlcnMsIG90aGVyd2lzZSBpdCBnaXZlcyAyMCUgaW1wcm92ZW1lbnQgZm9yIDI1Ni1iaXRcbiAgLy8gbXVsdGlwbGljYXRpb24gKGxpa2UgZWxsaXB0aWMgc2VjcDI1NmsxKS5cbiAgdmFyIGNvbWIxME11bFRvID0gZnVuY3Rpb24gY29tYjEwTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGEgPSBzZWxmLndvcmRzO1xuICAgIHZhciBiID0gbnVtLndvcmRzO1xuICAgIHZhciBvID0gb3V0LndvcmRzO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgbG87XG4gICAgdmFyIG1pZDtcbiAgICB2YXIgaGk7XG4gICAgdmFyIGEwID0gYVswXSB8IDA7XG4gICAgdmFyIGFsMCA9IGEwICYgMHgxZmZmO1xuICAgIHZhciBhaDAgPSBhMCA+Pj4gMTM7XG4gICAgdmFyIGExID0gYVsxXSB8IDA7XG4gICAgdmFyIGFsMSA9IGExICYgMHgxZmZmO1xuICAgIHZhciBhaDEgPSBhMSA+Pj4gMTM7XG4gICAgdmFyIGEyID0gYVsyXSB8IDA7XG4gICAgdmFyIGFsMiA9IGEyICYgMHgxZmZmO1xuICAgIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG4gICAgdmFyIGEzID0gYVszXSB8IDA7XG4gICAgdmFyIGFsMyA9IGEzICYgMHgxZmZmO1xuICAgIHZhciBhaDMgPSBhMyA+Pj4gMTM7XG4gICAgdmFyIGE0ID0gYVs0XSB8IDA7XG4gICAgdmFyIGFsNCA9IGE0ICYgMHgxZmZmO1xuICAgIHZhciBhaDQgPSBhNCA+Pj4gMTM7XG4gICAgdmFyIGE1ID0gYVs1XSB8IDA7XG4gICAgdmFyIGFsNSA9IGE1ICYgMHgxZmZmO1xuICAgIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG4gICAgdmFyIGE2ID0gYVs2XSB8IDA7XG4gICAgdmFyIGFsNiA9IGE2ICYgMHgxZmZmO1xuICAgIHZhciBhaDYgPSBhNiA+Pj4gMTM7XG4gICAgdmFyIGE3ID0gYVs3XSB8IDA7XG4gICAgdmFyIGFsNyA9IGE3ICYgMHgxZmZmO1xuICAgIHZhciBhaDcgPSBhNyA+Pj4gMTM7XG4gICAgdmFyIGE4ID0gYVs4XSB8IDA7XG4gICAgdmFyIGFsOCA9IGE4ICYgMHgxZmZmO1xuICAgIHZhciBhaDggPSBhOCA+Pj4gMTM7XG4gICAgdmFyIGE5ID0gYVs5XSB8IDA7XG4gICAgdmFyIGFsOSA9IGE5ICYgMHgxZmZmO1xuICAgIHZhciBhaDkgPSBhOSA+Pj4gMTM7XG4gICAgdmFyIGIwID0gYlswXSB8IDA7XG4gICAgdmFyIGJsMCA9IGIwICYgMHgxZmZmO1xuICAgIHZhciBiaDAgPSBiMCA+Pj4gMTM7XG4gICAgdmFyIGIxID0gYlsxXSB8IDA7XG4gICAgdmFyIGJsMSA9IGIxICYgMHgxZmZmO1xuICAgIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG4gICAgdmFyIGIyID0gYlsyXSB8IDA7XG4gICAgdmFyIGJsMiA9IGIyICYgMHgxZmZmO1xuICAgIHZhciBiaDIgPSBiMiA+Pj4gMTM7XG4gICAgdmFyIGIzID0gYlszXSB8IDA7XG4gICAgdmFyIGJsMyA9IGIzICYgMHgxZmZmO1xuICAgIHZhciBiaDMgPSBiMyA+Pj4gMTM7XG4gICAgdmFyIGI0ID0gYls0XSB8IDA7XG4gICAgdmFyIGJsNCA9IGI0ICYgMHgxZmZmO1xuICAgIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG4gICAgdmFyIGI1ID0gYls1XSB8IDA7XG4gICAgdmFyIGJsNSA9IGI1ICYgMHgxZmZmO1xuICAgIHZhciBiaDUgPSBiNSA+Pj4gMTM7XG4gICAgdmFyIGI2ID0gYls2XSB8IDA7XG4gICAgdmFyIGJsNiA9IGI2ICYgMHgxZmZmO1xuICAgIHZhciBiaDYgPSBiNiA+Pj4gMTM7XG4gICAgdmFyIGI3ID0gYls3XSB8IDA7XG4gICAgdmFyIGJsNyA9IGI3ICYgMHgxZmZmO1xuICAgIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG4gICAgdmFyIGI4ID0gYls4XSB8IDA7XG4gICAgdmFyIGJsOCA9IGI4ICYgMHgxZmZmO1xuICAgIHZhciBiaDggPSBiOCA+Pj4gMTM7XG4gICAgdmFyIGI5ID0gYls5XSB8IDA7XG4gICAgdmFyIGJsOSA9IGI5ICYgMHgxZmZmO1xuICAgIHZhciBiaDkgPSBiOSA+Pj4gMTM7XG5cbiAgICBvdXQubmVnYXRpdmUgPSBzZWxmLm5lZ2F0aXZlIF4gbnVtLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSAxOTtcbiAgICAvKiBrID0gMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDApO1xuICAgIHZhciB3MCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzAgPj4+IDI2KSkgfCAwO1xuICAgIHcwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMSkpIHwgMDtcbiAgICB2YXIgdzEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxID4+PiAyNikpIHwgMDtcbiAgICB3MSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgyKSkgfCAwO1xuICAgIHZhciB3MiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzIgPj4+IDI2KSkgfCAwO1xuICAgIHcyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgzKSkgfCAwO1xuICAgIHZhciB3MyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzMgPj4+IDI2KSkgfCAwO1xuICAgIHczICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNCkpIHwgMDtcbiAgICB2YXIgdzQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc0ID4+PiAyNikpIHwgMDtcbiAgICB3NCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg1KSkgfCAwO1xuICAgIHZhciB3NSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzUgPj4+IDI2KSkgfCAwO1xuICAgIHc1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg2KSkgfCAwO1xuICAgIHZhciB3NiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzYgPj4+IDI2KSkgfCAwO1xuICAgIHc2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNykpIHwgMDtcbiAgICB2YXIgdzcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgICB3NyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg4KSkgfCAwO1xuICAgIHZhciB3OCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzggPj4+IDI2KSkgfCAwO1xuICAgIHc4ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg5KSkgfCAwO1xuICAgIHZhciB3OSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzkgPj4+IDI2KSkgfCAwO1xuICAgIHc5ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgxKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwxKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gICAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgyKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwyKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgyKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzExID4+PiAyNikpIHwgMDtcbiAgICB3MTEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwzKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDMpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDMpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDMpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gICAgdzEyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg0KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw0KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG4gICAgdzEzICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg1KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw1KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg1KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE0ID4+PiAyNikpIHwgMDtcbiAgICB3MTQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw2KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDYpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDYpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDYpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG4gICAgdzE1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg3KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw3KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNiA+Pj4gMjYpKSB8IDA7XG4gICAgdzE2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg4KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw4KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg4KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE3ID4+PiAyNikpIHwgMDtcbiAgICB3MTcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw5KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDkpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDkpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDkpO1xuICAgIHZhciB3MTggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxOCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE4ICY9IDB4M2ZmZmZmZjtcbiAgICBvWzBdID0gdzA7XG4gICAgb1sxXSA9IHcxO1xuICAgIG9bMl0gPSB3MjtcbiAgICBvWzNdID0gdzM7XG4gICAgb1s0XSA9IHc0O1xuICAgIG9bNV0gPSB3NTtcbiAgICBvWzZdID0gdzY7XG4gICAgb1s3XSA9IHc3O1xuICAgIG9bOF0gPSB3ODtcbiAgICBvWzldID0gdzk7XG4gICAgb1sxMF0gPSB3MTA7XG4gICAgb1sxMV0gPSB3MTE7XG4gICAgb1sxMl0gPSB3MTI7XG4gICAgb1sxM10gPSB3MTM7XG4gICAgb1sxNF0gPSB3MTQ7XG4gICAgb1sxNV0gPSB3MTU7XG4gICAgb1sxNl0gPSB3MTY7XG4gICAgb1sxN10gPSB3MTc7XG4gICAgb1sxOF0gPSB3MTg7XG4gICAgaWYgKGMgIT09IDApIHtcbiAgICAgIG9bMTldID0gYztcbiAgICAgIG91dC5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICAvLyBQb2x5ZmlsbCBjb21iXG4gIGlmICghTWF0aC5pbXVsKSB7XG4gICAgY29tYjEwTXVsVG8gPSBzbWFsbE11bFRvO1xuICB9XG5cbiAgZnVuY3Rpb24gYmlnTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICB2YXIgaG5jYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgICBobmNhcnJ5ID0gMDtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gayAtIGo7XG4gICAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG4gICAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcbiAgICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG5cbiAgICAgICAgaG5jYXJyeSArPSBuY2FycnkgPj4+IDI2O1xuICAgICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQ7XG4gICAgICBjYXJyeSA9IG5jYXJyeTtcbiAgICAgIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBqdW1ib011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIHZhciBmZnRtID0gbmV3IEZGVE0oKTtcbiAgICByZXR1cm4gZmZ0bS5tdWxwKHNlbGYsIG51bSwgb3V0KTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uIG11bFRvIChudW0sIG91dCkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEwICYmIG51bS5sZW5ndGggPT09IDEwKSB7XG4gICAgICByZXMgPSBjb21iMTBNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCA2Mykge1xuICAgICAgcmVzID0gc21hbGxNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCAxMDI0KSB7XG4gICAgICByZXMgPSBiaWdNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29vbGV5LVR1a2V5IGFsZ29yaXRobSBmb3IgRkZUXG4gIC8vIHNsaWdodGx5IHJldmlzaXRlZCB0byByZWx5IG9uIGxvb3BpbmcgaW5zdGVhZCBvZiByZWN1cnNpb25cblxuICBmdW5jdGlvbiBGRlRNICh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgRkZUTS5wcm90b3R5cGUubWFrZVJCVCA9IGZ1bmN0aW9uIG1ha2VSQlQgKE4pIHtcbiAgICB2YXIgdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbCA9IEJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pIC0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdFtpXSA9IHRoaXMucmV2QmluKGksIGwsIE4pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYmluYXJ5LXJldmVyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuICBGRlRNLnByb3RvdHlwZS5yZXZCaW4gPSBmdW5jdGlvbiByZXZCaW4gKHgsIGwsIE4pIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSBOIC0gMSkgcmV0dXJuIHg7XG5cbiAgICB2YXIgcmIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICByYiB8PSAoeCAmIDEpIDw8IChsIC0gaSAtIDEpO1xuICAgICAgeCA+Pj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmI7XG4gIH07XG5cbiAgLy8gUGVyZm9ybXMgXCJ0d2VlZGxpbmdcIiBwaGFzZSwgdGhlcmVmb3JlICdlbXVsYXRpbmcnXG4gIC8vIGJlaGF2aW91ciBvZiB0aGUgcmVjdXJzaXZlIGFsZ29yaXRobVxuICBGRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZSAocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBydHdzW2ldID0gcndzW3JidFtpXV07XG4gICAgICBpdHdzW2ldID0gaXdzW3JidFtpXV07XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAocndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4sIHJidCkge1xuICAgIHRoaXMucGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKTtcblxuICAgIGZvciAodmFyIHMgPSAxOyBzIDwgTjsgcyA8PD0gMSkge1xuICAgICAgdmFyIGwgPSBzIDw8IDE7XG5cbiAgICAgIHZhciBydHdkZiA9IE1hdGguY29zKDIgKiBNYXRoLlBJIC8gbCk7XG4gICAgICB2YXIgaXR3ZGYgPSBNYXRoLnNpbigyICogTWF0aC5QSSAvIGwpO1xuXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IE47IHAgKz0gbCkge1xuICAgICAgICB2YXIgcnR3ZGZfID0gcnR3ZGY7XG4gICAgICAgIHZhciBpdHdkZl8gPSBpdHdkZjtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgIHZhciByZSA9IHJ0d3NbcCArIGpdO1xuICAgICAgICAgIHZhciBpZSA9IGl0d3NbcCArIGpdO1xuXG4gICAgICAgICAgdmFyIHJvID0gcnR3c1twICsgaiArIHNdO1xuICAgICAgICAgIHZhciBpbyA9IGl0d3NbcCArIGogKyBzXTtcblxuICAgICAgICAgIHZhciByeCA9IHJ0d2RmXyAqIHJvIC0gaXR3ZGZfICogaW87XG5cbiAgICAgICAgICBpbyA9IHJ0d2RmXyAqIGlvICsgaXR3ZGZfICogcm87XG4gICAgICAgICAgcm8gPSByeDtcblxuICAgICAgICAgIHJ0d3NbcCArIGpdID0gcmUgKyBybztcbiAgICAgICAgICBpdHdzW3AgKyBqXSA9IGllICsgaW87XG5cbiAgICAgICAgICBydHdzW3AgKyBqICsgc10gPSByZSAtIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGogKyBzXSA9IGllIC0gaW87XG5cbiAgICAgICAgICAvKiBqc2hpbnQgbWF4ZGVwdGggOiBmYWxzZSAqL1xuICAgICAgICAgIGlmIChqICE9PSBsKSB7XG4gICAgICAgICAgICByeCA9IHJ0d2RmICogcnR3ZGZfIC0gaXR3ZGYgKiBpdHdkZl87XG5cbiAgICAgICAgICAgIGl0d2RmXyA9IHJ0d2RmICogaXR3ZGZfICsgaXR3ZGYgKiBydHdkZl87XG4gICAgICAgICAgICBydHdkZl8gPSByeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2IgPSBmdW5jdGlvbiBndWVzc0xlbjEzYiAobiwgbSkge1xuICAgIHZhciBOID0gTWF0aC5tYXgobSwgbikgfCAxO1xuICAgIHZhciBvZGQgPSBOICYgMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yIChOID0gTiAvIDIgfCAwOyBOOyBOID0gTiA+Pj4gMSkge1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiAxIDw8IGkgKyAxICsgb2RkO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIGNvbmp1Z2F0ZSAocndzLCBpd3MsIE4pIHtcbiAgICBpZiAoTiA8PSAxKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB0ID0gcndzW2ldO1xuXG4gICAgICByd3NbaV0gPSByd3NbTiAtIGkgLSAxXTtcbiAgICAgIHJ3c1tOIC0gaSAtIDFdID0gdDtcblxuICAgICAgdCA9IGl3c1tpXTtcblxuICAgICAgaXdzW2ldID0gLWl3c1tOIC0gaSAtIDFdO1xuICAgICAgaXdzW04gLSBpIC0gMV0gPSAtdDtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiID0gZnVuY3Rpb24gbm9ybWFsaXplMTNiICh3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdyA9IE1hdGgucm91bmQod3NbMiAqIGkgKyAxXSAvIE4pICogMHgyMDAwICtcbiAgICAgICAgTWF0aC5yb3VuZCh3c1syICogaV0gLyBOKSArXG4gICAgICAgIGNhcnJ5O1xuXG4gICAgICB3c1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cbiAgICAgIGlmICh3IDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gdyAvIDB4NDAwMDAwMCB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdzO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbnZlcnQxM2IgPSBmdW5jdGlvbiBjb252ZXJ0MTNiICh3cywgbGVuLCByd3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhcnJ5ID0gY2FycnkgKyAod3NbaV0gfCAwKTtcblxuICAgICAgcndzWzIgKiBpXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICAgIHJ3c1syICogaSArIDFdID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgIH1cblxuICAgIC8vIFBhZCB3aXRoIHplcm9lc1xuICAgIGZvciAoaSA9IDIgKiBsZW47IGkgPCBOOyArK2kpIHtcbiAgICAgIHJ3c1tpXSA9IDA7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAwKTtcbiAgICBhc3NlcnQoKGNhcnJ5ICYgfjB4MWZmZikgPT09IDApO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnN0dWIgPSBmdW5jdGlvbiBzdHViIChOKSB7XG4gICAgdmFyIHBoID0gbmV3IEFycmF5KE4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBwaFtpXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBoO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwICh4LCB5LCBvdXQpIHtcbiAgICB2YXIgTiA9IDIgKiB0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG5cbiAgICB2YXIgcmJ0ID0gdGhpcy5tYWtlUkJUKE4pO1xuXG4gICAgdmFyIF8gPSB0aGlzLnN0dWIoTik7XG5cbiAgICB2YXIgcndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciByd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBpd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIG5yd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5yd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBybXdzID0gb3V0LndvcmRzO1xuICAgIHJtd3MubGVuZ3RoID0gTjtcblxuICAgIHRoaXMuY29udmVydDEzYih4LndvcmRzLCB4Lmxlbmd0aCwgcndzLCBOKTtcbiAgICB0aGlzLmNvbnZlcnQxM2IoeS53b3JkcywgeS5sZW5ndGgsIG5yd3MsIE4pO1xuXG4gICAgdGhpcy50cmFuc2Zvcm0ocndzLCBfLCByd3N0LCBpd3N0LCBOLCByYnQpO1xuICAgIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB2YXIgcnggPSByd3N0W2ldICogbnJ3c3RbaV0gLSBpd3N0W2ldICogbml3c3RbaV07XG4gICAgICBpd3N0W2ldID0gcndzdFtpXSAqIG5pd3N0W2ldICsgaXdzdFtpXSAqIG5yd3N0W2ldO1xuICAgICAgcndzdFtpXSA9IHJ4O1xuICAgIH1cblxuICAgIHRoaXMuY29uanVnYXRlKHJ3c3QsIGl3c3QsIE4pO1xuICAgIHRoaXMudHJhbnNmb3JtKHJ3c3QsIGl3c3QsIHJtd3MsIF8sIE4sIHJidCk7XG4gICAgdGhpcy5jb25qdWdhdGUocm13cywgXywgTik7XG4gICAgdGhpcy5ub3JtYWxpemUxM2Iocm13cywgTik7XG5cbiAgICBvdXQubmVnYXRpdmUgPSB4Lm5lZ2F0aXZlIF4geS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0geC5sZW5ndGggKyB5Lmxlbmd0aDtcbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgYHRoaXNgIGJ5IGBudW1gXG4gIEJOLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGVtcGxveWluZyBGRlRcbiAgQk4ucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBNdWx0aXBsaWNhdGlvblxuICBCTi5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8obnVtLCB0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblxuICAgIC8vIENhcnJ5XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSAqIG51bTtcbiAgICAgIHZhciBsbyA9ICh3ICYgMHgzZmZmZmZmKSArIChjYXJyeSAmIDB4M2ZmZmZmZik7XG4gICAgICBjYXJyeSA+Pj0gMjY7XG4gICAgICBjYXJyeSArPSAodyAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgLy8gTk9URTogbG8gaXMgMjdiaXQgbWF4aW11bVxuICAgICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uIG11bG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLmltdWwodGhpcy5jbG9uZSgpKTtcbiAgfTtcblxuICAvLyBNYXRoLnBvdyhgdGhpc2AsIGBudW1gKVxuICBCTi5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChudW0pIHtcbiAgICB2YXIgdyA9IHRvQml0QXJyYXkobnVtKTtcbiAgICBpZiAody5sZW5ndGggPT09IDApIHJldHVybiBuZXcgQk4oMSk7XG5cbiAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzXG4gICAgdmFyIHJlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrLCByZXMgPSByZXMuc3FyKCkpIHtcbiAgICAgIGlmICh3W2ldICE9PSAwKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIHEgPSByZXMuc3FyKCk7IGkgPCB3Lmxlbmd0aDsgaSsrLCBxID0gcS5zcXIoKSkge1xuICAgICAgICBpZiAod1tpXSA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gcmVzLm11bChxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnQgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1c2hsbiA9IGZ1bmN0aW9uIGl1c2hsbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcbiAgICB2YXIgY2FycnlNYXNrID0gKDB4M2ZmZmZmZiA+Pj4gKDI2IC0gcikpIDw8ICgyNiAtIHIpO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdDYXJyeSA9IHRoaXMud29yZHNbaV0gJiBjYXJyeU1hc2s7XG4gICAgICAgIHZhciBjID0gKCh0aGlzLndvcmRzW2ldIHwgMCkgLSBuZXdDYXJyeSkgPDwgcjtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcbiAgICAgICAgY2FycnkgPSBuZXdDYXJyeSA+Pj4gKDI2IC0gcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYXJyeSkge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHMgIT09IDApIHtcbiAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgc10gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCArPSBzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaGxuID0gZnVuY3Rpb24gaXNobG4gKGJpdHMpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXG4gIC8vIE5PVEU6IGBoaW50YCBpcyBhIGxvd2VzdCBiaXQgYmVmb3JlIHRyYWlsaW5nIHplcm9lc1xuICAvLyBOT1RFOiBpZiBgZXh0ZW5kZWRgIGlzIHByZXNlbnQgLSBpdCB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlc3Ryb3llZCBiaXRzXG4gIEJOLnByb3RvdHlwZS5pdXNocm4gPSBmdW5jdGlvbiBpdXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciBoO1xuICAgIGlmIChoaW50KSB7XG4gICAgICBoID0gKGhpbnQgLSAoaGludCAlIDI2KSkgLyAyNjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSBNYXRoLm1pbigoYml0cyAtIHIpIC8gMjYsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICB2YXIgbWFza2VkV29yZHMgPSBleHRlbmRlZDtcblxuICAgIGggLT0gcztcbiAgICBoID0gTWF0aC5tYXgoMCwgaCk7XG5cbiAgICAvLyBFeHRlbmRlZCBtb2RlLCBjb3B5IG1hc2tlZCBwYXJ0XG4gICAgaWYgKG1hc2tlZFdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICBtYXNrZWRXb3Jkcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG4gICAgICBtYXNrZWRXb3Jkcy5sZW5ndGggPSBzO1xuICAgIH1cblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICAvLyBOby1vcCwgd2Ugc2hvdWxkIG5vdCBtb3ZlIGFueXRoaW5nIGF0IGFsbFxuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiBzKSB7XG4gICAgICB0aGlzLmxlbmd0aCAtPSBzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaSArIHNdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKGNhcnJ5IDw8ICgyNiAtIHIpKSB8ICh3b3JkID4+PiByKTtcbiAgICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBjYXJyaWVkIGJpdHMgYXMgYSBtYXNrXG4gICAgaWYgKG1hc2tlZFdvcmRzICYmIGNhcnJ5ICE9PSAwKSB7XG4gICAgICBtYXNrZWRXb3Jkcy53b3Jkc1ttYXNrZWRXb3Jkcy5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hybihiaXRzLCBoaW50LCBleHRlbmRlZCk7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdFxuICBCTi5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uIHNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uIHVzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHRcbiAgQk4ucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbiBzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbiB1c2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFRlc3QgaWYgbiBiaXQgaXMgc2V0XG4gIEJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3NdO1xuXG4gICAgcmV0dXJuICEhKHcgJiBxKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXIgKGluLXBsYWNlKVxuICBCTi5wcm90b3R5cGUuaW1hc2tuID0gZnVuY3Rpb24gaW1hc2tuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcysrO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWluKHMsIHRoaXMubGVuZ3RoKTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG4gIH07XG5cbiAgLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG4gICAgLy8gUG9zc2libGUgc2lnbiBjaGFuZ2VcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPCBudW0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtICh0aGlzLndvcmRzWzBdIHwgMCk7XG4gICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlzdWJuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRob3V0IGNoZWNrc1xuICAgIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbiBfaWFkZG4gKG51bSkge1xuICAgIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG4gICAgLy8gQ2FycnlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPj0gMHg0MDAwMDAwOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuICAgICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBwbGFpbiBudW1iZXIgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24gaXN1Ym4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlhZGRuKC1udW0pO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkbihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IC10aGlzLndvcmRzWzBdO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhcnJ5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSArPSAweDQwMDAwMDA7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdIC09IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMgKCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uIF9pc2hsbnN1Ym11bCAobnVtLCBtdWwsIHNoaWZ0KSB7XG4gICAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcbiAgICB2YXIgaTtcblxuICAgIHRoaXMuX2V4cGFuZChsZW4pO1xuXG4gICAgdmFyIHc7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICB2YXIgcmlnaHQgPSAobnVtLndvcmRzW2ldIHwgMCkgKiBtdWw7XG4gICAgICB3IC09IHJpZ2h0ICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ID09PSAwKSByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXG4gICAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcbiAgICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAtKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3dvcmREaXYgPSBmdW5jdGlvbiBfd29yZERpdiAobnVtLCBtb2RlKSB7XG4gICAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW07XG5cbiAgICAvLyBOb3JtYWxpemVcbiAgICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB2YXIgYmhpQml0cyA9IHRoaXMuX2NvdW50Qml0cyhiaGkpO1xuICAgIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xuICAgIGlmIChzaGlmdCAhPT0gMCkge1xuICAgICAgYiA9IGIudXNobG4oc2hpZnQpO1xuICAgICAgYS5pdXNobG4oc2hpZnQpO1xuICAgICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHF1b3RpZW50XG4gICAgdmFyIG0gPSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICAgIHZhciBxO1xuXG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICBxID0gbmV3IEJOKG51bGwpO1xuICAgICAgcS5sZW5ndGggPSBtICsgMTtcbiAgICAgIHEud29yZHMgPSBuZXcgQXJyYXkocS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHEud29yZHNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaWZmID0gYS5jbG9uZSgpLl9pc2hsbnN1Ym11bChiLCAxLCBtKTtcbiAgICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgYSA9IGRpZmY7XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW21dID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gbSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB2YXIgcWogPSAoYS53b3Jkc1tiLmxlbmd0aCArIGpdIHwgMCkgKiAweDQwMDAwMDAgK1xuICAgICAgICAoYS53b3Jkc1tiLmxlbmd0aCArIGogLSAxXSB8IDApO1xuXG4gICAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuICAgICAgLy8gKDB4N2ZmZmZmZilcbiAgICAgIHFqID0gTWF0aC5taW4oKHFqIC8gYmhpKSB8IDAsIDB4M2ZmZmZmZik7XG5cbiAgICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcbiAgICAgIHdoaWxlIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIHFqLS07XG4gICAgICAgIGEubmVnYXRpdmUgPSAwO1xuICAgICAgICBhLl9pc2hsbnN1Ym11bChiLCAxLCBqKTtcbiAgICAgICAgaWYgKCFhLmlzWmVybygpKSB7XG4gICAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW2pdID0gcWo7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxKSB7XG4gICAgICBxLnN0cmlwKCk7XG4gICAgfVxuICAgIGEuc3RyaXAoKTtcblxuICAgIC8vIERlbm9ybWFsaXplXG4gICAgaWYgKG1vZGUgIT09ICdkaXYnICYmIHNoaWZ0ICE9PSAwKSB7XG4gICAgICBhLml1c2hybihzaGlmdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpdjogcSB8fCBudWxsLFxuICAgICAgbW9kOiBhXG4gICAgfTtcbiAgfTtcblxuICAvLyBOT1RFOiAxKSBgbW9kZWAgY2FuIGJlIHNldCB0byBgbW9kYCB0byByZXF1ZXN0IG1vZCBvbmx5LFxuICAvLyAgICAgICB0byBgZGl2YCB0byByZXF1ZXN0IGRpdiBvbmx5LCBvciBiZSBhYnNlbnQgdG9cbiAgLy8gICAgICAgcmVxdWVzdCBib3RoIGRpdiAmIG1vZFxuICAvLyAgICAgICAyKSBgcG9zaXRpdmVgIGlzIHRydWUgaWYgdW5zaWduZWQgbW9kIGlzIHJlcXVlc3RlZFxuICBCTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kIChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG4gICAgYXNzZXJ0KCFudW0uaXNaZXJvKCkpO1xuXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IG5ldyBCTigwKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGl2LCBtb2QsIHJlcztcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pYWRkKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IHJlcy5tb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLm5lZ2F0aXZlICYgbnVtLm5lZ2F0aXZlKSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaXN1YihudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogcmVzLmRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBhdCB0aGlzIHBvaW50XG5cbiAgICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcbiAgICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiB0aGlzXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFZlcnkgc2hvcnQgcmVkdWN0aW9uXG4gICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtb2RlID09PSAnZGl2Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgICAgbW9kOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlID09PSAnbW9kJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93b3JkRGl2KG51bSwgbW9kZSk7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnZGl2JywgZmFsc2UpLmRpdjtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAlIGBudW1gXG4gIEJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCBmYWxzZSkubW9kO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24gdW1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIHRydWUpLm1vZDtcbiAgfTtcblxuICAvLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuICBCTi5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbiBkaXZSb3VuZCAobnVtKSB7XG4gICAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuICAgIC8vIEZhc3QgY2FzZSAtIGV4YWN0IGRpdmlzaW9uXG4gICAgaWYgKGRtLm1vZC5pc1plcm8oKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuXG4gICAgdmFyIGhhbGYgPSBudW0udXNocm4oMSk7XG4gICAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuICAgIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG4gICAgLy8gUm91bmQgZG93blxuICAgIGlmIChjbXAgPCAwIHx8IHIyID09PSAxICYmIGNtcCA9PT0gMCkgcmV0dXJuIGRtLmRpdjtcblxuICAgIC8vIFJvdW5kIHVwXG4gICAgcmV0dXJuIGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLmRpdi5pc3VibigxKSA6IGRtLmRpdi5pYWRkbigxKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcbiAgICB2YXIgcCA9ICgxIDw8IDI2KSAlIG51bTtcblxuICAgIHZhciBhY2MgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBhY2MgPSAocCAqIGFjYyArICh0aGlzLndvcmRzW2ldIHwgMCkpICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuIChudW0pIHtcbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeSAqIDB4NDAwMDAwMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xuICAgICAgY2FycnkgPSB3ICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbiBlZ2NkIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgeCA9IHRoaXM7XG4gICAgdmFyIHkgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoeC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgeCA9IHgudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBBICogeCArIEIgKiB5ID0geFxuICAgIHZhciBBID0gbmV3IEJOKDEpO1xuICAgIHZhciBCID0gbmV3IEJOKDApO1xuXG4gICAgLy8gQyAqIHggKyBEICogeSA9IHlcbiAgICB2YXIgQyA9IG5ldyBCTigwKTtcbiAgICB2YXIgRCA9IG5ldyBCTigxKTtcblxuICAgIHZhciBnID0gMDtcblxuICAgIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcbiAgICAgIHguaXVzaHJuKDEpO1xuICAgICAgeS5pdXNocm4oMSk7XG4gICAgICArK2c7XG4gICAgfVxuXG4gICAgdmFyIHlwID0geS5jbG9uZSgpO1xuICAgIHZhciB4cCA9IHguY2xvbmUoKTtcblxuICAgIHdoaWxlICgheC5pc1plcm8oKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB4Lml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuICAgICAgICAgICAgQS5pYWRkKHlwKTtcbiAgICAgICAgICAgIEIuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQS5pdXNocm4oMSk7XG4gICAgICAgICAgQi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKHkud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICB5Lml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoQy5pc09kZCgpIHx8IEQuaXNPZGQoKSkge1xuICAgICAgICAgICAgQy5pYWRkKHlwKTtcbiAgICAgICAgICAgIEQuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQy5pdXNocm4oMSk7XG4gICAgICAgICAgRC5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHguY21wKHkpID49IDApIHtcbiAgICAgICAgeC5pc3ViKHkpO1xuICAgICAgICBBLmlzdWIoQyk7XG4gICAgICAgIEIuaXN1YihEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkuaXN1Yih4KTtcbiAgICAgICAgQy5pc3ViKEEpO1xuICAgICAgICBELmlzdWIoQik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IEMsXG4gICAgICBiOiBELFxuICAgICAgZ2NkOiB5Lml1c2hsbihnKVxuICAgIH07XG4gIH07XG5cbiAgLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG4gIC8vIGFib3ZlLCBkZXNpZ25hdGVkIHRvIGludmVydCBtZW1iZXJzIG9mIHRoZVxuICAvLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuICBCTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGIgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgYSA9IGEudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG4gICAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKGEuY21wbigxKSA+IDAgJiYgYi5jbXBuKDEpID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBhLml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDEuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDEuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7IChiLndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgYi5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgyLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgyLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xuICAgICAgICBhLmlzdWIoYik7XG4gICAgICAgIHgxLmlzdWIoeDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYi5pc3ViKGEpO1xuICAgICAgICB4Mi5pc3ViKHgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmIChhLmNtcG4oMSkgPT09IDApIHtcbiAgICAgIHJlcyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB4MjtcbiAgICB9XG5cbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZChwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QgKG51bSkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gbnVtLmFicygpO1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiB0aGlzLmFicygpO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW0uY2xvbmUoKTtcbiAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICBiLm5lZ2F0aXZlID0gMDtcblxuICAgIC8vIFJlbW92ZSBjb21tb24gZmFjdG9yIG9mIHR3b1xuICAgIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG4gICAgICBhLml1c2hybigxKTtcbiAgICAgIGIuaXVzaHJuKDEpO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG4gICAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcbiAgICAgICAgYi5pdXNocm4oMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gYS5jbXAoYik7XG4gICAgICBpZiAociA8IDApIHtcbiAgICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG4gICAgICAgIHZhciB0ID0gYTtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSB0O1xuICAgICAgfSBlbHNlIGlmIChyID09PSAwIHx8IGIuY21wbigxKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYS5pc3ViKGIpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcbiAgfTtcblxuICAvLyBJbnZlcnQgbnVtYmVyIGluIHRoZSBmaWVsZCBGKG51bSlcbiAgQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS51bW9kKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQgKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuICB9O1xuXG4gIC8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cbiAgQk4ucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24gYW5kbG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLndvcmRzWzBdICYgbnVtO1xuICB9O1xuXG4gIC8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcbiAgQk4ucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24gYmluY24gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgdGhpcy5fZXhwYW5kKHMgKyAxKTtcbiAgICAgIHRoaXMud29yZHNbc10gfD0gcTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBiaXQgYW5kIHByb3BhZ2F0ZSwgaWYgbmVlZGVkXG4gICAgdmFyIGNhcnJ5ID0gcTtcbiAgICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB3ICs9IGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgICAgIHcgJj0gMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHc7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuIChudW0pIHtcbiAgICB2YXIgbmVnYXRpdmUgPSBudW0gPCAwO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbmVnYXRpdmUpIHJldHVybiAxO1xuXG4gICAgdGhpcy5zdHJpcCgpO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgbnVtID0gLW51bTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYsICdOdW1iZXIgaXMgdG9vIGJpZycpO1xuXG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbMF0gfCAwO1xuICAgICAgcmVzID0gdyA9PT0gbnVtID8gMCA6IHcgPCBudW0gPyAtMSA6IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb21wYXJlIHR3byBudW1iZXJzIGFuZCByZXR1cm46XG4gIC8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuICAvLyAwIC0gaWYgYHRoaXNgID09IGBudW1gXG4gIC8vIC0xIC0gaWYgYHRoaXNgIDwgYG51bWBcbiAgQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcCAobnVtKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gMTtcblxuICAgIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gVW5zaWduZWQgY29tcGFyaXNvblxuICBCTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIHVjbXAgKG51bSkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiAxO1xuICAgIGlmICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHJldHVybiAtMTtcblxuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuXG4gICAgICBpZiAoYSA9PT0gYikgY29udGludWU7XG4gICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmVzID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RuID0gZnVuY3Rpb24gZ3RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gZ3QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGVuID0gZnVuY3Rpb24gZ3RlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIGd0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRuID0gZnVuY3Rpb24gbHRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIGx0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbiBsdGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24gbHRlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcW4gPSBmdW5jdGlvbiBlcW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG4gIH07XG5cbiAgLy9cbiAgLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcbiAgLy8gb24gdGhlIGBtYCBpdHNlbGYuXG4gIC8vXG4gIEJOLnJlZCA9IGZ1bmN0aW9uIHJlZCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgcmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQgKGN0eCkge1xuICAgIHRoaXMucmVkID0gY3R4O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNobCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXIodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuICB9O1xuXG4gIC8vIFNxdWFyZSByb290IG92ZXIgcFxuICBCTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2AgJSBgcmVkIG1vZHVsb2BcbiAgQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZyAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uIHJlZFBvdyAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XG4gIH07XG5cbiAgLy8gUHJpbWUgbnVtYmVycyB3aXRoIGVmZmljaWVudCByZWR1Y3Rpb25cbiAgdmFyIHByaW1lcyA9IHtcbiAgICBrMjU2OiBudWxsLFxuICAgIHAyMjQ6IG51bGwsXG4gICAgcDE5MjogbnVsbCxcbiAgICBwMjU1MTk6IG51bGxcbiAgfTtcblxuICAvLyBQc2V1ZG8tTWVyc2VubmUgcHJpbWVcbiAgZnVuY3Rpb24gTVByaW1lIChuYW1lLCBwKSB7XG4gICAgLy8gUCA9IDIgXiBOIC0gS1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcbiAgICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG4gICAgdGhpcy5rID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuICAgIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG4gIH1cblxuICBNUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wICgpIHtcbiAgICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuICAgIHRtcC53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKTtcbiAgICByZXR1cm4gdG1wO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uIGlyZWR1Y2UgKG51bSkge1xuICAgIC8vIEFzc3VtZXMgdGhhdCBgbnVtYCBpcyBsZXNzIHRoYW4gYFBeMmBcbiAgICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG4gICAgdmFyIHIgPSBudW07XG4gICAgdmFyIHJsZW47XG5cbiAgICBkbyB7XG4gICAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcbiAgICAgIHIgPSB0aGlzLmltdWxLKHIpO1xuICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG4gICAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcbiAgICB9IHdoaWxlIChybGVuID4gdGhpcy5uKTtcblxuICAgIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICByLndvcmRzWzBdID0gMDtcbiAgICAgIHIubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIHIuaXN1Yih0aGlzLnApO1xuICAgIH0gZWxzZSB7XG4gICAgICByLnN0cmlwKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG4gICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEsyNTYgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdrMjU2JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuICB9XG4gIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbiAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcbiAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICAgIH1cbiAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG4gICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcbiAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgICBwcmV2ID0gbmV4dDtcbiAgICB9XG4gICAgcHJldiA+Pj49IDIyO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuICAgIH1cbiAgfTtcblxuICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICAgIG51bS5sZW5ndGggKz0gMjtcblxuICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gICAgdmFyIGxvID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFAyMjQgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMjI0JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuICB9XG4gIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDE5MiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AxOTInLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuICAgIC8vIDIgXiAyNTUgLSAxOVxuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICcyNTUxOScsXG4gICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuICB9XG4gIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEzXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG4gICAgICBoaSA+Pj49IDI2O1xuXG4gICAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICAgIGNhcnJ5ID0gaGk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcbiAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcbiAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cbiAgICB2YXIgcHJpbWU7XG4gICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcbiAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cbiAgICByZXR1cm4gcHJpbWU7XG4gIH07XG5cbiAgLy9cbiAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG4gIC8vXG4gIGZ1bmN0aW9uIFJlZCAobSkge1xuICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcbiAgICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG4gICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcbiAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG4gICAgcmV0dXJuIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5hZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLnN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG4gICAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cbiAgICAvLyBGYXN0IGNhc2VcbiAgICBpZiAobW9kMyA9PT0gMykge1xuICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG4gICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcbiAgICB9XG5cbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG4gICAgLy9cbiAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG4gICAgdmFyIHMgPSAwO1xuICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG4gICAgICBzKys7XG4gICAgICBxLml1c2hybigxKTtcbiAgICB9XG4gICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cbiAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcbiAgICAgIHoucmVkSUFkZChuT25lKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG4gICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcbiAgICB2YXIgbSA9IHM7XG4gICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICAgIHZhciB0bXAgPSB0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG4gICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChpIDwgbSk7XG4gICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICAgIHIgPSByLnJlZE11bChiKTtcbiAgICAgIGMgPSBiLnJlZFNxcigpO1xuICAgICAgdCA9IHQucmVkTXVsKGMpO1xuICAgICAgbSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgICB9XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSk7XG4gICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcbiAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgd25kWzFdID0gYTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHduZFswXTtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcbiAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA8PD0gMTtcbiAgICAgICAgY3VycmVudCB8PSBiaXQ7XG4gICAgICAgIGN1cnJlbnRMZW4rKztcbiAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cbiAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgICByZXMucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vXG4gIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuICAvL1xuXG4gIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcbiAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBNb250IChtKSB7XG4gICAgUmVkLmNhbGwodGhpcywgbSk7XG5cbiAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcbiAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcbiAgICB9XG5cbiAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cbiAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gIH1cbiAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuICAgIHIucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgIGEud29yZHNbMF0gPSAwO1xuICAgICAgYS5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBhLmltdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG5cbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgdmFyIHQgPSBhLm11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xufSkodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCB0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibi5qcy9saWIvYm4uanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxsaXB0aWMgPSBleHBvcnRzO1xuXG5lbGxpcHRpYy52ZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbmVsbGlwdGljLnV0aWxzID0gcmVxdWlyZSgnLi9lbGxpcHRpYy91dGlscycpO1xuZWxsaXB0aWMucmFuZCA9IHJlcXVpcmUoJ2Jyb3JhbmQnKTtcbmVsbGlwdGljLmN1cnZlID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9jdXJ2ZScpO1xuZWxsaXB0aWMuY3VydmVzID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9jdXJ2ZXMnKTtcblxuLy8gUHJvdG9jb2xzXG5lbGxpcHRpYy5lYyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvZWMnKTtcbmVsbGlwdGljLmVkZHNhID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9lZGRzYScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaGFzaCA9IGV4cG9ydHM7XG5cbmhhc2gudXRpbHMgPSByZXF1aXJlKCcuL2hhc2gvdXRpbHMnKTtcbmhhc2guY29tbW9uID0gcmVxdWlyZSgnLi9oYXNoL2NvbW1vbicpO1xuaGFzaC5zaGEgPSByZXF1aXJlKCcuL2hhc2gvc2hhJyk7XG5oYXNoLnJpcGVtZCA9IHJlcXVpcmUoJy4vaGFzaC9yaXBlbWQnKTtcbmhhc2guaG1hYyA9IHJlcXVpcmUoJy4vaGFzaC9obWFjJyk7XG5cbi8vIFByb3h5IGhhc2ggZnVuY3Rpb25zIHRvIHRoZSBtYWluIG9iamVjdFxuaGFzaC5zaGExID0gaGFzaC5zaGEuc2hhMTtcbmhhc2guc2hhMjU2ID0gaGFzaC5zaGEuc2hhMjU2O1xuaGFzaC5zaGEyMjQgPSBoYXNoLnNoYS5zaGEyMjQ7XG5oYXNoLnNoYTM4NCA9IGhhc2guc2hhLnNoYTM4NDtcbmhhc2guc2hhNTEyID0gaGFzaC5zaGEuc2hhNTEyO1xuaGFzaC5yaXBlbWQxNjAgPSBoYXNoLnJpcGVtZC5yaXBlbWQxNjA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaGFzaC5qcy9saWIvaGFzaC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBhc3NlcnQ7XG5cbmZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuICBpZiAoIXZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG59XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGFzc2VydEVxdWFsKGwsIHIsIG1zZykge1xuICBpZiAobCAhPSByKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgKCdBc3NlcnRpb24gZmFpbGVkOiAnICsgbCArICcgIT0gJyArIHIpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWluaW1hbGlzdGljLWFzc2VydC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG52YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbmZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzTmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIOmYn+WIl1F1ZXVlXG4gKlxuICog6Zif5YiX5piv5LiA56eN5YWI6L+b5YWI5Ye677yIZmlyc3QgaW4gZmlyc3Qgb3V0LCBGSUZP77yJ55qE57q/5oCn6KGo44CC5a6D5Y+q5YWB6K645Zyo6KGo55qE5LiA56uv6L+b6KGM5o+S5YWl77yM6ICM5Zyo5Y+m5LiA56uv5Yig6Zmk5YWD57Sg44CCXG4gKiDlhYHorrjmj5LlhaXnmoTkuIDnq6/lj6vpmJ/lsL7vvIhyZWFy77yJ77yM5YWB6K645Yig6Zmk55qE5LiA56uv5Y+r6Zif5aS077yIZnJvbnTvvInjgIJcbiAqL1xuXG4vLyDpk77pmJ/liJdcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZWFyID0gdGhpcy5mcm9udCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhciA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5yZWFyID0gdGhpcy5mcm9udCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgZ2V0SGVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbnQgPyB0aGlzLmZyb250LmRhdGEgOiBudWxsO1xuICAgIH1cblxuICAgIGVuUXVldWUoZWxlbSkge1xuICAgICAgICBpZiAodGhpcy5mcm9udCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZWFyID0gdGhpcy5mcm9udCA9IHsgZGF0YTogZWxlbSwgbmV4dDogbnVsbCB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHAgPSB7IGRhdGE6IGVsZW0sIG5leHQ6IG51bGwgfTtcbiAgICAgICAgICAgIHRoaXMucmVhci5uZXh0ID0gcDtcbiAgICAgICAgICAgIHRoaXMucmVhciA9IHA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaXplKys7XG4gICAgfVxuXG4gICAgZGVRdWV1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbnQpIHtcbiAgICAgICAgICAgIGxldCBlbGVtID0gdGhpcy5mcm9udC5kYXRhO1xuICAgICAgICAgICAgdGhpcy5mcm9udCA9IHRoaXMuZnJvbnQubmV4dDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyb250ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvckVhY2goaXRlcmF0b3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXRlcmF0b3Igc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmZyb250O1xuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yKGN1cnJlbnQuZGF0YSkpIGJyZWFrO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmZyb250O1xuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgeWllbGQgY3VycmVudC5kYXRhO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBlZWtBdChpbmRleCA9IDApIHtcbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5zaXplKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZnJvbnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmZyb250ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhcnIgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmZyb250O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLnNpemU7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgYXJyW2ldID0gY3VycmVudC5kYXRhO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1F1ZXVlL1F1ZXVlLmpzIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpLlN0cmluZ0RlY29kZXJcbm1vZHVsZS5leHBvcnRzID0gQ2lwaGVyQmFzZVxuaW5oZXJpdHMoQ2lwaGVyQmFzZSwgVHJhbnNmb3JtKVxuZnVuY3Rpb24gQ2lwaGVyQmFzZSAoaGFzaE1vZGUpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5oYXNoTW9kZSA9IHR5cGVvZiBoYXNoTW9kZSA9PT0gJ3N0cmluZydcbiAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICB0aGlzW2hhc2hNb2RlXSA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbmFsID0gdGhpcy5fZmluYWxPckRpZ2VzdFxuICB9XG4gIHRoaXMuX2RlY29kZXIgPSBudWxsXG4gIHRoaXMuX2VuY29kaW5nID0gbnVsbFxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGlucHV0RW5jLCBvdXRwdXRFbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGlucHV0RW5jKVxuICB9XG4gIHZhciBvdXREYXRhID0gdGhpcy5fdXBkYXRlKGRhdGEpXG4gIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYylcbiAgfVxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uICgpIHt9XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLmdldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIGdldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEFBRCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gc2V0IGFhZCBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgXywgbmV4dCkge1xuICB2YXIgZXJyXG4gIHRyeSB7XG4gICAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShkYXRhKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5fdXBkYXRlKGRhdGEpKVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfSBmaW5hbGx5IHtcbiAgICBuZXh0KGVycilcbiAgfVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIHRoaXMucHVzaCh0aGlzLl9maW5hbCgpKVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZVxuICB9IGZpbmFsbHkge1xuICAgIGRvbmUoZXJyKVxuICB9XG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmluYWxPckRpZ2VzdCA9IGZ1bmN0aW9uIChvdXRwdXRFbmMpIHtcbiAgdmFyIG91dERhdGEgPSB0aGlzLl9maW5hbCgpIHx8IG5ldyBCdWZmZXIoJycpXG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jLCB0cnVlKVxuICB9XG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jLCBmaW4pIHtcbiAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgdGhpcy5fZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYylcbiAgICB0aGlzLl9lbmNvZGluZyA9IGVuY1xuICB9XG4gIGlmICh0aGlzLl9lbmNvZGluZyAhPT0gZW5jKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IHN3aXRjaCBlbmNvZGluZ3MnKVxuICB9XG4gIHZhciBvdXQgPSB0aGlzLl9kZWNvZGVyLndyaXRlKHZhbHVlKVxuICBpZiAoZmluKSB7XG4gICAgb3V0ICs9IHRoaXMuX2RlY29kZXIuZW5kKClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY2lwaGVyLWJhc2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBzdG9yZSAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgU3ltYm9sICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbFxuICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbWQ1ID0gcmVxdWlyZSgnLi9tZDUnKVxudmFyIHJtZDE2MCA9IHJlcXVpcmUoJ3JpcGVtZDE2MCcpXG52YXIgc2hhID0gcmVxdWlyZSgnc2hhLmpzJylcblxudmFyIEJhc2UgPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG5cbmZ1bmN0aW9uIEhhc2hOb0NvbnN0cnVjdG9yKGhhc2gpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdkaWdlc3QnKVxuXG4gIHRoaXMuX2hhc2ggPSBoYXNoXG4gIHRoaXMuYnVmZmVycyA9IFtdXG59XG5cbmluaGVyaXRzKEhhc2hOb0NvbnN0cnVjdG9yLCBCYXNlKVxuXG5IYXNoTm9Db25zdHJ1Y3Rvci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGRhdGEpXG59XG5cbkhhc2hOb0NvbnN0cnVjdG9yLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KHRoaXMuYnVmZmVycylcbiAgdmFyIHIgPSB0aGlzLl9oYXNoKGJ1ZilcbiAgdGhpcy5idWZmZXJzID0gbnVsbFxuXG4gIHJldHVybiByXG59XG5cbmZ1bmN0aW9uIEhhc2goaGFzaCkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaCA9IGhhc2hcbn1cblxuaW5oZXJpdHMoSGFzaCwgQmFzZSlcblxuSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG59XG5cbkhhc2gucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc2guZGlnZXN0KClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIYXNoIChhbGcpIHtcbiAgYWxnID0gYWxnLnRvTG93ZXJDYXNlKClcbiAgaWYgKCdtZDUnID09PSBhbGcpIHJldHVybiBuZXcgSGFzaE5vQ29uc3RydWN0b3IobWQ1KVxuICBpZiAoJ3JtZDE2MCcgPT09IGFsZyB8fCAncmlwZW1kMTYwJyA9PT0gYWxnKSByZXR1cm4gbmV3IEhhc2hOb0NvbnN0cnVjdG9yKHJtZDE2MClcblxuICByZXR1cm4gbmV3IEhhc2goc2hhKGFsZykpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3JlYXRlLWhhc2gvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gcHJvdG90eXBlIGNsYXNzIGZvciBoYXNoIGZ1bmN0aW9uc1xuZnVuY3Rpb24gSGFzaCAoYmxvY2tTaXplLCBmaW5hbFNpemUpIHtcbiAgdGhpcy5fYmxvY2sgPSBuZXcgQnVmZmVyKGJsb2NrU2l6ZSlcbiAgdGhpcy5fZmluYWxTaXplID0gZmluYWxTaXplXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9sZW4gPSAwXG4gIHRoaXMuX3MgPSAwXG59XG5cbkhhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGVuYyB8fCAndXRmOCdcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG4gIH1cblxuICB2YXIgbCA9IHRoaXMuX2xlbiArPSBkYXRhLmxlbmd0aFxuICB2YXIgcyA9IHRoaXMuX3MgfHwgMFxuICB2YXIgZiA9IDBcbiAgdmFyIGJ1ZmZlciA9IHRoaXMuX2Jsb2NrXG5cbiAgd2hpbGUgKHMgPCBsKSB7XG4gICAgdmFyIHQgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCwgZiArIHRoaXMuX2Jsb2NrU2l6ZSAtIChzICUgdGhpcy5fYmxvY2tTaXplKSlcbiAgICB2YXIgY2ggPSAodCAtIGYpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoOyBpKyspIHtcbiAgICAgIGJ1ZmZlclsocyAlIHRoaXMuX2Jsb2NrU2l6ZSkgKyBpXSA9IGRhdGFbaSArIGZdXG4gICAgfVxuXG4gICAgcyArPSBjaFxuICAgIGYgKz0gY2hcblxuICAgIGlmICgocyAlIHRoaXMuX2Jsb2NrU2l6ZSkgPT09IDApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShidWZmZXIpXG4gICAgfVxuICB9XG4gIHRoaXMuX3MgPSBzXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICAvLyBTdXBwb3NlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2UgTSwgaW4gYml0cywgaXMgbFxuICB2YXIgbCA9IHRoaXMuX2xlbiAqIDhcblxuICAvLyBBcHBlbmQgdGhlIGJpdCAxIHRvIHRoZSBlbmQgb2YgdGhlIG1lc3NhZ2VcbiAgdGhpcy5fYmxvY2tbdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplXSA9IDB4ODBcblxuICAvLyBhbmQgdGhlbiBrIHplcm8gYml0cywgd2hlcmUgayBpcyB0aGUgc21hbGxlc3Qgbm9uLW5lZ2F0aXZlIHNvbHV0aW9uIHRvIHRoZSBlcXVhdGlvbiAobCArIDEgKyBrKSA9PT0gZmluYWxTaXplIG1vZCBibG9ja1NpemVcbiAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemUgKyAxKVxuXG4gIGlmIChsICUgKHRoaXMuX2Jsb2NrU2l6ZSAqIDgpID49IHRoaXMuX2ZpbmFsU2l6ZSAqIDgpIHtcbiAgICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gICAgdGhpcy5fYmxvY2suZmlsbCgwKVxuICB9XG5cbiAgLy8gdG8gdGhpcyBhcHBlbmQgdGhlIGJsb2NrIHdoaWNoIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgbCB3cml0dGVuIGluIGJpbmFyeVxuICAvLyBUT0RPOiBoYW5kbGUgY2FzZSB3aGVyZSBsIGlzID4gTWF0aC5wb3coMiwgMjkpXG4gIHRoaXMuX2Jsb2NrLndyaXRlSW50MzJCRShsLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuXG4gIHZhciBoYXNoID0gdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKSB8fCB0aGlzLl9oYXNoKClcblxuICByZXR1cm4gZW5jID8gaGFzaC50b1N0cmluZyhlbmMpIDogaGFzaFxufVxuXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ191cGRhdGUgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzcycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NoYS5qcy9oYXNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiDmoJHnmoTkuIDkupvmpoLlv7VcbiAqXG4gKiDmoJHvvIhUcmVl77yJ5pivbu+8iG4+PTDvvInkuKrnu5PngrnnmoTmnInpmZDpm4bjgILlnKjku7vmhI/kuIDmo7XpnZ7nqbrmoJHkuK3vvJpcbiAqIO+8iDHvvInmnInkuJTku4XmnInkuIDkuKrnibnlrprnmoTnp7DkuLrmoLnvvIhSb29077yJ55qE57uT54K577ybXG4gKiDvvIgy77yJ5b2Tbj4x5pe277yM5YW25L2Z57uT54K55Y+v5YiG5Li6bShtPjAp5Liq5LqS5LiN55u45Lqk55qE5pyJ6ZmQ6ZuGVDEsVDIsVDMsLi4uVG3vvIzlhbbkuK3mr4/kuIDkuKrpm4blkIjmnKzouqvlj4jmmK/kuIDmo7XmoJHvvIzlubbkuJTnp7DkuLrmoLnnmoTlrZDmoJHvvIhTdWJ0cmVl77yJ44CCXG4gKlxuICog5L6L5aaC77yM77yIYe+8ieaYr+WPquacieS4gOS4quaguee7k+eCueeahOagke+8m1xuICog77yIYu+8ieaYr+aciTEz5Liq57uT54K555qE5qCR77yM5YW25LitQeaYr+ague+8jOWFtuS9mee7k+eCueWIhuaIkDPkuKrkupLkuI3nm7jkuqTnmoTlrZDpm4bvvJpUMT17QixFLEYsSyxMfSx0Mj17RCxILEksSixNfTtUMSxUMuWSjFQz6YO95piv5qC5QeeahOWtkOagke+8jOS4lOacrOi6q+S5n+aYr+S4gOajteagkeOAglxuICpcbiAqIOagkeeahOe7k+eCueWMheWQq+S4gOS4quaVsOaNruWFg+e0oOWPiuiLpeW5suaMh+WQkeWFtuWtkOagkeeahOWIhuaUr+OAgue7k+eCueaLpeacieeahOWtkOagkeaVsOensOS4uue7k+eCueeahOW6pu+8iERlZ3JlZe+8ieOAguS+i+Wmgu+8jO+8iGLvvInkuK1B55qE5bqm5Li6M++8jEPnmoTluqbkuLox77yMRueahOW6puS4ujAu5bqm5Li6MOeahOe7k+eCueensOS4uuWPtuWtkO+8iExlYWbvvInmiJbogIXnu4jnq6/nu5PngrnjgILluqbkuI3kuLow55qE57uT54K556ew5Li66Z2e57uI56uv57uT54K55oiW5YiG5pSv57uT54K544CC5qCR55qE5bqm5piv5qCR5YaF5ZCE57uT54K555qE5bqm55qE5pyA5aSn5YC844CC77yIYu+8ieeahOagkeeahOW6puS4ujMu57uT54K555qE5a2Q5qCR55qE5qC556ew5Li66K+l57uT54K555qE5a2p5a2Q77yIQ2hpbGTvvInjgILnm7jlupTnmoTvvIzor6Xnu5Pngrnnp7DkuLrlranlrZDnmoTlj4zkurLvvIhQYXJlbnTvvInjgILlkIzkuIDkuKrlj4zkurLnmoTlranlrZDkuYvpl7TkupLnp7DlhYTlvJ/vvIhTaWJsaW5n77yJ44CC57uT54K555qE56WW5YWI5piv5LuO5qC55Yiw6K+l57uT54K55omA57uP5YiG5pSv5LiK55qE5omA5pyJ57uT54K544CC5Y+N5LmL77yM5Lul5p+Q57uT54K55Li65qC555qE5a2Q5qCR5Lit55qE5Lu75LiA57uT54K56YO956ew5Li66K+l57uT54K555qE5a2Q5a2Z44CCXG4gKiDnu5PngrnnmoTlsYLmrKHvvIhMZXZlbO+8ieS7juagueW8gOWni+WumuS5iei1t++8jOagueS4uuesrOS4gOWxgu+8jOi3n+eahOWtqeWtkOS4uuesrOS6jOWxguOAguiLpeafkOe7k+eCueWcqOesrGzlsYLvvIzliJnlhbblrZDmoJHnmoTmoLnlsLHlnKjnrKxsKzHlsYLjgILlhbblj4zkurLlnKjlkIzkuIDlsYLnmoTnu5PngrnkupLkuLrloILlhYTlvJ/jgILkvovlpoLvvIznu5PngrlH5LiORe+8jEYsSCxJLErkupLkuLrloILlhYTlvJ/jgILmoJHkuK3nu5PngrnnmoTmnIDlpKflsYLmrKHnp7DkuLrmoJHnmoTmt7HluqbvvIhEZXB0aO+8ieaIlumrmOW6puOAgu+8iGLvvInnmoTmoJHnmoTmt7HluqbkuLo044CCXG4gKlxuICog5aaC5p6c5bCG5qCR5Lit57uT54K555qE5ZCE5a2Q5qCR55yL5oiQ5LuO5bem6Iez5Y+z5piv5pyJ5qyh5bqP55qE77yI5Y2z5LiN6IO95Lqk5o2i77yJ77yM5YiZ56ew6K+l5qCR5Li65pyJ5bqP5qCR77yM5ZCm5YiZ56ew5Li65peg5bqP5qCR44CC5Zyo5pyJ5bqP5qCR5Lit5pyA5bem6L6555qE5a2Q5qCR55qE5qC556ew5Li656ys5LiA5Liq5a2p5a2Q77yM5pyA5Y+z6L6555qE56ew5Li65pyA5ZCO5LiA5Liq5a2p5a2Q44CCXG4gKiDmo67mnpfvvIhGb3Jlc3TvvInmmK9t77yIbT49MO+8ieajteS6kuS4jeebuOS6pOeahOagkeeahOmbhuWQiOOAguWvueagkeS4reavj+S4que7k+eCueiAjOiogO+8jOWFtuWtkOagkeeahOmbhuWQiOWNs+S4uuajruael+OAglxuICpcbiAqXG4gKi9cblxuLyoqXG4gKiDkuozlj4nmoJHvvIhCaW5hcnkgVHJlZe+8ieaYr+WPpuS4gOenjeagkeWei+e7k+aehO+8jOWug+eahOeJueeCueaYr+avj+S4que7k+eCueiHs+WkmuWPquacieS4pOajteWtkOagke+8iOWNs+S6jOWPieagkeS4reS4jeWtmOWcqOW6puWkp+S6jjLnmoTnu5PngrnvvInvvIzlubbkuJTvvIzkuozlj4nmoJHnmoTlrZDmoJHmnInlt6blj7PkuYvliIbvvIjlhbbmrKHluo/kuI3og73ku7vmhI/poqDlgJLjgILvvIlcbiAqXG4gKiDkuozlj4nmoJHnmoTmgKfotKhcbiAqIDEu5Zyo5LqM5Y+J5qCR55qE56ysaeWxguS4iuiHs+WkmuaciTLnmoRpLTHmrKHmlrnkuKrnu5PngrkoaT49MSnjgIJcbiAqIDIu5rex5bqm5Li6a+eahOS6jOWPieagkeiHs+WkmuaciTLnmoRr5qyh5pa5LTHkuKrnu5PngrnvvIwoaz49MSnjgIJcbiAqIDMu5a+55Lu75L2V5LiA5qO15LqM5Y+J5qCRVO+8jOWmguaenOWFtue7iOerr+e7k+eCueaVsOS4um4w77yM5bqm5Li6MueahOe7k+eCueaVsOS4um4y77yM5YiZbjAgPSBuMiArIDE7XG4gKiAgICAgIOS4gOajtea3seW6puS4umvkuJTmnIky55qEa+asoeaWuS0x5Liq57uT54K555qE5LqM5Y+J5qCR56ew5Li65ruh5LqM5Y+J5qCR44CCXG4gKiAgICAgIOa3seW6puS4umvnmoTvvIzmnIlu5Liq57uT54K555qE5LqM5Y+J5qCR77yM5b2T5LiU5LuF5b2T5YW25q+P5LiA5Liq57uT54K56YO95LiO5rex5bqm5Li6a+eahOa7oeS6jOWPieagkeS4ree8luWPt+S7jjHoh7Nu55qE57uT54K55LiA5LiA5a+55bqU5pe277yM56ew5LmL5Li65a6M5YWo5LqM5Y+J5qCR44CCXG4gKiDkuIvpnaLmmK/lrozlhajkuozlj4nmoJHnmoTkuKTkuKrnibnmgKdcbiAqIDQu5YW35pyJbuS4que7k+eCueeahOWujOWFqOS6jOWPieagkeeahOa3seW6puS4uk1hdGguZmxvb3IobG9nIDIgbikgKyAxXG4gKiA1LuWmguaenOWvueS4gOajteaciW7kuKrnu5PngrnnmoTlrozlhajkuozlj4nmoJHvvIjlhbbmt7HluqbkuLpNYXRoLmZsb29yKGxvZyAyIG4pICsgMe+8ieeahOe7k+eCueaMieWxguW6j+e8luWPt++8iOS7juesrDHlsYLliLDnrKxNYXRoLmZsb29yKDIgbikgKyAx77yM5q+P5bGC5LuO5bem5Yiw5Y+z77yJ77yM5YiZ5a+55Lu75LiA57uT54K577yIMTw9aTw9bu+8ieacie+8mlxuICogICAgICgxKeWmguaenGk9Me+8jOWImee7k+eCuWnjgIHmmK/kuozlj4nmoJHnmoTmoLnvvIzml6Dlj4zkurLvvJvlpoLmnpxpPjHvvIzliJnlhbblj4zkurJwYXJlbnQoaSnmmK/nu5PngrlNYXRoLmZsb29yKGkvMinjgIJcbiAqICAgICAoMinlpoLmnpwyaSA+IG7vvIzliJnnu5Pngrlp5peg5bem5a2p5a2Q77yI57uT54K5aeS4uuWPtuWtkOe7k+eCue+8ie+8m+WQpuWImeWFtuW3puWtqeWtkExDaGlsZChpKeaYr+e7k+eCuTJpLlxuICogICAgICgzKeWmguaenDJpICsgMSA+IG7vvIzliJnnu5Pngrlp5peg5Y+z5a2p5a2Q77yb5ZCm5YiZ5YW25Y+z5a2p5a2QUkNoaWxkKGkp5piv57uT54K5MmkgKyAxO1xuICovXG5cbi8qXG4g5LqM5Y+J5qCR55qE5a2Y5YKo57uT5p6EXG5cbiAxLumhuuW6j+WtmOWCqOe7k+aehFxuIOeUqOS4gOe7hOi/nue7reeahOWtmOWCqOWNleWFg+S+neasoeiHquS4iuiAjOS4i++8jOiHquW3puiHs+WPs+WtmOWCqOWujOWFqOS6jOWPieagkeS4iueahOe7k+eCueWFg+e0oO+8jOWNs+WwhuS6jOWPieagkeS4iue8luWPt+S4umnnmoTnu5PngrnlhYPntKDlrZjlgqjlnKjliqDkuIrlrprkuYnnmoTkuIDnu7TmlbDnu4TkuK3kuIvmoIfkuLppLTHnmoTliIbph4/kuK3jgILigJww4oCd6KGo56S65LiN5a2Y5Zyo5q2k57uT54K544CC6L+Z56eN6aG65bqP5a2Y5YKo57uT5p6E5LuF6YCC55So5LqO5a6M5YWo5LqM5Y+J5qCR44CCXG4g5Zug5Li677yM5Zyo5pyA5Z2P5oOF5Ya15LiL77yM5LiA5Liq5rex5bqm5Li6a+S4lOWPquaciWvkuKrnu5PngrnnmoTljZXmlK/moJHvvIjmoJHkuK3kuI3lrZjlnKjluqbkuLoy55qE57uT54K577yJ5Y206ZyA6KaB6ZW/5bqm5Li6MueahG7mrKHmlrktMeeahOS4gOe7tOaVsOe7hOOAglxuXG4gMi7pk77lvI/lrZjlgqjnu5PmnoRcbiDkuozlj4nmoJHnmoTnu5PngrnnlLHkuIDkuKrmlbDmja7lhYPntKDlkozliIbliKvmjIflkJHlhbblt6blj7PlrZDmoJHnmoTkuKTkuKrliIbmlK/mnoTmiJDvvIzliJnooajnpLrkuozlj4nmoJHnmoTpk77ooajkuK3nmoTnu5Pngrnoh7PlsJHljIXlkKvkuInkuKrln5/vvJrmlbDmja7ln5/lkozlt6blj7PmjIfpkojln5/jgILmnInml7bvvIzkuLrkuobkvr/kuo7mib7liLDnu5PngrnnmoTlj4zkurLvvIzliJnov5jlj6/lnKjnu5Pngrnnu5PmnoTkuK3lop7liqDkuIDkuKrmjIflkJHlhbblj4zkurLnu5PngrnnmoTmjIfpkojln5/jgILliKnnlKjov5nkuKTnp43nu5PmnoTmiYDlvpfnmoTkuozlj4nmoJHnmoTlrZjlgqjnu5PmnoTliIbliKvnp7DkuYvkuLrkuozlj4npk77ooajlkozkuInlj4npk77ooajjgIJcbiDlnKjlkKvmnIlu5Liq57uT54K555qE5LqM5Y+J6ZO+6KGo5Lit5pyJbisx5Liq56m66ZO+5Z+f77yM5oiR5Lus5Y+v5Lul5Yip55So6L+Z5Lqb56m66ZO+5Z+f5a2Y5YKo5YW25LuW5pyJ55So5L+h5oGv77yM5LuO6ICM5b6X5Yiw5Y+m5LiA56eN6ZO+5byP5a2Y5YKo57uT5p6ELS0t57q/57Si6ZO+6KGo44CCXG5cbiDlhYjvvIjmoLnvvInluo/pgY3ljobvvJrmoLnlt6blj7NcbiDkuK3vvIjmoLnvvInluo/pgY3ljobvvJrlt6bmoLnlj7NcbiDlkI7vvIjmoLnvvInluo/pgY3ljobvvJrlt6blj7PmoLlcblxuICovXG5cbmltcG9ydCBTdGFjayBmcm9tICcuLi9TdGFjay9pbmRleCc7XG5pbXBvcnQgUXVldWUgZnJvbSAnLi4vUXVldWUvUXVldWUnO1xuXG4vLyDpk77lvI/lrZjlgqjnu5PmnoRcbmV4cG9ydCBjbGFzcyBCaW5hcnlUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgbGVmdENoaWxkID0gbnVsbCwgcmlnaHRDaGlsZCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgLy8g5bem5Y+z5a2p5a2Q57uT54K5XG4gICAgICAgIHRoaXMubGVmdENoaWxkID0gbGVmdENoaWxkO1xuICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQgPSByaWdodENoaWxkO1xuICAgIH1cblxuICAgIC8vIOWIpOaWreS4pOajteagkeaYr+WQpuebuOS8vFxuICAgIGlzU2ltaWxhcih0cmVlKSB7XG4gICAgICAgIHJldHVybiAhISh0cmVlICYmXG4gICAgICAgICAgICAoKHRoaXMubGVmdENoaWxkICYmIHRoaXMubGVmdENoaWxkLmlzU2ltaWxhcih0cmVlLmxlZnRDaGlsZCkpIHx8ICghdGhpcy5sZWZ0Q2hpbGQgJiYgIXRyZWUubGVmdENoaWxkKSkgJiZcbiAgICAgICAgICAgICgodGhpcy5yaWdodENoaWxkICYmIHRoaXMucmlnaHRDaGlsZC5pc1NpbWlsYXIodHJlZS5yaWdodENoaWxkKSkgfHwgKCF0aGlzLnJpZ2h0Q2hpbGQgJiYgIXRyZWUucmlnaHRDaGlsZCkpKTtcbiAgICB9XG5cbiAgICBjcmVhdGVCaW5hcnlUcmVlKHRyZWUpIHtcbiAgICAgICAgdm9pZCBmdW5jdGlvbiBwcmVPcmRlclJlY3Vyc2l2ZShub2RlLCB4LCB2aXNpdCkge1xuICAgICAgICAgICAgdmlzaXQobm9kZSwgdHJlZVt4XSk7XG5cbiAgICAgICAgICAgIGxldCBwO1xuICAgICAgICAgICAgaWYgKHRyZWVbMiAqIHggKyAxXSkge1xuICAgICAgICAgICAgICAgIHAgPSBub2RlLmxlZnRDaGlsZCA9IG5ldyBCaW5hcnlUcmVlKCk7XG4gICAgICAgICAgICAgICAgcHJlT3JkZXJSZWN1cnNpdmUocCwgMiAqIHggKyAxLCB2aXNpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJlZVsyICogeCArIDJdKSB7XG4gICAgICAgICAgICAgICAgcCA9IG5vZGUucmlnaHRDaGlsZCA9IG5ldyBCaW5hcnlUcmVlKCk7XG4gICAgICAgICAgICAgICAgcHJlT3JkZXJSZWN1cnNpdmUocCwgMiAqIHggKyAyLCB2aXNpdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwKSBwLnBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgICB9KHRoaXMsIDAsIChub2RlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIOagueaNrnR5cGXnsbvlnovkvb/nlKjkuI3lkIzpobrluo/ov63ku6PvvIzpu5jorqTliY3luo/pgY3ljoZcbiAgICAgKiAxOiDliY3luo8gMjog5Lit5bqPIDM6IOWQjuW6j1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpdGVyYXRvclR5cGVcbiAgICAgKiBcbiAgICAgKiBAbWVtYmVyT2YgQmluYXJ5VHJlZVxuICAgICAqL1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXShpdGVyYXRvclR5cGUgPSAxKSB7XG4gICAgICAgIHN3aXRjaCAoaXRlcmF0b3JUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnRDaGlsZCkgeWllbGQqIHRoaXMubGVmdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHlpZWxkKiB0aGlzLnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB5aWVsZCogdGhpcy5sZWZ0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHlpZWxkKiB0aGlzLnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB5aWVsZCogdGhpcy5sZWZ0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgeWllbGQqIHRoaXMucmlnaHRDaGlsZDtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIOWFiOW6j+mBjeWOhuS6jOWPieagkeeahOmdnumAkuW9kueul+azlVxuICAgIHByZU9yZGVyTm9uUmVjdXJzaXZlKHZpc2l0KSB7XG4gICAgICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG5cbiAgICAgICAgd2hpbGUgKHAgfHwgc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyDlkJHlt6botbDliLDlsL3lpLRcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChwKTtcbiAgICAgICAgICAgICAgICBwLmRhdGEgJiYgdmlzaXQocC5kYXRhKTtcbiAgICAgICAgICAgICAgICBwID0gcC5sZWZ0Q2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBwID0gcC5yaWdodENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g5Lit5bqP6Z2e6YCS5b2S6YGN5Y6GXG4gICAgaW5PcmRlck5vblJlY3Vyc2l2ZSh2aXNpdCkge1xuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xuXG4gICAgICAgIHdoaWxlIChwIHx8IHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHApO1xuICAgICAgICAgICAgICAgIHAgPSBwLmxlZnRDaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHAuZGF0YSAmJiB2aXNpdChwLmRhdGEpO1xuICAgICAgICAgICAgICAgIHAgPSBwLnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDkuLrkuobljLrliIbkuKTmrKHov4fmoIjnmoTkuI3lkIzlpITnkIbmlrnlvI/vvIzlnKjloIbmoIjkuK3lop7liqDkuIDkuKptYXJr5Z+f77yMXG4gICAgLy8gbWFyaz0w6KGo56S65Yia5Yia6K6/6Zeu5q2k57uT54K577yMbWFyaz0x6KGo56S65bem5a2Q5qCR5aSE55CG57uT5p2f6L+U5Zue77yMXG4gICAgLy8gbWFyaz0y6KGo56S65Y+z5a2Q5qCR5aSE55CG57uT5p2f6L+U5Zue44CC5q+P5qyh5qC55o2u5qCI6aG255qEbWFya+Wfn+WGs+WumuWBmuS9leWKqOS9nFxuICAgIHBvc3RPcmRlck5vblJlY3Vyc2l2ZSh2aXNpdCkge1xuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgICAgc3RhY2sucHVzaChbdGhpcywgMF0pO1xuXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBhID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGFbMF07XG5cbiAgICAgICAgICAgIHN3aXRjaCAoYVsxXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChbbm9kZSwgMV0pOyAgLy8g5L+u5pS5bWFya+Wfn1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWZ0Q2hpbGQpIHN0YWNrLnB1c2goW25vZGUubGVmdENoaWxkLCAwXSk7ICAvLyDorr/pl67lt6blrZDmoJFcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFtub2RlLCAyXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJpZ2h0Q2hpbGQpIHN0YWNrLnB1c2goW25vZGUucmlnaHRDaGlsZCwgMF0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSAmJiB2aXNpdChub2RlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByZU9yZGVyUmVjdXJzaXZlKHZpc2l0KSB7XG4gICAgICAgIHZpc2l0KHRoaXMuZGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmxlZnRDaGlsZCkgdGhpcy5sZWZ0Q2hpbGQucHJlT3JkZXJSZWN1cnNpdmUodmlzaXQpO1xuICAgICAgICBpZiAodGhpcy5yaWdodENoaWxkKSB0aGlzLnJpZ2h0Q2hpbGQucHJlT3JkZXJSZWN1cnNpdmUodmlzaXQpO1xuICAgIH1cblxuICAgIGluT3JkZXJSZWN1cnNpdmUodmlzaXQpIHtcbiAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZC5pbk9yZGVyUmVjdXJzaXZlKHZpc2l0KTtcbiAgICAgICAgdmlzaXQodGhpcy5kYXRhKTtcbiAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkLmluT3JkZXJSZWN1cnNpdmUodmlzaXQpO1xuICAgIH1cblxuICAgIHBvc3RPcmRlclJlY3Vyc2l2ZSh2aXNpdCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0Q2hpbGQpIHRoaXMubGVmdENoaWxkLnBvc3RPcmRlclJlY3Vyc2l2ZSh2aXNpdCk7XG4gICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpIHRoaXMucmlnaHRDaGlsZC5wb3N0T3JkZXJSZWN1cnNpdmUodmlzaXQpO1xuICAgICAgICB2aXNpdCh0aGlzLmRhdGEpO1xuICAgIH1cblxuICAgIGxldmVsT3JkZXJUcmF2ZXJzZSh2aXNpdCkge1xuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgcXVldWUuZW5RdWV1ZSh0aGlzKTtcblxuICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xuICAgICAgICAgICAgbGV0IHAgPSBxdWV1ZS5kZVF1ZXVlKCk7XG4gICAgICAgICAgICBwLmRhdGEgJiYgdmlzaXQocC5kYXRhKTtcbiAgICAgICAgICAgIHAubGVmdENoaWxkICYmIHF1ZXVlLmVuUXVldWUocC5sZWZ0Q2hpbGQpO1xuICAgICAgICAgICAgcC5yaWdodENoaWxkICYmIHF1ZXVlLmVuUXVldWUocC5yaWdodENoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIOaxguWFiOW6j+W6j+WIl+S4umvnmoTnu5PngrnnmoTlgLxcbiAgICBnZXRQcmVTZXF1ZW5jZShrKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGxldCBkYXRhID0gbnVsbDtcblxuICAgICAgICB2b2lkIGZ1bmN0aW9uIHJlY3Vyc2Uobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKytjb3VudCA9PT0gaylcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzZShub2RlLmxlZnRDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2Uobm9kZS5yaWdodENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0odGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLy8g5rGC5LqM5Y+J5qCR5Lit5Y+25a2Q57uT54K555qE5pWw55uuXG4gICAgY291bnRMZWF2ZXMoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByZWN1cnNlKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSkgcmV0dXJuIDA7XG4gICAgICAgICAgICBlbHNlIGlmICghbm9kZS5sZWZ0Q2hpbGQgJiYgIW5vZGUucmlnaHRDaGlsZCkgcmV0dXJuIDE7XG4gICAgICAgICAgICBlbHNlIHJldHVybiByZWN1cnNlKG5vZGUubGVmdENoaWxkKSArIHJlY3Vyc2Uobm9kZS5yaWdodENoaWxkKTtcbiAgICAgICAgfSh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyDkuqTmjaLmiYDmnInnu5PngrnnmoTlt6blj7PlrZDmoJFcbiAgICByZXZvbHV0ZUJpbmFyeVRyZWUoKSB7XG4gICAgICAgIFt0aGlzLmxlZnRDaGlsZCwgdGhpcy5yaWdodENoaWxkXSA9IFt0aGlzLnJpZ2h0Q2hpbGQsIHRoaXMubGVmdENoaWxkXTtcblxuICAgICAgICBpZiAodGhpcy5sZWZ0Q2hpbGQpIHRoaXMubGVmdENoaWxkLnJldm9sdXRlQmluYXJ5VHJlZSgpO1xuICAgICAgICBpZiAodGhpcy5yaWdodENoaWxkKSB0aGlzLnJpZ2h0Q2hpbGQucmV2b2x1dGVCaW5hcnlUcmVlKCk7XG4gICAgfVxuXG4gICAgcmV2b2x1dGVOb25SZWN1cnNpdmUoKSB7XG4gICAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgICBzdGFjay5wdXNoKHRoaXMpO1xuXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBbbm9kZS5sZWZ0Q2hpbGQsIG5vZGUucmlnaHRDaGlsZF0gPSBbbm9kZS5yaWdodENoaWxkLCBub2RlLmxlZnRDaGlsZF07XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlZnRDaGlsZCkgc3RhY2sucHVzaChub2RlLmxlZnRDaGlsZCk7XG4gICAgICAgICAgICBpZiAobm9kZS5yaWdodENoaWxkKSBzdGFjay5wdXNoKG5vZGUucmlnaHRDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDmsYLkuozlj4nmoJHkuK3ku6XlgLzkuLp455qE57uT54K55Li65qC555qE5a2Q5qCR5rex5bqmXG4gICAgZ2V0U3ViRGVwdGgoeCkge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgICAgc3RhY2sucHVzaCh0aGlzKTtcblxuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSB4KSB7XG4gICAgICAgICAgICAgICAgY291bnQgPSBub2RlLmdldERlcHRoKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmxlZnRDaGlsZCkgc3RhY2sucHVzaChub2RlLmxlZnRDaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucmlnaHRDaGlsZCkgc3RhY2sucHVzaChub2RlLnJpZ2h0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cblxuICAgIGdldERlcHRoKCkge1xuICAgICAgICBsZXQgbSA9IHRoaXMubGVmdENoaWxkICYmIHRoaXMubGVmdENoaWxkLmdldERlcHRoKCkgfHwgMDtcbiAgICAgICAgbGV0IG4gPSB0aGlzLnJpZ2h0Q2hpbGQgJiYgdGhpcy5yaWdodENoaWxkLmdldERlcHRoKCkgfHwgMDtcbiAgICAgICAgcmV0dXJuIChtID4gbiA/IG0gOiBuKSArIDE7XG4gICAgfVxuXG4gICAgLy8g5Yig6Zmk5omA5pyJ5Lul5YWD57SgeOS4uuagueeahOWtkOagkVxuICAgIGRlbFN1YlgoeCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhID09PSB4KSB7XG4gICAgICAgICAgICB0aGlzLmxlZnRDaGlsZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZC5kZWxTdWJYKHgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkLmRlbFN1YlgoeCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDpnZ7pgJLlvZLlpI3liLbkuozlj4nmoJFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiDmi7fotJ3ov4fnqIvkuK3kvJrmiafooYznmoTlm57osIPvvIzlj6/ku6XnlKjmnaXmi7fotJ3lhbblroPoh6rlrprkuYnlsZ7mgKdcbiAgICAgKiBAcmV0dXJucyB7Q3N0cn0g6L+U5Zue5paw55qE5a6e5L6LXG4gICAgICovXG4gICAgY29weShjYiA9IGZ1bmN0aW9uICgpIHsgfSkge1xuICAgICAgICAvLyDnlKjmnaXlrZjmlL7mnKzkvZPnu5PngrnnmoTmoIhcbiAgICAgICAgbGV0IHN0YWNrMSA9IG5ldyBTdGFjaygpO1xuICAgICAgICAvLyDnlKjmnaXlrZjmlL7mlrDkuozlj4nmoJHnu5PngrnnmoTmoIhcbiAgICAgICAgbGV0IHN0YWNrMiA9IG5ldyBTdGFjaygpO1xuICAgICAgICBzdGFjazEucHVzaCh0aGlzKTtcbiAgICAgICAgbGV0IENzdHIgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICBsZXQgbmV3VHJlZSA9IG5ldyBDc3RyKCk7XG4gICAgICAgIGxldCBxID0gbmV3VHJlZTtcbiAgICAgICAgc3RhY2syLnB1c2gobmV3VHJlZSk7XG4gICAgICAgIGxldCBwO1xuXG4gICAgICAgIHdoaWxlIChzdGFjazEubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyDlkJHlt6botbDliLDlsL3lpLRcbiAgICAgICAgICAgIHdoaWxlICgocCA9IHN0YWNrMS5wZWVrKCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAubGVmdENoaWxkKSBxLmxlZnRDaGlsZCA9IG5ldyBDc3RyKCk7XG4gICAgICAgICAgICAgICAgcSA9IHEubGVmdENoaWxkO1xuICAgICAgICAgICAgICAgIHN0YWNrMS5wdXNoKHAubGVmdENoaWxkKTtcbiAgICAgICAgICAgICAgICBzdGFjazIucHVzaChxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IHN0YWNrMS5wb3AoKTtcbiAgICAgICAgICAgIHEgPSBzdGFjazIucG9wKCk7XG5cbiAgICAgICAgICAgIGlmIChzdGFjazEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcCA9IHN0YWNrMS5wb3AoKTtcbiAgICAgICAgICAgICAgICBxID0gc3RhY2syLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChwLnJpZ2h0Q2hpbGQpIHEucmlnaHRDaGlsZCA9IG5ldyBDc3RyKCk7XG4gICAgICAgICAgICAgICAgcS5kYXRhID0gcC5kYXRhO1xuICAgICAgICAgICAgICAgIGNiKHEsIHApO1xuICAgICAgICAgICAgICAgIHEgPSBxLnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgc3RhY2sxLnB1c2gocC5yaWdodENoaWxkKTsgIC8vIOWQkeWPs+S4gOatpVxuICAgICAgICAgICAgICAgIHN0YWNrMi5wdXNoKHEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld1RyZWU7XG4gICAgfVxuXG4gICAgLy8g5rGC5LqM5Y+J5qCR5Lit57uT54K5cOWSjHHnmoTmnIDov5HnpZblhYhcbiAgICBmaW5kTmVhckFuY2llbnQocE5vZGUsIHFOb2RlKSB7XG4gICAgICAgIGxldCBwYXRoUCA9IGZpbmRQYXRoKHRoaXMsIHBOb2RlLCAwKTtcbiAgICAgICAgbGV0IHBhdGhRID0gZmluZFBhdGgodGhpcywgcU5vZGUsIDApO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBwYXRoUFtpXSA9PSBwYXRoUVtpXSAmJiBwYXRoUFtpXTsgaSsrKTtcbiAgICAgICAgcmV0dXJuIHBhdGhQWy0taV07XG4gICAgfVxuXG4gICAgLy8gdG9kb1xuICAgIHRvU3RyaW5nKCkge1xuICAgIH1cblxuICAgIC8vIOaxguS4gOajteS6jOWPieagkeeahOe5geiMguW6plxuICAgIGx1c2hEZWdyZWUoKSB7XG4gICAgICAgIGxldCBjb3VudEFyciA9IFtdO1xuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgcXVldWUuZW5RdWV1ZSh7XG4gICAgICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICAgICAgbGF5ZXI6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIOWIqeeUqOWxguW6j+mBjeWOhuadpee7n+iuoeWQhOWxgueahOe7k+eCueaVsFxuICAgICAgICBsZXQgcjtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLnJlYXIpIHtcbiAgICAgICAgICAgIHIgPSBxdWV1ZS5kZVF1ZXVlKCk7XG4gICAgICAgICAgICBjb3VudEFycltyLmxheWVyXSA9IChjb3VudEFycltyLmxheWVyXSB8fCAwKSArIDE7XG5cbiAgICAgICAgICAgIGlmIChyLm5vZGUubGVmdENoaWxkKVxuICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUoe1xuICAgICAgICAgICAgICAgICAgICBub2RlOiByLm5vZGUubGVmdENoaWxkLFxuICAgICAgICAgICAgICAgICAgICBsYXllcjogci5sYXllciArIDFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyLm5vZGUucmlnaHRDaGlsZClcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogci5ub2RlLnJpZ2h0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiByLmxheWVyICsgMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5pyA5ZCO5LiA5Liq6Zif5YiX5YWD57Sg5omA5Zyo5bGC5bCx5piv5qCR55qE6auY5bqmXG4gICAgICAgIGxldCBoZWlnaHQgPSByLmxheWVyO1xuICAgICAgICBsZXQgbWF4ID0gY291bnRBcnJbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBjb3VudEFycltpXTsgaSsrKVxuICAgICAgICAgICAgLy8g5rGC5bGC5pyA5aSn57uT54K55pWwXG4gICAgICAgICAgICBpZiAoY291bnRBcnJbaV0gPiBtYXgpIG1heCA9IGNvdW50QXJyW2ldO1xuXG4gICAgICAgIHJldHVybiBoZWlnaHQgKiBtYXg7XG4gICAgfVxuXG4gICAgLy8g5rGC5qCR57uT54K555qE5a2Q5a2Z5oC75pWw5aGr5YWlZGVzY051beWtl+auteS4re+8jOW5tui/lOWbnlxuICAgIGRlc2NOdW0oKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiByZWN1cnNlKG5vZGUpIHtcbiAgICAgICAgICAgIGxldCBkO1xuICAgICAgICAgICAgaWYgKCFub2RlKSByZXR1cm4gLTE7XG4gICAgICAgICAgICBlbHNlIGQgPSByZWN1cnNlKG5vZGUubGVmdENoaWxkKSArIHJlY3Vyc2Uobm9kZS5yaWdodENoaWxkKSArIDI7XG5cbiAgICAgICAgICAgIG5vZGUuZGVzY051bSA9IGQ7XG5cbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KHRoaXMpO1xuICAgIH1cblxuICAgIC8vIOWIpOaWreS6jOWPieagkeaYr+WQpuWujOWFqOS6jOWPieagkVxuICAgIHN0YXRpYyBpc0Z1bGxCaW5hcnlUcmVlKHRyZWUpIHtcbiAgICAgICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gICAgICAgIGxldCBmbGFnID0gMDtcbiAgICAgICAgcXVldWUuZW5RdWV1ZSh0cmVlKTtcblxuICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xuICAgICAgICAgICAgbGV0IHAgPSBxdWV1ZS5kZVF1ZXVlKCk7XG5cbiAgICAgICAgICAgIGlmICghcCkgZmxhZyA9IDE7XG4gICAgICAgICAgICBlbHNlIGlmIChmbGFnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHAubGVmdENoaWxkKTtcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHAucmlnaHRDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbi8vIOaxguS7jnRyZWXliLBub2Rl57uT54K56Lev5b6E55qE6YCS5b2S566X5rOVXG5mdW5jdGlvbiBmaW5kUGF0aCh0cmVlLCBub2RlLCBpID0gMCkge1xuICAgIGxldCBwYXRoID0gW107XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgICB2b2lkIGZ1bmN0aW9uIHJlY3Vyc2UodHJlZSwgaSkge1xuICAgICAgICBpZiAodHJlZSA9PSBub2RlKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoW2ldID0gdHJlZTtcbiAgICAgICAgaWYgKHRyZWUubGVmdENoaWxkKSByZWN1cnNlKHRyZWUubGVmdENoaWxkLCBpICsgMSk7XG4gICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQgJiYgIWZvdW5kKSByZWN1cnNlKHRyZWUucmlnaHRDaGlsZCwgaSArIDEpO1xuICAgICAgICBpZiAoIWZvdW5kKSBwYXRoW2ldID0gbnVsbDtcbiAgICB9KHRyZWUsIGkpO1xuXG4gICAgcmV0dXJuIHBhdGg7XG59XG5cbmxldCBnbG9iYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXM7JykoKTtcblxuLy8g5rGC5rex5bqm562J5LqO5qCR55qE6auY5bqm5YeP5LiA55qE5pyA6Z2g5bem55qE57uT54K5XG5mdW5jdGlvbiBwcmludFBhdGhfbWF4RGVwdGhTMSh0cmVlKSB7XG4gICAgbGV0IG1heGggPSB0cmVlLmdldERlcHRoKCk7XG4gICAgbGV0IHBhdGggPSBbXTtcblxuICAgIGlmIChtYXhoIDwgMikgcmV0dXJuIGZhbHNlO1xuICAgIGZpbmRfaCh0cmVlLCAxKTtcblxuICAgIGZ1bmN0aW9uIGZpbmRfaCh0cmVlLCBoKSB7XG4gICAgICAgIHBhdGhbaF0gPSB0cmVlO1xuXG4gICAgICAgIGlmIChoID09IG1heGggLSAxKSB7XG4gICAgICAgICAgICBsZXQgcyA9ICcgJztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBwYXRoW2ldOyBpKyspIHMgKz0gcGF0aFtpXS5kYXRhICsgKHBhdGhbaSArIDFdID8gJyAtPiAnIDogJycpO1xuICAgICAgICAgICAgY29uc29sZS5sb2cocyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHJlZS5sZWZ0Q2hpbGQpIGZpbmRfaCh0cmVlLmxlZnRDaGlsZCwgaCArIDEpO1xuICAgICAgICAgICAgaWYgKHRyZWUucmlnaHRDaGlsZCkgZmluZF9oKHRyZWUucmlnaHRDaGlsZCwgaCArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aFtoXSA9IG51bGw7XG4gICAgfVxufVxuXG52YXIgdHJlZSA9IFsxLCAyLCAzLCA0LCA1LCAsIDYsICwgLCA3XTtcbnZhciB0ZXN0ID0gbmV3IEJpbmFyeVRyZWUoKTtcbnRlc3QuY3JlYXRlQmluYXJ5VHJlZSh0cmVlKTtcblxuY29uc29sZS5sb2coJ2l0ZXJhdG9yOiAnKTtcbmZvciAobGV0IHggb2YgdGVzdCkge1xuICAgIGNvbnNvbGUubG9nKHgpO1xufVxuXG5cbi8qKlxuICog5qCR55qEM+enjeW4uOeUqOmTvuihqOe7k+aehFxuICovXG5cbi8vIDEu5Y+M5Lqy6KGo56S65rOVXG4vLyDkvJjngrnvvJpwYXJlbnQodHJlZSwgeCnmk43kvZzlj6/ku6XlnKjluLjph4/ml7bpl7TlhoXlrp7njrBcbi8vIOe8uueCue+8muaxgue7k+eCueeahOWtqeWtkOaXtumcgOimgemBjeWOhuaVtOS4que7k+aehFxuZXhwb3J0IGNsYXNzIFBhcmVudFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgfVxuXG4gICAgZ2V0RGVwdGgoKSB7XG4gICAgICAgIGxldCBtYXhEZXB0aCA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZGVwID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqID49IDA7IGogPSB0aGlzLm5vZGVzW2ldLnBhcmVudCkgZGVwKys7XG4gICAgICAgICAgICBpZiAoZGVwID4gbWF4RGVwdGgpIG1heERlcHRoID0gZGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heERlcHRoO1xuICAgIH1cbn1cblxuY2xhc3MgUGFyZW50VHJlZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEgPSBudWxsLCBwYXJlbnQgPSAwKSB7XG4gICAgICAgIC8vIHR5cGU6IFBhcmVudFRyZWVcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgLy8g5Y+M5Lqy5L2N572u5Z+fIHtOdW1iZXJ9XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbn1cblxubGV0IHB0ID0gbmV3IFBhcmVudFRyZWUoKTtcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdSJywgLTEpKTtcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdBJywgMCkpO1xucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0InLCAwKSk7XG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnQycsIDApKTtcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdEJywgMSkpO1xucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0UnLCAxKSk7XG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnRicsIDMpKTtcbnB0Lm5vZGVzLnB1c2gobmV3IFBhcmVudFRyZWVOb2RlKCdHJywgNikpO1xucHQubm9kZXMucHVzaChuZXcgUGFyZW50VHJlZU5vZGUoJ0gnLCA2KSk7XG5wdC5ub2Rlcy5wdXNoKG5ldyBQYXJlbnRUcmVlTm9kZSgnSScsIDYpKTtcblxuXG4vLyDlranlrZDooajnpLrms5VcblxuZXhwb3J0IGNsYXNzIENoaWxkVHJlZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBnZXREZXB0aCgpIHtcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3ViRGVwdGgocm9vdEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYubm9kZXNbcm9vdEluZGV4XSkgcmV0dXJuIDE7XG5cbiAgICAgICAgICAgIGxldCBzZCA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCBwID0gc2VsZi5ub2Rlc1tyb290SW5kZXhdOyBwOyBwID0gcC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGQgPSBzdWJEZXB0aChwLmNoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoZCA+IHNkKSBzZCA9IGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZCArIDE7XG4gICAgICAgIH0odGhpcy5kYXRhWzBdKTtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqIEBwYXJhbSB7Q2hpbGRUcmVlTm9kZX0gZmlyc3RDaGlsZCDlranlrZDpk77ooajlpLTmjIfpkohcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBDaGlsZFRyZWVCb3gge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEgPSBudWxsLCBmaXJzdENoaWxkID0gbnVsbCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkO1xuICAgIH1cbn1cblxuLyoqXG4gKiDlranlrZDnu5PngrlcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY2hpbGRcbiAqIEBwYXJhbSB7Q2hpbGRUcmVlTm9kZX0gbmV4dFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIENoaWxkVHJlZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkID0gbnVsbCwgbmV4dCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGlsZCA9IGNoaWxkO1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIH1cbn1cblxuLypcbiDlranlrZDooajnpLrms5Xkvr/kuo7mtonlj4rlranlrZDnmoTmk43kvZznmoTlrp7njrDvvIzkvYbkuI3pgILnlKjkuo5wYXJlbnTmk43kvZzjgIJcbiDmiJHku6zlj6/ku6Xmiorlj4zkurLooajnpLrms5XlkozlranlrZDooajnpLrms5Xnu5PlkIjotbfmnaXjgIJcbiAqL1xuXG5cbi8vIOWtqeWtkOWFhOW8n+ihqOekuuazlSjkuozlj4nmoJHooajnpLrms5UpXG4vLyDlj6/lop7orr7kuIDkuKpwYXJlbnTln5/lrp7njrBwYXJlbnTmk43kvZxcbmV4cG9ydCBjbGFzcyBDaGlsZFNpYmxpbmdUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgZmlyc3RDaGlsZCA9IG51bGwsIG5leHRTaWJsaW5nID0gbnVsbCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkO1xuICAgICAgICB0aGlzLm5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmc7XG4gICAgfVxuXG4gICAgLy8g6L6T5Ye65a2p5a2Q5YWE5byf6ZO+6KGo6KGo56S655qE5qCR55qE5ZCE6L65XG4gICAgcHJpbnQoKSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gdGhpcy5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJyVjICVjJywgdGhpcy5kYXRhLCBjaGlsZC5kYXRhKTtcbiAgICAgICAgICAgIGNoaWxkLnByaW50KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDmsYLlranlrZDlhYTlvJ/pk77ooajooajnpLrnmoTmoJHnmoTlj7blrZDmlbDnm65cbiAgICBsZWFmQ291bnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5maXJzdENoaWxkKSByZXR1cm4gMTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgPSB0aGlzLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gY2hpbGQubGVhZkNvdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDmsYLmoJHnmoTluqZcbiAgICBnZXREZWdyZWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5maXJzdENoaWxkKSByZXR1cm4gMDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGVncmVlID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLmZpcnN0Q2hpbGQ7IHA7IHAgPSBwLm5leHRTaWJsaW5nKSBkZWdyZWUrKztcblxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMuZmlyc3RDaGlsZDsgcDsgcCA9IHAubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgZCA9IHAuZ2V0RGVncmVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGQgPiBkZWdyZWUpIGRlZ3JlZSA9IGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZWdyZWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXREZXB0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IGdsb2JhbCkgcmV0dXJuIDA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1heGQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMuZmlyc3RDaGlsZDsgcDsgcCA9IHAubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgZCA9IHAuZ2V0RGVwdGgoKTtcbiAgICAgICAgICAgICAgICBpZiAoZCA+IG1heGQpIG1heGQgPSBkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF4ZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQmluYXJ5VHJlZS9CaW5hcnlUcmVlLmpzIiwiLyoqXG4gKiDmoIhcbiAqXG4gKiDmmK/pmZDlrprku4XlnKjooajlsL7ov5vooYzmj5LlhaXmiJbliKDpmaTmk43kvZznmoTnur/mgKfooajjgILooajlsL7kuLrmoIjpobbvvIh0b3DvvInvvIzooajlpLTkuLrmoIjlupXvvIhib3R0b23vvInvvIzkuI3lkKvlhYPntKDnmoTnqbrooajkuLrnqbrmoIjjgIJcbiAqIOagiOWPiOensOS4uuWQjui/m+WFiOWHuu+8iGxhc3QgaW4gZmlyc3Qgb3V077yJ55qE57q/5oCn6KGo44CCXG4gKi9cblxuLyoqXG4gKiDpobrluo/moIhcbiAqIOagiOeahOmhuuW6j+WtmOWCqOe7k+aehOaYr+WIqeeUqOS4gOe7hOWcsOWdgOi/nue7reeahOWtmOWCqOWNleWFg+S+neasoeWtmOaUvuiHs+agiOW6leWIsOagiOmhtueahOWFg+e0oO+8jOWQjOaXtumZhOiuvuaMh+mSiHRvcOaMh+ekuuagiOmhtuWFg+e0oOWcqOmhuuW6j+agiOS4reeahOS9jee9ruOAglxuICpcbiAqL1xuXG4vLyDmoIjnmoTpk77lvI/ooajnpLpcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50b3AgPSBudWxsO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgZ2V0IHNpemUoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlzRW1wdHkoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBwdXNoIChkYXRhKSB7XG4gICAgICAgIGxldCBub2RlID0ge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBub2RlLm5leHQgPSB0aGlzLnRvcDtcbiAgICAgICAgdGhpcy50b3AgPSBub2RlO1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICBwZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wID09PSBudWxsID9cbiAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgdGhpcy50b3AuZGF0YTtcbiAgICB9XG4gICAgcG9wICgpIHtcbiAgICAgICAgaWYgKHRoaXMudG9wID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBsZXQgb3V0ID0gdGhpcy50b3A7XG4gICAgICAgIHRoaXMudG9wID0gdGhpcy50b3AubmV4dDtcblxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLmxlbmd0aC0tO1xuICAgICAgICBcblxuICAgICAgICByZXR1cm4gb3V0LmRhdGE7XG4gICAgfVxuICAgIGNsZWFyICgpIHtcbiAgICAgICAgdGhpcy50b3AgPSBudWxsO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgICAgaWYgKHRoaXMudG9wID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBsZXQgYXJyID0gW107XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy50b3A7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuc2l6ZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBjdXJyZW50LmRhdGE7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU3RhY2svaW5kZXguanMiLCJ2YXIgYXNuMSA9IGV4cG9ydHM7XG5cbmFzbjEuYmlnbnVtID0gcmVxdWlyZSgnYm4uanMnKTtcblxuYXNuMS5kZWZpbmUgPSByZXF1aXJlKCcuL2FzbjEvYXBpJykuZGVmaW5lO1xuYXNuMS5iYXNlID0gcmVxdWlyZSgnLi9hc24xL2Jhc2UnKTtcbmFzbjEuY29uc3RhbnRzID0gcmVxdWlyZSgnLi9hc24xL2NvbnN0YW50cycpO1xuYXNuMS5kZWNvZGVycyA9IHJlcXVpcmUoJy4vYXNuMS9kZWNvZGVycycpO1xuYXNuMS5lbmNvZGVycyA9IHJlcXVpcmUoJy4vYXNuMS9lbmNvZGVycycpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FzbjEuanMvbGliL2FzbjEuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlID0gZXhwb3J0cztcblxuYmFzZS5SZXBvcnRlciA9IHJlcXVpcmUoJy4vcmVwb3J0ZXInKS5SZXBvcnRlcjtcbmJhc2UuRGVjb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJykuRGVjb2RlckJ1ZmZlcjtcbmJhc2UuRW5jb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJykuRW5jb2RlckJ1ZmZlcjtcbmJhc2UuTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FzbjEuanMvbGliL2FzbjEvYmFzZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4b3IgKGEsIGIpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXJbaV0gPSBhW2ldIF4gYltpXVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2J1ZmZlci14b3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBrZXksIG93biwgb3V0O1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG4gICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEM7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmKElTX1BST1RPKXtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZih0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKWhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBvbGRCcm93c2VyICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdzZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyXFxudXNlIGNocm9tZSwgRmlyZUZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMScpXG59XG5cbnZhciBjcnlwdG8gPSBnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0b1xuXG5pZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByYW5kb21CeXRlc1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBvbGRCcm93c2VyXG59XG5cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzIChzaXplLCBjYikge1xuICAvLyBwaGFudG9tanMgbmVlZHMgdG8gdGhyb3dcbiAgaWYgKHNpemUgPiA2NTUzNikgdGhyb3cgbmV3IEVycm9yKCdyZXF1ZXN0ZWQgdG9vIG1hbnkgcmFuZG9tIGJ5dGVzJylcbiAgLy8gaW4gY2FzZSBicm93c2VyaWZ5ICBpc24ndCB1c2luZyB0aGUgVWludDhBcnJheSB2ZXJzaW9uXG4gIHZhciByYXdCeXRlcyA9IG5ldyBnbG9iYWwuVWludDhBcnJheShzaXplKVxuXG4gIC8vIFRoaXMgd2lsbCBub3Qgd29yayBpbiBvbGRlciBicm93c2Vycy5cbiAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICBpZiAoc2l6ZSA+IDApIHsgIC8vIGdldFJhbmRvbVZhbHVlcyBmYWlscyBvbiBJRSBpZiBzaXplID09IDBcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJhd0J5dGVzKVxuICB9XG4gIC8vIHBoYW50b21qcyBkb2Vzbid0IGxpa2UgYSBidWZmZXIgYmVpbmcgcGFzc2VkIGhlcmVcbiAgdmFyIGJ5dGVzID0gbmV3IEJ1ZmZlcihyYXdCeXRlcy5idWZmZXIpXG5cbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG51bGwsIGJ5dGVzKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYW5kb21ieXRlcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENyZWF0ZWQgYnkgbGRwIG9uIDIwMTUvNC8xMi5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU29ydC9kZWZhdWx0Q29tcGFyaXNpb24uanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGJhc2VkIG9uIHRoZSBhZXMgaW1wbGltZW50YXRpb24gaW4gdHJpcGxlIHNlY1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2tleWJhc2UvdHJpcGxlc2VjXG5cbi8vIHdoaWNoIGlzIGluIHR1cm4gYmFzZWQgb24gdGhlIG9uZSBmcm9tIGNyeXB0by1qc1xuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvXG5cbnZhciB1aW50X21heCA9IE1hdGgucG93KDIsIDMyKVxuZnVuY3Rpb24gZml4dXBfdWludDMyICh4KSB7XG4gIHZhciByZXQsIHhfcG9zXG4gIHJldCA9IHggPiB1aW50X21heCB8fCB4IDwgMCA/ICh4X3BvcyA9IE1hdGguYWJzKHgpICUgdWludF9tYXgsIHggPCAwID8gdWludF9tYXggLSB4X3BvcyA6IHhfcG9zKSA6IHhcbiAgcmV0dXJuIHJldFxufVxuZnVuY3Rpb24gc2NydWJfdmVjICh2KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IHYrKykge1xuICAgIHZbaV0gPSAwXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIEdsb2JhbCAoKSB7XG4gIHRoaXMuU0JPWCA9IFtdXG4gIHRoaXMuSU5WX1NCT1ggPSBbXVxuICB0aGlzLlNVQl9NSVggPSBbW10sIFtdLCBbXSwgW11dXG4gIHRoaXMuSU5WX1NVQl9NSVggPSBbW10sIFtdLCBbXSwgW11dXG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XVxufVxuXG5HbG9iYWwucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkLCBpLCBzeCwgdCwgeCwgeDIsIHg0LCB4OCwgeGksIF9pXG4gIGQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBfaSwgX3Jlc3VsdHNcbiAgICBfcmVzdWx0cyA9IFtdXG4gICAgZm9yIChpID0gX2kgPSAwOyBfaSA8IDI1NjsgaSA9ICsrX2kpIHtcbiAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgIF9yZXN1bHRzLnB1c2goaSA8PCAxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCgoaSA8PCAxKSBeIDB4MTFiKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHNcbiAgfSkoKVxuICB4ID0gMFxuICB4aSA9IDBcbiAgZm9yIChpID0gX2kgPSAwOyBfaSA8IDI1NjsgaSA9ICsrX2kpIHtcbiAgICBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpXG4gICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzXG4gICAgdGhpcy5TQk9YW3hdID0gc3hcbiAgICB0aGlzLklOVl9TQk9YW3N4XSA9IHhcbiAgICB4MiA9IGRbeF1cbiAgICB4NCA9IGRbeDJdXG4gICAgeDggPSBkW3g0XVxuICAgIHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApXG4gICAgdGhpcy5TVUJfTUlYWzBdW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpXG4gICAgdGhpcy5TVUJfTUlYWzFdW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KVxuICAgIHRoaXMuU1VCX01JWFsyXVt4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KVxuICAgIHRoaXMuU1VCX01JWFszXVt4XSA9IHRcbiAgICB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApXG4gICAgdGhpcy5JTlZfU1VCX01JWFswXVtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOClcbiAgICB0aGlzLklOVl9TVUJfTUlYWzFdW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNilcbiAgICB0aGlzLklOVl9TVUJfTUlYWzJdW3N4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KVxuICAgIHRoaXMuSU5WX1NVQl9NSVhbM11bc3hdID0gdFxuICAgIGlmICh4ID09PSAwKSB7XG4gICAgICB4ID0geGkgPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV1cbiAgICAgIHhpIF49IGRbZFt4aV1dXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbnZhciBHID0gbmV3IEdsb2JhbCgpXG5cbkFFUy5ibG9ja1NpemUgPSA0ICogNFxuXG5BRVMucHJvdG90eXBlLmJsb2NrU2l6ZSA9IEFFUy5ibG9ja1NpemVcblxuQUVTLmtleVNpemUgPSAyNTYgLyA4XG5cbkFFUy5wcm90b3R5cGUua2V5U2l6ZSA9IEFFUy5rZXlTaXplXG5cbmZ1bmN0aW9uIGJ1ZmZlclRvQXJyYXkgKGJ1Zikge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aCAvIDRcbiAgdmFyIG91dCA9IG5ldyBBcnJheShsZW4pXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGJ1Zi5yZWFkVUludDMyQkUoaSAqIDQpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuZnVuY3Rpb24gQUVTIChrZXkpIHtcbiAgdGhpcy5fa2V5ID0gYnVmZmVyVG9BcnJheShrZXkpXG4gIHRoaXMuX2RvUmVzZXQoKVxufVxuXG5BRVMucHJvdG90eXBlLl9kb1Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaW52S3NSb3csIGtleVNpemUsIGtleVdvcmRzLCBrc1Jvdywga3NSb3dzLCB0XG4gIGtleVdvcmRzID0gdGhpcy5fa2V5XG4gIGtleVNpemUgPSBrZXlXb3Jkcy5sZW5ndGhcbiAgdGhpcy5fblJvdW5kcyA9IGtleVNpemUgKyA2XG4gIGtzUm93cyA9ICh0aGlzLl9uUm91bmRzICsgMSkgKiA0XG4gIHRoaXMuX2tleVNjaGVkdWxlID0gW11cbiAgZm9yIChrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG4gICAgdGhpcy5fa2V5U2NoZWR1bGVba3NSb3ddID0ga3NSb3cgPCBrZXlTaXplID8ga2V5V29yZHNba3NSb3ddIDogKHQgPSB0aGlzLl9rZXlTY2hlZHVsZVtrc1JvdyAtIDFdLCAoa3NSb3cgJSBrZXlTaXplKSA9PT0gMCA/ICh0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpLCB0ID0gKEcuU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKEcuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKEcuU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IEcuU0JPWFt0ICYgMHhmZl0sIHQgXj0gRy5SQ09OWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQpIDoga2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0ID8gdCA9IChHLlNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChHLlNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChHLlNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBHLlNCT1hbdCAmIDB4ZmZdIDogdm9pZCAwLCB0aGlzLl9rZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdClcbiAgfVxuICB0aGlzLl9pbnZLZXlTY2hlZHVsZSA9IFtdXG4gIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3dcbiAgICB0ID0gdGhpcy5fa2V5U2NoZWR1bGVba3NSb3cgLSAoaW52S3NSb3cgJSA0ID8gMCA6IDQpXVxuICAgIHRoaXMuX2ludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0ID8gdCA6IEcuSU5WX1NVQl9NSVhbMF1bRy5TQk9YW3QgPj4+IDI0XV0gXiBHLklOVl9TVUJfTUlYWzFdW0cuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl1dIF4gRy5JTlZfU1VCX01JWFsyXVtHLlNCT1hbKHQgPj4+IDgpICYgMHhmZl1dIF4gRy5JTlZfU1VCX01JWFszXVtHLlNCT1hbdCAmIDB4ZmZdXVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbkFFUy5wcm90b3R5cGUuZW5jcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0pIHtcbiAgTSA9IGJ1ZmZlclRvQXJyYXkobmV3IEJ1ZmZlcihNKSlcbiAgdmFyIG91dCA9IHRoaXMuX2RvQ3J5cHRCbG9jayhNLCB0aGlzLl9rZXlTY2hlZHVsZSwgRy5TVUJfTUlYLCBHLlNCT1gpXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKDE2KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMF0sIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSwgNClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzJdLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDEyKVxuICByZXR1cm4gYnVmXG59XG5cbkFFUy5wcm90b3R5cGUuZGVjcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0pIHtcbiAgTSA9IGJ1ZmZlclRvQXJyYXkobmV3IEJ1ZmZlcihNKSlcbiAgdmFyIHRlbXAgPSBbTVszXSwgTVsxXV1cbiAgTVsxXSA9IHRlbXBbMF1cbiAgTVszXSA9IHRlbXBbMV1cbiAgdmFyIG91dCA9IHRoaXMuX2RvQ3J5cHRCbG9jayhNLCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgRy5JTlZfU1VCX01JWCwgRy5JTlZfU0JPWClcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzNdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSwgMTIpXG4gIHJldHVybiBidWZcbn1cblxuQUVTLnByb3RvdHlwZS5zY3J1YiA9IGZ1bmN0aW9uICgpIHtcbiAgc2NydWJfdmVjKHRoaXMuX2tleVNjaGVkdWxlKVxuICBzY3J1Yl92ZWModGhpcy5faW52S2V5U2NoZWR1bGUpXG4gIHNjcnViX3ZlYyh0aGlzLl9rZXkpXG59XG5cbkFFUy5wcm90b3R5cGUuX2RvQ3J5cHRCbG9jayA9IGZ1bmN0aW9uIChNLCBrZXlTY2hlZHVsZSwgU1VCX01JWCwgU0JPWCkge1xuICB2YXIga3NSb3csIHMwLCBzMSwgczIsIHMzLCB0MCwgdDEsIHQyLCB0M1xuXG4gIHMwID0gTVswXSBeIGtleVNjaGVkdWxlWzBdXG4gIHMxID0gTVsxXSBeIGtleVNjaGVkdWxlWzFdXG4gIHMyID0gTVsyXSBeIGtleVNjaGVkdWxlWzJdXG4gIHMzID0gTVszXSBeIGtleVNjaGVkdWxlWzNdXG4gIGtzUm93ID0gNFxuICBmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgdGhpcy5fblJvdW5kczsgcm91bmQrKykge1xuICAgIHQwID0gU1VCX01JWFswXVtzMCA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczEgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MzICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQxID0gU1VCX01JWFswXVtzMSA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczIgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczMgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MwICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQyID0gU1VCX01JWFswXVtzMiA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczMgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczAgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQzID0gU1VCX01JWFswXVtzMyA+Pj4gMjRdIF4gU1VCX01JWFsxXVsoczAgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWFsyXVsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYWzNdW3MyICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHMwID0gdDBcbiAgICBzMSA9IHQxXG4gICAgczIgPSB0MlxuICAgIHMzID0gdDNcbiAgfVxuICB0MCA9ICgoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQxID0gKChTQk9YW3MxID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MwICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDIgPSAoKFNCT1hbczIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MyA9ICgoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHJldHVybiBbXG4gICAgZml4dXBfdWludDMyKHQwKSxcbiAgICBmaXh1cF91aW50MzIodDEpLFxuICAgIGZpeHVwX3VpbnQzMih0MiksXG4gICAgZml4dXBfdWludDMyKHQzKVxuICBdXG59XG5cbmV4cG9ydHMuQUVTID0gQUVTXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvYWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzWydhZXMtMTI4LWVjYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDAsXG4gIG1vZGU6ICdFQ0InLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMtMTkyLWVjYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDE5MixcbiAgaXY6IDAsXG4gIG1vZGU6ICdFQ0InLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMtMjU2LWVjYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDAsXG4gIG1vZGU6ICdFQ0InLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMtMTI4LWNiYyddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0JDJyxcbiAgdHlwZTogJ2Jsb2NrJ1xufVxuZXhwb3J0c1snYWVzLTE5Mi1jYmMnXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxOTIsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NCQycsXG4gIHR5cGU6ICdibG9jaydcbn1cbmV4cG9ydHNbJ2Flcy0yNTYtY2JjJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMjU2LFxuICBpdjogMTYsXG4gIG1vZGU6ICdDQkMnLFxuICB0eXBlOiAnYmxvY2snXG59XG5leHBvcnRzWydhZXMxMjgnXSA9IGV4cG9ydHNbJ2Flcy0xMjgtY2JjJ11cbmV4cG9ydHNbJ2FlczE5MiddID0gZXhwb3J0c1snYWVzLTE5Mi1jYmMnXVxuZXhwb3J0c1snYWVzMjU2J10gPSBleHBvcnRzWydhZXMtMjU2LWNiYyddXG5leHBvcnRzWydhZXMtMTI4LWNmYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0ZCJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xOTItY2ZiJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDRkInLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTI1Ni1jZmInXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAyNTYsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NGQicsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWNmYjgnXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxMjgsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NGQjgnLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTE5Mi1jZmI4J10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDRkI4JyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0yNTYtY2ZiOCddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0ZCOCcsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWNmYjEnXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAxMjgsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NGQjEnLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTE5Mi1jZmIxJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDRkIxJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0yNTYtY2ZiMSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ0ZCMScsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LW9mYiddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnT0ZCJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xOTItb2ZiJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdPRkInLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTI1Ni1vZmInXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAyNTYsXG4gIGl2OiAxNixcbiAgbW9kZTogJ09GQicsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWN0ciddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDE2LFxuICBtb2RlOiAnQ1RSJyxcbiAgdHlwZTogJ3N0cmVhbSdcbn1cbmV4cG9ydHNbJ2Flcy0xOTItY3RyJ10gPSB7XG4gIGNpcGhlcjogJ0FFUycsXG4gIGtleTogMTkyLFxuICBpdjogMTYsXG4gIG1vZGU6ICdDVFInLFxuICB0eXBlOiAnc3RyZWFtJ1xufVxuZXhwb3J0c1snYWVzLTI1Ni1jdHInXSA9IHtcbiAgY2lwaGVyOiAnQUVTJyxcbiAga2V5OiAyNTYsXG4gIGl2OiAxNixcbiAgbW9kZTogJ0NUUicsXG4gIHR5cGU6ICdzdHJlYW0nXG59XG5leHBvcnRzWydhZXMtMTI4LWdjbSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDEyOCxcbiAgaXY6IDEyLFxuICBtb2RlOiAnR0NNJyxcbiAgdHlwZTogJ2F1dGgnXG59XG5leHBvcnRzWydhZXMtMTkyLWdjbSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDE5MixcbiAgaXY6IDEyLFxuICBtb2RlOiAnR0NNJyxcbiAgdHlwZTogJ2F1dGgnXG59XG5leHBvcnRzWydhZXMtMjU2LWdjbSddID0ge1xuICBjaXBoZXI6ICdBRVMnLFxuICBrZXk6IDI1NixcbiAgaXY6IDEyLFxuICBtb2RlOiAnR0NNJyxcbiAgdHlwZTogJ2F1dGgnXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcblxuZnVuY3Rpb24gaW5jcjMyIChpdikge1xuICB2YXIgbGVuID0gaXYubGVuZ3RoXG4gIHZhciBpdGVtXG4gIHdoaWxlIChsZW4tLSkge1xuICAgIGl0ZW0gPSBpdi5yZWFkVUludDgobGVuKVxuICAgIGlmIChpdGVtID09PSAyNTUpIHtcbiAgICAgIGl2LndyaXRlVUludDgoMCwgbGVuKVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtKytcbiAgICAgIGl2LndyaXRlVUludDgoaXRlbSwgbGVuKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmxvY2sgKHNlbGYpIHtcbiAgdmFyIG91dCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgaW5jcjMyKHNlbGYuX3ByZXYpXG4gIHJldHVybiBvdXRcbn1cblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rKSB7XG4gIHdoaWxlIChzZWxmLl9jYWNoZS5sZW5ndGggPCBjaHVuay5sZW5ndGgpIHtcbiAgICBzZWxmLl9jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3NlbGYuX2NhY2hlLCBnZXRCbG9jayhzZWxmKV0pXG4gIH1cbiAgdmFyIHBhZCA9IHNlbGYuX2NhY2hlLnNsaWNlKDAsIGNodW5rLmxlbmd0aClcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShjaHVuay5sZW5ndGgpXG4gIHJldHVybiB4b3IoY2h1bmssIHBhZClcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jdHIuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IGV4cG9ydHM7XG5cbmN1cnZlLmJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcbmN1cnZlLnNob3J0ID0gcmVxdWlyZSgnLi9zaG9ydCcpO1xuY3VydmUubW9udCA9IHJlcXVpcmUoJy4vbW9udCcpO1xuY3VydmUuZWR3YXJkcyA9IHJlcXVpcmUoJy4vZWR3YXJkcycpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V2ZW50cy9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtZDUgPSByZXF1aXJlKCdjcmVhdGUtaGFzaC9tZDUnKVxubW9kdWxlLmV4cG9ydHMgPSBFVlBfQnl0ZXNUb0tleVxuZnVuY3Rpb24gRVZQX0J5dGVzVG9LZXkgKHBhc3N3b3JkLCBzYWx0LCBrZXlMZW4sIGl2TGVuKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhc3N3b3JkKSkge1xuICAgIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZCwgJ2JpbmFyeScpXG4gIH1cbiAgaWYgKHNhbHQgJiYgIUJ1ZmZlci5pc0J1ZmZlcihzYWx0KSkge1xuICAgIHNhbHQgPSBuZXcgQnVmZmVyKHNhbHQsICdiaW5hcnknKVxuICB9XG4gIGtleUxlbiA9IGtleUxlbiAvIDhcbiAgaXZMZW4gPSBpdkxlbiB8fCAwXG4gIHZhciBraSA9IDBcbiAgdmFyIGlpID0gMFxuICB2YXIga2V5ID0gbmV3IEJ1ZmZlcihrZXlMZW4pXG4gIHZhciBpdiA9IG5ldyBCdWZmZXIoaXZMZW4pXG4gIHZhciBhZGRtZCA9IDBcbiAgdmFyIG1kX2J1ZlxuICB2YXIgaVxuICB2YXIgYnVmcyA9IFtdXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGFkZG1kKysgPiAwKSB7XG4gICAgICBidWZzLnB1c2gobWRfYnVmKVxuICAgIH1cbiAgICBidWZzLnB1c2gocGFzc3dvcmQpXG4gICAgaWYgKHNhbHQpIHtcbiAgICAgIGJ1ZnMucHVzaChzYWx0KVxuICAgIH1cbiAgICBtZF9idWYgPSBtZDUoQnVmZmVyLmNvbmNhdChidWZzKSlcbiAgICBidWZzID0gW11cbiAgICBpID0gMFxuICAgIGlmIChrZXlMZW4gPiAwKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoa2V5TGVuID09PSAwKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gbWRfYnVmLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAga2V5W2tpKytdID0gbWRfYnVmW2ldXG4gICAgICAgIGtleUxlbi0tXG4gICAgICAgIGkrK1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXZMZW4gPiAwICYmIGkgIT09IG1kX2J1Zi5sZW5ndGgpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChpdkxlbiA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG1kX2J1Zi5sZW5ndGgpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGl2W2lpKytdID0gbWRfYnVmW2ldXG4gICAgICAgIGl2TGVuLS1cbiAgICAgICAgaSsrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlMZW4gPT09IDAgJiYgaXZMZW4gPT09IDApIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBtZF9idWYubGVuZ3RoOyBpKyspIHtcbiAgICBtZF9idWZbaV0gPSAwXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBrZXk6IGtleSxcbiAgICBpdjogaXZcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V2cF9ieXRlc3Rva2V5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXNuMSA9IHJlcXVpcmUoJy4vYXNuMScpXG52YXIgYWVzaWQgPSByZXF1aXJlKCcuL2Flc2lkLmpzb24nKVxudmFyIGZpeFByb2MgPSByZXF1aXJlKCcuL2ZpeFByb2MnKVxudmFyIGNpcGhlcnMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcycpXG52YXIgY29tcGF0ID0gcmVxdWlyZSgncGJrZGYyJylcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VLZXlzXG5cbmZ1bmN0aW9uIHBhcnNlS2V5cyAoYnVmZmVyKSB7XG4gIHZhciBwYXNzd29yZFxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ29iamVjdCcgJiYgIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgcGFzc3dvcmQgPSBidWZmZXIucGFzc3BocmFzZVxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5rZXlcbiAgfVxuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcilcbiAgfVxuXG4gIHZhciBzdHJpcHBlZCA9IGZpeFByb2MoYnVmZmVyLCBwYXNzd29yZClcblxuICB2YXIgdHlwZSA9IHN0cmlwcGVkLnRhZ1xuICB2YXIgZGF0YSA9IHN0cmlwcGVkLmRhdGFcbiAgdmFyIHN1YnR5cGUsIG5kYXRhXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ0NFUlRJRklDQVRFJzpcbiAgICAgIG5kYXRhID0gYXNuMS5jZXJ0aWZpY2F0ZS5kZWNvZGUoZGF0YSwgJ2RlcicpLnRic0NlcnRpZmljYXRlLnN1YmplY3RQdWJsaWNLZXlJbmZvXG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgY2FzZSAnUFVCTElDIEtFWSc6XG4gICAgICBpZiAoIW5kYXRhKSB7XG4gICAgICAgIG5kYXRhID0gYXNuMS5QdWJsaWNLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgfVxuICAgICAgc3VidHlwZSA9IG5kYXRhLmFsZ29yaXRobS5hbGdvcml0aG0uam9pbignLicpXG4gICAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjEnOlxuICAgICAgICAgIHJldHVybiBhc24xLlJTQVB1YmxpY0tleS5kZWNvZGUobmRhdGEuc3ViamVjdFB1YmxpY0tleS5kYXRhLCAnZGVyJylcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0NS4yLjEnOlxuICAgICAgICAgIG5kYXRhLnN1YmplY3RQcml2YXRlS2V5ID0gbmRhdGEuc3ViamVjdFB1YmxpY0tleVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZWMnLFxuICAgICAgICAgICAgZGF0YTogbmRhdGFcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDAuNC4xJzpcbiAgICAgICAgICBuZGF0YS5hbGdvcml0aG0ucGFyYW1zLnB1Yl9rZXkgPSBhc24xLkRTQXBhcmFtLmRlY29kZShuZGF0YS5zdWJqZWN0UHVibGljS2V5LmRhdGEsICdkZXInKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZHNhJyxcbiAgICAgICAgICAgIGRhdGE6IG5kYXRhLmFsZ29yaXRobS5wYXJhbXNcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgaWQgJyArIHN1YnR5cGUpXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArIHR5cGUpXG4gICAgY2FzZSAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJzpcbiAgICAgIGRhdGEgPSBhc24xLkVuY3J5cHRlZFByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgZGF0YSA9IGRlY3J5cHQoZGF0YSwgcGFzc3dvcmQpXG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgY2FzZSAnUFJJVkFURSBLRVknOlxuICAgICAgbmRhdGEgPSBhc24xLlByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgc3VidHlwZSA9IG5kYXRhLmFsZ29yaXRobS5hbGdvcml0aG0uam9pbignLicpXG4gICAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjEnOlxuICAgICAgICAgIHJldHVybiBhc24xLlJTQVByaXZhdGVLZXkuZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJylcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0NS4yLjEnOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJ2ZTogbmRhdGEuYWxnb3JpdGhtLmN1cnZlLFxuICAgICAgICAgICAgcHJpdmF0ZUtleTogYXNuMS5FQ1ByaXZhdGVLZXkuZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJykucHJpdmF0ZUtleVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0MC40LjEnOlxuICAgICAgICAgIG5kYXRhLmFsZ29yaXRobS5wYXJhbXMucHJpdl9rZXkgPSBhc24xLkRTQXBhcmFtLmRlY29kZShuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSwgJ2RlcicpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICAgICAgcGFyYW1zOiBuZGF0YS5hbGdvcml0aG0ucGFyYW1zXG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IGlkICcgKyBzdWJ0eXBlKVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSB0eXBlICcgKyB0eXBlKVxuICAgIGNhc2UgJ1JTQSBQVUJMSUMgS0VZJzpcbiAgICAgIHJldHVybiBhc24xLlJTQVB1YmxpY0tleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgY2FzZSAnUlNBIFBSSVZBVEUgS0VZJzpcbiAgICAgIHJldHVybiBhc24xLlJTQVByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgIGNhc2UgJ0RTQSBQUklWQVRFIEtFWSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZHNhJyxcbiAgICAgICAgcGFyYW1zOiBhc24xLkRTQVByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgfVxuICAgIGNhc2UgJ0VDIFBSSVZBVEUgS0VZJzpcbiAgICAgIGRhdGEgPSBhc24xLkVDUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJ2ZTogZGF0YS5wYXJhbWV0ZXJzLnZhbHVlLFxuICAgICAgICBwcml2YXRlS2V5OiBkYXRhLnByaXZhdGVLZXlcbiAgICAgIH1cbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArIHR5cGUpXG4gIH1cbn1cbnBhcnNlS2V5cy5zaWduYXR1cmUgPSBhc24xLnNpZ25hdHVyZVxuZnVuY3Rpb24gZGVjcnlwdCAoZGF0YSwgcGFzc3dvcmQpIHtcbiAgdmFyIHNhbHQgPSBkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmtkZS5rZGVwYXJhbXMuc2FsdFxuICB2YXIgaXRlcnMgPSBwYXJzZUludChkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmtkZS5rZGVwYXJhbXMuaXRlcnMudG9TdHJpbmcoKSwgMTApXG4gIHZhciBhbGdvID0gYWVzaWRbZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5jaXBoZXIuYWxnby5qb2luKCcuJyldXG4gIHZhciBpdiA9IGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQuY2lwaGVyLml2XG4gIHZhciBjaXBoZXJUZXh0ID0gZGF0YS5zdWJqZWN0UHJpdmF0ZUtleVxuICB2YXIga2V5bGVuID0gcGFyc2VJbnQoYWxnby5zcGxpdCgnLScpWzFdLCAxMCkgLyA4XG4gIHZhciBrZXkgPSBjb21wYXQucGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcnMsIGtleWxlbilcbiAgdmFyIGNpcGhlciA9IGNpcGhlcnMuY3JlYXRlRGVjaXBoZXJpdihhbGdvLCBrZXksIGl2KVxuICB2YXIgb3V0ID0gW11cbiAgb3V0LnB1c2goY2lwaGVyLnVwZGF0ZShjaXBoZXJUZXh0KSlcbiAgb3V0LnB1c2goY2lwaGVyLmZpbmFsKCkpXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZS1hc24xL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNpcGhlcnMgPSByZXF1aXJlKCcuL2VuY3J5cHRlcicpXG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGV4cG9ydHMuQ2lwaGVyID0gY2lwaGVycy5jcmVhdGVDaXBoZXJcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyaXYgPSBleHBvcnRzLkNpcGhlcml2ID0gY2lwaGVycy5jcmVhdGVDaXBoZXJpdlxudmFyIGRlY2lwaGVycyA9IHJlcXVpcmUoJy4vZGVjcnlwdGVyJylcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXIgPSBleHBvcnRzLkRlY2lwaGVyID0gZGVjaXBoZXJzLmNyZWF0ZURlY2lwaGVyXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBleHBvcnRzLkRlY2lwaGVyaXYgPSBkZWNpcGhlcnMuY3JlYXRlRGVjaXBoZXJpdlxudmFyIG1vZGVzID0gcmVxdWlyZSgnLi9tb2RlcycpXG5mdW5jdGlvbiBnZXRDaXBoZXJzICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1vZGVzKVxufVxuZXhwb3J0cy5saXN0Q2lwaGVycyA9IGV4cG9ydHMuZ2V0Q2lwaGVycyA9IGdldENpcGhlcnNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm93c2VyaWZ5LWFlcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gY3J0O1xuZnVuY3Rpb24gYmxpbmQocHJpdikge1xuICB2YXIgciA9IGdldHIocHJpdik7XG4gIHZhciBibGluZGVyID0gci50b1JlZChibi5tb250KHByaXYubW9kdWx1cykpXG4gIC5yZWRQb3cobmV3IGJuKHByaXYucHVibGljRXhwb25lbnQpKS5mcm9tUmVkKCk7XG4gIHJldHVybiB7XG4gICAgYmxpbmRlcjogYmxpbmRlcixcbiAgICB1bmJsaW5kZXI6ci5pbnZtKHByaXYubW9kdWx1cylcbiAgfTtcbn1cbmZ1bmN0aW9uIGNydChtc2csIHByaXYpIHtcbiAgdmFyIGJsaW5kcyA9IGJsaW5kKHByaXYpO1xuICB2YXIgbGVuID0gcHJpdi5tb2R1bHVzLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIG1vZCA9IGJuLm1vbnQocHJpdi5tb2R1bHVzKTtcbiAgdmFyIGJsaW5kZWQgPSBuZXcgYm4obXNnKS5tdWwoYmxpbmRzLmJsaW5kZXIpLnVtb2QocHJpdi5tb2R1bHVzKTtcbiAgdmFyIGMxID0gYmxpbmRlZC50b1JlZChibi5tb250KHByaXYucHJpbWUxKSk7XG4gIHZhciBjMiA9IGJsaW5kZWQudG9SZWQoYm4ubW9udChwcml2LnByaW1lMikpO1xuICB2YXIgcWludiA9IHByaXYuY29lZmZpY2llbnQ7XG4gIHZhciBwID0gcHJpdi5wcmltZTE7XG4gIHZhciBxID0gcHJpdi5wcmltZTI7XG4gIHZhciBtMSA9IGMxLnJlZFBvdyhwcml2LmV4cG9uZW50MSk7XG4gIHZhciBtMiA9IGMyLnJlZFBvdyhwcml2LmV4cG9uZW50Mik7XG4gIG0xID0gbTEuZnJvbVJlZCgpO1xuICBtMiA9IG0yLmZyb21SZWQoKTtcbiAgdmFyIGggPSBtMS5pc3ViKG0yKS5pbXVsKHFpbnYpLnVtb2QocCk7XG4gIGguaW11bChxKTtcbiAgbTIuaWFkZChoKTtcbiAgcmV0dXJuIG5ldyBCdWZmZXIobTIuaW11bChibGluZHMudW5ibGluZGVyKS51bW9kKHByaXYubW9kdWx1cykudG9BcnJheShmYWxzZSwgbGVuKSk7XG59XG5jcnQuZ2V0ciA9IGdldHI7XG5mdW5jdGlvbiBnZXRyKHByaXYpIHtcbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciByID0gbmV3IGJuKHJhbmRvbUJ5dGVzKGxlbikpO1xuICB3aGlsZSAoci5jbXAocHJpdi5tb2R1bHVzKSA+PSAgMCB8fCAhci51bW9kKHByaXYucHJpbWUxKSB8fCAhci51bW9kKHByaXYucHJpbWUyKSkge1xuICAgIHIgPSBuZXcgYm4ocmFuZG9tQnl0ZXMobGVuKSk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1yc2EvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXI7XG52YXIgU2xvd0J1ZmZlciA9IGJ1ZmZlci5TbG93QnVmZmVyO1xudmFyIE1BWF9MRU4gPSBidWZmZXIua01heExlbmd0aCB8fCAyMTQ3NDgzNjQ3O1xuZXhwb3J0cy5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IG5vdCBiZSBudW1iZXInKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPiBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgdmFyIGVuYyA9IGVuY29kaW5nO1xuICB2YXIgX2ZpbGwgPSBmaWxsO1xuICBpZiAoX2ZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuYyA9IHVuZGVmaW5lZDtcbiAgICBfZmlsbCA9IDA7XG4gIH1cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIGlmICh0eXBlb2YgX2ZpbGwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGZpbGxCdWYgPSBuZXcgQnVmZmVyKF9maWxsLCBlbmMpO1xuICAgIHZhciBmbGVuID0gZmlsbEJ1Zi5sZW5ndGg7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgc2l6ZSkge1xuICAgICAgYnVmW2ldID0gZmlsbEJ1ZltpICUgZmxlbl07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKF9maWxsKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuZXhwb3J0cy5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIGFsbG9jVW5zYWZlKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbn1cbmV4cG9ydHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5mcm9tID09PSAnZnVuY3Rpb24nICYmICghZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgVWludDhBcnJheS5mcm9tICE9PSBCdWZmZXIuZnJvbSkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgdmFyIG9mZnNldCA9IGVuY29kaW5nT3JPZmZzZXQ7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICB2YXIgbGVuID0gbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgbGVuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbGVuID0gdmFsdWUuYnl0ZUxlbmd0aCAtIG9mZnNldDtcbiAgICB9XG4gICAgaWYgKG9mZnNldCA+PSB2YWx1ZS5ieXRlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKGxlbiA+IHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIodmFsdWUubGVuZ3RoKTtcbiAgICB2YWx1ZS5jb3B5KG91dCwgMCwgMCwgdmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkodmFsdWUuZGF0YSkpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLmRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgJyArICdBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpO1xufVxuZXhwb3J0cy5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiBhbGxvY1Vuc2FmZVNsb3coc2l6ZSkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyhzaXplKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPj0gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzaXplKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idWZmZXItc2hpbXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxuICAgICwgbHQgICAgID0gJzwnXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XG4gIHZhciByZXN1bHQ7XG4gIGlmKE8gIT09IG51bGwpe1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaGFzID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge3ZhbHVlOiB3a3NFeHQuZihuYW1lKX0pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaC9icm93c2VyJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cblxudmFyIFpFUk9TID0gbmV3IEJ1ZmZlcigxMjgpXG5aRVJPUy5maWxsKDApXG5cbmZ1bmN0aW9uIEhtYWMoYWxnLCBrZXkpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgYWxnID0gYWxnLnRvTG93ZXJDYXNlKClcbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAga2V5ID0gbmV3IEJ1ZmZlcihrZXkpXG4gIH1cblxuICB2YXIgYmxvY2tzaXplID0gKGFsZyA9PT0gJ3NoYTUxMicgfHwgYWxnID09PSAnc2hhMzg0JykgPyAxMjggOiA2NFxuXG4gIHRoaXMuX2FsZyA9IGFsZ1xuICB0aGlzLl9rZXkgPSBrZXlcblxuICBpZiAoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IGNyZWF0ZUhhc2goYWxnKS51cGRhdGUoa2V5KS5kaWdlc3QoKVxuXG4gIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgWkVST1NdLCBibG9ja3NpemUpXG4gIH1cblxuICB2YXIgaXBhZCA9IHRoaXMuX2lwYWQgPSBuZXcgQnVmZmVyKGJsb2Nrc2l6ZSlcbiAgdmFyIG9wYWQgPSB0aGlzLl9vcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3NpemU7IGkrKykge1xuICAgIGlwYWRbaV0gPSBrZXlbaV0gXiAweDM2XG4gICAgb3BhZFtpXSA9IGtleVtpXSBeIDB4NUNcbiAgfVxuXG4gIHRoaXMuX2hhc2ggPSBjcmVhdGVIYXNoKGFsZykudXBkYXRlKGlwYWQpXG59XG5cbmluaGVyaXRzKEhtYWMsIFRyYW5zZm9ybSlcblxuSG1hYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhLCBlbmMpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuSG1hYy5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChkYXRhLCBfLCBuZXh0KSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG5cbiAgbmV4dCgpXG59XG5cbkhtYWMucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gIHRoaXMucHVzaCh0aGlzLmRpZ2VzdCgpKVxuXG4gIG5leHQoKVxufVxuXG5IbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHZhciBoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuXG4gIHJldHVybiBjcmVhdGVIYXNoKHRoaXMuX2FsZykudXBkYXRlKHRoaXMuX29wYWQpLnVwZGF0ZShoKS5kaWdlc3QoZW5jKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUhtYWMoYWxnLCBrZXkpIHtcbiAgcmV0dXJuIG5ldyBIbWFjKGFsZywga2V5KVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NyZWF0ZS1obWFjL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy51dGlscyA9IHJlcXVpcmUoJy4vZGVzL3V0aWxzJyk7XG5leHBvcnRzLkNpcGhlciA9IHJlcXVpcmUoJy4vZGVzL2NpcGhlcicpO1xuZXhwb3J0cy5ERVMgPSByZXF1aXJlKCcuL2Rlcy9kZXMnKTtcbmV4cG9ydHMuQ0JDID0gcmVxdWlyZSgnLi9kZXMvY2JjJyk7XG5leHBvcnRzLkVERSA9IHJlcXVpcmUoJy4vZGVzL2VkZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Rlcy5qcy9saWIvZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gbmV4dFRpY2s7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MubmV4dFRpY2s7XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcblxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoc3RyZWFtLCBlciwgZGF0YSk7XG4gICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcHJvY2Vzc05leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG4gIH0gY2F0Y2ggKF8pIHt9IGZpbmFsbHkge1xuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gIH1cbn0pKCk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSBCdWZmZXIuaXNCdWZmZXIoY2h1bmspO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuICBpZiAoc3luYykgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7ZWxzZSBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3NOZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKGVycikge1xuICAgIHZhciBlbnRyeSA9IF90aGlzLmVudHJ5O1xuICAgIF90aGlzLmVudHJ5ID0gbnVsbDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcnIpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IF90aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBfdGhpcztcbiAgICB9XG4gIH07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3RyaW5nX2RlY29kZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog5aCGXG4gKiBcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBIZWFwXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlYXAge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmUgPSBkZWZhdWx0Q29tcHJlKSB7XG4gICAgICAgIHRoaXMuYXJyID0gW107XG4gICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgfVxuXG4gICAgYWRkKGVsZW0pIHtcbiAgICAgICAgdGhpcy5hcnIucHVzaChlbGVtKTtcblxuICAgICAgICBpZiAodGhpcy5hcnIubGVuZ3RoID09PSAxKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5fdXBIZWFwQWRqdXN0KCh0aGlzLmFyci5sZW5ndGggPj4gMSkgLSAxKTtcbiAgICB9XG5cbiAgICByZW1vdmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5hcnIubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgbGV0IGhlYXAgPSB0aGlzLmFycjtcbiAgICAgICAgLy8g5Ye66Zif5YiX5pON5L2c77yM5by55Ye65pWw5o2u5aS05YWD57SgXG4gICAgICAgIGxldCBkYXRhID0gaGVhcFswXTtcbiAgICAgICAgLy8g55So5bC+5YWD57Sg5aGr5YWF5aS05YWD57SgXG4gICAgICAgIGhlYXBbMF0gPSBoZWFwW2hlYXAubGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIOWIoOmZpOWwvuiKgueCuVxuICAgICAgICBoZWFwLnBvcCgpO1xuXG4gICAgICAgIC8v54S25ZCO5LuO5qC56IqC54K55LiL5ruk5aCGXG4gICAgICAgIGlmIChoZWFwLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICB0aGlzLl9kb3duSGVhcEFkanVzdCgwKTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5hcnIubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICAvLyDlr7nloIbov5vooYzkuIrmu6Tmk43kvZzvvIzkvb/lvpfmu6HotrPloIbmgKfotKhcbiAgICBfdXBIZWFwQWRqdXN0KHBhcmVudCkge1xuICAgICAgICBsZXQgaGVhcCA9IHRoaXMuYXJyO1xuICAgICAgICBsZXQgbGVuID0gaGVhcC5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKHBhcmVudCA+PSAwKSB7XG4gICAgICAgICAgICBsZXQgbGVmdENoaWxkID0gMiAqIHBhcmVudCArIDE7XG4gICAgICAgICAgICBsZXQgcmlnaHRDaGlsZCA9IGxlZnRDaGlsZCArIDE7XG4gICAgICAgICAgICBsZXQgbWF4ID0gbGVmdENoaWxkO1xuXG4gICAgICAgICAgICBpZiAocmlnaHRDaGlsZCA8IGxlbikge1xuICAgICAgICAgICAgICAgIG1heCA9IHRoaXMuY29tcGFyZShoZWFwW2xlZnRDaGlsZF0sIGhlYXBbcmlnaHRDaGlsZF0pIDwgMFxuICAgICAgICAgICAgICAgICAgICA/IHJpZ2h0Q2hpbGQgOiBsZWZ0Q2hpbGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIOWmguaenHBhcmVudOiKgueCueWwj+S6juWug+eahOafkOS4quWtkOiKgueCueeahOivne+8jOatpOaXtuetm+mAieaTjeS9nFxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZShoZWFwW3BhcmVudF0sIGhlYXBbbWF4XSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBoZWFwW3BhcmVudF07XG4gICAgICAgICAgICAgICAgaGVhcFtwYXJlbnRdID0gaGVhcFttYXhdO1xuICAgICAgICAgICAgICAgIGhlYXBbbWF4XSA9IHRlbXA7XG5cbiAgICAgICAgICAgICAgICAvLyDnu6fnu63ov5vooYzmm7TkuIrkuIDlsYLnmoTov4fmu6RcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBNYXRoLmNlaWwocGFyZW50IC8gMikgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g5a+55aCG6L+b6KGM5LiL5ruk5pON5L2c77yM5L2/5b6X5ruh6Laz5aCG5oCn6LSoXG4gICAgX2Rvd25IZWFwQWRqdXN0KHBhcmVudCkge1xuICAgICAgICBsZXQgaGVhcCA9IHRoaXMuYXJyO1xuICAgICAgICBsZXQgbGVuID0gaGVhcC5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKDIgKiBwYXJlbnQgKyAxIDwgbGVuKSB7XG4gICAgICAgICAgICBsZXQgbGVmdENoaWxkID0gMiAqIHBhcmVudCArIDE7XG4gICAgICAgICAgICBsZXQgcmlnaHRDaGlsZCA9IGxlZnRDaGlsZCArIDE7XG4gICAgICAgICAgICBsZXQgbWF4ID0gbGVmdENoaWxkO1xuXG4gICAgICAgICAgICBpZiAocmlnaHRDaGlsZCA8IGxlbikge1xuICAgICAgICAgICAgICAgIG1heCA9IHRoaXMuY29tcGFyZShoZWFwW2xlZnRDaGlsZF0sIGhlYXBbcmlnaHRDaGlsZF0pIDwgMFxuICAgICAgICAgICAgICAgICAgICA/IHJpZ2h0Q2hpbGQgOiBsZWZ0Q2hpbGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmUoaGVhcFtwYXJlbnRdLCBoZWFwW21heF0pIDwgMCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gaGVhcFtwYXJlbnRdO1xuICAgICAgICAgICAgICAgIGhlYXBbcGFyZW50XSA9IGhlYXBbbWF4XTtcbiAgICAgICAgICAgICAgICBoZWFwW21heF0gPSB0ZW1wO1xuXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbWF4O1xuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZGVmYXVsdENvbXByZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuXG5cbi8vIHZhciBhcnIgPSBbMSwgMCwgNSwgNCwgM107XG4vLyB2YXIgaGVhcCA9IG5ldyBIZWFwKCk7XG4vLyBmb3IgKGxldCBlbGUgb2YgYXJyKSB7XG4vLyAgICAgaGVhcC5hZGQoZWxlKTtcbi8vIH1cbi8vIGNvbnNvbGUubG9nKGBoZWFwOiAke2hlYXAuYXJyLmpvaW4oJywnKX1gKTtcbi8vIGZvciAobGV0IGVsZSBvZiBhcnIpIHtcbi8vICAgICBoZWFwLnJlbW92ZSgpO1xuLy8gICAgIGNvbnNvbGUubG9nKGBoZWFwOiAke2hlYXAuYXJyLmpvaW4oJywnKX1gKTtcbi8vIH1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9IZWFwL2luZGV4LmpzIiwiXG4vKipcbiAqIOWPjOWQkemTvuihqFxuICpcbiAqIOWPjOWQkemTvuihqOaYr+S4uuS6huWFi+acjeWNlemTvuihqOi/meenjeWNleWQkeaAp+eahOe8uueCueOAglxuICog5Y+M5ZCR6ZO+6KGo55qE57uT54K55Lit5pyJ5Lik5Liq5oyH6ZKI5Z+f77yM5YW25LiA5oyH5ZCR55u05o6l5ZCO57un77yM5Y+m5LiA5oyH5ZCR55u05o6l5YmN6LaL44CCXG4gKlxuICog5Y+M5ZCR6ZO+6KGo5Lmf5Y+v5Lul5pyJ5b6q546v6KGo44CCXG4gKi9cblxuY2xhc3MgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgcHJldiA9IG51bGwsIG5leHQgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvdWJsZUxpbmtlZExpc3Qge1xuICAgIGNvbnN0cnVjdG9yKHNxTGlzdCA9IFtdLCBjb21wYXJlID0gZGVmYXVsdENvbXBhcmUpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5jb21wYXJlID0gY29tcGFyZTtcblxuICAgICAgICBpZihzcUxpc3QgJiYgc3FMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBzcUxpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKXtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG5cbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHlpZWxkIGN1cnJlbnQuZGF0YTtcblxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH1cblxuICAgIGNsZWFyKCl7XG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVzaChkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHRocm93IG5ldyBFcnJvcigncGFyYW0gZGF0YSByZXF1aXJlZCcpO1xuXG4gICAgICAgICsrdGhpcy5zaXplO1xuXG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgTm9kZShkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gbmV3IE5vZGUoZGF0YSwgdGhpcy50YWlsLCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICB1bnNoaWZ0KGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdwYXJhbSBkYXRhIHJlcXVpcmVkJyk7XG5cbiAgICAgICAgKyt0aGlzLnNpemU7XG5cbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBOb2RlKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBuZXcgTm9kZShkYXRhLCBudWxsLCB0aGlzLmhlYWQpO1xuICAgICAgICAgICAgdGhpcy5oZWFkLnByZXYgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHBvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAtLXRoaXMuc2l6ZTtcblxuICAgICAgICBsZXQgZGF0YSA9IHRoaXMudGFpbC5kYXRhO1xuXG4gICAgICAgIHRoaXMudGFpbC5wcmV2Lm5leHQgPSBudWxsO1xuICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwucHJldjtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAtLXRoaXMuc2l6ZTtcblxuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuaGVhZC5kYXRhO1xuXG4gICAgICAgIHRoaXMuaGVhZC5uZXh0LnByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSB2YWx1ZSBvZiBleGlzdGluZyBub2RlIGJ5IGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBcbiAgICAgKi9cbiAgICB1cGRhdGUoaW5kZXgsIGRhdGEpe1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZmluZEJ5SW5kZXgoaW5kZXgsIHRydWUpO1xuXG4gICAgICAgIGlmIChub2RlKSBub2RlLmRhdGEgPSBkYXRhO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuICEhbm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGZpcnN0IG1hdGNoZWQgZGF0YVxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBcbiAgICAgKi9cbiAgICByZW1vdmUoZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignUGFyYW0gZGF0YSByZXF1aXJlZCcpO1xuXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlKGRhdGEsIGN1cnJlbnQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAtLXRoaXMuc2l6ZTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkLnByZXYgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50ID09PSB0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXY7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGFpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YWlsLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5wcmV2Lm5leHQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dC5wcmV2ID0gY3VycmVudC5wcmV2O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50LmRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpbmRleE9mKGRhdGEpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZShkYXRhLCBjdXJyZW50LmRhdGEpKSByZXR1cm4gaW5kZXg7XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmluZCBub2RlIG9yIGRhdGEgYnkgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5Ob2RlIHRydWU6IHJldHVybiB0aGUgbm9kZSBvYmplY3Q7IG90aGVyd2lzZSByZXR1cm4gZGF0YTtcbiAgICAgKi9cbiAgICBmaW5kQnlJbmRleChpbmRleCA9IDAsIHJldHVybk5vZGUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBqID0gMDtcblxuICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICBpZiAoaisrID09PSBpbmRleCkgYnJlYWs7XG5cbiAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gcmV0dXJuTm9kZSA/IGN1cnJlbnQgOiAoY3VycmVudCA/IGN1cnJlbnQuZGF0YSA6IG51bGwpO1xuICAgIH1cblxuICAgIGZvckVhY2goY2IgPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcblxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgY2IoY3VycmVudC5kYXRhLCBpbmRleCsrKTtcblxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG5cbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChjdXJyZW50LmRhdGEpO1xuXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSlNPTigpICsgJyc7XG4gICAgfVxufVxuXG5cbi8vIGxldCBhID0gbmV3IERvdWJsZUxpbmtlZExpc3QoWzIsIDNdKTtcbi8vIGEudW5zaGlmdCgxKTtcbi8vIGEucHVzaCg0KTtcbi8vIGNvbnNvbGUubG9nKGEuaW5kZXhPZig0KSk7XG4vLyBjb25zb2xlLmxvZyhhLmZpbmRCeUluZGV4KDIpKTtcblxuLy8gZm9yKGxldCBpdGVtIG9mIGEpe1xuLy8gICAgIGNvbnNvbGUubG9nKGl0ZW0pO1xuLy8gfVxuXG4vLyBhLnBvcCgpO1xuLy8gYS5zaGlmdCgpO1xuLy8gYS5yZW1vdmUoMik7XG4vLyBhLnJlbW92ZSgzMik7XG4vLyBhLnJlbW92ZSgzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9MaXN0L0RvdWJsZUxpbmtlZExpc3QuanMiLCIvLyDpnZnmgIHljZXpk77ooahcbi8qXG4g5pyJ5pe25Y+v5YCf55So5LiA57u05pWw57uE5p2l5o+P6L+w57q/5oCn6ZO+6KGo77yM6L+Z5bCx5piv57q/5oCn6KGo55qE6Z2Z5oCB5Y2V6ZO+6KGo5a2Y5YKo57uT5p6E44CCXG4g5Zyo6Z2Z5oCB6ZO+6KGo5Lit77yM5pWw57uE55qE5LiA5Liq5YiG6YeP6KGo56S65LiA5Liq57uT54K577yM5ZCM5pe255So5ri45qCH77yIY3Vy77yJ5Luj5pu/5oyH6ZKI5oyH56S657uT54K55Zyo5pWw57uE5Lit55qE55u45a+55L2N572u44CCXG4g5pWw57uE55qE56ysMOWIhumHj+WPr+eci+aIkOWktOe7k+eCue+8jOWFtuaMh+mSiOWfn+aMh+ekuumTvuihqOeahOesrOS4gOS4que7k+eCueOAglxuIOi/meenjeWtmOWCqOe7k+aehOmcgOimgemihOWFiOWIhumFjeS4gOS4qui+g+Wkp+eahOepuumXtO+8jOS9huWcqOe6v+aAp+ihqOeahOaPkuWFpeWSjOWIoOmZpOaTjeS9nOaXtuS4jemcgOenu+WKqOWFg+e0oO+8jFxuIOS7hemcgOimgeS/ruaUueaMh+mSiO+8jOaVheS7jeWFt+aciemTvuW8j+WtmOWCqOe7k+aehOeahOS4u+imgeS8mOeCuVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRpY0xpbmtlZExpc3Qge1xuICAgIGNvbnN0cnVjdG9yKE1BWFNJWkUpIHtcbiAgICAgICAgdGhpc1stMV0gPSB7Y3VyOiAwfTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLk1BWFNJWkUgPSBNQVhTSVpFICsgMSB8fCAxMDAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWcqOmdmeaAgeWNlemTvue6v+aAp+ihqEzkuK3mn6Xmib7nrKwx5Liq5YC85Li6ZeeahOWFg+e0oO+8jFxuICAgICAqIOiLpeaJvuWIsO+8jOWImei/lOWbnuWug+WcqEzkuK3nmoTkvY3luo9cbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIGZpbmQgKGRhdGEpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzWzBdLmN1cjtcbiAgICAgICAgd2hpbGUgKGkgJiYgdGhpc1tpXS5kYXRhICE9PSBkYXRhKSB7XG4gICAgICAgICAgICBpID0gdGhpc1tpXS5jdXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWwhuS4gOe7tOaVsOe7hOS4reWQhOWIhumHj+mTvuaIkOS4gOS4quWkh+eUqOmTvuihqFxuICAgICAqIHRoaXNbMF0uY3Vy5Li65aS05oyH6ZKIXG4gICAgICovXG4gICAgaW5pdCAobGVuKSB7XG4gICAgICAgIGxlbiA9IGxlbiA/IGxlbiArIDEgOiB0aGlzLk1BWFNJWkU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuIC0gMTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzW2ldID0gdGhpc1tpXSB8fCB7ZGF0YTogbnVsbCwgY3VyOiBudWxsfTtcbiAgICAgICAgICAgIHRoaXNbaV0uY3VyID0gaSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW2xlbiAtIDFdID0gdGhpc1tsZW4gLSAxXSB8fCB7fTtcbiAgICAgICAgdGhpc1tsZW4gLSAxXS5jdXIgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDoi6XlpIfnlKjpk77ooajpnZ7nqbrvvIzliJnov5Tlm57liIbphY3nmoTnu5PngrnkuIvmoIfvvIzlj43liJnov5Tlm54wXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgbWFsbG9jICgpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzWy0xXS5jdXI7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1stMV0uY3VyICE9PSAndW5kZWZpbmVkJykgdGhpc1stMV0uY3VyID0gdGhpc1tpXS5jdXI7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDlsIbkuIvmoIfkuLpr55qE56m66Zey57uT54K55Zue5pS25Yiw5aSH55So6ZO+6KGoXG4gICAgICogQHBhcmFtIGtcbiAgICAgKi9cbiAgICBmcmVlIChrKSB7XG4gICAgICAgIHRoaXNba10uY3VyID0gdGhpc1swXS5jdXI7XG4gICAgICAgIHRoaXNbMF0uY3VyID0gaztcbiAgICB9XG5cbiAgICBjcmVhdGUgKHNxTGlzdCkge1xuICAgICAgICAvLyDliJ3lp4vljJblpIfnlKjnqbrpl7RcbiAgICAgICAgdGhpcy5pbml0KHNxTGlzdC5sZW5ndGgpO1xuICAgICAgICAvLyDnlJ/miJBz55qE5aS057uT54K5XG4gICAgICAgIGxldCBzID0gdGhpcy5tYWxsb2MoKTtcbiAgICAgICAgLy8gcuaMh+WQkXPnmoTlvZPliY3mnIDlkI7nu5PngrlcbiAgICAgICAgbGV0IHIgPSBzO1xuICAgICAgICBsZXQgbSA9IHNxTGlzdC5sZW5ndGg7XG5cbiAgICAgICAgLy8g5bu656uL6ZuG5ZCIQeeahOmTvuihqFxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICAgICAgLy/liIbphY3nu5PngrlcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5tYWxsb2MoKTtcbiAgICAgICAgICAgIC8vIOi+k+WFpUHlhYPntKDnmoTlgLxcbiAgICAgICAgICAgIHRoaXNbaV0uZGF0YSA9IHNxTGlzdFtqXTtcbiAgICAgICAgICAgIC8vIOaPkuWFpeWIsOihqOWwvlxuICAgICAgICAgICAgdGhpc1tyXS5jdXIgPSBpO1xuICAgICAgICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIHIgPSBpO1xuICAgICAgICB9XG4gICAgICAgIC8vIOWwvue7k+eCueeahOaMh+mSiOS4uuepulxuICAgICAgICB0aGlzW3JdLmN1ciA9IDA7XG4gICAgfVxuXG4gICAgLy8gdG9kb1xuICAgIGFkZCAoaW5kZXgsIGVsZW0pIHtcbiAgICB9XG5cbiAgICByZW1vdmUgKGluZGV4KSB7XG4gICAgfVxufVxuXG4vKipcbiAqIOWcqOS4gOe7tOaVsOe7hOS4reW7uueri+ihqOekuumbhuWQiChBLUIpVShCLUEpXG4gKiDnmoTpnZnmgIHpk77ooajvvIxz5Li65YW25aS05oyH6ZKI44CCXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gZGlmZmVyZW5jZShzbGxpc3QsIGFycjEsIGFycjIpIHtcbiAgICAvLyDliJ3lp4vljJblpIfnlKjnqbrpl7RcbiAgICBzbGxpc3QuaW5pdCgpO1xuICAgIC8vIOeUn+aIkHPnmoTlpLTnu5PngrlcbiAgICBsZXQgcyA9IHNsbGlzdC5tYWxsb2MoKTtcbiAgICAvLyBy5oyH5ZCRc+eahOW9k+WJjeacgOWQjue7k+eCuVxuICAgIGxldCByID0gcztcbiAgICAvLyDliKDpmaRB5ZKMQueahOWFg+e0oOS4quaVsFxuICAgIGxldCBtID0gYXJyMS5sZW5ndGg7XG4gICAgbGV0IG4gPSBhcnIyLmxlbmd0aDtcblxuICAgIC8vIOW7uueri+mbhuWQiEHnmoTpk77ooahcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICAvL+WIhumFjee7k+eCuVxuICAgICAgICBsZXQgaSA9IHNsbGlzdC5tYWxsb2MoKTtcbiAgICAgICAgLy8g6L6T5YWlQeWFg+e0oOeahOWAvFxuICAgICAgICBzbGxpc3RbaV0uZGF0YSA9IGFycjFbal07XG4gICAgICAgIC8vIOaPkuWFpeWIsOihqOWwvlxuICAgICAgICBzbGxpc3Rbcl0uY3VyID0gaTtcbiAgICAgICAgciA9IGk7XG4gICAgfVxuICAgIC8vIOWwvue7k+eCueeahOaMh+mSiOS4uuepulxuICAgIHNsbGlzdFtyXS5jdXIgPSAwO1xuXG4gICAgLy8g5L6d5qyh6L6T5YWlQueahOWFg+e0oO+8jOiLpeS4jeWcqOW9k+WJjeihqOS4re+8jOWImeaPkuWFpe+8jFxuICAgIC8vIOWQpuWImeWIoOmZpFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgIGxldCBiID0gYXJyMltqXTtcbiAgICAgICAgbGV0IHAgPSBzO1xuICAgICAgICAvLyBr5oyH5ZCR6ZuG5ZCI5Lit55qE56ys5LiA5Liq57uT54K5XG4gICAgICAgIGxldCBrID0gc2xsaXN0W3NdLmN1cjtcbiAgICAgICAgLy8g5Zyo5b2T5YmN6KGo5Lit5p+l5om+XG4gICAgICAgIHdoaWxlIChrICE9PSBzbGxpc3Rbcl0uY3VyICYmIHNsbGlzdFtrXS5kYXRhICE9PSBiKSB7XG4gICAgICAgICAgICBwID0gaztcbiAgICAgICAgICAgIGsgPSBzbGxpc3Rba10uY3VyO1xuICAgICAgICB9XG4gICAgICAgIC8vIOW9k+WJjeihqOS4reS4jeWtmOWcqOivpeWFg+e0oO+8jOaPkuWFpeWcqHLmiYDmjIfnu5PngrnkuYvlkI7vvIzkuJRy55qE5L2N572u5LiN5Y+YXG4gICAgICAgIGlmIChrID09PSBzbGxpc3Rbcl0uY3VyKSB7XG4gICAgICAgICAgICBsZXQgaSA9IHNsbGlzdC5tYWxsb2MoKTtcbiAgICAgICAgICAgIHNsbGlzdFtpXS5kYXRhID0gYjtcbiAgICAgICAgICAgIHNsbGlzdFtpXS5jdXIgPSBzbGxpc3Rbcl0uY3VyO1xuICAgICAgICAgICAgc2xsaXN0W3JdLmN1ciA9IGk7XG5cbiAgICAgICAgICAgIC8vIOivpeWFg+e0oOW3suWcqOihqOS4re+8jOWIoOmZpOS5i1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2xsaXN0W3BdLmN1ciA9IHNsbGlzdFtrXS5jdXI7XG4gICAgICAgICAgICBzbGxpc3QuZnJlZShrKTtcbiAgICAgICAgICAgIC8vIOiLpeWIoOmZpOeahOaYr3LmiYDmjIfnu5PngrnvvIzliJnpnIDkv67mlLnlsL7mjIfpkohcbiAgICAgICAgICAgIGlmIChyID09PSBrKSByID0gcDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubGV0IHNsID0gbmV3IFN0YXRpY0xpbmtlZExpc3QoMTApO1xubGV0IHJldCA9IGRpZmZlcmVuY2Uoc2wsIFsxLCAyLCAzXSwgWzMsIDQsIDVdKTtcbmNvbnNvbGUubG9nKHNsKTtcblxuXG5sZXQgdGVzdCA9IG5ldyBTdGF0aWNMaW5rZWRMaXN0KDEwKTtcbnRlc3QuY3JlYXRlKFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDldKTtcbmNvbnNvbGUubG9nKHRlc3QpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9MaXN0L1N0YXRpY0xpbmtlZExpc3QuanMiLCIvKlxuIOWKqOaAgeafpeaJvlxuXG4g5b2T5p+l5om+6KGo5Lul57q/5oCn6KGo55qE5b2i5byP57uE57uH5pe277yM6Iul5a+55p+l5om+6KGo6L+b6KGM5o+S5YWl44CB5Yig6Zmk5oiW5o6S5bqP5pON5L2c77yM5bCx5b+F6aG756e75Yqo5aSn6YeP55qE6K6w5b2V77yM5b2T6K6w5b2V5pWw5b6I5aSa5pe277yM6L+Z56eN56e75Yqo55qE5Luj5Lu35b6I5aSn44CCXG4g5Yip55So5qCR55qE5b2i5byP57uE57uH5p+l5om+6KGo77yM5Y+v5Lul5a+55p+l5om+6KGo6L+b6KGM5Yqo5oCB6auY5pWI55qE5p+l5om+44CCXG5cblxuIOS6jOWPieaOkuW6j+agkShCU1Qp55qE5a6a5LmJXG5cbiDkuozlj4nmjpLluo/moJEoQmluYXJ5IFNvcnQgVHJlZeaIlkJpbmFyeSBTZWFyY2ggVHJlZSkg55qE5a6a5LmJ5Li677ya5LqM5Y+J5o6S5bqP5qCR5oiW6ICF5piv56m65qCR77yM5oiW6ICF5piv5ruh6Laz5LiL5YiX5oCn6LSo55qE5LqM5Y+J5qCR44CCXG4gKDEpIO+8muiLpeW3puWtkOagkeS4jeS4uuepuu+8jOWImeW3puWtkOagkeS4iuaJgOaciee7k+eCueeahOWAvCjlhbPplK7lrZcp6YO95bCP5LqO5qC557uT54K555qE5YC877ybXG4gKDIpIO+8muiLpeWPs+WtkOagkeS4jeS4uuepuu+8jOWImeWPs+WtkOagkeS4iuaJgOaciee7k+eCueeahOWAvCjlhbPplK7lrZcp6YO95aSn5LqO5qC557uT54K555qE5YC877ybXG4gKDMpIO+8muW3puOAgeWPs+WtkOagkemDveWIhuWIq+aYr+S6jOWPieaOkuW6j+agkeOAglxuIOe7k+iuuu+8muiLpeaMieS4reW6j+mBjeWOhuS4gOajteS6jOWPieaOkuW6j+agke+8jOaJgOW+l+WIsOeahOe7k+eCueW6j+WIl+aYr+S4gOS4qumAkuWinuW6j+WIl+OAglxuXG5cbiBCU1TmoJHnmoTmn6Xmib5cbiAxICDmn6Xmib7mgJ3mg7NcbiDpppblhYjlsIbnu5nlrprnmoRL5YC85LiO5LqM5Y+J5o6S5bqP5qCR55qE5qC557uT54K555qE5YWz6ZSu5a2X6L+b6KGM5q+U6L6D77ya6Iul55u4562J77yaIOWImeafpeaJvuaIkOWKn++8m1xuIOKRoCDnu5nlrprnmoRL5YC85bCP5LqOQlNU55qE5qC557uT54K555qE5YWz6ZSu5a2X77ya57un57ut5Zyo6K+l57uT54K555qE5bem5a2Q5qCR5LiK6L+b6KGM5p+l5om+77ybXG4g4pGhIOe7meWumueahEvlgLzlpKfkuo5CU1TnmoTmoLnnu5PngrnnmoTlhbPplK7lrZfvvJrnu6fnu63lnKjor6Xnu5PngrnnmoTlj7PlrZDmoJHkuIrov5vooYzmn6Xmib7jgIJcblxuIOWcqOmaj+acuuaDheWGteS4i++8jOS6jOWPieaOkuW6j+agkeeahOW5s+Wdh+afpeaJvumVv+W6pkFTTOWSjOOPkihuKSjmoJHnmoTmt7HluqYp5piv562J5pWw6YeP57qn55qE44CCXG5cblxuIEJTVOagkeeahOaPkuWFpVxuXG4g5ZyoQlNU5qCR5Lit5o+S5YWl5LiA5Liq5paw57uT54K577yM6KaB5L+d6K+B5o+S5YWl5ZCO5LuN5ruh6LazQlNU55qE5oCn6LSo44CCXG5cbiAxIOaPkuWFpeaAneaDs1xuIOWcqEJTVOagkeS4reaPkuWFpeS4gOS4quaWsOe7k+eCuXjml7bvvIzoi6VCU1TmoJHkuLrnqbrvvIzliJnku6TmlrDnu5Pngrl45Li65o+S5YWl5ZCOQlNU5qCR55qE5qC557uT54K577yb5ZCm5YiZ77yM5bCG57uT54K5eOeahOWFs+mUruWtl+S4juaguee7k+eCuVTnmoTlhbPplK7lrZfov5vooYzmr5TovoPvvJpcbiDikaAg6Iul55u4562J77yaIOS4jemcgOimgeaPkuWFpe+8m1xuIOKRoSAg6IuleC5rZXk8VC0+a2V577ya57uT54K5eOaPkuWFpeWIsFTnmoTlt6blrZDmoJHkuK3vvJtcbiDikaIgIOiLpXgua2V5PlQtPmtlee+8mue7k+eCuXjmj5LlhaXliLBU55qE5Y+z5a2Q5qCR5Lit44CCXG5cbiDnlLHnu5Porrrnn6XvvIzlr7nkuo7kuIDkuKrml6Dluo/luo/liJflj6/ku6XpgJrov4fmnoTpgKDkuIDmo7VCU1TmoJHogIzlj5jmiJDkuIDkuKrmnInluo/luo/liJfjgIJcbiDnlLHnrpfms5Xnn6XvvIzmr4/mrKHmj5LlhaXnmoTmlrDnu5Pngrnpg73mmK9CU1TmoJHnmoTlj7blrZDnu5PngrnvvIzljbPlnKjmj5LlhaXml7bkuI3lv4Xnp7vliqjlhbblroPnu5PngrnvvIzku4XpnIDkv67mlLnmn5DkuKrnu5PngrnnmoTmjIfpkojjgIJcblxuXG4gQlNU5qCR55qE5Yig6ZmkXG5cbiAxICDliKDpmaTmk43kvZzov4fnqIvliIbmnpBcbiDku45CU1TmoJHkuIrliKDpmaTkuIDkuKrnu5PngrnvvIzku43nhLbopoHkv53or4HliKDpmaTlkI7mu6HotrNCU1TnmoTmgKfotKjjgILorr7ooqvliKDpmaTnu5PngrnkuLpw77yM5YW254i257uT54K55Li6ZiDvvIzliKDpmaTmg4XlhrXlpoLkuIvvvJpcbiDikaAgIOiLpXDmmK/lj7blrZDnu5PngrnvvJog55u05o6l5Yig6ZmkcOOAglxuIOKRoSAg6IulcOWPquacieS4gOajteWtkOagkSjlt6blrZDmoJHmiJblj7PlrZDmoJEp77ya55u05o6l55SocOeahOW3puWtkOagkSjmiJblj7PlrZDmoJEp5Y+W5LujcOeahOS9jee9ruiAjOaIkOS4umbnmoTkuIDmo7XlrZDmoJHjgILljbPljp/mnaVw5pivZueahOW3puWtkOagke+8jOWImXDnmoTlrZDmoJHmiJDkuLpm55qE5bem5a2Q5qCR77yb5Y6f5p2lcOaYr2bnmoTlj7PlrZDmoJHvvIzliJlw55qE5a2Q5qCR5oiQ5Li6ZueahOWPs+WtkOagkeOAglxuIOKRoiDoi6Vw5pei5pyJ5bem5a2Q5qCR5Y+I5pyJ5Y+z5a2Q5qCRIO+8muWkhOeQhuaWueazleacieS7peS4i+S4pOenje+8jOWPr+S7peS7u+mAieWFtuS4reS4gOenjeOAglxuIOKXhiAg55SocOeahOebtOaOpeWJjempsee7k+eCueS7o+abv3DjgILljbPku45w55qE5bem5a2Q5qCR5Lit6YCJ5oup5YC85pyA5aSn55qE57uT54K5c+aUvuWcqHDnmoTkvY3nva4o55So57uT54K5c+eahOWGheWuueabv+aNoue7k+eCuXDlhoXlrrkp77yM54S25ZCO5Yig6Zmk57uT54K5c+OAgnPmmK9w55qE5bem5a2Q5qCR5Lit55qE5pyA5Y+z6L6555qE57uT54K55LiU5rKh5pyJ5Y+z5a2Q5qCR77yM5a+5c+eahOWIoOmZpOWQjOKRoeOAglxuIOKXhiDnlKhw55qE55u05o6l5ZCO57un57uT54K55Luj5pu/cOOAguWNs+S7jnDnmoTlj7PlrZDmoJHkuK3pgInmi6nlgLzmnIDlsI/nmoTnu5Pngrlz5pS+5ZyocOeahOS9jee9rijnlKjnu5Pngrlz55qE5YaF5a655pu/5o2i57uT54K5cOWGheWuuSnvvIznhLblkI7liKDpmaTnu5Pngrlz44CCc+aYr3DnmoTlj7PlrZDmoJHkuK3nmoTmnIDlt6bovrnnmoTnu5PngrnkuJTmsqHmnInlt6blrZDmoJHvvIzlr7lz55qE5Yig6Zmk5ZCM4pGh44CCXG5cbiAqL1xuXG5pbXBvcnQgeyBCaW5hcnlUcmVlIH0gZnJvbSAnLi4vQmluYXJ5VHJlZS9CaW5hcnlUcmVlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQlNUTm9kZSBleHRlbmRzIEJpbmFyeVRyZWUge1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZykge1xuICAgICAgICBzdXBlciguLi5hcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJTVOagkeeahOafpeaJvu+8iOmAkuW9ku+8iVxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc2VhcmNoKGtleSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEgPT09IGtleSkgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPCB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWZ0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnRDaGlsZC5zZWFyY2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Q2hpbGQuc2VhcmNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCU1TmoJHnmoTmn6Xmib7vvIjpnZ7pgJLlvZLvvIlcbiAgICAgKiBAcGFyYW0geyp9IGtleVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHNlYXJjaE5vblJlY3Vyc2l2ZShrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChwICYmIHAuZGF0YSAhPT0ga2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5IDwgcC5kYXRhKSBwID0gcC5sZWZ0Q2hpbGQ7XG4gICAgICAgICAgICBlbHNlIHAgPSBwLnJpZ2h0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXAgfHwga2V5ICE9PSBwLmRhdGEpIHJldHVybiBudWxsO1xuICAgICAgICBlbHNlIHJldHVybiBwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJTVOagkeeahOaPkuWFpe+8iOmAkuW9ku+8iVxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XG4gICAgICovXG4gICAgaW5zZXJ0KGtleSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGtleTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSB0aGlzLmRhdGEpIHJldHVybjtcblxuICAgICAgICBsZXQgbm9kZSA9IG5ldyBCU1ROb2RlKGtleSk7XG4gICAgICAgIGlmIChrZXkgPCB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sZWZ0Q2hpbGQpIHRoaXMubGVmdENoaWxkID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMubGVmdENoaWxkLmluc2VydChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJpZ2h0Q2hpbGQpIHRoaXMucmlnaHRDaGlsZCA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQuaW5zZXJ0KGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCU1TmoJHnmoTmj5LlhaXvvIjpnZ7pgJLlvZLvvIlcbiAgICAgKiBAcGFyYW0geyp9IGtleVxuICAgICAqL1xuICAgIGluc2VydE5vblJlY3Vyc2l2ZShrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBrZXk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIGxldCBxO1xuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgaWYgKHAuZGF0YSA9PT0ga2V5KSByZXR1cm47XG4gICAgICAgICAgICAvLyBx5L2c5Li6cOeahOeItuiKgueCuVxuICAgICAgICAgICAgcSA9IHA7XG4gICAgICAgICAgICBpZiAoa2V5IDwgcC5kYXRhKSBwID0gcC5sZWZ0Q2hpbGQ7XG4gICAgICAgICAgICBlbHNlIHAgPSBwLnJpZ2h0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbm9kZSA9IG5ldyBCU1ROb2RlKGtleSk7XG4gICAgICAgIGlmIChrZXkgPCBxLmRhdGEpIHEubGVmdENoaWxkID0gbm9kZTtcbiAgICAgICAgZWxzZSBxLnJpZ2h0Q2hpbGQgPSBub2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWIqeeUqEJTVOagkeeahOaPkuWFpeaTjeS9nOW7uueri+S4gOajtUJTVOagkVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnx1bmRlZmluZWR9IHVzZU5vblJlY3Vyc2l2ZSDmmK/lkKbkvb/nlKjpnZ7pgJLlvZJcbiAgICAgKi9cbiAgICBjcmVhdGVCU1QoYXJyLCB1c2VOb25SZWN1cnNpdmUpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGlmICh1c2VOb25SZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnROb25SZWN1cnNpdmUoYXJyW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoYXJyW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOS9v+eUqOmAkuW9kueahOaWueazleWIoOmZpOS4juWFs+mUruWtl+espuWQiOeahOe7k+eCuVxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IOmcgOimgeafpeaJvueahOWFs+mUruWtl1xuICAgICAqIEBwYXJhbSB7QlNUTm9kZX0gcGFyZW50IOeItuiKgueCue+8jOWGhemDqOiwg+eUqOmcgOimgeeUqOWIsFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIHJlbW92ZShrZXksIHBhcmVudCkge1xuICAgICAgICAvLyDnqbrnu5PngrnnmoTmg4XlhrVcbiAgICAgICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgLy8g5om+5Yiw5YWz6ZSu5a2XXG4gICAgICAgIGlmICh0aGlzLmRhdGEgPT09IGtleSkgcmV0dXJuIGRlbGV0ZU5vZGUodGhpcywgcGFyZW50KTtcbiAgICAgICAgLy8g5p+l5om+5bem5a2Q5qCR77yM5aaC5p6c5pyJ55qE6K+dXG4gICAgICAgIGVsc2UgaWYgKGtleSA8IHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGVmdENoaWxkKSByZXR1cm4gdGhpcy5sZWZ0Q2hpbGQucmVtb3ZlKGtleSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8g5p+l5om+5Y+z5a2Q5qCR77yM5aaC5p6c5pyJ55qE6K+dXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHRDaGlsZCkgcmV0dXJuIHRoaXMucmlnaHRDaGlsZC5yZW1vdmUoa2V5LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOacquaJvuWIsFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6Z2e6YCS5b2S5Yig6Zmk5LiO5YWz6ZSu5a2X56ym5ZCI55qE57uT54K5XG4gICAgICogQHBhcmFtIHsqfSBrZXkg6ZyA6KaB5p+l5om+55qE5YWz6ZSu5a2XXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgcmVtb3ZlTm9uUmVjdXJzaXZlKGtleSkge1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIGxldCBmO1xuXG4gICAgICAgIHdoaWxlIChwICYmIHAuZGF0YSAhPT0ga2V5KSB7XG4gICAgICAgICAgICBmID0gcDtcbiAgICAgICAgICAgIGlmIChrZXkgPCBwLmRhdGEpIHAgPSBwLmxlZnRDaGlsZDtcbiAgICAgICAgICAgIGVsc2UgcCA9IHAucmlnaHRDaGlsZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOayoeacieimgeWIoOmZpOeahOe7k+eCuVxuICAgICAgICBpZiAoIXApIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyDmib7liLDkuobopoHliKDpmaTnmoTnu5PngrlwXG4gICAgICAgIGxldCBzID0gcDtcbiAgICAgICAgbGV0IHE7XG4gICAgICAgIC8vIOWmguaenOacieW3puWPs+WtkOagkVxuICAgICAgICBpZiAocC5sZWZ0Q2hpbGQgJiYgcC5yaWdodENoaWxkKSB7XG4gICAgICAgICAgICBmID0gcDtcbiAgICAgICAgICAgIHMgPSBwLmxlZnRDaGlsZDtcblxuICAgICAgICAgICAgLy8g5om+5Yiw5bem5a2Q5qCR55qE5pyA5aSn5Y+z5a2Q5qCR77yM5Y2z5LuF5bCP5LqO5bem5a2Q5qCR55qE5YC855qE57uT54K5XG4gICAgICAgICAgICB3aGlsZSAocy5yaWdodENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZiA9IHM7XG4gICAgICAgICAgICAgICAgcyA9IHMucmlnaHRDaGlsZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC5kYXRhID0gcy5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g6Iulc+acieW3puWtkOagke+8jOWPs+WtkOagkeS4uuepulxuICAgICAgICBpZiAocy5sZWZ0Q2hpbGQpIHEgPSBzLmxlZnRDaGlsZDtcbiAgICAgICAgZWxzZSBxID0gcy5yaWdodENoaWxkO1xuXG4gICAgICAgIC8vIOWPquacieS4gOS4quaguee7k+eCueeahOaDheWGtVxuICAgICAgICBpZiAoIWYpIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgICAgIGVsc2UgaWYgKGYubGVmdENoaWxkID09IHMpIGYubGVmdENoaWxkID0gcTtcbiAgICAgICAgZWxzZSBmLnJpZ2h0Q2hpbGQgPSBxO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaJvuWIsOWwj+S6jnjnmoTmnIDlpKflhYPntKDlkozlpKfkuo5455qE5pyA5bCP5YWD57SgXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge0FycmF5fSBbbWluLCBtYXhdXG4gICAgICovXG4gICAgZmluZE5laWdoYm9yRWxlbSh4KSB7XG4gICAgICAgIGxldCBsYXN0ID0gdHlwZW9mIHRoaXMuZGF0YSA9PT0gJ251bWJlcicgPyAtSW5maW5pdHkgOiAnYSc7XG4gICAgICAgIGxldCByZXQgPSBbXTtcblxuICAgICAgICB2b2lkIGZ1bmN0aW9uIHJlY3Vyc2UodHJlZSwgeCkge1xuICAgICAgICAgICAgaWYgKHRyZWUubGVmdENoaWxkKSByZWN1cnNlKHRyZWUubGVmdENoaWxkLCB4KTtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgeCAmJiB0cmVlLmRhdGEgPj0geCkgcmV0WzBdID0gbGFzdDtcbiAgICAgICAgICAgIGlmIChsYXN0IDw9IHggJiYgdHJlZS5kYXRhID4geCkgcmV0WzFdID0gdHJlZS5kYXRhO1xuICAgICAgICAgICAgbGFzdCA9IHRyZWUuZGF0YTtcbiAgICAgICAgICAgIGlmICh0cmVlLnJpZ2h0Q2hpbGQpIHJlY3Vyc2UodHJlZS5yaWdodENoaWxkLCB4KTtcbiAgICAgICAgfSh0aGlzLCB4KTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaKiuS6jOWPieaOkuW6j+agkWJzdOWQiOW5tuWIsOivpeagkeS4rVxuICAgICAqIEBwYXJhbSB7QlNUTm9kZX0gYnN0XG4gICAgICovXG4gICAgbWVyZ2UoYnN0KSB7XG4gICAgICAgIGlmIChic3QubGVmdENoaWxkKSB0aGlzLm1lcmdlKGJzdC5sZWZ0Q2hpbGQpO1xuICAgICAgICBpZiAoYnN0LnJpZ2h0Q2hpbGQpIHRoaXMubWVyZ2UoYnN0LnJpZ2h0Q2hpbGQpO1xuICAgICAgICB0aGlzLmluc2VydChic3QuZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5oqK57uT54K55o+S5YWl5Yiw5ZCI6YCC5L2N572uXG4gICAgICogQHBhcmFtIHtCU1ROb2RlfSBub2RlIOW+heaPkuWFpeeahOe7k+eCuVxuICAgICAqL1xuICAgIGluc2VydE5vZGUobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPiB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmlnaHRDaGlsZCkgdGhpcy5yaWdodENoaWxkID0gbm9kZTtcbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMucmlnaHRDaGlsZC5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmRhdGEgPCB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGVmdENoaWxkKSB0aGlzLmxlZnRDaGlsZCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgZWxzZSB0aGlzLmxlZnRDaGlsZC5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5sZWZ0Q2hpbGQgPSBub2RlLnJpZ2h0Q2hpbGQgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWIhuijguS4uuS4pOajteS6jOWPieaOkuW6j+agkVxuICAgICAqIEBwYXJhbSB7Kn0geFxuICAgICAqIEByZXR1cm5zIHtCU1ROb2RlW2EsIGJdfSBh55qE5YWD57Sg5YWo6YOo5bCP5LqO562J5LqOeO+8jGLnmoTlhYPntKDlhajpg6jlpKfkuo54XG4gICAgICovXG4gICAgc3BsaXQoeCkge1xuICAgICAgICBsZXQgYSA9IG5ldyBCU1ROb2RlKCk7XG4gICAgICAgIGxldCBiID0gbmV3IEJTVE5vZGUoKTtcblxuICAgICAgICB2b2lkIGZ1bmN0aW9uIHNwbGl0KHRyZWUsIHgpIHtcbiAgICAgICAgICAgIGlmICh0cmVlLmxlZnRDaGlsZCkgc3BsaXQodHJlZS5sZWZ0Q2hpbGQsIHgpO1xuICAgICAgICAgICAgaWYgKHRyZWUucmlnaHRDaGlsZCkgc3BsaXQodHJlZS5yaWdodENoaWxkLCB4KTtcbiAgICAgICAgICAgIGlmICh0cmVlLmRhdGEgPD0geCkgYS5pbnNlcnROb2RlKHRyZWUpO1xuICAgICAgICAgICAgZWxzZSBiLmluc2VydE5vZGUodHJlZSk7XG4gICAgICAgIH0odGhpcywgeCk7XG5cbiAgICAgICAgcmV0dXJuIFthLCBiXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDliKTmlq10cmVl5piv5ZCm5piv5LqM5Y+J5o6S5bqP5qCRXG4gICAgICogQHBhcmFtIHRyZWVcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNCU1RUcmVlKHRyZWUpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0eXBlb2YgdHJlZS5kYXRhID09PSAnbnVtYmVyJyA/IC1JbmZpbml0eSA6ICdhJztcbiAgICAgICAgbGV0IGZsYWcgPSB0cnVlO1xuXG4gICAgICAgIHZvaWQgZnVuY3Rpb24gaXNCU1RUcmVlKHRyZWUpIHtcbiAgICAgICAgICAgIGlmICh0cmVlLmxlZnRDaGlsZCAmJiBmbGFnKSBpc0JTVFRyZWUodHJlZS5sZWZ0Q2hpbGQpO1xuICAgICAgICAgICAgaWYgKHRyZWUuZGF0YSA8IGxhc3QpIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIGxhc3QgPSB0cmVlLmRhdGE7XG4gICAgICAgICAgICBpZiAodHJlZS5yaWdodENoaWxkICYmIGZsYWcpIGlzQlNUVHJlZSh0cmVlLnJpZ2h0Q2hpbGQpO1xuXG4gICAgICAgIH0odHJlZSk7XG5cbiAgICAgICAgcmV0dXJuIGZsYWc7XG4gICAgfVxufVxuXG4vKipcbiAqIOWIoOmZpOe7k+eCuVxuICogQHBhcmFtIHtCU1ROb2RlfSBwIOimgeWIoOmZpOeahOe7k+eCuVxuICogQHBhcmFtIHtCU1ROb2RlfSBwYXJlbnQg6KaB5Yig6Zmk55qE57uT54K555qE54i26IqC54K5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0g6L+U5Zue5Yig6Zmk5oiQ5YqfXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZU5vZGUocCwgcGFyZW50KSB7XG4gICAgLy8g5Y+25a2Q57uT54K55oiW5Y+q5pyJ5LiA5Liq57uT54K5XG4gICAgaWYgKCFwLmxlZnRDaGlsZCAmJiAhcC5yaWdodENoaWxkKSB7XG4gICAgICAgIC8vIOW9k+WJjee7k+eCueaYr+WFtueItue7k+eCueeahOW3puWtkOagkei/mOaYr+WPs+WtkOagkVxuICAgICAgICBsZXQgcG9zID0gcGFyZW50ICYmIHBhcmVudC5sZWZ0Q2hpbGQgPT0gcCA/ICdsZWZ0Q2hpbGQnIDogJ3JpZ2h0Q2hpbGQnO1xuICAgICAgICBpZiAocGFyZW50KSBwYXJlbnRbcG9zXSA9IG51bGw7XG4gICAgICAgIC8vIOWPquacieS4gOS4que7k+eCueeahOaDheWGtVxuICAgICAgICBlbHNlICBwLmRhdGEgPSBudWxsO1xuICAgIH1cbiAgICAvLyDlj6rmnInlt6blrZDmoJFcbiAgICBlbHNlIGlmICghcC5yaWdodENoaWxkKSB7XG4gICAgICAgIHAuZGF0YSA9IHAubGVmdENoaWxkLmRhdGE7XG4gICAgICAgIHAubGVmdENoaWxkID0gcC5sZWZ0Q2hpbGQubGVmdENoaWxkO1xuICAgIH1cbiAgICAvLyDlj6rmnInlj7PlrZDmoJFcbiAgICBlbHNlIGlmICghcC5sZWZ0Q2hpbGQpIHtcbiAgICAgICAgcC5kYXRhID0gcC5yaWdodENoaWxkLmRhdGE7XG4gICAgICAgIHAucmlnaHRDaGlsZCA9IHAucmlnaHRDaGlsZC5yaWdodENoaWxkO1xuICAgIH1cbiAgICAvLyDlt6blj7PlrZDmoJHpg73mnIlcbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHMgPSBwLmxlZnRDaGlsZDtcbiAgICAgICAgLy8gceS4uueItue7k+eCuVxuICAgICAgICBsZXQgcSA9IHA7XG4gICAgICAgIC8vIOaJvuWIsOW3puWtkOagkeeahOacgOWkp+WPs+WtkOagke+8jOWNs+S7heWwj+S6juW3puWtkOagkeeahOWAvOeahOe7k+eCuVxuICAgICAgICB3aGlsZSAocy5yaWdodENoaWxkKSB7XG4gICAgICAgICAgICBxID0gcztcbiAgICAgICAgICAgIHMgPSBzLnJpZ2h0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBwLmRhdGEgPSBzLmRhdGE7XG4gICAgICAgIGlmIChxICE9IHApIHEucmlnaHRDaGlsZCA9IHMubGVmdENoaWxkO1xuICAgICAgICBlbHNlIHEubGVmdENoaWxkID0gcy5sZWZ0Q2hpbGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmxldCBic3QgPSBuZXcgQlNUTm9kZSgpO1xuYnN0LmNyZWF0ZUJTVChbNDUsIDI0LCA1MywgMTIsIDI0LCA5MF0pO1xuY29uc29sZS5sb2coYnN0LnNlYXJjaCgxMikpO1xuY29uc29sZS5sb2coYnN0LnNlYXJjaCgxMykpO1xuXG5sZXQgYnN0MiA9IG5ldyBCU1ROb2RlKCk7XG5ic3QyLmNyZWF0ZUJTVChbNDUsIDI0LCA1MywgMTIsIDI0LCA5MF0sIHRydWUpO1xuY29uc29sZS5sb2coYnN0Mi5zZWFyY2hOb25SZWN1cnNpdmUoMTIpKTtcbmNvbnNvbGUubG9nKGJzdDIuc2VhcmNoTm9uUmVjdXJzaXZlKDEzKSk7XG5cbmNvbnNvbGUubG9nKCdcXG5maW5kU2libGluZ0VsZW06ICcpO1xuY29uc29sZS5sb2coYnN0LmZpbmROZWlnaGJvckVsZW0oMTIpICsgJycpO1xuY29uc29sZS5sb2coYnN0LmZpbmROZWlnaGJvckVsZW0oOTApICsgJycpO1xuY29uc29sZS5sb2coYnN0LmZpbmROZWlnaGJvckVsZW0oNDUpICsgJycpO1xuXG5jb25zb2xlLmxvZyhic3QucmVtb3ZlKDQ1KSk7XG5jb25zb2xlLmxvZyhic3QucmVtb3ZlKDEpKTtcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoNTMpKTtcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoMTIpKTtcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoOTApKTtcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoMjQpKTtcbmNvbnNvbGUubG9nKGJzdC5yZW1vdmUoMikpO1xuXG4vL2NvbnNvbGUubG9nKGJzdDIucmVtb3ZlTm9uUmVjdXJzaXZlKDQ1KSk7XG4vL2NvbnNvbGUubG9nKGJzdDIucmVtb3ZlTm9uUmVjdXJzaXZlKDEpKTtcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoNTMpKTtcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoMTIpKTtcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoOTApKTtcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoMjQpKTtcbi8vY29uc29sZS5sb2coYnN0Mi5yZW1vdmVOb25SZWN1cnNpdmUoMikpO1xuXG5jb25zb2xlLmxvZygnXFxuaXNCU1RUcmVlOiAnKTtcbmNvbnNvbGUubG9nKEJTVE5vZGUuaXNCU1RUcmVlKGJzdCkpO1xuLy9jb25zb2xlLmxvZyhCU1ROb2RlLmlzQlNUVHJlZShzb3NUcmVlKSk7XG5cblxuLyoqXG4gKiDku47lpKfliLDlsI/ovpPlh7rkuozlj4nmjpLluo/moJHkuK3miYDmnInkuI3lsI/kuo5455qE5YWD57SgXG4gKiBAcGFyYW0gYnN0XG4gKiBAcGFyYW0geFxuICovXG5mdW5jdGlvbiBwcmludE5vdExlc3NUaGFuKGJzdCwgeCkge1xuICAgIGlmIChic3QucmlnaHRDaGlsZCkgcHJpbnROb3RMZXNzVGhhbihic3QucmlnaHRDaGlsZCwgeCk7XG4gICAgaWYgKGJzdC5kYXRhIDwgeCkgcmV0dXJuO1xuICAgIGNvbnNvbGUubG9nKGJzdC5kYXRhKTtcbiAgICBpZiAoYnN0LmxlZnRDaGlsZCkgcHJpbnROb3RMZXNzVGhhbihic3QubGVmdENoaWxkLCB4KTtcbn1cblxuY29uc29sZS5sb2coJ1xcbnByaW50Tm90TGVzc1RoYW46ICcpO1xucHJpbnROb3RMZXNzVGhhbihic3QyLCA5MCk7XG5jb25zb2xlLmxvZygnXFxuJyk7XG5wcmludE5vdExlc3NUaGFuKGJzdDIsIDEyKTtcblxuXG5ic3QubWVyZ2UoYnN0Mik7XG5cbmxldCBhMSA9IG5ldyBCU1ROb2RlKDUpO1xubGV0IGEyID0gbmV3IEJTVE5vZGUoOTEpO1xuYnN0Mi5pbnNlcnROb2RlKGExKTtcbmJzdDIuaW5zZXJ0Tm9kZShhMik7XG5cbmJzdDIuc3BsaXQoNDUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1NlYXJjaC9CaW5hcnlTb3J0ZWRUcmVlLmpzIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IEx1a2Ugb24gMjAxNS8yLzIuXG4gKi9cblxuaW1wb3J0IGRlZmF1bHRDb21wYXJlIGZyb20gJy4uL2RlZmF1bHRDb21wYXJpc2lvbic7XG5cbi8qXG4g5Lqk5o2i5o6S5bqPXG5cbiDmmK/kuIDnsbvln7rkuo7kuqTmjaLnmoTmjpLluo/vvIzns7vnu5/lnLDkuqTmjaLlj43luo/nmoTorrDlvZXnmoTlgbblr7nvvIznm7TliLDkuI3lho3mnInov5nmoLfnmoTlgbblr7nkuLrmraLjgILlhbbkuK3mnIDln7rmnKznmoTmmK/lhpLms6HmjpLluo8oQnViYmxlIFNvcnQp44CCXG5cbiDlhpLms6HmjpLluo9cbiAxICDmjpLluo/mgJ3mg7NcbiDkvp3mrKHmr5TovoPnm7jpgrvnmoTkuKTkuKrorrDlvZXnmoTlhbPplK7lrZfvvIzoi6XkuKTkuKrorrDlvZXmmK/lj43luo/nmoQo5Y2z5YmN5LiA5Liq6K6w5b2V55qE5YWz6ZSu5a2X5aSn5LqO5ZCO5YmN5LiA5Liq6K6w5b2V55qE5YWz6ZSu5a2XKe+8jOWImei/m+ihjOS6pOaNou+8jOebtOWIsOayoeacieWPjeW6j+eahOiusOW9leS4uuatouOAglxuICAgICDikaAg6aaW5YWI5bCGTC0+UlsxXeS4jkwtPlJbMl3nmoTlhbPplK7lrZfov5vooYzmr5TovoPvvIzoi6XkuLrlj43luo8oTC0+UlsxXeeahOWFs+mUruWtl+Wkp+S6jkwtPlJbMl3nmoTlhbPplK7lrZcp77yM5YiZ5Lqk5o2i5Lik5Liq6K6w5b2V77yb54S25ZCO5q+U6L6DTC0+UlsyXeS4jkwtPlJbM13nmoTlhbPplK7lrZfvvIzkvp3mraTnsbvmjqjvvIznm7TliLBMLT5SW24tMV3kuI5MLT5SW25d55qE5YWz6ZSu5a2X5q+U6L6D5ZCO5Li65q2i77yM56ew5Li65LiA6Laf5YaS5rOh5o6S5bqP77yMTC0+UltuXeS4uuWFs+mUruWtl+acgOWkp+eahOiusOW9leOAglxuICAgICDikaEgIOeEtuWQjui/m+ihjOesrOS6jOi2n+WGkuazoeaOkuW6j++8jOWvueWJjW4tMeS4quiusOW9lei/m+ihjOWQjOagt+eahOaTjeS9nOOAglxuIOS4gOiIrOWcsO+8jOesrGnotp/lhpLms6HmjpLluo/mmK/lr7lMLT5SWzEg4oCmIG4taSsxXeS4reeahOiusOW9lei/m+ihjOeahO+8jOWboOatpO+8jOiLpeW+heaOkuW6j+eahOiusOW9leaciW7kuKrvvIzliJnopoHnu4/ov4duLTHotp/lhpLms6HmjpLluo/miY3og73kvb/miYDmnInnmoTorrDlvZXmnInluo/jgIJcblxuIDIgIOaOkuW6j+ekuuS+i1xuIOiuvuaciTnkuKrlvoXmjpLluo/nmoTorrDlvZXvvIzlhbPplK7lrZfliIbliKvkuLoyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXG5cbiDliJ3lp4vlhbPplK7lrZfluo/liJc6ICAyMyAgICAzOCAgICAgMjIgICAgIDQ1ICAgICAyMyAgICAgNjcgICAgIDMxICAgICAxNSAgICA0MVxuIOesrOS4gOi2n+aOkuW6j+WQjjogICAgMjMgICAgMjIgICAgIDM4ICAgICAyMyAgICAgNDUgICAgIDMxICAgICAxNSAgICAgNDEgICAgNjdcbiDnrKzkuozotp/mjpLluo/lkI46ICAgIDIyICAgIDIzICAgICAyMyAgICAgMzggICAgIDMxICAgICAxNSAgICAgNDEgICAgIDQ1ICAgIDY3XG4g56ys5LiJ6Laf5o6S5bqP5ZCOOiAgICAyMiAgICAyMyAgICAgMjMgICAgIDMxICAgICAxNSAgICAgMzggICAgIDQxICAgICA0NSAgICA2N1xuIOesrOWbm+i2n+aOkuW6j+WQjjogICAgMjIgICAgMjMgICAgIDIzICAgICAxNSAgICAgMzEgICAgIDM4ICAgICA0MSAgICAgNDUgICAgNjdcbiDnrKzkupTotp/mjpLluo/lkI46ICAgIDIyICAgIDIzICAgICAxNSAgICAgMjMgICAgIDMxICAgICAzOCAgICAgNDEgICAgIDQ1ICAgIDY3XG4g56ys5YWt6Laf5o6S5bqP5ZCOOiAgICAyMiAgICAxNSAgICAgMjMgICAgIDIzICAgICAzMSAgICAgMzggICAgIDQxICAgICA0NSAgICA2N1xuIOesrOS4g+i2n+aOkuW6j+WQjjogICAgMTUgICAgMjIgICAgIDIzICAgICAyMyAgICAgMzEgICAgIDM4ICAgICA0MSAgICAgNDUgICAgNjdcblxuMy7nrpfms5XliIbmnpBcbiDml7bpl7TlpI3mnYLluqZcbiDil4YgIOacgOWlveaDheWGtSjmraPluo8p77ya5q+U6L6D5qyh5pWw77yabi0x77yb56e75Yqo5qyh5pWw77yaMO+8m1xuIOKXhiAg5pyA5Z2P5oOF5Ya1KOmAhuW6jynvvJpcbiDmr5TovoPmrKHmlbDvvJogbiAqIChuIC0gMSkgLyAyXG4g56e75Yqo5qyh5pWw77yaIDMqbioobiAtIDEpIC8gMlxuXG4g5pWF5pe26Ze05aSN5p2C5bqm77yaVChuKT1PKG7CsilcbiDnqbrpl7TlpI3mnYLluqbvvJpTKG4pPU8oMSlcblxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBidWJibGVTb3J0KHNxTGlzdCwgY29tcCA9IGRlZmF1bHRDb21wYXJlKSB7XG4gICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBsZXQgY2hhbmdlID0gMDtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBsZW4gLSBpOyArK2opIHtcbiAgICAgICAgICAgIGlmIChjb21wKHNxTGlzdFtqICsgMV0sIHNxTGlzdFtqXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlID0gMTtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IHNxTGlzdFtqXTtcbiAgICAgICAgICAgICAgICBzcUxpc3Rbal0gPSBzcUxpc3RbaiArIDFdO1xuICAgICAgICAgICAgICAgIHNxTGlzdFtqICsgMV0gPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjaGFuZ2UpIGJyZWFrO1xuICAgIH1cbn1cblxuXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xuYnViYmxlU29ydChhcnIpO1xuY29uc29sZS5sb2coJ2J1YmJsZVNvcnQ6XFxuJyArIGFyciArICcnKTtcblxuXG4vLyDlhpLms6HmlLnov5sxXG5leHBvcnQgZnVuY3Rpb24gYnViYmxlU29ydDIoc3FMaXN0LCBjb21wID0gZGVmYXVsdENvbXBhcmUpIHtcbiAgICBsZXQgbGVuID0gc3FMaXN0Lmxlbmd0aDtcbiAgICBsZXQgY2hhbmdlID0gbGVuIC0gMTtcblxuICAgIHdoaWxlIChjaGFuZ2UpIHtcbiAgICAgICAgbGV0IGMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgMV0pID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gc3FMaXN0W2ldO1xuICAgICAgICAgICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFtpICsgMV07XG4gICAgICAgICAgICAgICAgc3FMaXN0W2kgKyAxXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgLy8gY+aMh+ekuui/meS4gOi2n+WGkuazoeS4reWPkeeUn+S6pOaNoueahOWFg+e0oFxuICAgICAgICAgICAgICAgIGMgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZSA9IGM7XG4gICAgfVxufVxuXG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xuYnViYmxlU29ydDIoYXJyKTtcbmNvbnNvbGUubG9nKCdidWJibGVTb3J0MjpcXG4nICsgYXJyICsgJycpO1xuXG5cbi8vIOebuOmCu+S4pOi2n+WPjeaWueWQkei1t+azoeeahOWGkuazoeaOkuW6j+eul+azlVxuZXhwb3J0IGZ1bmN0aW9uIGNvY2tUYWlsU29ydChzcUxpc3QsIGNvbXAgPSBkZWZhdWx0Q29tcGFyZSkge1xuICAgIGxldCBsZW4gPSBzcUxpc3QubGVuZ3RoO1xuICAgIC8vIOWGkuazoeS4iuS4i+eVjFxuICAgIGxldCBsb3cgPSAwLCBoaWdoID0gbGVuIC0gMTtcbiAgICBsZXQgY2hhbmdlID0gMTtcbiAgICBsZXQgdGVtcDtcblxuICAgIHdoaWxlIChsb3cgPCBoaWdoICYmIGNoYW5nZSkge1xuICAgICAgICBjaGFuZ2UgPSAwO1xuXG4gICAgICAgIC8vIOS7juS4iuWQkeS4i+i1t+azoVxuICAgICAgICBmb3IgKGxldCBpID0gbG93OyBpIDwgaGlnaDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgMV0pID4gMCkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbaV07XG4gICAgICAgICAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2kgKyAxXTtcbiAgICAgICAgICAgICAgICBzcUxpc3RbaSArIDFdID0gdGVtcDtcbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIOS/ruaUueS4iueVjFxuICAgICAgICAtLWhpZ2g7XG5cbiAgICAgICAgLy8g5LuO5LiL5ZCR5LiK6LW35rOhXG4gICAgICAgIGZvciAobGV0IGkgPSBoaWdoOyBpID4gbG93OyAtLWkpIHtcbiAgICAgICAgICAgIGlmIChjb21wKHNxTGlzdFtpXSwgc3FMaXN0W2kgLSAxXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtpXTtcbiAgICAgICAgICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3RbaSAtIDFdO1xuICAgICAgICAgICAgICAgIHNxTGlzdFtpIC0gMV0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgIGNoYW5nZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8g5L+u5pS55LiL55WMXG4gICAgICAgICsrbG93O1xuICAgIH1cbn1cblxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcbmNvY2tUYWlsU29ydChhcnIpO1xuY29uc29sZS5sb2coJ2NvY2tUYWlsU29ydDpcXG4nICsgYXJyICsgJycpO1xuXG5cbi8vIOaUuei/mzNcbmV4cG9ydCBmdW5jdGlvbiBjb2NrVGFpbFNvcnQyKHNxTGlzdCwgY29tcCA9IGRlZmF1bHRDb21wYXJlKSB7XG4gICAgbGV0IGIgPSB7fTtcbiAgICBsZXQgbGVuID0gc3FMaXN0Lmxlbmd0aDtcbiAgICAvLyBk5Li65YaS5rOh5pa55ZCR5qCH6K+G77yMIDHkuLrlkJHkuIrvvIwtMeS4uuWQkeS4i1xuICAgIGxldCBkID0gMTtcbiAgICAvLyBiWzBd5Li65YaS5rOh5LiK55WM77yMYlsyXeS4uuWGkuazoeS4iueVjO+8jGJbMV3ml6DnlKhcbiAgICBiWzBdID0gMDtcbiAgICBiWzJdID0gbGVuIC0gMTtcbiAgICBsZXQgY2hhbmdlID0gMTtcblxuICAgIHdoaWxlIChiWzBdIDwgYlsyXSAmJiBjaGFuZ2UpIHtcbiAgICAgICAgY2hhbmdlID0gMDtcblxuICAgICAgICAvLyDnu5/kuIDnmoTlhpLms6Hnrpfms5VcbiAgICAgICAgZm9yIChsZXQgaSA9IGJbMSAtIGRdOyBpICE9PSBiWzEgKyBkXTsgaSArPSBkKSB7XG4gICAgICAgICAgICAvLyDms6jmhI/ov5nkuKrkuqTmjaLmnaHku7ZcbiAgICAgICAgICAgIGlmIChjb21wKHNxTGlzdFtpXSwgc3FMaXN0W2kgKyBkXSkgKiBkID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gc3FMaXN0W2ldO1xuICAgICAgICAgICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFtpICsgZF07XG4gICAgICAgICAgICAgICAgc3FMaXN0W2kgKyBkXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgY2hhbmdlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOS/ruaUuei+ueeVjFxuICAgICAgICBiWzEgKyBkXSAtPSBkO1xuICAgICAgICAvLyDmjaLkuKrmlrnlkJFcbiAgICAgICAgZCAqPSAtMTtcbiAgICB9XG59XG5cbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XG5jb2NrVGFpbFNvcnQyKGFycik7XG5jb25zb2xlLmxvZygnY29ja1RhaWxTb3J0MjpcXG4nICsgYXJyICsgJycpO1xuXG5cblxuLypcbiDlv6vpgJ/mjpLluo9cblxuIDEgIOaOkuW6j+aAneaDs1xuIOmAmui/h+S4gOi2n+aOkuW6j++8jOWwhuW+heaOkuW6j+iusOW9leWIhuWJsuaIkOeLrOeri+eahOS4pOmDqOWIhu+8jOWFtuS4reS4gOmDqOWIhuiusOW9leeahOWFs+mUruWtl+Wdh+avlOWPpuS4gOmDqOWIhuiusOW9leeahOWFs+mUruWtl+Wwj++8jOWGjeWIhuWIq+Wvuei/meS4pOmDqOWIhuiusOW9lei/m+ihjOS4i+S4gOi2n+aOkuW6j++8jOS7pei+vuWIsOaVtOS4quW6j+WIl+acieW6j+OAglxuXG4gMiAg5o6S5bqP6L+H56iLXG4g6K6+5b6F5o6S5bqP55qE6K6w5b2V5bqP5YiX5pivUltz4oCmdF0g77yM5Zyo6K6w5b2V5bqP5YiX5Lit5Lu75Y+W5LiA5Liq6K6w5b2VKOS4gOiIrOWPllJbc10p5L2c5Li65Y+C54WnKOWPiOensOS4uuWfuuWHhuaIluaeoui9tCnvvIzku6VSW3NdLmtleeS4uuWfuuWHhumHjeaWsOaOkuWIl+WFtuS9meeahOaJgOacieiusOW9le+8jOaWueazleaYr++8mlxuICAgICDil4Yg5omA5pyJ5YWz6ZSu5a2X5q+U5Z+65YeG5bCP55qE5pS+UltzXeS5i+WJje+8m1xuICAgICDil4Yg5omA5pyJ5YWz6ZSu5a2X5q+U5Z+65YeG5aSn55qE5pS+UltzXeS5i+WQjuOAglxuIOS7pVJbc10ua2V55pyA5ZCO5omA5Zyo5L2N572uaeS9nOS4uuWIhueVjO+8jOWwhuW6j+WIl1Jbc+KApnRd5YiG5Ymy5oiQ5Lik5Liq5a2Q5bqP5YiX77yM56ew5Li65LiA6Laf5b+r6YCf5o6S5bqP44CCXG5cbiAzICDkuIDotp/lv6vpgJ/mjpLluo/mlrnms5VcbiDku47luo/liJfnmoTkuKTnq6/kuqTmm7/miavmj4/lkITkuKrorrDlvZXvvIzlsIblhbPplK7lrZflsI/kuo7ln7rlh4blhbPplK7lrZfnmoTorrDlvZXkvp3mrKHmlL7nva7liLDluo/liJfnmoTliY3ovrnvvJvogIzlsIblhbPplK7lrZflpKfkuo7ln7rlh4blhbPplK7lrZfnmoTorrDlvZXku47luo/liJfnmoTmnIDlkI7nq6/otbfvvIzkvp3mrKHmlL7nva7liLDluo/liJfnmoTlkI7ovrnvvIznm7TliLDmiavmj4/lrozmiYDmnInnmoTorrDlvZXjgIJcblxuIOiuvue9ruaMh+mSiGxvd++8jGhpZ2jvvIzliJ3lgLzkuLrnrKwx5Liq5ZKM5pyA5ZCO5LiA5Liq6K6w5b2V55qE5L2N572u44CCXG4g6K6+5Lik5Liq5Y+Y6YePae+8jGrvvIzliJ3lp4vml7bku6RpPWxvd++8jGo9aGlnaO+8jOS7pVJbbG93XS5rZXnkvZzkuLrln7rlh4Yo5bCGUltsb3dd5L+d5a2Y5ZyodGVtcOS4rSkg44CCXG4g4pGgIOS7jmrmiYDmjIfkvY3nva7lkJHliY3mkJzntKLvvJrlsIZ0ZW1w5LiOUltqXS5rZXnov5vooYzmr5TovoPvvJpcbiAgICDil4Yg6IuldGVtcOKJpFJbal0ua2V5IO+8muS7pGo9ai0x77yM54S25ZCO57un57ut6L+b6KGM5q+U6L6D77yMIOebtOWIsGk9auaIlnRlbXA+UltqXS5rZXnkuLrmraLvvJtcbiAgICDil4Yg6IuldGVtcD5SW2pdLmtleSDvvJpSW2pd74OeUltpXe+8jOiFvuepulJbal3nmoTkvY3nva7vvIwg5LiU5LukaT1pKzHvvJtcbiDikaEg5LuOaeaJgOaMh+S9jee9rui1t+WQkeWQjuaQnOe0ou+8muWwhnRlbXDkuI5SW2ldLmtleei/m+ihjOavlOi+g++8mlxuICAgIOKXhiDoi6V0ZW1w4omlUltpXS5rZXkg77ya5LukaT1pKzHvvIznhLblkI7nu6fnu63ov5vooYzmr5TovoPvvIwg55u05YiwaT1q5oiWdGVtcDxSW2ldLmtleeS4uuatou+8m1xuICAgIOKXhiDoi6V0ZW1wPFJbaV0ua2V5IO+8mlJbaV3vg55SW2pd77yM6IW+56m6UltpXeeahOS9jee9ru+8jCDkuJTku6RqPWotMe+8m1xuIOKRoiDph43lpI3ikaDjgIHikaHvvIznm7Toh7NpPWrkuLrmraLvvIxp5bCx5pivdGVtcCjln7rlh4Yp5omA5bqU5pS+572u55qE5L2N572u44CCXG5cbiDnrpfms5XliIbmnpBcbiDlv6vpgJ/mjpLluo/nmoTkuLvopoHml7bpl7TmmK/oirHotLnlnKjliJLliIbkuIrvvIzlr7nplb/luqbkuLpr55qE6K6w5b2V5bqP5YiX6L+b6KGM5YiS5YiG5pe25YWz6ZSu5a2X55qE5q+U6L6D5qyh5pWw5pivay0xIOOAguiuvumVv+W6puS4um7nmoTorrDlvZXluo/liJfov5vooYzmjpLluo/nmoTmr5TovoPmrKHmlbDkuLpDKG4p77yM5YiZQyhuKT1uLTErQyhrKStDKG4tay0xKSDjgIJcbiDil4YgIOacgOWlveaDheWGte+8muavj+asoeWIkuWIhuW+l+WIsOeahOWtkOW6j+WIl+Wkp+iHtOebuOetie+8jOWImVxuIEMobik8PWjDl24rMmjDl0Mobi8yaCkg77yM5b2Tbi8yaD0x5pe25o6S5bqP57uT5p2f44CCXG4g5Y2zQyhuKeKJpE8obsOX44+SMm4pIO+8m1xuIOKXhiAg5pyA5Z2P5oOF5Ya177ya5q+P5qyh5YiS5YiG5b6X5Yiw55qE5a2Q5bqP5YiX5Lit5pyJ5LiA5Liq5Li656m677yM5Y+m5LiA5Liq5a2Q5bqP5YiX55qE6ZW/5bqm5Li6bi0x44CC5Y2z5q+P5qyh5YiS5YiG5omA6YCJ5oup55qE5Z+65YeG5piv5b2T5YmN5b6F5o6S5bqP5bqP5YiX5Lit55qE5pyA5bCPKOaIluacgOWkpynlhbPplK7lrZfjgIJcbiDmr5TovoPmrKHmlbDvvJo6ICDljbNDKG4pPU8objIpXG4g4peGICDkuIDoiKzmg4XlhrXvvJog5a+5buS4quiusOW9lei/m+ihjOW/q+mAn+aOkuW6j+aJgOmcgOeahOaXtumXtFQobinnu4TmiJDmmK/vvJpcbiAgICAg4pGgIOWvuW7kuKrorrDlvZXov5vooYzkuIDotp/liJLliIbmiYDpnIDnmoTml7bpl7TmmK/vvJpuw5dDIO+8jEPmmK/luLjmlbDvvJtcbiAgICAg4pGhIOWvueaJgOW+l+WIsOeahOS4pOS4quWtkOW6j+WIl+i/m+ihjOW/q+mAn+aOkuW6j+eahOaXtumXtO+8mlxuICAgICAgICBUYXZnKG4pPUMobikrVGF2ZyhrLTEpK1Rhdmcobi1rKSAgICAgICAgICDigKbigKZcblxuIOW/q+mAn+aOkuW6j+eahOW5s+Wdh+aXtumXtOWkjeadguW6puaYr++8mlQobik9Tyhu44+SMm4pXG4g5LuO5omA6ZyA6KaB55qE6ZmE5Yqg56m66Ze05p2l55yL77yM5b+r6YCf5o6S5bqP566X5rOV5piv6YCS5b2S6LCD55So77yM57O757uf5YaF55So5aCG5qCI5L+d5a2Y6YCS5b2S5Y+C5pWw77yM5b2T5q+P5qyh5YiS5YiG5q+U6L6D5Z2H5YyA5pe277yM5qCI55qE5pyA5aSn5rex5bqm5Li6W+OPkjJuXSsxIOOAglxuXG4g5b+r6YCf5o6S5bqP55qE56m66Ze05aSN5p2C5bqm5piv77yaUyhuKT1PKOOPkjJuKVxuIOS7juaOkuW6j+eahOeos+WumuaAp+adpeeci++8jOW/q+mAn+aOkuW6j+aYr+S4jeeos+WumueahOOAglxuXG4gKi9cblxuZnVuY3Rpb24gcGFydGl0aW9uMShzcUxpc3QsIGxvdywgaGlnaCkge1xuICAgIGxldCB0ZW1wID0gc3FMaXN0W2xvd107XG5cbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCAmJiBzcUxpc3RbaGlnaF0gPj0gdGVtcCktLWhpZ2g7XG4gICAgICAgIHNxTGlzdFtsb3ddID0gc3FMaXN0W2hpZ2hdO1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCAmJiBzcUxpc3RbbG93XSA8PSB0ZW1wKSsrbG93O1xuICAgICAgICBzcUxpc3RbaGlnaF0gPSBzcUxpc3RbbG93XTtcbiAgICB9XG5cbiAgICBzcUxpc3RbbG93XSA9IHRlbXA7XG5cbiAgICByZXR1cm4gbG93O1xufVxuXG4vLyDkvJjljJbkuIDotp/lv6vpgJ/mjpLluo/mlrnms5XvvJog6ZqP5py65YyWcGFydGl0aW9uXG4vLyDmnIDlnY/mg4XlhrXmlYjnjoflpKfluYXmj5DljYfvvIzml7bpl7TlpI3mnYLluqZUKG4pPU8obuOPkjJuKVxuZnVuY3Rpb24gcGFydGl0aW9uMihzcUxpc3QsIGxvdywgaGlnaCkge1xuICAgIGxldCB0ZW1wO1xuICAgIGxldCBuID0gaGlnaCAtIGxvdyArIDE7XG4gICAgbGV0IHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBuKSArIGxvdztcblxuICAgIC8vbGV0IHJhbmQgPSAobG93ICsgaGlnaCkgPj4gMTtcbiAgICB0ZW1wID0gc3FMaXN0W2hpZ2hdO1xuICAgIHNxTGlzdFtoaWdoXSA9IHNxTGlzdFtyYW5kXTtcbiAgICBzcUxpc3RbcmFuZF0gPSB0ZW1wO1xuXG4gICAgbGV0IGkgPSBsb3cgLSAxO1xuICAgIGxldCBwaXZvdCA9IHNxTGlzdFtoaWdoXTtcblxuICAgIGZvciAobGV0IGogPSBsb3c7IGogPCBoaWdoOyArK2opIHtcbiAgICAgICAgaWYgKHNxTGlzdFtqXSA8PSBwaXZvdCkge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtpXTtcbiAgICAgICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFtqXTtcbiAgICAgICAgICAgIHNxTGlzdFtqXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICArK2k7XG4gICAgc3FMaXN0W2hpZ2hdID0gc3FMaXN0W2ldO1xuICAgIHNxTGlzdFtpXSA9IHBpdm90O1xuXG4gICAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIHBhcnRpdGlvbihzcUxpc3QsIGxvdywgaGlnaCwgY29tcCkge1xuICAgIGxldCB0ZW1wO1xuICAgIGxldCBpID0gbG93O1xuICAgIGxldCBqID0gaGlnaCArIDE7XG4gICAgbGV0IHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpICsgbG93ICsgMTtcbiAgICAvL2xldCByYW5kID0gKGxvdyArIGhpZ2gpID4+IDE7XG5cbiAgICB0ZW1wID0gc3FMaXN0W2xvd107XG4gICAgc3FMaXN0W2xvd10gPSBzcUxpc3RbcmFuZF07XG4gICAgc3FMaXN0W3JhbmRdID0gdGVtcDtcblxuICAgIGxldCB4ID0gc3FMaXN0W2xvd107XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgICB3aGlsZSAoY29tcChzcUxpc3RbKytpXSwgeCkgPCAwICYmIGkgPCBoaWdoKTtcbiAgICAgICAgd2hpbGUgKGNvbXAoc3FMaXN0Wy0tal0sIHgpID4gMCk7XG4gICAgICAgIGlmIChpID49IGopIGJyZWFrO1xuICAgICAgICB0ZW1wID0gc3FMaXN0W2ldO1xuICAgICAgICBzcUxpc3RbaV0gPSBzcUxpc3Rbal07XG4gICAgICAgIHNxTGlzdFtqXSA9IHRlbXA7XG4gICAgfVxuXG4gICAgc3FMaXN0W2xvd10gPSBzcUxpc3Rbal07XG4gICAgc3FMaXN0W2pdID0geDtcblxuICAgIHJldHVybiBqO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVpY2tTb3J0UmVjdXJzaXZlKFxuICAgIHNxTGlzdCA9IFtdLFxuICAgIGxvdyA9IDAsXG4gICAgaGlnaCA9IHNxTGlzdC5sZW5ndGggLSAxLFxuICAgIGNvbXAgPSBkZWZhdWx0Q29tcGFyZVxuKSB7XG4gICAgaWYgKGxvdyA+PSBoaWdoKSByZXR1cm47XG5cbiAgICBsZXQgayA9IHBhcnRpdGlvbihzcUxpc3QsIGxvdywgaGlnaCwgY29tcCk7XG4gICAgcXVpY2tTb3J0UmVjdXJzaXZlKHNxTGlzdCwgbG93LCBrIC0gMSwgY29tcCk7XG4gICAgcXVpY2tTb3J0UmVjdXJzaXZlKHNxTGlzdCwgayArIDEsIGhpZ2gsIGNvbXApO1xufVxuXG5cbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XG5xdWlja1NvcnRSZWN1cnNpdmUoYXJyKTtcbmNvbnNvbGUubG9nKCdxdWlja1NvcnRSZWN1cnNpdmU6XFxuJyArIGFyciArICcnKTtcblxuXG4vKlxu5b+r5o6S6YCS5b2S566X5rOV5LyY5YyW77yM5Zyo5pyA5Z2P5oOF5Ya15LiL5aCG5qCI5rex5bqm5Li6Tyhsb2duKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVpY2tTb3J0UmVjdXJzaXZlMihcbiAgICBzcUxpc3QgPSBbXSxcbiAgICBsb3cgPSAwLFxuICAgIGhpZ2ggPSBzcUxpc3QubGVuZ3RoIC0gMSxcbiAgICBjb21wID0gZGVmYXVsdENvbXBhcmVcbikge1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIGxldCBrID0gcGFydGl0aW9uKHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKTtcblxuICAgICAgICAvLyDlr7nkuKTkuKrlrZDmlbDnu4TkuK3ovoPlsI/nmoTkuIDkuKrlrZDmlbDnu4Tov5vooYzpgJLlvZLosIPnlKjjgIJcbiAgICAgICAgLy8g6L6D5bCP5a2Q5pWw57uE55qE5aSn5bCP5pyA5aSa5Li65Y6f5pWw57uE5aSn5bCP5LiA5Y2K77yMXG4gICAgICAgIC8vIOeUseS6juavj+asoemAkuW9kuiwg+eUqOeahOaVsOe7hOWkp+Wwj+iHs+WwkeWHj+WwkeS4gOWNiu+8jOaJgOS7pemAkuW9kuiwg+eUqOeahOasoeaVsFxuICAgICAgICAvLyDmnIDlpJrkuLpPKGxvZ24pXG4gICAgICAgIGlmIChrIC0gbG93ICsgMSA8IGhpZ2ggLSBrKSB7XG4gICAgICAgICAgICBxdWlja1NvcnRSZWN1cnNpdmUyKHNxTGlzdCwgbG93LCBrIC0gMSwgY29tcCk7XG4gICAgICAgICAgICBsb3cgPSBrICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1aWNrU29ydFJlY3Vyc2l2ZTIoc3FMaXN0LCBrICsgMSwgaGlnaCwgY29tcCk7XG4gICAgICAgICAgICBoaWdoID0gayAtIDE7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgYXJyID0gWzIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDFdO1xucXVpY2tTb3J0UmVjdXJzaXZlMihhcnIpO1xuY29uc29sZS5sb2coJ3F1aWNrU29ydFJlY3Vyc2l2ZTI6XFxuJyArIGFyciArICcnKTtcblxuXG5leHBvcnQgZnVuY3Rpb24gcXVpY2tTb3J0Tm9uUmVjdXJzaXZlKFxuICAgIHNxTGlzdCA9IFtdLFxuICAgIGxvdyA9IDAsXG4gICAgaGlnaCA9IHNxTGlzdC5sZW5ndGggLSAxLFxuICAgIGNvbXAgPSBkZWZhdWx0Q29tcGFyZVxuKSB7XG4gICAgbGV0IHN0YWNrID0gW107XG4gICAgbGV0IGs7XG5cbiAgICBkbyB7XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICBrID0gcGFydGl0aW9uKHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKTtcbiAgICAgICAgICAgIC8vIOesrOS6jOS4quWtkOW6j+WIl+eahOS4iizkuIvnlYzliIbliKvlhaXmoIhcbiAgICAgICAgICAgIHN0YWNrLnB1c2goaGlnaCwgayArIDEpO1xuICAgICAgICAgICAgLy9zdGFjay5wdXNoKGsgKyAxKTtcbiAgICAgICAgICAgIGhpZ2ggPSBrIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3RhY2subGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgbG93ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGhpZ2ggPSBzdGFjay5wb3AoKTtcbiAgICB9IHdoaWxlICgxKTtcbn1cblxudmFyIGFyciA9IFsyMywgMzgsIDIyLCA0NSwgMjMsIDY3LCAzMSwgMTUsIDQxXTtcbnF1aWNrU29ydE5vblJlY3Vyc2l2ZShhcnIpO1xuY29uc29sZS5sb2coJ3F1aWNrU29ydE5vblJlY3Vyc2l2ZTpcXG4nICsgYXJyICsgJycpO1xuXG4vLyDkvJjljJbniYjmnKxcbmV4cG9ydCBmdW5jdGlvbiBxdWlja1NvcnQoXG4gICAgc3FMaXN0ID0gW10sXG4gICAgbG93ID0gMCxcbiAgICBoaWdoID0gc3FMaXN0Lmxlbmd0aCAtIDEsXG4gICAgY29tcCA9IGRlZmF1bHRDb21wYXJlXG4pIHtcbiAgICBsZXQgc3RhY2sgPSBbXTtcbiAgICBsZXQgcGl2b3Q7XG5cbiAgICBkbyB7XG4gICAgICAgIC8vIOWmguaenOW9k+WJjeWtkOW6j+WIl+mVv+W6puWkp+S6jjPkuJTlsJrmnKrmjpLlpb3luo9cbiAgICAgICAgaWYgKGhpZ2ggLSBsb3cgPiAyKSB7XG4gICAgICAgICAgICAvLyDov5vooYzkuIDotp/liJLliIZcbiAgICAgICAgICAgIHBpdm90ID0gcGFydGl0aW9uKHNxTGlzdCwgbG93LCBoaWdoLCBjb21wKTtcblxuICAgICAgICAgICAgLy8g5ZCn6ZW/55qE5a2Q5bqP5YiX6L6555WM5YWl5qCI77yMXG4gICAgICAgICAgICAvLyDnn63nmoTlrZDluo/liJfnlZnlvoXkuIvmrKHmjpLluo9cbiAgICAgICAgICAgIGlmIChoaWdoIC0gcGl2b3QgPiBwaXZvdCAtIGxvdykge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goaGlnaCwgcGl2b3QgKyAxKTtcbiAgICAgICAgICAgICAgICAvL3N0YWNrLnB1c2goKTtcbiAgICAgICAgICAgICAgICBoaWdoID0gcGl2b3QgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHBpdm90IC0gMSwgbG93KTtcbiAgICAgICAgICAgICAgICAvL3N0YWNrLnB1c2goKTtcbiAgICAgICAgICAgICAgICBsb3cgPSBwaXZvdCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8g5aaC5p6c5b2T5YmN5a2Q5bqP5YiX6ZW/5bqm5bCP5LqOM++8jOS4lOWwmuacquaOkuWlveW6j++8jFxuICAgICAgICAvLyDnm7TmjqXov5vooYzmr5TovoPmjpLluo/kubDlvZPliY3lrZDluo/liJfmoIflv5fkuLrlt7LmjpLlpb3luo9cbiAgICAgICAgZWxzZSBpZiAobG93IDwgaGlnaCAmJiBoaWdoIC0gbG93IDwgMykge1xuICAgICAgICAgICAgZWFzeVNvcnQoc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApO1xuICAgICAgICAgICAgbG93ID0gaGlnaDtcbiAgICAgICAgfVxuICAgICAgICAvLyDlpoLmnpzlvZPliY3lrZDluo/liJflt7LmjpLlpb3luo/kvYbmoIjkuK3ov5jmnInmnKrmjpLluo/nmoTlrZDluo/liJdcbiAgICAgICAgLy8g5LuO5qCI5Lit5Y+W5Ye65LiA5Liq5a2Q5bqP5YiXXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzdGFjay5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICAgICAgbG93ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBoaWdoID0gc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlICgxKTtcbn1cblxuZnVuY3Rpb24gZWFzeVNvcnQoc3FMaXN0LCBsb3csIGhpZ2gsIGNvbXApIHtcbiAgICBsZXQgdGVtcDtcblxuICAgIGlmIChoaWdoIC0gbG93ID09PSAxKSB7XG4gICAgICAgIGlmIChjb21wKHNxTGlzdFtsb3ddLCBzcUxpc3RbaGlnaF0pID4gMCkge1xuICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtsb3ddO1xuICAgICAgICAgICAgc3FMaXN0W2xvd10gPSBzcUxpc3RbaGlnaF07XG4gICAgICAgICAgICBzcUxpc3RbaGlnaF0gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbXAoc3FMaXN0W2xvd10sIHNxTGlzdFtsb3cgKyAxXSkgPiAwKSB7XG4gICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2xvd107XG4gICAgICAgICAgICBzcUxpc3RbbG93XSA9IHNxTGlzdFtsb3cgKyAxXTtcbiAgICAgICAgICAgIHNxTGlzdFtsb3cgKyAxXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXAoc3FMaXN0W2xvdyArIDFdLCBzcUxpc3RbaGlnaF0pID4gMCkge1xuICAgICAgICAgICAgdGVtcCA9IHNxTGlzdFtsb3cgKyAxXTtcbiAgICAgICAgICAgIHNxTGlzdFtsb3cgKyAxXSA9IHNxTGlzdFtoaWdoXTtcbiAgICAgICAgICAgIHNxTGlzdFtoaWdoXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXAoc3FMaXN0W2xvd10sIHNxTGlzdFtsb3cgKyAxXSkgPiAwKSB7XG4gICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2xvd107XG4gICAgICAgICAgICBzcUxpc3RbbG93XSA9IHNxTGlzdFtsb3cgKyAxXTtcbiAgICAgICAgICAgIHNxTGlzdFtsb3cgKyAxXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XG5xdWlja1NvcnQoYXJyKTtcbmNvbnNvbGUubG9nKCdxdWlja1NvcnQ6XFxuJyArIGFyciArICcnKTtcblxuXG4vLyDlpYflgbbkuqTmjaLmjpLluo9cbmV4cG9ydCBmdW5jdGlvbiBvZGRFdmVuU29ydChzcUxpc3QgPSBbXSwgY29tcCA9IGRlZmF1bHRDb21wYXJlKSB7XG4gICAgbGV0IGNoYW5nZSA9IDE7XG4gICAgbGV0IHRlbXA7XG4gICAgbGV0IGxlbiA9IHNxTGlzdC5sZW5ndGg7XG5cbiAgICB3aGlsZSAoY2hhbmdlKSB7XG4gICAgICAgIGNoYW5nZSA9IDA7XG4gICAgICAgIC8vIOWvueaJgOacieWlh+aVsOi/m+ihjOS4gOi2n+avlOi+g1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbiAtIDE7IGkgKz0gMikge1xuICAgICAgICAgICAgaWYgKGNvbXAoc3FMaXN0W2ldLCBzcUxpc3RbaSArIDFdKSA+IDApIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0gc3FMaXN0W2ldO1xuICAgICAgICAgICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFtpICsgMV07XG4gICAgICAgICAgICAgICAgc3FMaXN0W2kgKyAxXSA9IHRlbXA7XG5cbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5a+55omA5pyJ5YG25pWw6L+b6KGM5LiA6Laf5q+U6L6DXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuIC0gMTsgaSArPSAyKSB7XG4gICAgICAgICAgICBpZiAoY29tcChzcUxpc3RbaV0sIHNxTGlzdFtpICsgMV0pID4gMCkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBzcUxpc3RbaV07XG4gICAgICAgICAgICAgICAgc3FMaXN0W2ldID0gc3FMaXN0W2kgKyAxXTtcbiAgICAgICAgICAgICAgICBzcUxpc3RbaSArIDFdID0gdGVtcDtcblxuICAgICAgICAgICAgICAgIGNoYW5nZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBhcnIgPSBbMjMsIDM4LCAyMiwgNDUsIDIzLCA2NywgMzEsIDE1LCA0MV07XG5vZGRFdmVuU29ydChhcnIpO1xuY29uc29sZS5sb2coJ29kZEV2ZW5Tb3J0OlxcbicgKyBhcnIgKyAnJyk7XG5cblxuLypcbuaKiueUseS4ieenjeminOiJsue7hOaIkOeahOW6j+WIl+mHjeaOkuS4uuaMieeFp+e6oueZveiTneeahOmhuuW6j+aOkuWIl++8jFxu5oCd6Lev77yaXG7orr7nq4vkuInkuKrmjIfpkojvvIzlhbbkuK1q6KGo56S65b2T5YmN5YWD57Sg77ybaeS7peWJjeeahOWFg+e0oOWFqOmDqOS4uue6ouiJsu+8m2vku6XlkI7nmoTpopzoibLlhajkuLrok53oibLjgILov5nmoLflsLHlj6/ku6XmoLnmja5q55qE6aKc6Imy5oqK5YW25Lqk5o2i5Yiw5bqP5YiX55qE5YmN6Z2i5oiW6ICF5ZCO6Z2i44CCXG4gKi9cbmNvbnN0IFJFRCA9IDA7XG5jb25zdCBXSElURSA9IDE7XG5jb25zdCBCTFVFID0gMjtcblxuZnVuY3Rpb24gZmxhZ0FycmFuZ2UoY29sb3JzKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBqID0gMDtcbiAgICBsZXQgayA9IGNvbG9ycy5sZW5ndGggLSAxO1xuICAgIGxldCB0ZW1wO1xuXG4gICAgd2hpbGUgKGogPD0gaykge1xuICAgICAgICBzd2l0Y2ggKGNvbG9yc1tqXSkge1xuICAgICAgICAgICAgY2FzZSBSRUQ6XG4gICAgICAgICAgICAgICAgdGVtcCA9IGNvbG9yc1tpXTtcbiAgICAgICAgICAgICAgICBjb2xvcnNbaV0gPSBjb2xvcnNbal07XG4gICAgICAgICAgICAgICAgY29sb3JzW2pdID0gdGVtcDtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXSElURTpcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJMVUU6XG4gICAgICAgICAgICAgICAgdGVtcCA9IGNvbG9yc1tqXTtcbiAgICAgICAgICAgICAgICBjb2xvcnNbal0gPSBjb2xvcnNba107XG4gICAgICAgICAgICAgICAgY29sb3JzW2tdID0gdGVtcDtcbiAgICAgICAgICAgICAgICAtLWs7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgYXJyID0gWzIsIDEsIDAsIDIsIDEsIDEsIDAsIDIsIDAsIDIsIDFdO1xuZmxhZ0FycmFuZ2UoYXJyKTtcbmNvbnNvbGUubG9nKGFyciArICcnKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU29ydC9leGNoYW5nZS9pbmRleC5qcyIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgUmVwb3J0ZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuUmVwb3J0ZXI7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG5mdW5jdGlvbiBEZWNvZGVyQnVmZmVyKGJhc2UsIG9wdGlvbnMpIHtcbiAgUmVwb3J0ZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYmFzZSkpIHtcbiAgICB0aGlzLmVycm9yKCdJbnB1dCBub3QgQnVmZmVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5iYXNlID0gYmFzZTtcbiAgdGhpcy5vZmZzZXQgPSAwO1xuICB0aGlzLmxlbmd0aCA9IGJhc2UubGVuZ3RoO1xufVxuaW5oZXJpdHMoRGVjb2RlckJ1ZmZlciwgUmVwb3J0ZXIpO1xuZXhwb3J0cy5EZWNvZGVyQnVmZmVyID0gRGVjb2RlckJ1ZmZlcjtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XG4gIHJldHVybiB7IG9mZnNldDogdGhpcy5vZmZzZXQsIHJlcG9ydGVyOiBSZXBvcnRlci5wcm90b3R5cGUuc2F2ZS5jYWxsKHRoaXMpIH07XG59O1xuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZShzYXZlKSB7XG4gIC8vIFJldHVybiBza2lwcGVkIGRhdGFcbiAgdmFyIHJlcyA9IG5ldyBEZWNvZGVyQnVmZmVyKHRoaXMuYmFzZSk7XG4gIHJlcy5vZmZzZXQgPSBzYXZlLm9mZnNldDtcbiAgcmVzLmxlbmd0aCA9IHRoaXMub2Zmc2V0O1xuXG4gIHRoaXMub2Zmc2V0ID0gc2F2ZS5vZmZzZXQ7XG4gIFJlcG9ydGVyLnByb3RvdHlwZS5yZXN0b3JlLmNhbGwodGhpcywgc2F2ZS5yZXBvcnRlcik7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICByZXR1cm4gdGhpcy5vZmZzZXQgPT09IHRoaXMubGVuZ3RoO1xufTtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4KGZhaWwpIHtcbiAgaWYgKHRoaXMub2Zmc2V0ICsgMSA8PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5iYXNlLnJlYWRVSW50OCh0aGlzLm9mZnNldCsrLCB0cnVlKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmVycm9yKGZhaWwgfHwgJ0RlY29kZXJCdWZmZXIgb3ZlcnJ1bicpO1xufVxuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChieXRlcywgZmFpbCkge1xuICBpZiAoISh0aGlzLm9mZnNldCArIGJ5dGVzIDw9IHRoaXMubGVuZ3RoKSlcbiAgICByZXR1cm4gdGhpcy5lcnJvcihmYWlsIHx8ICdEZWNvZGVyQnVmZmVyIG92ZXJydW4nKTtcblxuICB2YXIgcmVzID0gbmV3IERlY29kZXJCdWZmZXIodGhpcy5iYXNlKTtcblxuICAvLyBTaGFyZSByZXBvcnRlciBzdGF0ZVxuICByZXMuX3JlcG9ydGVyU3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHJlcy5vZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgcmVzLmxlbmd0aCA9IHRoaXMub2Zmc2V0ICsgYnl0ZXM7XG4gIHRoaXMub2Zmc2V0ICs9IGJ5dGVzO1xuICByZXR1cm4gcmVzO1xufVxuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbiByYXcoc2F2ZSkge1xuICByZXR1cm4gdGhpcy5iYXNlLnNsaWNlKHNhdmUgPyBzYXZlLm9mZnNldCA6IHRoaXMub2Zmc2V0LCB0aGlzLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIEVuY29kZXJCdWZmZXIodmFsdWUsIHJlcG9ydGVyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBFbmNvZGVyQnVmZmVyKSlcbiAgICAgICAgaXRlbSA9IG5ldyBFbmNvZGVyQnVmZmVyKGl0ZW0sIHJlcG9ydGVyKTtcbiAgICAgIHRoaXMubGVuZ3RoICs9IGl0ZW0ubGVuZ3RoO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSwgdGhpcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGlmICghKDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMHhmZikpXG4gICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ25vbi1ieXRlIEVuY29kZXJCdWZmZXIgdmFsdWUnKTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGU6ICcgKyB0eXBlb2YgdmFsdWUpO1xuICB9XG59XG5leHBvcnRzLkVuY29kZXJCdWZmZXIgPSBFbmNvZGVyQnVmZmVyO1xuXG5FbmNvZGVyQnVmZmVyLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihvdXQsIG9mZnNldCkge1xuICBpZiAoIW91dClcbiAgICBvdXQgPSBuZXcgQnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgaWYgKCFvZmZzZXQpXG4gICAgb2Zmc2V0ID0gMDtcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG91dDtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSkge1xuICAgIHRoaXMudmFsdWUuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpdGVtLmpvaW4ob3V0LCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGl0ZW0ubGVuZ3RoO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICBvdXRbb2Zmc2V0XSA9IHRoaXMudmFsdWU7XG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgb3V0LndyaXRlKHRoaXMudmFsdWUsIG9mZnNldCk7XG4gICAgZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHRoaXMudmFsdWUpKVxuICAgICAgdGhpcy52YWx1ZS5jb3B5KG91dCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hc24xLmpzL2xpYi9hc24xL2Jhc2UvYnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29uc3RhbnRzID0gZXhwb3J0cztcblxuLy8gSGVscGVyXG5jb25zdGFudHMuX3JldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKG1hcCkge1xuICB2YXIgcmVzID0ge307XG5cbiAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIC8vIENvbnZlcnQga2V5IHRvIGludGVnZXIgaWYgaXQgaXMgc3RyaW5naWZpZWRcbiAgICBpZiAoKGtleSB8IDApID09IGtleSlcbiAgICAgIGtleSA9IGtleSB8IDA7XG5cbiAgICB2YXIgdmFsdWUgPSBtYXBba2V5XTtcbiAgICByZXNbdmFsdWVdID0ga2V5O1xuICB9KTtcblxuICByZXR1cm4gcmVzO1xufTtcblxuY29uc3RhbnRzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYXNuMS5qcy9saWIvYXNuMS9jb25zdGFudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBhc24xID0gcmVxdWlyZSgnLi4vLi4vYXNuMScpO1xudmFyIGJhc2UgPSBhc24xLmJhc2U7XG52YXIgYmlnbnVtID0gYXNuMS5iaWdudW07XG5cbi8vIEltcG9ydCBERVIgY29uc3RhbnRzXG52YXIgZGVyID0gYXNuMS5jb25zdGFudHMuZGVyO1xuXG5mdW5jdGlvbiBERVJEZWNvZGVyKGVudGl0eSkge1xuICB0aGlzLmVuYyA9ICdkZXInO1xuICB0aGlzLm5hbWUgPSBlbnRpdHkubmFtZTtcbiAgdGhpcy5lbnRpdHkgPSBlbnRpdHk7XG5cbiAgLy8gQ29uc3RydWN0IGJhc2UgdHJlZVxuICB0aGlzLnRyZWUgPSBuZXcgREVSTm9kZSgpO1xuICB0aGlzLnRyZWUuX2luaXQoZW50aXR5LmJvZHkpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gREVSRGVjb2RlcjtcblxuREVSRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIGJhc2UuRGVjb2RlckJ1ZmZlcikpXG4gICAgZGF0YSA9IG5ldyBiYXNlLkRlY29kZXJCdWZmZXIoZGF0YSwgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMudHJlZS5fZGVjb2RlKGRhdGEsIG9wdGlvbnMpO1xufTtcblxuLy8gVHJlZSBtZXRob2RzXG5cbmZ1bmN0aW9uIERFUk5vZGUocGFyZW50KSB7XG4gIGJhc2UuTm9kZS5jYWxsKHRoaXMsICdkZXInLCBwYXJlbnQpO1xufVxuaW5oZXJpdHMoREVSTm9kZSwgYmFzZS5Ob2RlKTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3BlZWtUYWcgPSBmdW5jdGlvbiBwZWVrVGFnKGJ1ZmZlciwgdGFnLCBhbnkpIHtcbiAgaWYgKGJ1ZmZlci5pc0VtcHR5KCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBzdGF0ZSA9IGJ1ZmZlci5zYXZlKCk7XG4gIHZhciBkZWNvZGVkVGFnID0gZGVyRGVjb2RlVGFnKGJ1ZmZlciwgJ0ZhaWxlZCB0byBwZWVrIHRhZzogXCInICsgdGFnICsgJ1wiJyk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihkZWNvZGVkVGFnKSlcbiAgICByZXR1cm4gZGVjb2RlZFRhZztcblxuICBidWZmZXIucmVzdG9yZShzdGF0ZSk7XG5cbiAgcmV0dXJuIGRlY29kZWRUYWcudGFnID09PSB0YWcgfHwgZGVjb2RlZFRhZy50YWdTdHIgPT09IHRhZyB8fFxuICAgIChkZWNvZGVkVGFnLnRhZ1N0ciArICdvZicpID09PSB0YWcgfHwgYW55O1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZVRhZyA9IGZ1bmN0aW9uIGRlY29kZVRhZyhidWZmZXIsIHRhZywgYW55KSB7XG4gIHZhciBkZWNvZGVkVGFnID0gZGVyRGVjb2RlVGFnKGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBkZWNvZGUgdGFnIG9mIFwiJyArIHRhZyArICdcIicpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IoZGVjb2RlZFRhZykpXG4gICAgcmV0dXJuIGRlY29kZWRUYWc7XG5cbiAgdmFyIGxlbiA9IGRlckRlY29kZUxlbihidWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZFRhZy5wcmltaXRpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBnZXQgbGVuZ3RoIG9mIFwiJyArIHRhZyArICdcIicpO1xuXG4gIC8vIEZhaWx1cmVcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKGxlbikpXG4gICAgcmV0dXJuIGxlbjtcblxuICBpZiAoIWFueSAmJlxuICAgICAgZGVjb2RlZFRhZy50YWcgIT09IHRhZyAmJlxuICAgICAgZGVjb2RlZFRhZy50YWdTdHIgIT09IHRhZyAmJlxuICAgICAgZGVjb2RlZFRhZy50YWdTdHIgKyAnb2YnICE9PSB0YWcpIHtcbiAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdGYWlsZWQgdG8gbWF0Y2ggdGFnOiBcIicgKyB0YWcgKyAnXCInKTtcbiAgfVxuXG4gIGlmIChkZWNvZGVkVGFnLnByaW1pdGl2ZSB8fCBsZW4gIT09IG51bGwpXG4gICAgcmV0dXJuIGJ1ZmZlci5za2lwKGxlbiwgJ0ZhaWxlZCB0byBtYXRjaCBib2R5IG9mOiBcIicgKyB0YWcgKyAnXCInKTtcblxuICAvLyBJbmRlZmluaXRlIGxlbmd0aC4uLiBmaW5kIEVORCB0YWdcbiAgdmFyIHN0YXRlID0gYnVmZmVyLnNhdmUoKTtcbiAgdmFyIHJlcyA9IHRoaXMuX3NraXBVbnRpbEVuZChcbiAgICAgIGJ1ZmZlcixcbiAgICAgICdGYWlsZWQgdG8gc2tpcCBpbmRlZmluaXRlIGxlbmd0aCBib2R5OiBcIicgKyB0aGlzLnRhZyArICdcIicpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSlcbiAgICByZXR1cm4gcmVzO1xuXG4gIGxlbiA9IGJ1ZmZlci5vZmZzZXQgLSBzdGF0ZS5vZmZzZXQ7XG4gIGJ1ZmZlci5yZXN0b3JlKHN0YXRlKTtcbiAgcmV0dXJuIGJ1ZmZlci5za2lwKGxlbiwgJ0ZhaWxlZCB0byBtYXRjaCBib2R5IG9mOiBcIicgKyB0YWcgKyAnXCInKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9za2lwVW50aWxFbmQgPSBmdW5jdGlvbiBza2lwVW50aWxFbmQoYnVmZmVyLCBmYWlsKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsIGZhaWwpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcih0YWcpKVxuICAgICAgcmV0dXJuIHRhZztcbiAgICB2YXIgbGVuID0gZGVyRGVjb2RlTGVuKGJ1ZmZlciwgdGFnLnByaW1pdGl2ZSwgZmFpbCk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKGxlbikpXG4gICAgICByZXR1cm4gbGVuO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGFnLnByaW1pdGl2ZSB8fCBsZW4gIT09IG51bGwpXG4gICAgICByZXMgPSBidWZmZXIuc2tpcChsZW4pXG4gICAgZWxzZVxuICAgICAgcmVzID0gdGhpcy5fc2tpcFVudGlsRW5kKGJ1ZmZlciwgZmFpbCk7XG5cbiAgICAvLyBGYWlsdXJlXG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXG4gICAgICByZXR1cm4gcmVzO1xuXG4gICAgaWYgKHRhZy50YWdTdHIgPT09ICdlbmQnKVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVMaXN0ID0gZnVuY3Rpb24gZGVjb2RlTGlzdChidWZmZXIsIHRhZywgZGVjb2RlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKCFidWZmZXIuaXNFbXB0eSgpKSB7XG4gICAgdmFyIHBvc3NpYmxlRW5kID0gdGhpcy5fcGVla1RhZyhidWZmZXIsICdlbmQnKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IocG9zc2libGVFbmQpKVxuICAgICAgcmV0dXJuIHBvc3NpYmxlRW5kO1xuXG4gICAgdmFyIHJlcyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlciwgJ2RlcicsIG9wdGlvbnMpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcihyZXMpICYmIHBvc3NpYmxlRW5kKVxuICAgICAgYnJlYWs7XG4gICAgcmVzdWx0LnB1c2gocmVzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZVN0ciA9IGZ1bmN0aW9uIGRlY29kZVN0cihidWZmZXIsIHRhZykge1xuICBpZiAodGFnID09PSAnYml0c3RyJykge1xuICAgIHZhciB1bnVzZWQgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHVudXNlZCkpXG4gICAgICByZXR1cm4gdW51c2VkO1xuICAgIHJldHVybiB7IHVudXNlZDogdW51c2VkLCBkYXRhOiBidWZmZXIucmF3KCkgfTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdibXBzdHInKSB7XG4gICAgdmFyIHJhdyA9IGJ1ZmZlci5yYXcoKTtcbiAgICBpZiAocmF3Lmxlbmd0aCAlIDIgPT09IDEpXG4gICAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdEZWNvZGluZyBvZiBzdHJpbmcgdHlwZTogYm1wc3RyIGxlbmd0aCBtaXNtYXRjaCcpO1xuXG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Lmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocmF3LnJlYWRVSW50MTZCRShpICogMikpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ251bXN0cicpIHtcbiAgICB2YXIgbnVtc3RyID0gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCdhc2NpaScpO1xuICAgIGlmICghdGhpcy5faXNOdW1zdHIobnVtc3RyKSkge1xuICAgICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnbnVtc3RyIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bXN0cjtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdvY3RzdHInKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5yYXcoKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdvYmpEZXNjJykge1xuICAgIHJldHVybiBidWZmZXIucmF3KCk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAncHJpbnRzdHInKSB7XG4gICAgdmFyIHByaW50c3RyID0gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCdhc2NpaScpO1xuICAgIGlmICghdGhpcy5faXNQcmludHN0cihwcmludHN0cikpIHtcbiAgICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByaW50c3RyIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHByaW50c3RyO1xuICB9IGVsc2UgaWYgKC9zdHIkLy50ZXN0KHRhZykpIHtcbiAgICByZXR1cm4gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6ICcgKyB0YWcgKyAnIHVuc3VwcG9ydGVkJyk7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVPYmppZCA9IGZ1bmN0aW9uIGRlY29kZU9iamlkKGJ1ZmZlciwgdmFsdWVzLCByZWxhdGl2ZSkge1xuICB2YXIgcmVzdWx0O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgdmFyIGlkZW50ID0gMDtcbiAgd2hpbGUgKCFidWZmZXIuaXNFbXB0eSgpKSB7XG4gICAgdmFyIHN1YmlkZW50ID0gYnVmZmVyLnJlYWRVSW50OCgpO1xuICAgIGlkZW50IDw8PSA3O1xuICAgIGlkZW50IHw9IHN1YmlkZW50ICYgMHg3ZjtcbiAgICBpZiAoKHN1YmlkZW50ICYgMHg4MCkgPT09IDApIHtcbiAgICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnQpO1xuICAgICAgaWRlbnQgPSAwO1xuICAgIH1cbiAgfVxuICBpZiAoc3ViaWRlbnQgJiAweDgwKVxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnQpO1xuXG4gIHZhciBmaXJzdCA9IChpZGVudGlmaWVyc1swXSAvIDQwKSB8IDA7XG4gIHZhciBzZWNvbmQgPSBpZGVudGlmaWVyc1swXSAlIDQwO1xuXG4gIGlmIChyZWxhdGl2ZSlcbiAgICByZXN1bHQgPSBpZGVudGlmaWVycztcbiAgZWxzZVxuICAgIHJlc3VsdCA9IFtmaXJzdCwgc2Vjb25kXS5jb25jYXQoaWRlbnRpZmllcnMuc2xpY2UoMSkpO1xuXG4gIGlmICh2YWx1ZXMpIHtcbiAgICB2YXIgdG1wID0gdmFsdWVzW3Jlc3VsdC5qb2luKCcgJyldO1xuICAgIGlmICh0bXAgPT09IHVuZGVmaW5lZClcbiAgICAgIHRtcCA9IHZhbHVlc1tyZXN1bHQuam9pbignLicpXTtcbiAgICBpZiAodG1wICE9PSB1bmRlZmluZWQpXG4gICAgICByZXN1bHQgPSB0bXA7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZVRpbWUgPSBmdW5jdGlvbiBkZWNvZGVUaW1lKGJ1ZmZlciwgdGFnKSB7XG4gIHZhciBzdHIgPSBidWZmZXIucmF3KCkudG9TdHJpbmcoKTtcbiAgaWYgKHRhZyA9PT0gJ2dlbnRpbWUnKSB7XG4gICAgdmFyIHllYXIgPSBzdHIuc2xpY2UoMCwgNCkgfCAwO1xuICAgIHZhciBtb24gPSBzdHIuc2xpY2UoNCwgNikgfCAwO1xuICAgIHZhciBkYXkgPSBzdHIuc2xpY2UoNiwgOCkgfCAwO1xuICAgIHZhciBob3VyID0gc3RyLnNsaWNlKDgsIDEwKSB8IDA7XG4gICAgdmFyIG1pbiA9IHN0ci5zbGljZSgxMCwgMTIpIHwgMDtcbiAgICB2YXIgc2VjID0gc3RyLnNsaWNlKDEyLCAxNCkgfCAwO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3V0Y3RpbWUnKSB7XG4gICAgdmFyIHllYXIgPSBzdHIuc2xpY2UoMCwgMikgfCAwO1xuICAgIHZhciBtb24gPSBzdHIuc2xpY2UoMiwgNCkgfCAwO1xuICAgIHZhciBkYXkgPSBzdHIuc2xpY2UoNCwgNikgfCAwO1xuICAgIHZhciBob3VyID0gc3RyLnNsaWNlKDYsIDgpIHwgMDtcbiAgICB2YXIgbWluID0gc3RyLnNsaWNlKDgsIDEwKSB8IDA7XG4gICAgdmFyIHNlYyA9IHN0ci5zbGljZSgxMCwgMTIpIHwgMDtcbiAgICBpZiAoeWVhciA8IDcwKVxuICAgICAgeWVhciA9IDIwMDAgKyB5ZWFyO1xuICAgIGVsc2VcbiAgICAgIHllYXIgPSAxOTAwICsgeWVhcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdEZWNvZGluZyAnICsgdGFnICsgJyB0aW1lIGlzIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gIH1cblxuICByZXR1cm4gRGF0ZS5VVEMoeWVhciwgbW9uIC0gMSwgZGF5LCBob3VyLCBtaW4sIHNlYywgMCk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlTnVsbCA9IGZ1bmN0aW9uIGRlY29kZU51bGwoYnVmZmVyKSB7XG4gIHJldHVybiBudWxsO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZUJvb2wgPSBmdW5jdGlvbiBkZWNvZGVCb29sKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gYnVmZmVyLnJlYWRVSW50OCgpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSlcbiAgICByZXR1cm4gcmVzO1xuICBlbHNlXG4gICAgcmV0dXJuIHJlcyAhPT0gMDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVJbnQgPSBmdW5jdGlvbiBkZWNvZGVJbnQoYnVmZmVyLCB2YWx1ZXMpIHtcbiAgLy8gQmlnaW50LCByZXR1cm4gYXMgaXQgaXMgKGFzc3VtZSBiaWcgZW5kaWFuKVxuICB2YXIgcmF3ID0gYnVmZmVyLnJhdygpO1xuICB2YXIgcmVzID0gbmV3IGJpZ251bShyYXcpO1xuXG4gIGlmICh2YWx1ZXMpXG4gICAgcmVzID0gdmFsdWVzW3Jlcy50b1N0cmluZygxMCldIHx8IHJlcztcblxuICByZXR1cm4gcmVzO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3VzZSA9IGZ1bmN0aW9uIHVzZShlbnRpdHksIG9iaikge1xuICBpZiAodHlwZW9mIGVudGl0eSA9PT0gJ2Z1bmN0aW9uJylcbiAgICBlbnRpdHkgPSBlbnRpdHkob2JqKTtcbiAgcmV0dXJuIGVudGl0eS5fZ2V0RGVjb2RlcignZGVyJykudHJlZTtcbn07XG5cbi8vIFV0aWxpdHkgbWV0aG9kc1xuXG5mdW5jdGlvbiBkZXJEZWNvZGVUYWcoYnVmLCBmYWlsKSB7XG4gIHZhciB0YWcgPSBidWYucmVhZFVJbnQ4KGZhaWwpO1xuICBpZiAoYnVmLmlzRXJyb3IodGFnKSlcbiAgICByZXR1cm4gdGFnO1xuXG4gIHZhciBjbHMgPSBkZXIudGFnQ2xhc3NbdGFnID4+IDZdO1xuICB2YXIgcHJpbWl0aXZlID0gKHRhZyAmIDB4MjApID09PSAwO1xuXG4gIC8vIE11bHRpLW9jdGV0IHRhZyAtIGxvYWRcbiAgaWYgKCh0YWcgJiAweDFmKSA9PT0gMHgxZikge1xuICAgIHZhciBvY3QgPSB0YWc7XG4gICAgdGFnID0gMDtcbiAgICB3aGlsZSAoKG9jdCAmIDB4ODApID09PSAweDgwKSB7XG4gICAgICBvY3QgPSBidWYucmVhZFVJbnQ4KGZhaWwpO1xuICAgICAgaWYgKGJ1Zi5pc0Vycm9yKG9jdCkpXG4gICAgICAgIHJldHVybiBvY3Q7XG5cbiAgICAgIHRhZyA8PD0gNztcbiAgICAgIHRhZyB8PSBvY3QgJiAweDdmO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YWcgJj0gMHgxZjtcbiAgfVxuICB2YXIgdGFnU3RyID0gZGVyLnRhZ1t0YWddO1xuXG4gIHJldHVybiB7XG4gICAgY2xzOiBjbHMsXG4gICAgcHJpbWl0aXZlOiBwcmltaXRpdmUsXG4gICAgdGFnOiB0YWcsXG4gICAgdGFnU3RyOiB0YWdTdHJcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVyRGVjb2RlTGVuKGJ1ZiwgcHJpbWl0aXZlLCBmYWlsKSB7XG4gIHZhciBsZW4gPSBidWYucmVhZFVJbnQ4KGZhaWwpO1xuICBpZiAoYnVmLmlzRXJyb3IobGVuKSlcbiAgICByZXR1cm4gbGVuO1xuXG4gIC8vIEluZGVmaW5pdGUgZm9ybVxuICBpZiAoIXByaW1pdGl2ZSAmJiBsZW4gPT09IDB4ODApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgLy8gRGVmaW5pdGUgZm9ybVxuICBpZiAoKGxlbiAmIDB4ODApID09PSAwKSB7XG4gICAgLy8gU2hvcnQgZm9ybVxuICAgIHJldHVybiBsZW47XG4gIH1cblxuICAvLyBMb25nIGZvcm1cbiAgdmFyIG51bSA9IGxlbiAmIDB4N2Y7XG4gIGlmIChudW0gPiA0KVxuICAgIHJldHVybiBidWYuZXJyb3IoJ2xlbmd0aCBvY3RlY3QgaXMgdG9vIGxvbmcnKTtcblxuICBsZW4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgbGVuIDw8PSA4O1xuICAgIHZhciBqID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgICBpZiAoYnVmLmlzRXJyb3IoaikpXG4gICAgICByZXR1cm4gajtcbiAgICBsZW4gfD0gajtcbiAgfVxuXG4gIHJldHVybiBsZW47XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJy4uLy4uL2FzbjEnKTtcbnZhciBiYXNlID0gYXNuMS5iYXNlO1xuXG4vLyBJbXBvcnQgREVSIGNvbnN0YW50c1xudmFyIGRlciA9IGFzbjEuY29uc3RhbnRzLmRlcjtcblxuZnVuY3Rpb24gREVSRW5jb2RlcihlbnRpdHkpIHtcbiAgdGhpcy5lbmMgPSAnZGVyJztcbiAgdGhpcy5uYW1lID0gZW50aXR5Lm5hbWU7XG4gIHRoaXMuZW50aXR5ID0gZW50aXR5O1xuXG4gIC8vIENvbnN0cnVjdCBiYXNlIHRyZWVcbiAgdGhpcy50cmVlID0gbmV3IERFUk5vZGUoKTtcbiAgdGhpcy50cmVlLl9pbml0KGVudGl0eS5ib2R5KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERFUkVuY29kZXI7XG5cbkRFUkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlcikge1xuICByZXR1cm4gdGhpcy50cmVlLl9lbmNvZGUoZGF0YSwgcmVwb3J0ZXIpLmpvaW4oKTtcbn07XG5cbi8vIFRyZWUgbWV0aG9kc1xuXG5mdW5jdGlvbiBERVJOb2RlKHBhcmVudCkge1xuICBiYXNlLk5vZGUuY2FsbCh0aGlzLCAnZGVyJywgcGFyZW50KTtcbn1cbmluaGVyaXRzKERFUk5vZGUsIGJhc2UuTm9kZSk7XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVDb21wb3NpdGUgPSBmdW5jdGlvbiBlbmNvZGVDb21wb3NpdGUodGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCkge1xuICB2YXIgZW5jb2RlZFRhZyA9IGVuY29kZVRhZyh0YWcsIHByaW1pdGl2ZSwgY2xzLCB0aGlzLnJlcG9ydGVyKTtcblxuICAvLyBTaG9ydCBmb3JtXG4gIGlmIChjb250ZW50Lmxlbmd0aCA8IDB4ODApIHtcbiAgICB2YXIgaGVhZGVyID0gbmV3IEJ1ZmZlcigyKTtcbiAgICBoZWFkZXJbMF0gPSBlbmNvZGVkVGFnO1xuICAgIGhlYWRlclsxXSA9IGNvbnRlbnQubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgaGVhZGVyLCBjb250ZW50IF0pO1xuICB9XG5cbiAgLy8gTG9uZyBmb3JtXG4gIC8vIENvdW50IG9jdGV0cyByZXF1aXJlZCB0byBzdG9yZSBsZW5ndGhcbiAgdmFyIGxlbk9jdGV0cyA9IDE7XG4gIGZvciAodmFyIGkgPSBjb250ZW50Lmxlbmd0aDsgaSA+PSAweDEwMDsgaSA+Pj0gOClcbiAgICBsZW5PY3RldHMrKztcblxuICB2YXIgaGVhZGVyID0gbmV3IEJ1ZmZlcigxICsgMSArIGxlbk9jdGV0cyk7XG4gIGhlYWRlclswXSA9IGVuY29kZWRUYWc7XG4gIGhlYWRlclsxXSA9IDB4ODAgfCBsZW5PY3RldHM7XG5cbiAgZm9yICh2YXIgaSA9IDEgKyBsZW5PY3RldHMsIGogPSBjb250ZW50Lmxlbmd0aDsgaiA+IDA7IGktLSwgaiA+Pj0gOClcbiAgICBoZWFkZXJbaV0gPSBqICYgMHhmZjtcblxuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIGhlYWRlciwgY29udGVudCBdKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVTdHIgPSBmdW5jdGlvbiBlbmNvZGVTdHIoc3RyLCB0YWcpIHtcbiAgaWYgKHRhZyA9PT0gJ2JpdHN0cicpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIHN0ci51bnVzZWQgfCAwLCBzdHIuZGF0YSBdKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdibXBzdHInKSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3RyLmxlbmd0aCAqIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShzdHIuY2hhckNvZGVBdChpKSwgaSAqIDIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihidWYpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ251bXN0cicpIHtcbiAgICBpZiAoIXRoaXMuX2lzTnVtc3RyKHN0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyBvZiBzdHJpbmcgdHlwZTogbnVtc3RyIHN1cHBvcnRzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29ubHkgZGlnaXRzIGFuZCBzcGFjZScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihzdHIpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3ByaW50c3RyJykge1xuICAgIGlmICghdGhpcy5faXNQcmludHN0cihzdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignRW5jb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6IHByaW50c3RyIHN1cHBvcnRzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29ubHkgbGF0aW4gdXBwZXIgYW5kIGxvd2VyIGNhc2UgbGV0dGVycywgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGlnaXRzLCBzcGFjZSwgYXBvc3Ryb3BoZSwgbGVmdCBhbmQgcmlndGggJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFyZW50aGVzaXMsIHBsdXMgc2lnbiwgY29tbWEsIGh5cGhlbiwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZG90LCBzbGFzaCwgY29sb24sIGVxdWFsIHNpZ24sICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3F1ZXN0aW9uIG1hcmsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoc3RyKTtcbiAgfSBlbHNlIGlmICgvc3RyJC8udGVzdCh0YWcpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoc3RyKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdvYmpEZXNjJykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICsgdGFnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHVuc3VwcG9ydGVkJyk7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVPYmppZCA9IGZ1bmN0aW9uIGVuY29kZU9iamlkKGlkLCB2YWx1ZXMsIHJlbGF0aXZlKSB7XG4gIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignc3RyaW5nIG9iamlkIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCBmb3VuZCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCBub3QgZm91bmQgaW4gdmFsdWVzIG1hcCcpO1xuICAgIGlkID0gdmFsdWVzW2lkXS5zcGxpdCgvW1xcc1xcLl0rL2cpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgaWQgPSBpZC5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGlkKSkge1xuICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCgpIHNob3VsZCBiZSBlaXRoZXIgYXJyYXkgb3Igc3RyaW5nLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ290OiAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKTtcbiAgfVxuXG4gIGlmICghcmVsYXRpdmUpIHtcbiAgICBpZiAoaWRbMV0gPj0gNDApXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU2Vjb25kIG9iamlkIGlkZW50aWZpZXIgT09CJyk7XG4gICAgaWQuc3BsaWNlKDAsIDIsIGlkWzBdICogNDAgKyBpZFsxXSk7XG4gIH1cblxuICAvLyBDb3VudCBudW1iZXIgb2Ygb2N0ZXRzXG4gIHZhciBzaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpZGVudCA9IGlkW2ldO1xuICAgIGZvciAoc2l6ZSsrOyBpZGVudCA+PSAweDgwOyBpZGVudCA+Pj0gNylcbiAgICAgIHNpemUrKztcbiAgfVxuXG4gIHZhciBvYmppZCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIHZhciBvZmZzZXQgPSBvYmppZC5sZW5ndGggLSAxO1xuICBmb3IgKHZhciBpID0gaWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgaWRlbnQgPSBpZFtpXTtcbiAgICBvYmppZFtvZmZzZXQtLV0gPSBpZGVudCAmIDB4N2Y7XG4gICAgd2hpbGUgKChpZGVudCA+Pj0gNykgPiAwKVxuICAgICAgb2JqaWRbb2Zmc2V0LS1dID0gMHg4MCB8IChpZGVudCAmIDB4N2YpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIob2JqaWQpO1xufTtcblxuZnVuY3Rpb24gdHdvKG51bSkge1xuICBpZiAobnVtIDwgMTApXG4gICAgcmV0dXJuICcwJyArIG51bTtcbiAgZWxzZVxuICAgIHJldHVybiBudW07XG59XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVUaW1lID0gZnVuY3Rpb24gZW5jb2RlVGltZSh0aW1lLCB0YWcpIHtcbiAgdmFyIHN0cjtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcblxuICBpZiAodGFnID09PSAnZ2VudGltZScpIHtcbiAgICBzdHIgPSBbXG4gICAgICB0d28oZGF0ZS5nZXRGdWxsWWVhcigpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0RhdGUoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENIb3VycygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01pbnV0ZXMoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENTZWNvbmRzKCkpLFxuICAgICAgJ1onXG4gICAgXS5qb2luKCcnKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICd1dGN0aW1lJykge1xuICAgIHN0ciA9IFtcbiAgICAgIHR3byhkYXRlLmdldEZ1bGxZZWFyKCkgJSAxMDApLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDRGF0ZSgpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0hvdXJzKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTWludXRlcygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ1NlY29uZHMoKSksXG4gICAgICAnWidcbiAgICBdLmpvaW4oJycpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nICcgKyB0YWcgKyAnIHRpbWUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoc3RyLCAnb2N0c3RyJyk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlTnVsbCA9IGZ1bmN0aW9uIGVuY29kZU51bGwoKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKCcnKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVJbnQgPSBmdW5jdGlvbiBlbmNvZGVJbnQobnVtLCB2YWx1ZXMpIHtcbiAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU3RyaW5nIGludCBvciBlbnVtIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KG51bSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdWYWx1ZXMgbWFwIGRvZXNuXFwndCBjb250YWluOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG51bSkpO1xuICAgIH1cbiAgICBudW0gPSB2YWx1ZXNbbnVtXTtcbiAgfVxuXG4gIC8vIEJpZ251bSwgYXNzdW1lIGJpZyBlbmRpYW5cbiAgaWYgKHR5cGVvZiBudW0gIT09ICdudW1iZXInICYmICFCdWZmZXIuaXNCdWZmZXIobnVtKSkge1xuICAgIHZhciBudW1BcnJheSA9IG51bS50b0FycmF5KCk7XG4gICAgaWYgKCFudW0uc2lnbiAmJiBudW1BcnJheVswXSAmIDB4ODApIHtcbiAgICAgIG51bUFycmF5LnVuc2hpZnQoMCk7XG4gICAgfVxuICAgIG51bSA9IG5ldyBCdWZmZXIobnVtQXJyYXkpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihudW0pKSB7XG4gICAgdmFyIHNpemUgPSBudW0ubGVuZ3RoO1xuICAgIGlmIChudW0ubGVuZ3RoID09PSAwKVxuICAgICAgc2l6ZSsrO1xuXG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgbnVtLmNvcHkob3V0KTtcbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMClcbiAgICAgIG91dFswXSA9IDBcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihvdXQpO1xuICB9XG5cbiAgaWYgKG51bSA8IDB4ODApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIobnVtKTtcblxuICBpZiAobnVtIDwgMHgxMDApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoWzAsIG51bV0pO1xuXG4gIHZhciBzaXplID0gMTtcbiAgZm9yICh2YXIgaSA9IG51bTsgaSA+PSAweDEwMDsgaSA+Pj0gOClcbiAgICBzaXplKys7XG5cbiAgdmFyIG91dCA9IG5ldyBBcnJheShzaXplKTtcbiAgZm9yICh2YXIgaSA9IG91dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIG91dFtpXSA9IG51bSAmIDB4ZmY7XG4gICAgbnVtID4+PSA4O1xuICB9XG4gIGlmKG91dFswXSAmIDB4ODApIHtcbiAgICBvdXQudW5zaGlmdCgwKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG5ldyBCdWZmZXIob3V0KSk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlQm9vbCA9IGZ1bmN0aW9uIGVuY29kZUJvb2wodmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIodmFsdWUgPyAweGZmIDogMCk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fdXNlID0gZnVuY3Rpb24gdXNlKGVudGl0eSwgb2JqKSB7XG4gIGlmICh0eXBlb2YgZW50aXR5ID09PSAnZnVuY3Rpb24nKVxuICAgIGVudGl0eSA9IGVudGl0eShvYmopO1xuICByZXR1cm4gZW50aXR5Ll9nZXRFbmNvZGVyKCdkZXInKS50cmVlO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3NraXBEZWZhdWx0ID0gZnVuY3Rpb24gc2tpcERlZmF1bHQoZGF0YUJ1ZmZlciwgcmVwb3J0ZXIsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBpO1xuICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRhdGEgPSBkYXRhQnVmZmVyLmpvaW4oKTtcbiAgaWYgKHN0YXRlLmRlZmF1bHRCdWZmZXIgPT09IHVuZGVmaW5lZClcbiAgICBzdGF0ZS5kZWZhdWx0QnVmZmVyID0gdGhpcy5fZW5jb2RlVmFsdWUoc3RhdGVbJ2RlZmF1bHQnXSwgcmVwb3J0ZXIsIHBhcmVudCkuam9pbigpO1xuXG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlci5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoaT0wOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICBpZiAoZGF0YVtpXSAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlcltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFV0aWxpdHkgbWV0aG9kc1xuXG5mdW5jdGlvbiBlbmNvZGVUYWcodGFnLCBwcmltaXRpdmUsIGNscywgcmVwb3J0ZXIpIHtcbiAgdmFyIHJlcztcblxuICBpZiAodGFnID09PSAnc2Vxb2YnKVxuICAgIHRhZyA9ICdzZXEnO1xuICBlbHNlIGlmICh0YWcgPT09ICdzZXRvZicpXG4gICAgdGFnID0gJ3NldCc7XG5cbiAgaWYgKGRlci50YWdCeU5hbWUuaGFzT3duUHJvcGVydHkodGFnKSlcbiAgICByZXMgPSBkZXIudGFnQnlOYW1lW3RhZ107XG4gIGVsc2UgaWYgKHR5cGVvZiB0YWcgPT09ICdudW1iZXInICYmICh0YWcgfCAwKSA9PT0gdGFnKVxuICAgIHJlcyA9IHRhZztcbiAgZWxzZVxuICAgIHJldHVybiByZXBvcnRlci5lcnJvcignVW5rbm93biB0YWc6ICcgKyB0YWcpO1xuXG4gIGlmIChyZXMgPj0gMHgxZilcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ011bHRpLW9jdGV0IHRhZyBlbmNvZGluZyB1bnN1cHBvcnRlZCcpO1xuXG4gIGlmICghcHJpbWl0aXZlKVxuICAgIHJlcyB8PSAweDIwO1xuXG4gIHJlcyB8PSAoZGVyLnRhZ0NsYXNzQnlOYW1lW2NscyB8fCAndW5pdmVyc2FsJ10gPDwgNik7XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2Rlci5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiDnlLHkuo7pk77ooajlnKjnqbrpl7TnmoTlkIjnkIbliKnnlKjkuIrlkozmj5LlhaXvvIzliKDpmaTml7bkuI3pnIDopoHnp7vliqjnrYnnmoTmnInngrnvvIzlm6DmraTlnKjlvojlpJrlnLrlkIjkuIvvvIzlroPmmK/nur/mgKfooajnmoTpppbpgInlrZjlgqjnu5PmnoTjgILnhLbogIzvvIzlroPkuZ/lrZjlnKjnnYDlrp7njrDmn5Dkupvln7rmnKzmk43kvZzvvIzlpoLmsYLnur/mgKfooajplb/luqbml7bkuI3lpoLpobrluo/lrZjlgqjnu5PmnoTnmoTnvLrngrnvvJvlj6bkuIDmlrnpnaLvvIznlLHkuo7lnKjpk77ooajkuK3vvIznu5PngrnkuYvpl7TnmoTlhbPns7vkvb/nlKjmjIfpkojmnaXooajnpLrvvIzliJnmlbDmja7lhYPntKDlnKjnur/mgKfooajkuK3nmoTigJzkvY3luo/igJ3nmoTmpoLlv7Xlt7Lmt6HljJbvvIzogIzooqvmlbDmja7lhYPntKDlnKjnur/mgKfpk77ooajkuK3nmoTigJzkvY3nva7igJ3miYDku6Pmm7/jgILkuLrmraTvvIzku47lrp7pmYXlh7rlj5Hph43mlrDlrprkuYnnur/mgKfpk77ooajlj4rlhbbln7rmnKzmk43kvZxcbiAqL1xuXG5jbGFzcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgbmV4dCA9IG51bGwpe1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlua2VkTGlzdCB7XG4gICAgY29uc3RydWN0b3Ioc3FMaXN0ID0gW10pe1xuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgICAgIGlmIChzcUxpc3QpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzcUxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKHNxTGlzdFtpXSk7XG4gICAgICAgIH0gXG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIG1lcmdlIGxpc3QsIG5vdGU6IHRoaXMgb3BlcmF0aW9uIHdpbGwgZGVsZXRlIGEgYW5kIGIgbm9kZXMuXG4gICAgICogQHBhcmFtIHtMaW5rZWRMaXN0fSBhIFxuICAgICAqIEBwYXJhbSB7TGlua2VkTGlzdH0gYlxuICAgICAqIEBwYXJhbSB7Kn0gY29tcGFyZSBcbiAgICAgKi9cbiAgICBzdGF0aWMgbWVyZ2VMaXN0IChhLCBiLCBjb21wYXJlID0gY29tcEZuKSB7XG4gICAgICAgIGxldCBoYSA9IGEuaGVhZDtcbiAgICAgICAgbGV0IGhiID0gYi5oZWFkO1xuICAgICAgICBsZXQgcGEgPSBoYTtcbiAgICAgICAgbGV0IHBiID0gaGI7XG4gICAgICAgIGxldCBjID0gbmV3IExpbmtlZExpc3QoKTtcbiAgICAgICAgbGV0IHE7XG5cbiAgICAgICAgd2hpbGUgKHBhICYmIHBiKSB7XG4gICAgICAgICAgICBsZXQgZGF0YTEgPSBwYS5kYXRhO1xuICAgICAgICAgICAgbGV0IGRhdGEyID0gcGIuZGF0YTtcblxuICAgICAgICAgICAgaWYgKCFjb21wYXJlKGRhdGExLCBkYXRhMikpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgaGVhZCBub2RlXG4gICAgICAgICAgICAgICAgcSA9IGEuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgdGhlIG5vZGUgdG8gYyBsaW5rZWRMaXN0XG4gICAgICAgICAgICAgICAgYy5hcHBlbmQocSk7XG4gICAgICAgICAgICAgICAgcGEgPSBhLmhlYWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHEgPSBiLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgYy5hcHBlbmQocSk7XG4gICAgICAgICAgICAgICAgcGIgPSBiLmhlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChwYSkge1xuICAgICAgICAgICAgYy5hcHBlbmQocGEpO1xuICAgICAgICAgICAgYy50YWlsID0gYS50YWlsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYy5hcHBlbmQocGIpO1xuICAgICAgICAgICAgYy50YWlsID0gYi50YWlsO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgdGhlIGZpcnN0IGVsZW1lbnQgYW5kIHJldHVybiBpdFxuICAgICAqL1xuICAgIHNoaWZ0ICgpIHtcbiAgICAgICAgbGV0IGhlYWQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgICBoZWFkLm5leHQgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT09IG51bGwpIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgIHJldHVybiBoZWFkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgbGFzdCBlbGVtZW50IGFuZCByZXR1cm4gaXRcbiAgICAgKi9cbiAgICBwb3AoKXtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRoaXMuaGVhZDtcbiAgICAgICAgbGV0IGVsZW07XG5cbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhaWwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzLnRhaWwuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy50YWlsID0gcHJldmlvdXM7XG5cbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgIGVsZW0gPSBjdXJyZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiBlbGVtID8gZWxlbSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFwcGVuZCBub2RlXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFxuICAgICAqL1xuICAgIGFwcGVuZCAobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5oZWFkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwubmV4dCA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGRhdGFcbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgXG4gICAgICovXG4gICAgcHVzaCAoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBuZXcgTm9kZShkYXRhKTtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IHRoaXMuaGVhZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGFpbC5uZXh0ID0gbmV3IE5vZGUoZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGFpbC5kYXRhID0gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgZGF0YVxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBcbiAgICAgKi9cbiAgICByZW1vdmUgKGRhdGEpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRoaXMuaGVhZDtcbiAgICAgICAgbGV0IGVsZW07XG5cbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChkYXRhID09PSBjdXJyZW50LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGN1cnJlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMudGFpbCkgdGhpcy50YWlsID0gcHJldmlvdXM7XG5cbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgICAgIGVsZW0gPSBjdXJyZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBudWxsKSB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiBlbGVtID8gZWxlbSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZpbmQgdGhlIGluZGV4IG9mIG1hdGNoZWQgZGF0YSBcbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgXG4gICAgICovXG4gICAgaW5kZXhPZihkYXRhKXtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmRhdGEgPT09IGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGRhdGEgdG8gdGhlIGZyb250XG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFxuICAgICAqL1xuICAgIHVuc2hpZnQgKGRhdGEpIHtcbiAgICAgICAgbGV0IHRlbXAgPSBuZXcgTm9kZShkYXRhKTtcbiAgICAgICAgdGVtcC5uZXh0ID0gdGhpcy5oZWFkO1xuICAgICAgICB0aGlzLmhlYWQgPSB0ZW1wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBcbiAgICAgKi9cbiAgICBpbnNlcnRBZnRlciAodGFyZ2V0LCBkYXRhKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuZGF0YSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBuZXcgTm9kZShkYXRhKTtcbiAgICAgICAgICAgICAgICB0ZW1wLm5leHQgPSBjdXJyZW50Lm5leHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy50YWlsKSB0aGlzLnRhaWwgPSB0ZW1wO1xuXG4gICAgICAgICAgICAgICAgY3VycmVudC5uZXh0ID0gdGVtcDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpdGVtIChpbmRleCkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcblxuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKC0taW5kZXggPT09IDApIHJldHVybiBjdXJyZW50O1xuXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZm9yRWFjaCAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgICAgIGZvciAobGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQsIGluZGV4ID0gMDsgY3VycmVudDsgY3VycmVudCA9IGN1cnJlbnQubmV4dCkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGN1cnJlbnQuZGF0YSwgaW5kZXgrKykpIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCl7XG4gICAgICAgIGZvcihsZXQgY3VycmVudCA9IHRoaXMuaGVhZDsgY3VycmVudDsgY3VycmVudCA9IGN1cnJlbnQubmV4dCl7XG4gICAgICAgICAgICB5aWVsZCBjdXJyZW50LmRhdGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2l6ZSAoKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICsrc2l6ZTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICAgIGxldCBzdHIgPSAnJztcblxuICAgICAgICB0aGlzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIHN0ciArPSBub2RlLmRhdGEgKyAobm9kZS5uZXh0ID8gJywnIDogJycpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluc2VydCBlbGVtZW50IGJ5IG9yZGVyXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNtcCBcbiAgICAgKi9cbiAgICBvcmRlckluc2VydCAoZGF0YSwgY21wKSB7XG4gICAgICAgIGNtcCA9IHR5cGVvZiBjbXAgPT09ICdmdW5jdGlvbicgPyBjbXAgOiAoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGEgPiBiKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgZWxzZSBpZiAoYSA9PT0gYilcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwcmV2aW91cyA9IHRoaXMuaGVhZDtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBOb2RlKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGxldCByZXQgPSBjbXAoZGF0YSwgY3VycmVudC5kYXRhKTtcbiAgICAgICAgICAgIC8vIOWmguaenOaPkuWFpeWFg+e0oOWkp+S6juW9k+WJjeWFg+e0oO+8jOWHhuWkh+S4i+asoemBjeWOhlxuICAgICAgICAgICAgaWYgKHJldCA+IDApIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcblxuICAgICAgICAgICAgICAgIC8vIOWmguaenOetieS6ju+8jOebtOaOpeaPkuWFpeWIsOWQjumdolxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zZXJ0QmV0d2VlbihkYXRhLCBwcmV2aW91cywgY3VycmVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyDlpoLmnpzlsI/kuo7liJnmj5LlhaXliLDliY3oioLngrnlkozlvZPliY3oioLngrnkuK1cbiAgICAgICAgICAgICAgICAvLyDlm6DkuLrlt7Lnu4/mmK/mjpLluo/kuobvvIzmiYDku6XkuI3pnIDopoHlpJrkvZnliKTmlq3kuoZcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCA9PT0gcHJldmlvdXMgJiYgcHJldmlvdXMgPT09IGN1cnJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2hpZnQoZGF0YSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zZXJ0QmV0d2VlbihkYXRhLCBwcmV2aW91cywgY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDmj5LlhaXliLDmnIDlkI7kuIDkuKrnu5PngrlcbiAgICAgICAgcHJldmlvdXMubmV4dCA9IG5ldyBOb2RlKGRhdGEpO1xuICAgICAgICB0aGlzLnRhaWwgPSBwcmV2aW91cy5uZXh0O1xuXG4gICAgICAgIGZ1bmN0aW9uIGluc2VydEJldHdlZW4oZGF0YSwgYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPT0gYikge1xuICAgICAgICAgICAgICAgIGlmIChhID09IG1lLmhlYWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZS51bnNoaWZ0KGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IG5ldyBOb2RlKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRlbXAubmV4dCA9IGI7XG4gICAgICAgICAgICAgICAgYS5uZXh0ID0gdGVtcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIOWIoOmZpOWFg+e0oOmAkuWinuaOkuWIl+eahOmTvuihqOS4reWAvOWkp+S6jm1pbu+8jOS4lOWwj+S6jm1heOeahOaJgOacieWFg+e0oFxuICAgIGRlbGV0ZUJldHdlZW4gKG1pbiwgbWF4KSB7XG4gICAgICAgIGxldCBwID0gdGhpcy5oZWFkO1xuXG4gICAgICAgIC8vIHDmmK/mnIDlkI7kuIDkuKrkuI3lpKfkuo5taW7nmoTlhYPntKBcbiAgICAgICAgd2hpbGUgKHAubmV4dCAmJiBwLm5leHQuZGF0YSA8PSBtaW4pIHAgPSBwLm5leHQ7XG5cbiAgICAgICAgLy8g5aaC5p6c6L+Y5pyJ5q+UbWlu5pu05aSn55qE5YWD57SgXG4gICAgICAgIGxldCBxO1xuICAgICAgICBpZiAocC5uZXh0KSB7XG4gICAgICAgICAgICBxID0gcC5uZXh0O1xuICAgICAgICAgICAgLy8gceaYr+esrOS4gOS4quS4jeWwj+S6jm1heOeahOWFg+e0oFxuICAgICAgICAgICAgd2hpbGUgKHEgJiYgcS5kYXRhIDwgbWF4KSBxID0gcS5uZXh0O1xuICAgICAgICAgICAgcC5uZXh0ID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsYXN0ID0gcSB8fCBwO1xuICAgICAgICB3aGlsZSAobGFzdC5uZXh0KSBsYXN0ID0gbGFzdC5uZXh0O1xuICAgICAgICB0aGlzLnRhaWwgPSBsYXN0O1xuICAgIH1cblxuICAgIC8vIOWIoOmZpOWFg+e0oOmAkuWinuaOkuWIl+eahOmTvuihqOeahOmHjeWkjeWFg+e0oFxuICAgIGRlbGV0ZUVxdWFsICgpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBxID0gcC5uZXh0O1xuXG4gICAgICAgIHdoaWxlIChwLm5leHQpIHtcbiAgICAgICAgICAgIC8vIOW9k+ebuOmCu+S4pOWFg+e0oOS4jeebuOetieaXtu+8jHAscemDveWQkeWQjuenu1xuICAgICAgICAgICAgaWYgKHAuZGF0YSAhPT0gcS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgICAgICAgICBxID0gcC5uZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAocS5kYXRhID09PSBwLmRhdGEpIHEgPSBxLm5leHQ7XG5cbiAgICAgICAgICAgICAgICAvLyDliKDpmaRcbiAgICAgICAgICAgICAgICBwLm5leHQgPSBxO1xuICAgICAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICAgICAgICAgIHEgPSBwLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXZlcnNlICgpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBxID0gcC5uZXh0O1xuICAgICAgICBsZXQgcyA9IHEubmV4dDtcbiAgICAgICAgdGhpcy50YWlsID0gcDtcbiAgICAgICAgcC5uZXh0ID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAocy5uZXh0KSB7XG4gICAgICAgICAgICBxLm5leHQgPSBwO1xuICAgICAgICAgICAgcCA9IHE7XG4gICAgICAgICAgICBxID0gcztcbiAgICAgICAgICAgIHMgPSBzLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBxLm5leHQgPSBwO1xuICAgICAgICBzLm5leHQgPSBxO1xuICAgICAgICB0aGlzLmhlYWQgPSBzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29tcEZuKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvTGlzdC9MaW5rZWRMaXN0LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJhbmQobGVuKSB7XG4gIGlmICghcilcbiAgICByID0gbmV3IFJhbmQobnVsbCk7XG5cbiAgcmV0dXJuIHIuZ2VuZXJhdGUobGVuKTtcbn07XG5cbmZ1bmN0aW9uIFJhbmQocmFuZCkge1xuICB0aGlzLnJhbmQgPSByYW5kO1xufVxubW9kdWxlLmV4cG9ydHMuUmFuZCA9IFJhbmQ7XG5cblJhbmQucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUobGVuKSB7XG4gIHJldHVybiB0aGlzLl9yYW5kKGxlbik7XG59O1xuXG4vLyBFbXVsYXRlIGNyeXB0byBBUEkgdXNpbmcgcmFuZHlcblJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICBpZiAodGhpcy5yYW5kLmdldEJ5dGVzKVxuICAgIHJldHVybiB0aGlzLnJhbmQuZ2V0Qnl0ZXMobik7XG5cbiAgdmFyIHJlcyA9IG5ldyBVaW50OEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKylcbiAgICByZXNbaV0gPSB0aGlzLnJhbmQuZ2V0Qnl0ZSgpO1xuICByZXR1cm4gcmVzO1xufTtcblxuaWYgKHR5cGVvZiBzZWxmID09PSAnb2JqZWN0Jykge1xuICBpZiAoc2VsZi5jcnlwdG8gJiYgc2VsZi5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gTW9kZXJuIGJyb3dzZXJzXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICBzZWxmLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChzZWxmLm1zQ3J5cHRvICYmIHNlbGYubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gSUVcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIHNlbGYubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH07XG5cbiAgLy8gU2FmYXJpJ3MgV2ViV29ya2VycyBkbyBub3QgaGF2ZSBgY3J5cHRvYFxuICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gT2xkIGp1bmtcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgfTtcbiAgfVxufSBlbHNlIHtcbiAgLy8gTm9kZS5qcyBvciBXZWIgd29ya2VyIHdpdGggbm8gY3J5cHRvIHN1cHBvcnRcbiAgdHJ5IHtcbiAgICB2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8ucmFuZG9tQnl0ZXMgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQnKTtcblxuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyhuKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm9yYW5kL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBHSEFTSCA9IHJlcXVpcmUoJy4vZ2hhc2gnKVxudmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuaW5oZXJpdHMoU3RyZWFtQ2lwaGVyLCBUcmFuc2Zvcm0pXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUNpcGhlclxuXG5mdW5jdGlvbiBTdHJlYW1DaXBoZXIgKG1vZGUsIGtleSwgaXYsIGRlY3J5cHQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cmVhbUNpcGhlcikpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2ZpbklEID0gQnVmZmVyLmNvbmNhdChbaXYsIG5ldyBCdWZmZXIoWzAsIDAsIDAsIDFdKV0pXG4gIGl2ID0gQnVmZmVyLmNvbmNhdChbaXYsIG5ldyBCdWZmZXIoWzAsIDAsIDAsIDJdKV0pXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IG5ldyBCdWZmZXIoaXYubGVuZ3RoKVxuICB0aGlzLl9jYWNoZSA9IG5ldyBCdWZmZXIoJycpXG4gIHRoaXMuX3NlY0NhY2hlID0gbmV3IEJ1ZmZlcignJylcbiAgdGhpcy5fZGVjcnlwdCA9IGRlY3J5cHRcbiAgdGhpcy5fYWxlbiA9IDBcbiAgdGhpcy5fbGVuID0gMFxuICBpdi5jb3B5KHRoaXMuX3ByZXYpXG4gIHRoaXMuX21vZGUgPSBtb2RlXG4gIHZhciBoID0gbmV3IEJ1ZmZlcig0KVxuICBoLmZpbGwoMClcbiAgdGhpcy5fZ2hhc2ggPSBuZXcgR0hBU0godGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayhoKSlcbiAgdGhpcy5fYXV0aFRhZyA9IG51bGxcbiAgdGhpcy5fY2FsbGVkID0gZmFsc2Vcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICBpZiAoIXRoaXMuX2NhbGxlZCAmJiB0aGlzLl9hbGVuKSB7XG4gICAgdmFyIHJ1bXAgPSAxNiAtICh0aGlzLl9hbGVuICUgMTYpXG4gICAgaWYgKHJ1bXAgPCAxNikge1xuICAgICAgcnVtcCA9IG5ldyBCdWZmZXIocnVtcClcbiAgICAgIHJ1bXAuZmlsbCgwKVxuICAgICAgdGhpcy5fZ2hhc2gudXBkYXRlKHJ1bXApXG4gICAgfVxuICB9XG4gIHRoaXMuX2NhbGxlZCA9IHRydWVcbiAgdmFyIG91dCA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUoY2h1bmspXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZ2hhc2gudXBkYXRlKG91dClcbiAgfVxuICB0aGlzLl9sZW4gKz0gY2h1bmsubGVuZ3RoXG4gIHJldHVybiBvdXRcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGVjcnlwdCAmJiAhdGhpcy5fYXV0aFRhZykge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJylcbiAgfVxuICB2YXIgdGFnID0geG9yKHRoaXMuX2doYXNoLmZpbmFsKHRoaXMuX2FsZW4gKiA4LCB0aGlzLl9sZW4gKiA4KSwgdGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh0aGlzLl9maW5JRCkpXG4gIGlmICh0aGlzLl9kZWNyeXB0KSB7XG4gICAgaWYgKHhvclRlc3QodGFnLCB0aGlzLl9hdXRoVGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGEnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9hdXRoVGFnID0gdGFnXG4gIH1cbiAgdGhpcy5fY2lwaGVyLnNjcnViKClcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuZ2V0QXV0aFRhZyA9IGZ1bmN0aW9uIGdldEF1dGhUYWcgKCkge1xuICBpZiAoIXRoaXMuX2RlY3J5cHQgJiYgQnVmZmVyLmlzQnVmZmVyKHRoaXMuX2F1dGhUYWcpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dGhUYWdcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gZ2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbiAgfVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5zZXRBdXRoVGFnID0gZnVuY3Rpb24gc2V0QXV0aFRhZyAodGFnKSB7XG4gIGlmICh0aGlzLl9kZWNyeXB0KSB7XG4gICAgdGhpcy5fYXV0aFRhZyA9IHRhZ1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBzZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuICB9XG59XG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLnNldEFBRCA9IGZ1bmN0aW9uIHNldEFBRCAoYnVmKSB7XG4gIGlmICghdGhpcy5fY2FsbGVkKSB7XG4gICAgdGhpcy5fZ2hhc2gudXBkYXRlKGJ1ZilcbiAgICB0aGlzLl9hbGVuICs9IGJ1Zi5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gc2V0IEFBRCBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG4gIH1cbn1cbmZ1bmN0aW9uIHhvclRlc3QgKGEsIGIpIHtcbiAgdmFyIG91dCA9IDBcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIG91dCsrXG4gIH1cbiAgdmFyIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0ICs9IChhW2ldIF4gYltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvYXV0aENpcGhlci5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgYmxvY2spIHtcbiAgdmFyIGRhdGEgPSB4b3IoYmxvY2ssIHNlbGYuX3ByZXYpXG5cbiAgc2VsZi5fcHJldiA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soZGF0YSlcbiAgcmV0dXJuIHNlbGYuX3ByZXZcbn1cblxuZXhwb3J0cy5kZWNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHZhciBwYWQgPSBzZWxmLl9wcmV2XG5cbiAgc2VsZi5fcHJldiA9IGJsb2NrXG4gIHZhciBvdXQgPSBzZWxmLl9jaXBoZXIuZGVjcnlwdEJsb2NrKGJsb2NrKVxuXG4gIHJldHVybiB4b3Iob3V0LCBwYWQpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2JjLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBkYXRhLCBkZWNyeXB0KSB7XG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKCcnKVxuICB2YXIgbGVuXG5cbiAgd2hpbGUgKGRhdGEubGVuZ3RoKSB7XG4gICAgaWYgKHNlbGYuX2NhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gICAgICBzZWxmLl9wcmV2ID0gbmV3IEJ1ZmZlcignJylcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fY2FjaGUubGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICBsZW4gPSBzZWxmLl9jYWNoZS5sZW5ndGhcbiAgICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW291dCwgZW5jcnlwdFN0YXJ0KHNlbGYsIGRhdGEuc2xpY2UoMCwgbGVuKSwgZGVjcnlwdCldKVxuICAgICAgZGF0YSA9IGRhdGEuc2xpY2UobGVuKVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtvdXQsIGVuY3J5cHRTdGFydChzZWxmLCBkYXRhLCBkZWNyeXB0KV0pXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbmZ1bmN0aW9uIGVuY3J5cHRTdGFydCAoc2VsZiwgZGF0YSwgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gZGF0YS5sZW5ndGhcbiAgdmFyIG91dCA9IHhvcihkYXRhLCBzZWxmLl9jYWNoZSlcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShsZW4pXG4gIHNlbGYuX3ByZXYgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9wcmV2LCBkZWNyeXB0ID8gZGF0YSA6IG91dF0pXG4gIHJldHVybiBvdXRcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jZmIuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIGVuY3J5cHRCeXRlIChzZWxmLCBieXRlUGFyYW0sIGRlY3J5cHQpIHtcbiAgdmFyIHBhZFxuICB2YXIgaSA9IC0xXG4gIHZhciBsZW4gPSA4XG4gIHZhciBvdXQgPSAwXG4gIHZhciBiaXQsIHZhbHVlXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBwYWQgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gICAgYml0ID0gKGJ5dGVQYXJhbSAmICgxIDw8ICg3IC0gaSkpKSA/IDB4ODAgOiAwXG4gICAgdmFsdWUgPSBwYWRbMF0gXiBiaXRcbiAgICBvdXQgKz0gKCh2YWx1ZSAmIDB4ODApID4+IChpICUgOCkpXG4gICAgc2VsZi5fcHJldiA9IHNoaWZ0SW4oc2VsZi5fcHJldiwgZGVjcnlwdCA/IGJpdCA6IHZhbHVlKVxuICB9XG4gIHJldHVybiBvdXRcbn1cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaywgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gY2h1bmsubGVuZ3RoXG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKGxlbilcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gZW5jcnlwdEJ5dGUoc2VsZiwgY2h1bmtbaV0sIGRlY3J5cHQpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuZnVuY3Rpb24gc2hpZnRJbiAoYnVmZmVyLCB2YWx1ZSkge1xuICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aFxuICB2YXIgaSA9IC0xXG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKGJ1ZmZlci5sZW5ndGgpXG4gIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlciwgbmV3IEJ1ZmZlcihbdmFsdWVdKV0pXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBidWZmZXJbaV0gPDwgMSB8IGJ1ZmZlcltpICsgMV0gPj4gKDcpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jyb3dzZXJpZnktYWVzL21vZGVzL2NmYjEuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIGVuY3J5cHRCeXRlIChzZWxmLCBieXRlUGFyYW0sIGRlY3J5cHQpIHtcbiAgdmFyIHBhZCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgdmFyIG91dCA9IHBhZFswXSBeIGJ5dGVQYXJhbVxuICBzZWxmLl9wcmV2ID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fcHJldi5zbGljZSgxKSwgbmV3IEJ1ZmZlcihbZGVjcnlwdCA/IGJ5dGVQYXJhbSA6IG91dF0pXSlcbiAgcmV0dXJuIG91dFxufVxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBjaHVuay5sZW5ndGhcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIobGVuKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBlbmNyeXB0Qnl0ZShzZWxmLCBjaHVua1tpXSwgZGVjcnlwdClcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiOC5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHJldHVybiBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGJsb2NrKVxufVxuZXhwb3J0cy5kZWNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHJldHVybiBzZWxmLl9jaXBoZXIuZGVjcnlwdEJsb2NrKGJsb2NrKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jyb3dzZXJpZnktYWVzL21vZGVzL2VjYi5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5mdW5jdGlvbiBnZXRCbG9jayAoc2VsZikge1xuICBzZWxmLl9wcmV2ID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICByZXR1cm4gc2VsZi5fcHJldlxufVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmspIHtcbiAgd2hpbGUgKHNlbGYuX2NhY2hlLmxlbmd0aCA8IGNodW5rLmxlbmd0aCkge1xuICAgIHNlbGYuX2NhY2hlID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fY2FjaGUsIGdldEJsb2NrKHNlbGYpXSlcbiAgfVxuXG4gIHZhciBwYWQgPSBzZWxmLl9jYWNoZS5zbGljZSgwLCBjaHVuay5sZW5ndGgpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UoY2h1bmsubGVuZ3RoKVxuICByZXR1cm4geG9yKGNodW5rLCBwYWQpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvbW9kZXMvb2ZiLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuaW5oZXJpdHMoU3RyZWFtQ2lwaGVyLCBUcmFuc2Zvcm0pXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUNpcGhlclxuZnVuY3Rpb24gU3RyZWFtQ2lwaGVyIChtb2RlLCBrZXksIGl2LCBkZWNyeXB0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHJlYW1DaXBoZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIobW9kZSwga2V5LCBpdilcbiAgfVxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBuZXcgQnVmZmVyKGl2Lmxlbmd0aClcbiAgdGhpcy5fY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxuICB0aGlzLl9zZWNDYWNoZSA9IG5ldyBCdWZmZXIoJycpXG4gIHRoaXMuX2RlY3J5cHQgPSBkZWNyeXB0XG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbn1cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rLCB0aGlzLl9kZWNyeXB0KVxufVxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2NpcGhlci5zY3J1YigpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvc3RyZWFtQ2lwaGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJzaGEyMjRXaXRoUlNBRW5jcnlwdGlvblwiOiB7XG5cdFx0XCJzaWduXCI6IFwicnNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhMjI0XCIsXG5cdFx0XCJpZFwiOiBcIjMwMmQzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwNDA1MDAwNDFjXCJcblx0fSxcblx0XCJSU0EtU0hBMjI0XCI6IHtcblx0XHRcInNpZ25cIjogXCJlY2RzYS9yc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGEyMjRcIixcblx0XHRcImlkXCI6IFwiMzAyZDMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjA0MDUwMDA0MWNcIlxuXHR9LFxuXHRcInNoYTI1NldpdGhSU0FFbmNyeXB0aW9uXCI6IHtcblx0XHRcInNpZ25cIjogXCJyc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGEyNTZcIixcblx0XHRcImlkXCI6IFwiMzAzMTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAxMDUwMDA0MjBcIlxuXHR9LFxuXHRcIlJTQS1TSEEyNTZcIjoge1xuXHRcdFwic2lnblwiOiBcImVjZHNhL3JzYVwiLFxuXHRcdFwiaGFzaFwiOiBcInNoYTI1NlwiLFxuXHRcdFwiaWRcIjogXCIzMDMxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDEwNTAwMDQyMFwiXG5cdH0sXG5cdFwic2hhMzg0V2l0aFJTQUVuY3J5cHRpb25cIjoge1xuXHRcdFwic2lnblwiOiBcInJzYVwiLFxuXHRcdFwiaGFzaFwiOiBcInNoYTM4NFwiLFxuXHRcdFwiaWRcIjogXCIzMDQxMzAwZDA2MDk2MDg2NDgwMTY1MDMwNDAyMDIwNTAwMDQzMFwiXG5cdH0sXG5cdFwiUlNBLVNIQTM4NFwiOiB7XG5cdFx0XCJzaWduXCI6IFwiZWNkc2EvcnNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhMzg0XCIsXG5cdFx0XCJpZFwiOiBcIjMwNDEzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwMjA1MDAwNDMwXCJcblx0fSxcblx0XCJzaGE1MTJXaXRoUlNBRW5jcnlwdGlvblwiOiB7XG5cdFx0XCJzaWduXCI6IFwicnNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhNTEyXCIsXG5cdFx0XCJpZFwiOiBcIjMwNTEzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwMzA1MDAwNDQwXCJcblx0fSxcblx0XCJSU0EtU0hBNTEyXCI6IHtcblx0XHRcInNpZ25cIjogXCJlY2RzYS9yc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGE1MTJcIixcblx0XHRcImlkXCI6IFwiMzA1MTMwMGQwNjA5NjA4NjQ4MDE2NTAzMDQwMjAzMDUwMDA0NDBcIlxuXHR9LFxuXHRcIlJTQS1TSEExXCI6IHtcblx0XHRcInNpZ25cIjogXCJyc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGExXCIsXG5cdFx0XCJpZFwiOiBcIjMwMjEzMDA5MDYwNTJiMGUwMzAyMWEwNTAwMDQxNFwiXG5cdH0sXG5cdFwiZWNkc2Etd2l0aC1TSEExXCI6IHtcblx0XHRcInNpZ25cIjogXCJlY2RzYVwiLFxuXHRcdFwiaGFzaFwiOiBcInNoYTFcIixcblx0XHRcImlkXCI6IFwiXCJcblx0fSxcblx0XCJzaGEyNTZcIjoge1xuXHRcdFwic2lnblwiOiBcImVjZHNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhMjU2XCIsXG5cdFx0XCJpZFwiOiBcIlwiXG5cdH0sXG5cdFwic2hhMjI0XCI6IHtcblx0XHRcInNpZ25cIjogXCJlY2RzYVwiLFxuXHRcdFwiaGFzaFwiOiBcInNoYTIyNFwiLFxuXHRcdFwiaWRcIjogXCJcIlxuXHR9LFxuXHRcInNoYTM4NFwiOiB7XG5cdFx0XCJzaWduXCI6IFwiZWNkc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGEzODRcIixcblx0XHRcImlkXCI6IFwiXCJcblx0fSxcblx0XCJzaGE1MTJcIjoge1xuXHRcdFwic2lnblwiOiBcImVjZHNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhNTEyXCIsXG5cdFx0XCJpZFwiOiBcIlwiXG5cdH0sXG5cdFwiRFNBLVNIQVwiOiB7XG5cdFx0XCJzaWduXCI6IFwiZHNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhMVwiLFxuXHRcdFwiaWRcIjogXCJcIlxuXHR9LFxuXHRcIkRTQS1TSEExXCI6IHtcblx0XHRcInNpZ25cIjogXCJkc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGExXCIsXG5cdFx0XCJpZFwiOiBcIlwiXG5cdH0sXG5cdFwiRFNBXCI6IHtcblx0XHRcInNpZ25cIjogXCJkc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGExXCIsXG5cdFx0XCJpZFwiOiBcIlwiXG5cdH0sXG5cdFwiRFNBLVdJVEgtU0hBMjI0XCI6IHtcblx0XHRcInNpZ25cIjogXCJkc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGEyMjRcIixcblx0XHRcImlkXCI6IFwiXCJcblx0fSxcblx0XCJEU0EtU0hBMjI0XCI6IHtcblx0XHRcInNpZ25cIjogXCJkc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGEyMjRcIixcblx0XHRcImlkXCI6IFwiXCJcblx0fSxcblx0XCJEU0EtV0lUSC1TSEEyNTZcIjoge1xuXHRcdFwic2lnblwiOiBcImRzYVwiLFxuXHRcdFwiaGFzaFwiOiBcInNoYTI1NlwiLFxuXHRcdFwiaWRcIjogXCJcIlxuXHR9LFxuXHRcIkRTQS1TSEEyNTZcIjoge1xuXHRcdFwic2lnblwiOiBcImRzYVwiLFxuXHRcdFwiaGFzaFwiOiBcInNoYTI1NlwiLFxuXHRcdFwiaWRcIjogXCJcIlxuXHR9LFxuXHRcIkRTQS1XSVRILVNIQTM4NFwiOiB7XG5cdFx0XCJzaWduXCI6IFwiZHNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhMzg0XCIsXG5cdFx0XCJpZFwiOiBcIlwiXG5cdH0sXG5cdFwiRFNBLVNIQTM4NFwiOiB7XG5cdFx0XCJzaWduXCI6IFwiZHNhXCIsXG5cdFx0XCJoYXNoXCI6IFwic2hhMzg0XCIsXG5cdFx0XCJpZFwiOiBcIlwiXG5cdH0sXG5cdFwiRFNBLVdJVEgtU0hBNTEyXCI6IHtcblx0XHRcInNpZ25cIjogXCJkc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGE1MTJcIixcblx0XHRcImlkXCI6IFwiXCJcblx0fSxcblx0XCJEU0EtU0hBNTEyXCI6IHtcblx0XHRcInNpZ25cIjogXCJkc2FcIixcblx0XHRcImhhc2hcIjogXCJzaGE1MTJcIixcblx0XHRcImlkXCI6IFwiXCJcblx0fSxcblx0XCJEU0EtUklQRU1EMTYwXCI6IHtcblx0XHRcInNpZ25cIjogXCJkc2FcIixcblx0XHRcImhhc2hcIjogXCJybWQxNjBcIixcblx0XHRcImlkXCI6IFwiXCJcblx0fSxcblx0XCJyaXBlbWQxNjBXaXRoUlNBXCI6IHtcblx0XHRcInNpZ25cIjogXCJyc2FcIixcblx0XHRcImhhc2hcIjogXCJybWQxNjBcIixcblx0XHRcImlkXCI6IFwiMzAyMTMwMDkwNjA1MmIyNDAzMDIwMTA1MDAwNDE0XCJcblx0fSxcblx0XCJSU0EtUklQRU1EMTYwXCI6IHtcblx0XHRcInNpZ25cIjogXCJyc2FcIixcblx0XHRcImhhc2hcIjogXCJybWQxNjBcIixcblx0XHRcImlkXCI6IFwiMzAyMTMwMDkwNjA1MmIyNDAzMDIwMTA1MDAwNDE0XCJcblx0fSxcblx0XCJtZDVXaXRoUlNBRW5jcnlwdGlvblwiOiB7XG5cdFx0XCJzaWduXCI6IFwicnNhXCIsXG5cdFx0XCJoYXNoXCI6IFwibWQ1XCIsXG5cdFx0XCJpZFwiOiBcIjMwMjAzMDBjMDYwODJhODY0ODg2ZjcwZDAyMDUwNTAwMDQxMFwiXG5cdH0sXG5cdFwiUlNBLU1ENVwiOiB7XG5cdFx0XCJzaWduXCI6IFwicnNhXCIsXG5cdFx0XCJoYXNoXCI6IFwibWQ1XCIsXG5cdFx0XCJpZFwiOiBcIjMwMjAzMDBjMDYwODJhODY0ODg2ZjcwZDAyMDUwNTAwMDQxMFwiXG5cdH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jyb3dzZXJpZnktc2lnbi9icm93c2VyL2FsZ29yaXRobXMuanNvblxuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiMS4zLjEzMi4wLjEwXCI6IFwic2VjcDI1NmsxXCIsXG5cdFwiMS4zLjEzMi4wLjMzXCI6IFwicDIyNFwiLFxuXHRcIjEuMi44NDAuMTAwNDUuMy4xLjFcIjogXCJwMTkyXCIsXG5cdFwiMS4yLjg0MC4xMDA0NS4zLjEuN1wiOiBcInAyNTZcIixcblx0XCIxLjMuMTMyLjAuMzRcIjogXCJwMzg0XCIsXG5cdFwiMS4zLjEzMi4wLjM1XCI6IFwicDUyMVwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9jdXJ2ZXMuanNvblxuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMSBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gY29yZV9tZDUoeCwgbGVuKVxue1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8ICgobGVuKSAlIDMyKTtcbiAgeFsoKChsZW4gKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbGVuO1xuXG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcblxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyAwXSwgNyAsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTcsICA2MDYxMDU4MTkpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDcgLCAtMTc2NDE4ODk3KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgNV0sIDEyLCAgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDhdLCA3ICwgIDE3NzAwMzU0MTYpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE3LCAtNDIwNjMpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDcgLCAgMTgwNDYwMzY4Mik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xuXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDFdLCA1ICwgLTE2NTc5NjUxMCk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDZdLCA5ICwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzExXSwgMTQsICA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyAwXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA1XSwgNSAsIC03MDE1NTg2OTEpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzEwXSwgOSAsICAzODAxNjA4Myk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDldLCA1ICwgIDU2ODQ0NjQzOCk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTRdLCA5ICwgLTEwMTk4MDM2OTApO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA4XSwgMjAsICAxMTYzNTMxNTAxKTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsxM10sIDUgLCAtMTQ0NDY4MTQ2Nyk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDJdLCA5ICwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE0LCAgMTczNTMyODQ3Myk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDVdLCA0ICwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzExXSwgMTYsICAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyAxXSwgNCAsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKzEzXSwgNCAsICA2ODEyNzkxNzQpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyA2XSwgMjMsICA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDldLCA0ICwgLTY0MDM2NDQ4Nyk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTVdLCAxNiwgIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDJdLCAyMywgLTk5NTMzODY1MSk7XG5cbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDYgLCAtMTk4NjMwODQ0KTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgN10sIDEwLCAgMTEyNjg5MTQxNSk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krMTJdLCA2ICwgIDE3MDA0ODU1NzEpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA4XSwgNiAsICAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsxM10sIDIxLCAgMTMwOTE1MTY0OSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDRdLCA2ICwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTUsICA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuXG4gICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xuICB9XG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkKTtcblxufVxuXG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuZnVuY3Rpb24gbWQ1X2NtbihxLCBhLCBiLCB4LCBzLCB0KVxue1xuICByZXR1cm4gc2FmZV9hZGQoYml0X3JvbChzYWZlX2FkZChzYWZlX2FkZChhLCBxKSwgc2FmZV9hZGQoeCwgdCkpLCBzKSxiKTtcbn1cbmZ1bmN0aW9uIG1kNV9mZihhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfZ2coYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2hoKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaWkoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcbntcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gYml0X3JvbChudW0sIGNudClcbntcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1kNShidWYpIHtcbiAgcmV0dXJuIGhlbHBlcnMuaGFzaChidWYsIGNvcmVfbWQ1LCAxNik7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jcmVhdGUtaGFzaC9tZDUuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLlVJTlQzMiA9IHJlcXVpcmUoJy4vbGliL3VpbnQzMicpXG5leHBvcnRzLlVJTlQ2NCA9IHJlcXVpcmUoJy4vbGliL3VpbnQ2NCcpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2N1aW50L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZmluZFByaW1lO1xuZmluZFByaW1lLnNpbXBsZVNpZXZlID0gc2ltcGxlU2lldmU7XG5maW5kUHJpbWUuZmVybWF0VGVzdCA9IGZlcm1hdFRlc3Q7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIFRXRU5UWUZPVVIgPSBuZXcgQk4oMjQpO1xudmFyIE1pbGxlclJhYmluID0gcmVxdWlyZSgnbWlsbGVyLXJhYmluJyk7XG52YXIgbWlsbGVyUmFiaW4gPSBuZXcgTWlsbGVyUmFiaW4oKTtcbnZhciBPTkUgPSBuZXcgQk4oMSk7XG52YXIgVFdPID0gbmV3IEJOKDIpO1xudmFyIEZJVkUgPSBuZXcgQk4oNSk7XG52YXIgU0lYVEVFTiA9IG5ldyBCTigxNik7XG52YXIgRUlHSFQgPSBuZXcgQk4oOCk7XG52YXIgVEVOID0gbmV3IEJOKDEwKTtcbnZhciBUSFJFRSA9IG5ldyBCTigzKTtcbnZhciBTRVZFTiA9IG5ldyBCTig3KTtcbnZhciBFTEVWRU4gPSBuZXcgQk4oMTEpO1xudmFyIEZPVVIgPSBuZXcgQk4oNCk7XG52YXIgVFdFTFZFID0gbmV3IEJOKDEyKTtcbnZhciBwcmltZXMgPSBudWxsO1xuXG5mdW5jdGlvbiBfZ2V0UHJpbWVzKCkge1xuICBpZiAocHJpbWVzICE9PSBudWxsKVxuICAgIHJldHVybiBwcmltZXM7XG5cbiAgdmFyIGxpbWl0ID0gMHgxMDAwMDA7XG4gIHZhciByZXMgPSBbXTtcbiAgcmVzWzBdID0gMjtcbiAgZm9yICh2YXIgaSA9IDEsIGsgPSAzOyBrIDwgbGltaXQ7IGsgKz0gMikge1xuICAgIHZhciBzcXJ0ID0gTWF0aC5jZWlsKE1hdGguc3FydChrKSk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpICYmIHJlc1tqXSA8PSBzcXJ0OyBqKyspXG4gICAgICBpZiAoayAlIHJlc1tqXSA9PT0gMClcbiAgICAgICAgYnJlYWs7XG5cbiAgICBpZiAoaSAhPT0gaiAmJiByZXNbal0gPD0gc3FydClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgcmVzW2krK10gPSBrO1xuICB9XG4gIHByaW1lcyA9IHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gc2ltcGxlU2lldmUocCkge1xuICB2YXIgcHJpbWVzID0gX2dldFByaW1lcygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpbWVzLmxlbmd0aDsgaSsrKVxuICAgIGlmIChwLm1vZG4ocHJpbWVzW2ldKSA9PT0gMCkge1xuICAgICAgaWYgKHAuY21wbihwcmltZXNbaV0pID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZmVybWF0VGVzdChwKSB7XG4gIHZhciByZWQgPSBCTi5tb250KHApO1xuICByZXR1cm4gVFdPLnRvUmVkKHJlZCkucmVkUG93KHAuc3VibigxKSkuZnJvbVJlZCgpLmNtcG4oMSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmltZShiaXRzLCBnZW4pIHtcbiAgaWYgKGJpdHMgPCAxNikge1xuICAgIC8vIHRoaXMgaXMgd2hhdCBvcGVuc3NsIGRvZXNcbiAgICBpZiAoZ2VuID09PSAyIHx8IGdlbiA9PT0gNSkge1xuICAgICAgcmV0dXJuIG5ldyBCTihbMHg4YywgMHg3Yl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEJOKFsweDhjLCAweDI3XSk7XG4gICAgfVxuICB9XG4gIGdlbiA9IG5ldyBCTihnZW4pO1xuXG4gIHZhciBudW0sIG4yO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbnVtID0gbmV3IEJOKHJhbmRvbUJ5dGVzKE1hdGguY2VpbChiaXRzIC8gOCkpKTtcbiAgICB3aGlsZSAobnVtLmJpdExlbmd0aCgpID4gYml0cykge1xuICAgICAgbnVtLmlzaHJuKDEpO1xuICAgIH1cbiAgICBpZiAobnVtLmlzRXZlbigpKSB7XG4gICAgICBudW0uaWFkZChPTkUpO1xuICAgIH1cbiAgICBpZiAoIW51bS50ZXN0bigxKSkge1xuICAgICAgbnVtLmlhZGQoVFdPKTtcbiAgICB9XG4gICAgaWYgKCFnZW4uY21wKFRXTykpIHtcbiAgICAgIHdoaWxlIChudW0ubW9kKFRXRU5UWUZPVVIpLmNtcChFTEVWRU4pKSB7XG4gICAgICAgIG51bS5pYWRkKEZPVVIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWdlbi5jbXAoRklWRSkpIHtcbiAgICAgIHdoaWxlIChudW0ubW9kKFRFTikuY21wKFRIUkVFKSkge1xuICAgICAgICBudW0uaWFkZChGT1VSKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbjIgPSBudW0uc2hybigxKTtcbiAgICBpZiAoc2ltcGxlU2lldmUobjIpICYmIHNpbXBsZVNpZXZlKG51bSkgJiZcbiAgICAgIGZlcm1hdFRlc3QobjIpICYmIGZlcm1hdFRlc3QobnVtKSAmJlxuICAgICAgbWlsbGVyUmFiaW4udGVzdChuMikgJiYgbWlsbGVyUmFiaW4udGVzdChudW0pKSB7XG4gICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgfVxuXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZGlmZmllLWhlbGxtYW4vbGliL2dlbmVyYXRlUHJpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBicm9yYW5kID0gcmVxdWlyZSgnYnJvcmFuZCcpO1xuXG5mdW5jdGlvbiBNaWxsZXJSYWJpbihyYW5kKSB7XG4gIHRoaXMucmFuZCA9IHJhbmQgfHwgbmV3IGJyb3JhbmQuUmFuZCgpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBNaWxsZXJSYWJpbjtcblxuTWlsbGVyUmFiaW4uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHJhbmQpIHtcbiAgcmV0dXJuIG5ldyBNaWxsZXJSYWJpbihyYW5kKTtcbn07XG5cbk1pbGxlclJhYmluLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgdmFyIGxlbiA9IG4uYml0TGVuZ3RoKCk7XG4gIHZhciBidWYgPSB0aGlzLnJhbmQuZ2VuZXJhdGUoTWF0aC5jZWlsKGxlbiAvIDgpKTtcblxuICAvLyBTZXQgbG93IGJpdHNcbiAgYnVmWzBdIHw9IDM7XG5cbiAgLy8gTWFzayBoaWdoIGJpdHNcbiAgdmFyIG1hc2sgPSBsZW4gJiAweDc7XG4gIGlmIChtYXNrICE9PSAwKVxuICAgIGJ1ZltidWYubGVuZ3RoIC0gMV0gPj49IDcgLSBtYXNrO1xuXG4gIHJldHVybiBuZXcgYm4oYnVmKTtcbn1cblxuTWlsbGVyUmFiaW4ucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiB0ZXN0KG4sIGssIGNiKSB7XG4gIHZhciBsZW4gPSBuLmJpdExlbmd0aCgpO1xuICB2YXIgcmVkID0gYm4ubW9udChuKTtcbiAgdmFyIHJvbmUgPSBuZXcgYm4oMSkudG9SZWQocmVkKTtcblxuICBpZiAoIWspXG4gICAgayA9IE1hdGgubWF4KDEsIChsZW4gLyA0OCkgfCAwKTtcblxuICAvLyBGaW5kIGQgYW5kIHMsIChuIC0gMSkgPSAoMiBeIHMpICogZDtcbiAgdmFyIG4xID0gbi5zdWJuKDEpO1xuICB2YXIgbjIgPSBuMS5zdWJuKDEpO1xuICBmb3IgKHZhciBzID0gMDsgIW4xLnRlc3RuKHMpOyBzKyspIHt9XG4gIHZhciBkID0gbi5zaHJuKHMpO1xuXG4gIHZhciBybjEgPSBuMS50b1JlZChyZWQpO1xuXG4gIHZhciBwcmltZSA9IHRydWU7XG4gIGZvciAoOyBrID4gMDsgay0tKSB7XG4gICAgdmFyIGEgPSB0aGlzLl9yYW5kKG4yKTtcbiAgICBpZiAoY2IpXG4gICAgICBjYihhKTtcblxuICAgIHZhciB4ID0gYS50b1JlZChyZWQpLnJlZFBvdyhkKTtcbiAgICBpZiAoeC5jbXAocm9uZSkgPT09IDAgfHwgeC5jbXAocm4xKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzOyBpKyspIHtcbiAgICAgIHggPSB4LnJlZFNxcigpO1xuXG4gICAgICBpZiAoeC5jbXAocm9uZSkgPT09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh4LmNtcChybjEpID09PSAwKVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gcylcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwcmltZTtcbn07XG5cbk1pbGxlclJhYmluLnByb3RvdHlwZS5nZXREaXZpc29yID0gZnVuY3Rpb24gZ2V0RGl2aXNvcihuLCBrKSB7XG4gIHZhciBsZW4gPSBuLmJpdExlbmd0aCgpO1xuICB2YXIgcmVkID0gYm4ubW9udChuKTtcbiAgdmFyIHJvbmUgPSBuZXcgYm4oMSkudG9SZWQocmVkKTtcblxuICBpZiAoIWspXG4gICAgayA9IE1hdGgubWF4KDEsIChsZW4gLyA0OCkgfCAwKTtcblxuICAvLyBGaW5kIGQgYW5kIHMsIChuIC0gMSkgPSAoMiBeIHMpICogZDtcbiAgdmFyIG4xID0gbi5zdWJuKDEpO1xuICB2YXIgbjIgPSBuMS5zdWJuKDEpO1xuICBmb3IgKHZhciBzID0gMDsgIW4xLnRlc3RuKHMpOyBzKyspIHt9XG4gIHZhciBkID0gbi5zaHJuKHMpO1xuXG4gIHZhciBybjEgPSBuMS50b1JlZChyZWQpO1xuXG4gIGZvciAoOyBrID4gMDsgay0tKSB7XG4gICAgdmFyIGEgPSB0aGlzLl9yYW5kKG4yKTtcblxuICAgIHZhciBnID0gbi5nY2QoYSk7XG4gICAgaWYgKGcuY21wbigxKSAhPT0gMClcbiAgICAgIHJldHVybiBnO1xuXG4gICAgdmFyIHggPSBhLnRvUmVkKHJlZCkucmVkUG93KGQpO1xuICAgIGlmICh4LmNtcChyb25lKSA9PT0gMCB8fCB4LmNtcChybjEpID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHM7IGkrKykge1xuICAgICAgeCA9IHgucmVkU3FyKCk7XG5cbiAgICAgIGlmICh4LmNtcChyb25lKSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHguZnJvbVJlZCgpLnN1Ym4oMSkuZ2NkKG4pO1xuICAgICAgaWYgKHguY21wKHJuMSkgPT09IDApXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpID09PSBzKSB7XG4gICAgICB4ID0geC5yZWRTcXIoKTtcbiAgICAgIHJldHVybiB4LmZyb21SZWQoKS5zdWJuKDEpLmdjZChuKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21pbGxlci1yYWJpbi9saWIvbXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IGV4cG9ydHM7XG5cbmZ1bmN0aW9uIHRvQXJyYXkobXNnLCBlbmMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSlcbiAgICByZXR1cm4gbXNnLnNsaWNlKCk7XG4gIGlmICghbXNnKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHJlcyA9IFtdO1xuICBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCAnJyk7XG4gICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgbXNnID0gJzAnICsgbXNnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuICAgICAgcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldICsgbXNnW2kgKyAxXSwgMTYpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoaSA9IGMgPj4gODtcbiAgICAgIHZhciBsbyA9IGMgJiAweGZmO1xuICAgICAgaWYgKGhpKVxuICAgICAgICByZXMucHVzaChoaSwgbG8pO1xuICAgICAgZWxzZVxuICAgICAgICByZXMucHVzaChsbyk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0FycmF5ID0gdG9BcnJheTtcblxuZnVuY3Rpb24gemVybzIod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbnV0aWxzLnplcm8yID0gemVybzI7XG5cbmZ1bmN0aW9uIHRvSGV4KG1zZykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvSGV4ID0gdG9IZXg7XG5cbnV0aWxzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShhcnIsIGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdG9IZXgoYXJyKTtcbiAgZWxzZVxuICAgIHJldHVybiBhcnI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHMvbGliL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNyZWF0ZUhtYWMgPSByZXF1aXJlKCdjcmVhdGUtaG1hYycpXG52YXIgY2hlY2tQYXJhbWV0ZXJzID0gcmVxdWlyZSgnLi9wcmVjb25kaXRpb24nKVxuXG5leHBvcnRzLnBia2RmMiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGlnZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBkaWdlc3RcbiAgICBkaWdlc3QgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGNoZWNrUGFyYW1ldGVycyhpdGVyYXRpb25zLCBrZXlsZW4pXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignTm8gY2FsbGJhY2sgcHJvdmlkZWQgdG8gcGJrZGYyJylcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhudWxsLCBleHBvcnRzLnBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KSlcbiAgfSlcbn1cblxudmFyIGRlZmF1bHRFbmNvZGluZ1xuaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICBkZWZhdWx0RW5jb2RpbmcgPSAndXRmLTgnXG59IGVsc2Uge1xuICB2YXIgcFZlcnNpb25NYWpvciA9IHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbi5zcGxpdCgnLicpWzBdLnNsaWNlKDEpLCAxMClcblxuICBkZWZhdWx0RW5jb2RpbmcgPSBwVmVyc2lvbk1ham9yID49IDYgPyAndXRmLTgnIDogJ2JpbmFyeSdcbn1cblxuZXhwb3J0cy5wYmtkZjJTeW5jID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZCwgZGVmYXVsdEVuY29kaW5nKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzYWx0KSkgc2FsdCA9IG5ldyBCdWZmZXIoc2FsdCwgZGVmYXVsdEVuY29kaW5nKVxuXG4gIGNoZWNrUGFyYW1ldGVycyhpdGVyYXRpb25zLCBrZXlsZW4pXG5cbiAgZGlnZXN0ID0gZGlnZXN0IHx8ICdzaGExJ1xuXG4gIHZhciBoTGVuXG4gIHZhciBsID0gMVxuICB2YXIgREsgPSBuZXcgQnVmZmVyKGtleWxlbilcbiAgdmFyIGJsb2NrMSA9IG5ldyBCdWZmZXIoc2FsdC5sZW5ndGggKyA0KVxuICBzYWx0LmNvcHkoYmxvY2sxLCAwLCAwLCBzYWx0Lmxlbmd0aClcblxuICB2YXIgclxuICB2YXIgVFxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IGw7IGkrKykge1xuICAgIGJsb2NrMS53cml0ZVVJbnQzMkJFKGksIHNhbHQubGVuZ3RoKVxuICAgIHZhciBVID0gY3JlYXRlSG1hYyhkaWdlc3QsIHBhc3N3b3JkKS51cGRhdGUoYmxvY2sxKS5kaWdlc3QoKVxuXG4gICAgaWYgKCFoTGVuKSB7XG4gICAgICBoTGVuID0gVS5sZW5ndGhcbiAgICAgIFQgPSBuZXcgQnVmZmVyKGhMZW4pXG4gICAgICBsID0gTWF0aC5jZWlsKGtleWxlbiAvIGhMZW4pXG4gICAgICByID0ga2V5bGVuIC0gKGwgLSAxKSAqIGhMZW5cbiAgICB9XG5cbiAgICBVLmNvcHkoVCwgMCwgMCwgaExlbilcblxuICAgIGZvciAodmFyIGogPSAxOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG4gICAgICBVID0gY3JlYXRlSG1hYyhkaWdlc3QsIHBhc3N3b3JkKS51cGRhdGUoVSkuZGlnZXN0KClcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaExlbjsgaysrKSBUW2tdIF49IFVba11cbiAgICB9XG5cbiAgICB2YXIgZGVzdFBvcyA9IChpIC0gMSkgKiBoTGVuXG4gICAgdmFyIGxlbiA9IChpID09PSBsID8gciA6IGhMZW4pXG4gICAgVC5jb3B5KERLLCBkZXN0UG9zLCAwLCBsZW4pXG4gIH1cblxuICByZXR1cm4gREtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYmtkZjIvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlZWQsIGxlbikge1xuICB2YXIgdCA9IG5ldyBCdWZmZXIoJycpO1xuICB2YXIgIGkgPSAwLCBjO1xuICB3aGlsZSAodC5sZW5ndGggPCBsZW4pIHtcbiAgICBjID0gaTJvcHMoaSsrKTtcbiAgICB0ID0gQnVmZmVyLmNvbmNhdChbdCwgY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShzZWVkKS51cGRhdGUoYykuZGlnZXN0KCldKTtcbiAgfVxuICByZXR1cm4gdC5zbGljZSgwLCBsZW4pO1xufTtcblxuZnVuY3Rpb24gaTJvcHMoYykge1xuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcig0KTtcbiAgb3V0LndyaXRlVUludDMyQkUoYywwKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHVibGljLWVuY3J5cHQvbWdmLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbmZ1bmN0aW9uIHdpdGhQdWJsaWMocGFkZGVkTXNnLCBrZXkpIHtcbiAgcmV0dXJuIG5ldyBCdWZmZXIocGFkZGVkTXNnXG4gICAgLnRvUmVkKGJuLm1vbnQoa2V5Lm1vZHVsdXMpKVxuICAgIC5yZWRQb3cobmV3IGJuKGtleS5wdWJsaWNFeHBvbmVudCkpXG4gICAgLmZyb21SZWQoKVxuICAgIC50b0FycmF5KCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpdGhQdWJsaWM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3B1YmxpYy1lbmNyeXB0L3dpdGhQdWJsaWMuanNcbi8vIG1vZHVsZSBpZCA9IDExMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhvcihhLCBiKSB7XG4gIHZhciBsZW4gPSBhLmxlbmd0aDtcbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIGFbaV0gXj0gYltpXTtcbiAgfVxuICByZXR1cm4gYVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHVibGljLWVuY3J5cHQveG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG4gIH0gY2F0Y2ggKF8pIHt9IGZpbmFsbHkge1xuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gIH1cbn0pKCk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAgIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAgIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBidWZmZXJTaGltLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBfZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIF9lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNraXBBZGQ7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgc2tpcEFkZCA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIGNodW5rLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhZGRUb0Zyb250KSBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIERvbid0IGFkZCB0byB0aGUgYnVmZmVyIGlmIHdlJ3ZlIGRlY29kZWQgdG8gYW4gZW1wdHkgc3RyaW5nIGNodW5rIGFuZFxuICAgICAgLy8gd2UncmUgbm90IGluIG9iamVjdCBtb2RlXG4gICAgICBpZiAoIXNraXBBZGQpIHtcbiAgICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHByb2Nlc3NOZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uIChldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gYnVmZmVyU2hpbS5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIEsgPSBbXG4gIDB4NDI4QTJGOTgsIDB4NzEzNzQ0OTEsIDB4QjVDMEZCQ0YsIDB4RTlCNURCQTUsXG4gIDB4Mzk1NkMyNUIsIDB4NTlGMTExRjEsIDB4OTIzRjgyQTQsIDB4QUIxQzVFRDUsXG4gIDB4RDgwN0FBOTgsIDB4MTI4MzVCMDEsIDB4MjQzMTg1QkUsIDB4NTUwQzdEQzMsXG4gIDB4NzJCRTVENzQsIDB4ODBERUIxRkUsIDB4OUJEQzA2QTcsIDB4QzE5QkYxNzQsXG4gIDB4RTQ5QjY5QzEsIDB4RUZCRTQ3ODYsIDB4MEZDMTlEQzYsIDB4MjQwQ0ExQ0MsXG4gIDB4MkRFOTJDNkYsIDB4NEE3NDg0QUEsIDB4NUNCMEE5REMsIDB4NzZGOTg4REEsXG4gIDB4OTgzRTUxNTIsIDB4QTgzMUM2NkQsIDB4QjAwMzI3QzgsIDB4QkY1OTdGQzcsXG4gIDB4QzZFMDBCRjMsIDB4RDVBNzkxNDcsIDB4MDZDQTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdCNzBBODUsIDB4MkUxQjIxMzgsIDB4NEQyQzZERkMsIDB4NTMzODBEMTMsXG4gIDB4NjUwQTczNTQsIDB4NzY2QTBBQkIsIDB4ODFDMkM5MkUsIDB4OTI3MjJDODUsXG4gIDB4QTJCRkU4QTEsIDB4QTgxQTY2NEIsIDB4QzI0QjhCNzAsIDB4Qzc2QzUxQTMsXG4gIDB4RDE5MkU4MTksIDB4RDY5OTA2MjQsIDB4RjQwRTM1ODUsIDB4MTA2QUEwNzAsXG4gIDB4MTlBNEMxMTYsIDB4MUUzNzZDMDgsIDB4Mjc0ODc3NEMsIDB4MzRCMEJDQjUsXG4gIDB4MzkxQzBDQjMsIDB4NEVEOEFBNEEsIDB4NUI5Q0NBNEYsIDB4NjgyRTZGRjMsXG4gIDB4NzQ4RjgyRUUsIDB4NzhBNTYzNkYsIDB4ODRDODc4MTQsIDB4OENDNzAyMDgsXG4gIDB4OTBCRUZGRkEsIDB4QTQ1MDZDRUIsIDB4QkVGOUEzRjcsIDB4QzY3MTc4RjJcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTI1NiAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTI1NiwgSGFzaClcblxuU2hhMjU2LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2YTA5ZTY2N1xuICB0aGlzLl9iID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jID0gMHgzYzZlZjM3MlxuICB0aGlzLl9kID0gMHhhNTRmZjUzYVxuICB0aGlzLl9lID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9mID0gMHg5YjA1Njg4Y1xuICB0aGlzLl9nID0gMHgxZjgzZDlhYlxuICB0aGlzLl9oID0gMHg1YmUwY2QxOVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIGNoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDIgfCB4IDw8IDMwKSBeICh4ID4+PiAxMyB8IHggPDwgMTkpIF4gKHggPj4+IDIyIHwgeCA8PCAxMClcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNiB8IHggPDwgMjYpIF4gKHggPj4+IDExIHwgeCA8PCAyMSkgXiAoeCA+Pj4gMjUgfCB4IDw8IDcpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDcgfCB4IDw8IDI1KSBeICh4ID4+PiAxOCB8IHggPDwgMTQpIF4gKHggPj4+IDMpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDE3IHwgeCA8PCAxNSkgXiAoeCA+Pj4gMTkgfCB4IDw8IDEzKSBeICh4ID4+PiAxMClcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG4gIHZhciBmID0gdGhpcy5fZiB8IDBcbiAgdmFyIGcgPSB0aGlzLl9nIHwgMFxuICB2YXIgaCA9IHRoaXMuX2ggfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA2NDsgKytpKSBXW2ldID0gKGdhbW1hMShXW2kgLSAyXSkgKyBXW2kgLSA3XSArIGdhbW1hMChXW2kgLSAxNV0pICsgV1tpIC0gMTZdKSB8IDBcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDY0OyArK2opIHtcbiAgICB2YXIgVDEgPSAoaCArIHNpZ21hMShlKSArIGNoKGUsIGYsIGcpICsgS1tqXSArIFdbal0pIHwgMFxuICAgIHZhciBUMiA9IChzaWdtYTAoYSkgKyBtYWooYSwgYiwgYykpIHwgMFxuXG4gICAgaCA9IGdcbiAgICBnID0gZlxuICAgIGYgPSBlXG4gICAgZSA9IChkICsgVDEpIHwgMFxuICAgIGQgPSBjXG4gICAgYyA9IGJcbiAgICBiID0gYVxuICAgIGEgPSAoVDEgKyBUMikgfCAwXG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG4gIHRoaXMuX2YgPSAoZiArIHRoaXMuX2YpIHwgMFxuICB0aGlzLl9nID0gKGcgKyB0aGlzLl9nKSB8IDBcbiAgdGhpcy5faCA9IChoICsgdGhpcy5faCkgfCAwXG59XG5cblNoYTI1Ni5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigzMilcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9nLCAyNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5faCwgMjgpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyNTZcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zaGEuanMvc2hhMjU2LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXVxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTUxMiAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGE1MTIsIEhhc2gpXG5cblNoYTUxMi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweDZhMDllNjY3XG4gIHRoaXMuX2JoID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jaCA9IDB4M2M2ZWYzNzJcbiAgdGhpcy5fZGggPSAweGE1NGZmNTNhXG4gIHRoaXMuX2VoID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9maCA9IDB4OWIwNTY4OGNcbiAgdGhpcy5fZ2ggPSAweDFmODNkOWFiXG4gIHRoaXMuX2hoID0gMHg1YmUwY2QxOVxuXG4gIHRoaXMuX2FsID0gMHhmM2JjYzkwOFxuICB0aGlzLl9ibCA9IDB4ODRjYWE3M2JcbiAgdGhpcy5fY2wgPSAweGZlOTRmODJiXG4gIHRoaXMuX2RsID0gMHg1ZjFkMzZmMVxuICB0aGlzLl9lbCA9IDB4YWRlNjgyZDFcbiAgdGhpcy5fZmwgPSAweDJiM2U2YzFmXG4gIHRoaXMuX2dsID0gMHhmYjQxYmQ2YlxuICB0aGlzLl9obCA9IDB4MTM3ZTIxNzlcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBzaWdtYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMjggfCB4bCA8PCA0KSBeICh4bCA+Pj4gMiB8IHggPDwgMzApIF4gKHhsID4+PiA3IHwgeCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE0IHwgeGwgPDwgMTgpIF4gKHggPj4+IDE4IHwgeGwgPDwgMTQpIF4gKHhsID4+PiA5IHwgeCA8PCAyMylcbn1cblxuZnVuY3Rpb24gR2FtbWEwICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3KVxufVxuXG5mdW5jdGlvbiBHYW1tYTBsICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3IHwgeGwgPDwgMjUpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMSAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMWwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTkgfCB4bCA8PCAxMykgXiAoeGwgPj4+IDI5IHwgeCA8PCAzKSBeICh4ID4+PiA2IHwgeGwgPDwgMjYpXG59XG5cbmZ1bmN0aW9uIGdldENhcnJ5IChhLCBiKSB7XG4gIHJldHVybiAoYSA+Pj4gMCkgPCAoYiA+Pj4gMCkgPyAxIDogMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYWggPSB0aGlzLl9haCB8IDBcbiAgdmFyIGJoID0gdGhpcy5fYmggfCAwXG4gIHZhciBjaCA9IHRoaXMuX2NoIHwgMFxuICB2YXIgZGggPSB0aGlzLl9kaCB8IDBcbiAgdmFyIGVoID0gdGhpcy5fZWggfCAwXG4gIHZhciBmaCA9IHRoaXMuX2ZoIHwgMFxuICB2YXIgZ2ggPSB0aGlzLl9naCB8IDBcbiAgdmFyIGhoID0gdGhpcy5faGggfCAwXG5cbiAgdmFyIGFsID0gdGhpcy5fYWwgfCAwXG4gIHZhciBibCA9IHRoaXMuX2JsIHwgMFxuICB2YXIgY2wgPSB0aGlzLl9jbCB8IDBcbiAgdmFyIGRsID0gdGhpcy5fZGwgfCAwXG4gIHZhciBlbCA9IHRoaXMuX2VsIHwgMFxuICB2YXIgZmwgPSB0aGlzLl9mbCB8IDBcbiAgdmFyIGdsID0gdGhpcy5fZ2wgfCAwXG4gIHZhciBobCA9IHRoaXMuX2hsIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkgKz0gMikge1xuICAgIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICAgIFdbaSArIDFdID0gTS5yZWFkSW50MzJCRShpICogNCArIDQpXG4gIH1cbiAgZm9yICg7IGkgPCAxNjA7IGkgKz0gMikge1xuICAgIHZhciB4aCA9IFdbaSAtIDE1ICogMl1cbiAgICB2YXIgeGwgPSBXW2kgLSAxNSAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTAgPSBHYW1tYTAoeGgsIHhsKVxuICAgIHZhciBnYW1tYTBsID0gR2FtbWEwbCh4bCwgeGgpXG5cbiAgICB4aCA9IFdbaSAtIDIgKiAyXVxuICAgIHhsID0gV1tpIC0gMiAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTEgPSBHYW1tYTEoeGgsIHhsKVxuICAgIHZhciBnYW1tYTFsID0gR2FtbWExbCh4bCwgeGgpXG5cbiAgICAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cbiAgICB2YXIgV2k3aCA9IFdbaSAtIDcgKiAyXVxuICAgIHZhciBXaTdsID0gV1tpIC0gNyAqIDIgKyAxXVxuXG4gICAgdmFyIFdpMTZoID0gV1tpIC0gMTYgKiAyXVxuICAgIHZhciBXaTE2bCA9IFdbaSAtIDE2ICogMiArIDFdXG5cbiAgICB2YXIgV2lsID0gKGdhbW1hMGwgKyBXaTdsKSB8IDBcbiAgICB2YXIgV2loID0gKGdhbW1hMCArIFdpN2ggKyBnZXRDYXJyeShXaWwsIGdhbW1hMGwpKSB8IDBcbiAgICBXaWwgPSAoV2lsICsgZ2FtbWExbCkgfCAwXG4gICAgV2loID0gKFdpaCArIGdhbW1hMSArIGdldENhcnJ5KFdpbCwgZ2FtbWExbCkpIHwgMFxuICAgIFdpbCA9IChXaWwgKyBXaTE2bCkgfCAwXG4gICAgV2loID0gKFdpaCArIFdpMTZoICsgZ2V0Q2FycnkoV2lsLCBXaTE2bCkpIHwgMFxuXG4gICAgV1tpXSA9IFdpaFxuICAgIFdbaSArIDFdID0gV2lsXG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDE2MDsgaiArPSAyKSB7XG4gICAgV2loID0gV1tqXVxuICAgIFdpbCA9IFdbaiArIDFdXG5cbiAgICB2YXIgbWFqaCA9IG1haihhaCwgYmgsIGNoKVxuICAgIHZhciBtYWpsID0gbWFqKGFsLCBibCwgY2wpXG5cbiAgICB2YXIgc2lnbWEwaCA9IHNpZ21hMChhaCwgYWwpXG4gICAgdmFyIHNpZ21hMGwgPSBzaWdtYTAoYWwsIGFoKVxuICAgIHZhciBzaWdtYTFoID0gc2lnbWExKGVoLCBlbClcbiAgICB2YXIgc2lnbWExbCA9IHNpZ21hMShlbCwgZWgpXG5cbiAgICAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbal0gKyBXW2pdXG4gICAgdmFyIEtpaCA9IEtbal1cbiAgICB2YXIgS2lsID0gS1tqICsgMV1cblxuICAgIHZhciBjaGggPSBDaChlaCwgZmgsIGdoKVxuICAgIHZhciBjaGwgPSBDaChlbCwgZmwsIGdsKVxuXG4gICAgdmFyIHQxbCA9IChobCArIHNpZ21hMWwpIHwgMFxuICAgIHZhciB0MWggPSAoaGggKyBzaWdtYTFoICsgZ2V0Q2FycnkodDFsLCBobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBjaGwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBjaGggKyBnZXRDYXJyeSh0MWwsIGNobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBLaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBLaWggKyBnZXRDYXJyeSh0MWwsIEtpbCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBXaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBXaWggKyBnZXRDYXJyeSh0MWwsIFdpbCkpIHwgMFxuXG4gICAgLy8gdDIgPSBzaWdtYTAgKyBtYWpcbiAgICB2YXIgdDJsID0gKHNpZ21hMGwgKyBtYWpsKSB8IDBcbiAgICB2YXIgdDJoID0gKHNpZ21hMGggKyBtYWpoICsgZ2V0Q2FycnkodDJsLCBzaWdtYTBsKSkgfCAwXG5cbiAgICBoaCA9IGdoXG4gICAgaGwgPSBnbFxuICAgIGdoID0gZmhcbiAgICBnbCA9IGZsXG4gICAgZmggPSBlaFxuICAgIGZsID0gZWxcbiAgICBlbCA9IChkbCArIHQxbCkgfCAwXG4gICAgZWggPSAoZGggKyB0MWggKyBnZXRDYXJyeShlbCwgZGwpKSB8IDBcbiAgICBkaCA9IGNoXG4gICAgZGwgPSBjbFxuICAgIGNoID0gYmhcbiAgICBjbCA9IGJsXG4gICAgYmggPSBhaFxuICAgIGJsID0gYWxcbiAgICBhbCA9ICh0MWwgKyB0MmwpIHwgMFxuICAgIGFoID0gKHQxaCArIHQyaCArIGdldENhcnJ5KGFsLCB0MWwpKSB8IDBcbiAgfVxuXG4gIHRoaXMuX2FsID0gKHRoaXMuX2FsICsgYWwpIHwgMFxuICB0aGlzLl9ibCA9ICh0aGlzLl9ibCArIGJsKSB8IDBcbiAgdGhpcy5fY2wgPSAodGhpcy5fY2wgKyBjbCkgfCAwXG4gIHRoaXMuX2RsID0gKHRoaXMuX2RsICsgZGwpIHwgMFxuICB0aGlzLl9lbCA9ICh0aGlzLl9lbCArIGVsKSB8IDBcbiAgdGhpcy5fZmwgPSAodGhpcy5fZmwgKyBmbCkgfCAwXG4gIHRoaXMuX2dsID0gKHRoaXMuX2dsICsgZ2wpIHwgMFxuICB0aGlzLl9obCA9ICh0aGlzLl9obCArIGhsKSB8IDBcblxuICB0aGlzLl9haCA9ICh0aGlzLl9haCArIGFoICsgZ2V0Q2FycnkodGhpcy5fYWwsIGFsKSkgfCAwXG4gIHRoaXMuX2JoID0gKHRoaXMuX2JoICsgYmggKyBnZXRDYXJyeSh0aGlzLl9ibCwgYmwpKSB8IDBcbiAgdGhpcy5fY2ggPSAodGhpcy5fY2ggKyBjaCArIGdldENhcnJ5KHRoaXMuX2NsLCBjbCkpIHwgMFxuICB0aGlzLl9kaCA9ICh0aGlzLl9kaCArIGRoICsgZ2V0Q2FycnkodGhpcy5fZGwsIGRsKSkgfCAwXG4gIHRoaXMuX2VoID0gKHRoaXMuX2VoICsgZWggKyBnZXRDYXJyeSh0aGlzLl9lbCwgZWwpKSB8IDBcbiAgdGhpcy5fZmggPSAodGhpcy5fZmggKyBmaCArIGdldENhcnJ5KHRoaXMuX2ZsLCBmbCkpIHwgMFxuICB0aGlzLl9naCA9ICh0aGlzLl9naCArIGdoICsgZ2V0Q2FycnkodGhpcy5fZ2wsIGdsKSkgfCAwXG4gIHRoaXMuX2hoID0gKHRoaXMuX2hoICsgaGggKyBnZXRDYXJyeSh0aGlzLl9obCwgaGwpKSB8IDBcbn1cblxuU2hhNTEyLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDY0KVxuXG4gIGZ1bmN0aW9uIHdyaXRlSW50NjRCRSAoaCwgbCwgb2Zmc2V0KSB7XG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gIH1cblxuICB3cml0ZUludDY0QkUodGhpcy5fYWgsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYmgsIHRoaXMuX2JsLCA4KVxuICB3cml0ZUludDY0QkUodGhpcy5fY2gsIHRoaXMuX2NsLCAxNilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2RoLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9laCwgdGhpcy5fZWwsIDMyKVxuICB3cml0ZUludDY0QkUodGhpcy5fZmgsIHRoaXMuX2ZsLCA0MClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2doLCB0aGlzLl9nbCwgNDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9oaCwgdGhpcy5faGwsIDU2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhNTEyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2hhLmpzL3NoYTUxMi5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICog5LqM5Y+J5qCR55qE6aG65bqP5a2Y5YKo57uT5p6EXG4gKi9cblxuLy8g6aG65bqP5a2Y5YKo57uT5p6E55qE6YGN5Y6GXG5leHBvcnQgZnVuY3Rpb24gcHJlT3JkZXJSZWN1cnNpdmUodHJlZSwgeCwgdmlzaXQpIHtcbiAgICB2aXNpdCh0cmVlW3hdKTtcbiAgICBpZiAodHJlZVsyICogeCArIDFdKSBwcmVPcmRlclJlY3Vyc2l2ZSh0cmVlLCAyICogeCArIDEsIHZpc2l0KTtcbiAgICBpZiAodHJlZVsyICogeCArIDJdKSBwcmVPcmRlclJlY3Vyc2l2ZSh0cmVlLCAyICogeCArIDIsIHZpc2l0KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpbk9yZGVyUmVjdXJzaXZlKHRyZWUsIHgsIHZpc2l0KSB7XG4gICAgaWYgKHRyZWVbMiAqIHggKyAxXSkgaW5PcmRlclJlY3Vyc2l2ZSh0cmVlLCAyICogeCArIDEsIHZpc2l0KTtcbiAgICB2aXNpdCh0cmVlW3hdKTtcbiAgICBpZiAodHJlZVsyICogeCArIDJdKSBpbk9yZGVyUmVjdXJzaXZlKHRyZWUsIDIgKiB4ICsgMiwgdmlzaXQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zdE9yZGVyUmVjdXJzaXZlKHRyZWUsIHgsIHZpc2l0KSB7XG4gICAgaWYgKHRyZWVbMiAqIHggKyAxXSkgcG9zdE9yZGVyUmVjdXJzaXZlKHRyZWUsIDIgKiB4ICsgMSwgdmlzaXQpO1xuICAgIGlmICh0cmVlWzIgKiB4ICsgMl0pIHBvc3RPcmRlclJlY3Vyc2l2ZSh0cmVlLCAyICogeCArIDIsIHZpc2l0KTtcbiAgICB2aXNpdCh0cmVlW3hdKTtcbn1cblxubGV0IHRyZWUgPSBbMSwgMiwgMywgNCwgNSwgLCA2LCAsICwgN107XG5cbmNvbnNvbGUubG9nKCdwcmVPcmRlcjonKTtcbnByZU9yZGVyUmVjdXJzaXZlKHRyZWUsIDAsICh2YWx1ZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbn0pO1xuXG5jb25zb2xlLmxvZygnaW5PcmRlcjonKTtcbmluT3JkZXJSZWN1cnNpdmUodHJlZSwgMCwgKHZhbHVlKSA9PiB7XG4gICAgY29uc29sZS5sb2codmFsdWUpO1xufSk7XG5cbmNvbnNvbGUubG9nKCdwb3N0T3JkZXI6Jyk7XG5wb3N0T3JkZXJSZWN1cnNpdmUodHJlZSwgMCwgKHZhbHVlKSA9PiB7XG4gICAgY29uc29sZS5sb2codmFsdWUpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQmluYXJ5VHJlZS9CaW5hcnlUcmVlQXJyYXkuanMiLCIvKipcbiAqIOi1q+Wkq+abvO+8iEh1ZmZtYW7vvInmoJHvvIzlj4jnp7DmnIDkvJjmoJHvvIzmmK/kuIDnsbvluKbmnYPot6/lvoTplb/luqbmnIDnn63nmoTmoJHvvIzmnInnnYDlub/ms5vlupTnlKjjgIJcbiAqXG4gKiDku47moJHkuK3kuIDkuKrnu5PngrnliLDlj6bkuIDkuKrnu5PngrnkuYvpl7TnmoTliIbmlK/mnoTmiJDov5nkuKTkuKrnu5PngrnkuYvpl7TnmoTot6/lvoTvvIzot6/lvoTkuIrnmoTliIbmlK/mlbDnm67np7DkvZzot6/lvoTplb/luqbjgIJcbiAqIOagkeeahOi3r+W+hOmVv+W6puaYr+S7juagkeagueWIsOavj+S4gOS4que7k+eCueeahOi3r+W+hOS5i+WSjOOAglxuICog57uT54K555qE5bim5p2D6Lev5b6E6ZW/5bqm5Li65LuO6K+l57uT54K55Yiw5qCR5qC55LmL6Ze055qE6Lev5b6E6ZW/5bqm5LiO57uT54K55LiK5p2D55qE5LmY56ev44CC5qCR55qE5bim5p2D6Lev5b6E6ZW/5bqm5Li65qCR5Lit5omA5pyJ5Y+25a2Q57uT54K555qE5bim5p2D6Lev5b6E6ZW/5bqm5LmL5ZKM44CCXG4gKlxuICog5p6E6YCg6LWr5aSr5pu85qCR55qE5q2l6aqk77yaXG4gKiDvvIgx77yJ5qC55o2u57uZ5a6a55qEbuS4quadg+WAvHt3MSx3MiwuLi53bn3mnoTmiJBu5qO15LqM5Y+J5qCR55qE6ZuG5ZCIRiA9IHtUMSxUMiwuLi5Ubn3vvIzlhbbkuK3mr4/mo7Xkuozlj4nmoJFUaeS4reWPquacieS4gOS4quW4puadg+S4undp55qE5qC557uT54K577yM5YW25bem5Y+z5a2Q5qCR5Z2H56m644CCXG4gKiDvvIgy77yJ5ZyoRuS4remAieWPluS4pOajteaguee7k+eCueeahOadg+WAvOacgOWwj+eahOagkeS9nOS4uuW3puWPs+WtkOagkeaehOmAoOS4gOajteaWsOeahOS6jOWPieagke+8jOS4lOe9ruaWsOeahOS6jOWPieagkeeahOaguee7k+eCueeahOadg+WAvOS4uuWFtuW3puWPs+WtkOagkeS4iuaguee7k+eCueeahOadg+WAvOS5i+WSjOOAglxuICog77yIM++8ieWcqEbkuK3liKDpmaTov5nkuKTmo7XmoJHvvIzlkIzml7blsIbmlrDlvpfliLDnmoTkuozlj4nmoJHliqDlhaVG5Lit44CCXG4gKiDvvIg077yJ6YeN5aSN77yIMu+8ieWSjO+8iDPvvInvvIznm7TliLBG5Y+q5ZCr5LiA5qO15qCR5Li65q2i44CC6L+Z5qO15qCR5L6/5piv6LWr5aSr5pu85qCR44CCXG4gKi9cbi8qXG7otavlpKvmm7znvJbnoIFcbmh0dHA6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlDJThEJUU1JUE0JUFCJUU2JTlCJUJDJUU3JUJDJTk2JUU3JUEwJTgxXG5cbuWBh+iuvueUteaKpemcgOS8oOmAgeeahOeUteaWh+S4uuKAnEEgQiBBIEMgQyBEIEHigJ3vvIzlroPlj6rmnIk056eN5a2X56ym5Y+q6ZyA5Lik5Liq5a2X56ym5Liy5L6/5Y+v5YiG6L6o44CC5YGH6K6+QSxCLEMsROeahOe8lueggeWIhuWIq+S4ujAwLDAxLDEw5ZKMMTHvvIzliJnkuIrov7A35Liq5a2X56ym55qE55S15paH5L6/5Li64oCcMDAwMTAwMTAxMDExMDDigJ3vvIzlr7nmlrnmjqXmlLbml7bvvIzlj6/mjInkuozkvY3kuIDliIbov5vooYzor5HnoIHjgIJcbuWcqOS8oOmAgeeUteaWh+aXtu+8jOW4jOacm+aAu+mVv+WwveWPr+iDveWcsOefreOAguWmguaenOWvueavj+S4quWtl+espuiuvuiuoemVv+W6puS4jeetieeahOe8luegge+8jOS4lOiuqeeUteaWh+S4reWHuueOsOasoeaVsOi+g+WkmueahOWtl+espumHh+eUqOWwveWPr+iDveefreeahOe8luegge+8jOWImeS8oOmAgeeUteaWh+eahOaAu+mVv+S+v+WPr+WHj+WwkeOAglxu5aaC5p6c5raJ5Y+KQSxCLEMsROeahOe8lueggeWIhuWIq+S4ujAsMDAsMeWSjDAx77yM5YiZ5LiK6L+wN+S4quWtl+espueahOeUteaWh+WPr+i9rOaNouaIkOaAu+mVv+S4ujnnmoTlrZfnrKbkuLLigJwwMDAwMTEwMTDigJ3jgILkvYbmmK/vvIzov5nmoLfnmoTnlLXmlofml6Dms5Xnv7vor5HvvIzlm6DkuLrlj6/mnInlpJrnp43or5Hms5XjgIJcbuWboOatpO+8jOiLpeimgeiuvuiuoemVv+efreS4jeetieeahOe8luegge+8jOWImeW/hemhu+aYr+S7u+aEj+S4quWtl+espueahOe8lueggemDveS4jeaYr+WPpuS4gOS4quWtl+espue8lueggeeahOWJjee8gO+8jOi/meenjee8lueggeensOS9nOWJjee8gOe8lueggeOAglxu5Y+v5Yip55So5LqM5Y+J5qCR5p2l6K6+6K6h5LqM6L+b5Yi255qE5YmN57yA57yW56CB44CC5YGH6K6+5pyJ5LiA5qO15LqM5Y+J5qCR77yM5YW2NOS4quWPtuWtkOe7k+eCueWIhuWIq+ihqOekukEsQixDLETov5k05Liq5a2X56ym77yM5LiU57qm5a6a5bem5YiG5pSv6KGo56S65a2X56ym4oCcMOKAne+8jOWPs+WIhuaUr+ihqOekuuWtl+espuKAnDHigJ3vvIzliJnlj6/ku6Xku47moLnnu5PngrnliLDlj7blrZDnu5PngrnnmoTot6/lvoTkuIrliIbmlK/lrZfnrKbnu4TmiJDnmoTlrZfnrKbkuLLkvZzkuLror6Xlj7blrZDnu5PngrnlrZfnrKbnmoTnvJbnoIHjgILmiYDlvpfkuozov5vliLbliY3nvIDnvJbnoIHliIbliKvkuLowLDEwLDExMCwxMTEuXG7orr7orqHnlLXmlofmgLvplb/mnIDnn63nmoTkuozov5vliLbliY3nvIDnvJbnoIHljbPku6Vu56eN5a2X56ym5Ye6546w55qE6aKR546H5L2c5p2D44CCXG4gKi9cblxuLy8g6LWr5aSr5pu85qCR5ZKM6LWr5aSr5pu857yW56CB55qE5a2Y5YKo57uT5p6EXG5mdW5jdGlvbiBIdWZmbWFuTm9kZSh3ZWlnaHQsIHBhcmVudCwgbGVmdENoaWxkLCByaWdodENoaWxkKSB7XG4gICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQgfHwgMDtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCAwO1xuICAgIHRoaXMubGVmdENoaWxkID0gbGVmdENoaWxkIHx8IDA7XG4gICAgdGhpcy5yaWdodENoaWxkID0gcmlnaHRDaGlsZCB8fCAwO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaHVmZk1hbkNvZGluZyh3ZWlnaHRzKSB7XG4gICAgbGV0IG4gPSB3ZWlnaHRzLmxlbmd0aDtcbiAgICBpZiAobiA8IDEpIHJldHVybjtcblxuICAgIGxldCBodWZmbWFuVHJlZSA9IGJ1aWxkSHVmZm1hblRyZWUod2VpZ2h0cywgbik7XG5cbiAgICAvLyDku47lj7blrZDliLDmoLnpgIblkJHmsYLmr4/kuKrlrZfnrKbnmoTotavlpKvmm7znvJbnoIFcbiAgICBsZXQgaGMgPSBjYWxjSHVmZm1hbkNvZGUoaHVmZm1hblRyZWUsIG4pO1xuXG4gICAgcmV0dXJuIFtodWZmbWFuVHJlZSwgaGNdO1xufVxuXG5cbmZ1bmN0aW9uIGNhbGNIdWZmbWFuQ29kZShodWZmbWFuVHJlZSwgbikge1xuICAgIC8vIOS7juWPtuWtkOWIsOaguemAhuWQkeaxguavj+S4quWtl+espueahOi1q+Wkq+abvOe8lueggVxuICAgIGxldCBoYyA9IFtdO1xuICAgIGxldCBjZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGxldCBzdGFydCA9IG4gLSAxO1xuICAgICAgICBmb3IgKGxldCBjID0gaSwgZiA9IGh1ZmZtYW5UcmVlW2ldLnBhcmVudDsgZiAhPSAwOyBjID0gZiwgZiA9IGh1ZmZtYW5UcmVlW2ZdLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGh1ZmZtYW5UcmVlW2ZdLmxlZnRDaGlsZCA9PSBjKSBjZFstLXN0YXJ0XSA9ICcwJztcbiAgICAgICAgICAgIGVsc2UgY2RbLS1zdGFydF0gPSAnMSc7XG4gICAgICAgIH1cblxuICAgICAgICBoY1tpXSA9IHN0ckNvcHkoY2QsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGM7XG59XG5cbi8vIOWIm+W7uuS4gOajteWPtuWtkOe7k+eCueaVsOS4um7nmoRIdWZmbWFu5qCRXG5mdW5jdGlvbiBidWlsZEh1ZmZtYW5UcmVlKHdlaWdodHMsIG4pIHtcbiAgICBuID0gbiB8fCB3ZWlnaHRzLmxlbmd0aDtcbiAgICBsZXQgbSA9IDIgKiBuIC0gMTtcbiAgICBsZXQgaHVmZm1hblRyZWUgPSBbXTtcblxuICAgIC8vIOWIneWni+WMllxuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICAgIGh1ZmZtYW5UcmVlW2ldID0gbmV3IEh1ZmZtYW5Ob2RlKHdlaWdodHNbaV0sIDAsIDAsIDApO1xuICAgIGZvciAoOyBpIDwgbTsgaSsrKVxuICAgICAgICBodWZmbWFuVHJlZVtpXSA9IG5ldyBIdWZmbWFuTm9kZSgwLCAwLCAwLCAwKTtcblxuICAgIGZvciAobGV0IGkgPSBuOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgIC8vIOWcqEhUWzEuLmktMV3pgInmi6lwYXJlbnTkuLow5LiUd2VpZ2h05pyA5bCP55qE5Lik5Liq57uT54K577yM6L+U5Zue5YW25bqP5Y+35Li6W3MxLCBzMl1cbiAgICAgICAgbGV0IHJldCA9IHNlbGVjdChodWZmbWFuVHJlZSwgaSk7XG4gICAgICAgIGxldCBzMSA9IHJldFswXTtcbiAgICAgICAgbGV0IHMyID0gcmV0WzFdO1xuICAgICAgICBodWZmbWFuVHJlZVtzMV0ucGFyZW50ID0gaTtcbiAgICAgICAgaHVmZm1hblRyZWVbczJdLnBhcmVudCA9IGk7XG4gICAgICAgIGh1ZmZtYW5UcmVlW2ldLmxlZnRDaGlsZCA9IHMxO1xuICAgICAgICBodWZmbWFuVHJlZVtpXS5yaWdodENoaWxkID0gczI7XG4gICAgICAgIGh1ZmZtYW5UcmVlW2ldLndlaWdodCA9IGh1ZmZtYW5UcmVlW3MxXS53ZWlnaHQgKyBodWZmbWFuVHJlZVtzMl0ud2VpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiBodWZmbWFuVHJlZTtcbn1cblxuZnVuY3Rpb24gc3RyQ29weShzdHIsIHN0YXJ0KSB7XG4gICAgbGV0IHMgPSAnJztcbiAgICBmb3IgKDsgc3RyW3N0YXJ0XTsgc3RhcnQrKykge1xuICAgICAgICBzICs9IHN0cltzdGFydF07XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3QoaHVmZm1hblRyZWUsIGxlbikge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gaHVmZm1hblRyZWVbaV07XG4gICAgICAgIGlmIChub2RlLnBhcmVudCAhPT0gMCkgY29udGludWU7XG5cbiAgICAgICAgaWYgKHJldC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXQucHVzaChpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGh1ZmZtYW5UcmVlW3JldFswXV0ud2VpZ2h0ID4gaHVmZm1hblRyZWVbcmV0WzFdXS53ZWlnaHRcbiAgICAgICAgICAgICAgICA/IDAgOiAxO1xuXG4gICAgICAgICAgICBpZiAobm9kZS53ZWlnaHQgPCBodWZmbWFuVHJlZVtyZXRbaW5kZXhdXS53ZWlnaHQpXG4gICAgICAgICAgICAgICAgcmV0W2luZGV4XSA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmV0WzBdID4gcmV0WzFdKSB7XG4gICAgICAgIGxldCB0ZW1wID0gcmV0WzBdO1xuICAgICAgICByZXRbMF0gPSByZXRbMV07XG4gICAgICAgIHJldFsxXSA9IHRlbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuY29uc29sZS5sb2coJy0tLS0tLS1odWZmbWFuIGNvZGluZyAxOi0tLS0tLScpO1xuY29uc29sZS5sb2coaHVmZk1hbkNvZGluZyhbNSwgMjksIDcsIDgsIDE0LCAyMywgMywgMTFdKSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0JpbmFyeVRyZWUvaHVmZk1hbkNvZGluZy5qcyIsIi8qKlxuICog5bm/5LmJ6KGoXG4gKlxuICog5bm/5LmJ6KGo5piv57q/5oCn6KGo55qE5o6o5bm/44CC5bm/5rOb55So5LqO5Lq65bel5pm66IO955qE6KGo5aSE55CG6K+t6KiATGlzcO+8jOaKiuW5v+S5ieihqOS9nOS4uuWfuuacrOeahOaVsOaNrue7k+aehOOAglxuICog5bm/5LmJ6KGo5LiA6Iis6K6w5L2c77yaXG4gKiAgICAgIExTID0gKGExLCBhMiwgLi4uLCBhbilcbiAqIExT5piv5bm/5LmJ6KGo55qE5ZCN56ew77yMbuaYr+Wug+eahOmVv+W6pu+8jGFp5Y+v5Lul5piv5Y2V5Liq5YWD57Sg77yM5Lmf5Y+v5Lul5piv5bm/5LmJ6KGo77yM5YiG5Yir56ew5Li65bm/5LmJ6KGoTFPnmoTljp/lrZDlkozlrZDooajjgILkuaDmg6/kuIrvvIznlKjlpKflhpnlrZfmr43ooajnpLrlub/kuYnooajnmoTlkI3np7DvvIzlsI/lhpnlrZfmr43ooajnpLrljp/lrZDjgILlvZPlub/kuYnooahMU+mdnuepuuaXtu+8jOensOesrOS4gOS4quWFg+e0oGEx5Li6TFPnmoTooajlpLTvvIznp7DlhbbkvZnlhYPntKDnu4TmiJDnmoTooagoYTIsIGEzLCAuLi4sIGFuKeaYr0xT55qE6KGo5bC+44CCXG4gKlxuICog5LiL6Z2i5YiX5Li+5LiA5Lqb5bm/5LmJ6KGo55qE5L6L5a2Q77yaXG4gKiAxLkEgPSAoKSAtLS0tIEHmmK/kuIDkuKrnqbrooajvvIzlroPnmoTplb/luqbkuLow44CCXG4gKiAyLkIgPSAoZSkgLS0tLSDliJfooahC5Y+q5pyJ5LiA5Liq5Y6f5a2QZe+8jELnmoTplb/luqbkuLox44CCXG4gKiAzLkMgPSAoYSwgKGIsIGMsIGQpKSAtLS0tIOWIl+ihqEPnmoTplb/luqbkuLoy77yM5Lik5Liq5YWD57Sg5YiG5Yir5Li65Y6f5a2QYeWSjOWtkOihqChiLCBjLCBkKeOAglxuICogNC5EID0gKEEsIEIsIEMpIC0tLS0g5YiX6KGoROeahOmVv+W6puS4ujMsM+S4quWFg+e0oOmDveaYr+WIl+ihqOOAguaYvuekuu+8jOWwhuWtkOihqOeahOWAvOS7o+WFpeWQju+8jOWImeaciUQgPSAoKCksIChlKSwgKGEsIChiLCBjLCBkKSkp44CCXG4gKiA1LkUgPSAoYSwgRSkgLS0tLSDov5nmmK/kuIDkuKrpgJLlvZLnmoTooajvvIzlroPnmoTplb/luqbkuLoyLkXnm7jlvZPkuo7kuIDkuKrml6DpmZDnmoTliJfooahFID0gKGEsIChhLCAoYSwgLi4uKSkp44CCXG4gKlxuICogMe+8ieWIl+ihqOeahOWFg+e0oOWPr+S7peaYr+WtkOihqO+8jOiAjOWtkOihqOeahOWFg+e0oOi/mOWPr+S7peaYr+WtkOihqOOAgueUseatpO+8jOWIl+ihqOaYr+S4gOS4quWkmuWxguasoeeahOe7k+aehO+8jOWPr+S7peeUqOWbvuW9ouixoeWcsOihqOekuuOAglxuICogMinliJfooajlj6/kuLrlhbblroPliJfooajmiYDlhbHkuqvjgILliJfooahB77yMQuWSjEPkuLpE55qE5a2Q6KGo77yM5YiZ5ZyoROS4reWPr+S7peS4jeW/heWIl+WHuuWtkOihqOeahOWAvOOAglxuICogM++8ieWIl+ihqOWPr+S7peaYr+S4gOS4qumAkuW9kueahOihqO+8jOWNs+WIl+ihqOS5n+WPr+S7peaYr+WFtuacrOi6q+eahOS4gOS4quWtkOihqOOAguS+i+WmguWIl+ihqEXjgIJcbiAqXG4gKiDku7vkvZXkuIDkuKrpnZ7nqbrliJfooajlhbbooajlpLTlj6/og73mmK/ljp/lrZDvvIzkuZ/lj6/og73mmK/liJfooajvvIzogIzlhbbooajlsL7lv4XlrprkuLrliJfooajjgIJcbiAqXG4gKi9cblxuLypcbiDlub/kuYnooajnmoTpgJLlvZLnrpfms5VcblxuIOmAkuW9kuWumuS5ieeahOW9kue6s+mhueaPj+i/sOS6huWmguS9leWunueOsOS7juW9k+WJjeeKtuaAgeWIsOe7iOe7k+eKtuaAgeeahOi9rOWMluOAglxuXG4g55Sx5LqO6YCS5b2S5Ye95pWw55qE6K6+6K6h55So55qE5piv5b2S57qz5oCd57u055qE5pa55rOV77yM5YiZ5Zyo6K6+6K6h6YCS5b2S5Ye95pWw5pe277yM5bqU5rOo5oSP77yaXG4g77yIMe+8iemmluWFiOW6lOS5puWGmeWHveaVsOeahOmmlumDqOWSjOinhOagvOivtOaYju+8jOS4peagvOWumuS5ieWHveaVsOeahOWKn+iDveWSjOaOpeWPo++8iOmAkuW9kuiwg+eUqOeahOeVjOmdou+8ie+8jOWvueaxgueyvuWHveaVsOS4reaJgOW+l+eahOWSjOWOn+mXrumimOaAp+i0qOebuOWQjOeahOWtl+mXrumimO+8jOWPquimgeaOpeWPo+S4gOiHtO+8jOS+v+WPr+i/m+ihjOmAkuW9kuiwg+eUqOOAglxuIO+8iDLvvInlr7nlh73mlbDkuK3nmoTmr4/kuIDkuKrpgJLlvZLosIPnlKjpg73nnIvmiJDlj6rmmK/kuIDkuKrnroDljZXnmoTmk43kvZzvvIzlj6ropoHmjqXlj6PkuIDoh7TvvIzlv4Xog73lrp7njrDop4TmoLzor7TmmI7kuK3lrprkuYnnmoTlip/og73vvIzliIflv4zmg7PlvpflpKrmt7HlpKrov5zjgIJcbiAqL1xuXG4vKlxuIOaxguW5v+S5ieihqOeahOa3seW6plxuXG4g5bm/5LmJ6KGo55qE5rex5bqm5a6a5LmJ5Li65bm/5LmJ6KGo5Lit5ous5byn55qE6YeN5pWw77yM5piv5bm/5LmJ6KGo55qE5LiA56eN6YeP5bqm44CCXG4g6K6+6Z2e56m65bm/5LmJ6KGo5Li6OlxuIExTID0gKGExLCBhMiwgLi4uLCBhbilcblxuIOWFtuS4rWFpKGkgPSAxLCAyLCAuLi4sIG4p5oiW5Li65Y6f5a2Q5oiW5Li6TFPnmoTlrZDooajvvIzliJnmsYJMU+eahOa3seW6puWPr+WIhuino+S4um7kuKrlrZDpl67popjvvIzmr4/kuKrlrZDpl67popjkuLrmsYJhaeeahOa3seW6pu+8jOiLpWFp5piv5Y6f5a2Q77yM5YiZ55Sx5a6a5LmJ5YW25rex5bqm5Li66Zu277yM6IulYWnmmK/lub/kuYnooajvvIzliJnpgJLlvZLlpITnkIbvvIzogIxMU+eahOa3seW6puS4uuWQhGFpKGkgPSAxLCAyLCAuLi4sIG4p55qE5rex5bqm5pyA5aSn5YC85YqgMS7nqbrooajkuZ/mmK/lub/kuYnooajvvIzkuJTmt7HluqbkuLoxLlxuXG4g5bm/5LmJ6KGo55qE5rex5bqmREVQVEgoTFMp55qE6YCS5b2S5a6a5LmJ5Li677yaXG4g5Z+65pys6aG577yaICAgIERFUFRIKExTKSA9IDEgICDlvZNMU+S4uuepuuihqOaXtlxuIERFUFRIKExTKSA9IDAgICDlvZNMU+S4uuWOn+WtkOaXtlxuIOW9kue6s+mhue+8miAgICBERVBUSChMUykgPSAxICsgTUFYe0RFUFRIKGFpKX0gIDEgPD0gaSA8PSBuXG4gKi9cblxuY29uc3QgQVRPTSA9IFN5bWJvbCgpO1xuY29uc3QgTElTVCA9IFN5bWJvbCgpO1xuXG5sZXQgZ2xvYmFsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbi8vIOS9v+eUqOmTvumYn+WIl1xuaW1wb3J0IFF1ZXVlIGZyb20gJy4uL1F1ZXVlL1F1ZXVlLmpzJztcblxuLy8g5bm/5LmJ6KGo55qE5aS05bC+6ZO+6KGo5a2Y5YKo6KGo56S6XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHTE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIC8vIOWFrOWFsemDqOWIhu+8jOeUqOS6juWMuuWIhuWOn+WtkOe7k+eCueWSjOihqOe7k+eCuVxuICAgICAgICB0aGlzLnRhZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBhdG9t5piv5Y6f5a2Q57uT54K555qE5YC85Z+fXG4gICAgICAgIHRoaXMuYXRvbSA9IG51bGw7XG4gICAgICAgIC8vIHB0cuaYr+ihqOe7k+eCueeahOaMh+mSiOWfn1xuICAgICAgICB0aGlzLnB0ciA9IHtcbiAgICAgICAgICAgIC8vIHB0ci5ocOWSjHB0ci50cOWIhuWIq+aMh+WQkeihqOWktOWSjOihqOWwvlxuICAgICAgICAgICAgaHA6IG51bGwsXG4gICAgICAgICAgICB0cDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIOmHh+eUqOWktOWwvumTvuihqOWtmOWCqOe7k+aehO+8jOaxguW5v+S5ieihqOeahOa3seW6plxuICAgIGRlcHRoICgpe1xuICAgICAgICByZXR1cm4gZ2V0RGVwdGgodGhpcyk7XG4gICAgfVxuXG4gICAgLy8g5aSN5Yi25bm/5LmJ6KGoXG4gICAgY29weUxpc3QgKGdMaXN0KSB7XG4gICAgICAgIGdMaXN0LnRhZyA9IHRoaXMudGFnO1xuXG4gICAgICAgIGlmICh0aGlzLnRhZyA9PT0gQVRPTSkge1xuICAgICAgICAgICAgZ0xpc3QuYXRvbSA9IHRoaXMuYXRvbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnB0ci5ocCkge1xuICAgICAgICAgICAgICAgIGdMaXN0LnB0ci5ocCA9IG5ldyBHTE5vZGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnB0ci5ocC5jb3B5TGlzdChnTGlzdC5wdHIuaHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucHRyLnRwKSB7XG4gICAgICAgICAgICAgICAgZ0xpc3QucHRyLnRwID0gbmV3IEdMTm9kZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHRyLnRwLmNvcHlMaXN0KGdMaXN0LnB0ci50cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDph4fnlKjlpLTlsL7pk77ooajlrZjlgqjnu5PmnoTvvIznlLHlub/kuYnooajnmoTkuablhpnlvaLlvI/kuLLliJvlu7rlub/kuYnooahcbiAgICBjcmVhdGVHTGlzdCAoc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG5cbiAgICAgICAgLy8g5Yib5bu65Y2V5Y6f5a2Q5bm/5LmJ6KGoXG4gICAgICAgIGxldCBxO1xuICAgICAgICBpZiAoaXNXb3JkKHN0cmluZykpIHtcbiAgICAgICAgICAgIHRoaXMudGFnID0gQVRPTTtcbiAgICAgICAgICAgIHRoaXMuYXRvbSA9IHN0cmluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGFnID0gTElTVDtcbiAgICAgICAgICAgIGxldCBwID0gdGhpcztcblxuICAgICAgICAgICAgLy8g6ISx5aSW5bGC5ous5Y+3XG4gICAgICAgICAgICBsZXQgc3ViID0gc3RyaW5nLnN1YnN0cigxLCBzdHJpbmcubGVuZ3RoIC0gMik7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBsZXQgaHN1YjtcbiAgICAgICAgICAgICAgICBsZXQgbiA9IHN1Yi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgY2g7XG5cbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc3ViW2krK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PSAnKCcpICsraztcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT0gJyknKSAtLWs7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoaSA8IG4gJiYgKGNoICE9ICcsJyB8fCBrICE9IDApKTtcblxuICAgICAgICAgICAgICAgIC8vIGnkuLrnrKzkuIDkuKrpgJflj7fliIbpmpTntKLlvJVcbiAgICAgICAgICAgICAgICBpZiAoaSA8IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgaHN1YiA9IHN1Yi5zdWJzdHIoMCwgaSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBzdWIgPSBzdWIuc3Vic3RyKGksIG4gLSBpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyDmnIDlkI7kuIDnu4RcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoc3ViID0gc3ViO1xuICAgICAgICAgICAgICAgICAgICBzdWIgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihoc3ViID09PSAnKCknKSBwLnB0ci5ocCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8g5Yib5bu66KGo5aS057uT54K5XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAucHRyLmhwID0gbmV3IEdMTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBwLnB0ci5ocC5jcmVhdGVHTGlzdChoc3ViKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBxID0gcDtcblxuICAgICAgICAgICAgICAgIC8vIOWIm+W7uuihqOWwvue7k+eCuVxuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IG5ldyBHTE5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcC50YWcgPSBMSVNUO1xuICAgICAgICAgICAgICAgICAgICBxLnB0ci50cCA9IHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoc3ViKTtcblxuICAgICAgICAgICAgcS5wdHIudHAgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGVxdWFsKGdMaXN0MSwgZ0xpc3QyKSB7XG4gICAgICAgIC8vIOepuuihqOaXtuebuOetieeahFxuICAgICAgICBpZiAoIWdMaXN0MSAmJiAhZ0xpc3QyKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGdMaXN0MS50YWcgPT09IEFUT00gJiYgZ0xpc3QyLnRhZyA9PT0gQVRPTSAmJiBnTGlzdDEuYXRvbSA9PT0gZ0xpc3QyLmF0b20pIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGlmIChnTGlzdDEudGFnID09PSBMSVNUICYmIGdMaXN0Mi50YWcgPT09IExJU1QpIHtcbiAgICAgICAgICAgIC8vIOihqOWktOihqOWwvumDveebuOetiVxuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWwoZ0xpc3QxLnB0ci5ocCwgZ0xpc3QyLnB0ci5ocCkgJiYgdGhpcy5lcXVhbChnTGlzdDEucHRyLnRwLCBnTGlzdDIucHRyLnRwKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8g6YCS5b2S6YCG6L2s5bm/5LmJ6KGoXG4gICAgcmV2ZXJzZSgpIHtcbiAgICAgICAgbGV0IHB0ciA9IFtdO1xuICAgICAgICAvLyDlvZNB5LiN5Li65Y6f5a2Q5LiU6KGo5bC+6Z2e56m65pe25omN6ZyA6YCG6L2sXG4gICAgICAgIGlmICh0aGlzLnRhZyA9PT0gTElTVCAmJiB0aGlzLnB0ci50cCkge1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXM7IHA7IHAgPSBwLnB0ci50cCwgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8g6YCG6L2s5ZCE5a2Q6KGoXG4gICAgICAgICAgICAgICAgaWYgKHAucHRyLmhwKSBwLnB0ci5ocC5yZXZlcnNlKCk7XG5cbiAgICAgICAgICAgICAgICBwdHJbaV0gPSBwLnB0ci5ocDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g6YeN5paw5oyJ6YCG5bqP5o6S5YiX5ZCE5a2Q6KGo55qE6aG65bqPXG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpczsgcDsgcCA9IHAucHRyLnRwKVxuICAgICAgICAgICAgICAgIHAucHRyLmhwID0gcHRyWy0taV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgICAgaWYgKHRoaXMgPT0gZ2xvYmFsIHx8IHRoaXMgPT0gbnVsbCkgc3RyID0gJygpJztcbiAgICAgICAgZWxzZSBpZiAodGhpcy50YWcgPT09IEFUT00pIHN0ciA9IHRoaXMuYXRvbTsgIC8vIOWOn+WtkFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0ciArPSAnKCc7XG5cbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzOyBwOyBwID0gcC5wdHIudHApIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gdGhpcy50b1N0cmluZy5jYWxsKHAucHRyLmhwKTtcbiAgICAgICAgICAgICAgICBpZiAocC5wdHIudHApIHN0ciArPSAnLCAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyICs9ICcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgLy8g5oyJ5bGC5bqP6L6T5Ye65bm/5LmJ6KGoXG4gICAgLy8g5bGC5bqP6YGN5Y6G55qE6Zeu6aKY77yM5LiA6Iis6YO95piv5YCf5Yqp6Zif5YiX5p2l5a6M5oiQ55qE77yM5q+P5qyh5LuO6Zif5aS0XG4gICAgLy8g5Y+W5Ye65LiA5Liq5YWD57Sg55qE5ZCM5pe25oqK5a6D5LiL5LiA5bGC55qE5a2p5a2Q5o+S5YWl6Zif5bC+77yM6L+Z5piv5bGC5bqP6YGN5Y6G55qE5Z+65pys5oCd5oOzXG4gICAgb3JkZXJQcmludCAoKXtcbiAgICAgICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XG5cbiAgICAgICAgZm9yKGxldCBwID0gdGhpczsgcDsgcCA9IHAucHRyLnRwKSBxdWV1ZS5lblF1ZXVlKHApO1xuXG4gICAgICAgIHdoaWxlKHF1ZXVlLnNpemUpe1xuICAgICAgICAgICAgbGV0IHIgPSBxdWV1ZS5kZVF1ZXVlKCk7XG4gICAgICAgICAgICBpZihyLnRhZyA9PT0gQVRPTSkgY29uc29sZS5sb2coci5hdG9tKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcihyID0gci5wdHIuaHA7IHI7IHIgPSByLnB0ci50cClcbiAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8g5bm/5LmJ6KGo55qE5omp5bGV57q/5oCn6ZO+6KGo5a2Y5YKo6KGo56S6XG5jbGFzcyBHTE5vZGUyIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICAvLyDlhazlhbHpg6jliIbvvIznlKjkuo7ljLrliIbljp/lrZDnu5Pngrnlkozooajnu5PngrlcbiAgICAgICAgdGhpcy50YWcgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8g5Y6f5a2Q57uT54K555qE5YC85Z+fXG4gICAgICAgIHRoaXMuYXRvbSA9IG51bGw7XG4gICAgICAgIC8vIOihqOe7k+eCueeahOihqOWktOaMh+mSiFxuICAgICAgICB0aGlzLmhwID0gbnVsbDtcblxuICAgICAgICAvLyDnm7jlvZPkuo7nur/mgKfpk77ooajnmoRuZXh077yM5oyH5ZCR5LiL5LiA5Liq5YWD57Sg57uT54K5XG4gICAgICAgIHRoaXMudHAgPSBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVwdGgoZ0xpc3QpIHtcbiAgICBpZiAoIWdMaXN0KSByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChnTGlzdC50YWcgPT09IEFUT00pIHJldHVybiAwO1xuXG4gICAgbGV0IG0gPSBnZXREZXB0aChnTGlzdC5wdHIuaHApICsgMTtcbiAgICBsZXQgbiA9IGdldERlcHRoKGdMaXN0LnB0ci50cCk7XG5cbiAgICByZXR1cm4gbSA+IG4gPyBtIDogbjtcbn1cblxuZnVuY3Rpb24gaXNXb3JkKHN0cil7XG4gICAgcmV0dXJuIC9eW1xcdy1dKyQvLnRlc3Qoc3RyKTtcbn1cblxuXG4vKlxuIG3lhYPlpJrpobnlvI/ooajnpLpcblxuIOWmguaenOeUqOe6v+aAp+ihqOadpeihqOekuizliJnmr4/kuKrmlbDmja7lhYPntKDpnIDopoFtKzHkuKrmlbDmja7pobnvvIzku6XlrZjlgqjkuIDkuKrns7vmlbDlkoxt5Liq5oyH5pWw5YC877yM6L+Z5bCG5Lqn55Sf5Lik5Liq6Zeu6aKY44CCXG4g5LiA5piv5peg6K665aSa6aG55byP5Lit5ZCE6aG555qE5Y+Y5YWD5pWw5piv5aSa5piv5bCR77yM6Iul6YO95oyJbeS4quWPmOWFg+WIhumFjeWtmOWCqOepuumXtO+8jOWImeWwhumAoOaIkOa1qui0ue+8m+WPjeS5i++8jOiLpeaMieWQhOmhueWunumZheeahOWPmOWFg+aVsOWIhumFjeWtmOWCqOepuumXtO+8jOWwseS8mumAoOaIkOe7k+eCueeahOWkp+Wwj+S4jeWMgO+8jOe7meaTjeS9nOW4puadpeS4jeS+v+OAguS6jOaYr+WvuW3lgLzkuI3lkIznmoTlpJrpobnlvI/vvIznur/mgKfooajkuK3nmoTnu5PngrnlpKflsI/kuZ/kuI3lkIzvvIzov5nlkIzmoLflvJXotbflrZjlgqjnrqHnkIbnmoTkuI3kvr/jgIJcbiDmlYXkuI3pgILkuo7nlKjnur/mgKfooajooajnpLrjgIJcblxuIOS+i+WmguS4ieWFg+WkmumhueW8j++8mlxuIFAoeCwgeSwgeikgPSB4KDEwKXkoMyl6KDIpICsgMngoNil5KDMpeigyKSArIDN4KDUpeSgyKXooMikgKyB4KDQpeSg0KXogKyAyeXogKyAxNVxuXG4g5aaC6Iul5pS55YaZ5Li677yaXG4gUCh4LCB5LCB6KSA9ICgoeCgxMCkgKyAyeCg2KSl5KDMpICsgM3goNSl5KDIpKXooMikgKyAoKHgoNCkgKyA2eCgzKSl5KDQpICsgMnkpeiArIDE1XG5cbiDnlKjlub/kuYnooajooajnpLrvvJpcbiBQID0geigoQSwgMiksIChCLCAxKSwgKDE1LCAwKSlcbiBBID0geSgoQywgMyksIChELCAyKSlcbiBCID0geSgoRSwgNCksIChGLCAxKSlcbiBDID0geCgoMSwgMTApLCAoMiwgNikpXG4gRCA9IHgoKDMsIDUpKVxuIEUgPSB4KCgxLCA0KSwgKDYsIDMpKVxuIEYgPSB4KCgyLCAwKSlcblxuXG4gKi9cblxuZnVuY3Rpb24gTVBOb2RlKCkge1xuICAgIC8vIOWMuuWIhuWOn+WtkOe7k+eCueWSjOihqOe7k+eCuVxuICAgIHRoaXMudGFnID0gdW5kZWZpbmVkO1xuICAgIC8vIOaMh+aVsOWfn1xuICAgIHRoaXMuZXhwID0gMDtcblxuICAgIC8vIOezu+aVsOWfn1xuICAgIHRoaXMuY29lZiA9IDA7XG4gICAgLy8g6KGo57uT54K555qE6KGo5aS05oyH6ZKIXG4gICAgdGhpcy5ocCA9IG51bGw7XG5cbiAgICAvLyDnm7jlvZPkuo7nur/mgKfooajnmoRuZXh077yM5oyH5ZCR5LiL5LiA5Liq5YWD57Sg57uT54K5XG4gICAgdGhpcy50cCA9IG51bGw7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0dlbmVyYWxpemVkTGlzdC9HTGlzdC5qcyIsIi8qXG4g6YK75o6l5aSa6YeN6KGoXG5cbiDpgrvmjqXlpJrph43ooagoQWRqYWNlbmN5IE11bHRpbGlzdCnmmK/ml6DlkJHlm77nmoTlj6bkuIDnp43pk77lvI/lrZjlgqjnu5PmnoTjgIJcblxuIOmCu+aOpeihqOaYr+aXoOWQkeWbvueahOS4gOenjeacieaViOeahOWtmOWCqOe7k+aehO+8jOWcqOaXoOWQkeWbvueahOmCu+aOpeihqOS4re+8jOS4gOadoei+uSh2LHcp55qE5Lik5Liq6KGo57uT54K55YiG5Yir5Yid6YCJ5Zyo5LulduWSjHfkuLrlpLTnu5PngrnnmoTpk77ooajkuK3vvIzlvojlrrnmmJPmsYLlvpfpobbngrnlkozovrnnmoTkv6Hmga/vvIzkvYblnKjmtonlj4rliLDovrnnmoTmk43kvZzkvJrluKbmnaXkuI3kvr/jgIJcblxuIOmCu+aOpeWkmumHjeihqOeahOe7k+aehOWSjOWNgeWtl+mTvuihqOexu+S8vO+8jOavj+adoei+ueeUqOS4gOS4que7k+eCueihqOekuu+8m+mCu+aOpeWkmumHjeihqOS4reeahOmhtueCuee7k+eCuee7k+aehOS4jumCu+aOpeihqOS4reeahOWujOWFqOebuOWQjO+8jOiAjOihqOe7k+eCueWMheaLrOWFreS4quWfn+OAglxuXG4g4peGICBEYXRh5Z+f77ya5a2Y5YKo5ZKM6aG254K555u45YWz55qE5L+h5oGv77ybXG4g4peGIOaMh+mSiOWfn2ZpcnN0ZWRnZe+8muaMh+WQkeS+nemZhOS6juivpemhtueCueeahOesrOS4gOadoei+ueaJgOWvueW6lOeahOihqOe7k+eCue+8m1xuIOKXhiDmoIflv5fln59tYXJr77ya55So5Lul5qCH6K+G6K+l5p2h6L655piv5ZCm6KKr6K6/6Zeu6L+H77ybXG4g4peGIGl2ZXjlkoxqdmV45Z+f77ya5YiG5Yir5L+d5a2Y6K+l6L655omA5L6d6ZmE55qE5Lik5Liq6aG254K55Zyo5Zu+5Lit55qE5L2N572u77ybXG4g4peGIGluZm/ln5/vvJrkv53lrZjor6XovrnnmoTnm7jlhbPkv6Hmga/vvJtcbiDil4Yg5oyH6ZKI5Z+faWxpbmvvvJrmjIflkJHkuIvkuIDmnaHkvp3pmYTkuo7pobbngrlpdmV455qE6L6577ybXG4g4peGIOaMh+mSiOWfn2psaW5r77ya5oyH5ZCR5LiL5LiA5p2h5L6d6ZmE5LqO6aG254K5anZleOeahOi+ue+8m1xuXG4g6YK75o6l5aSa6YeN6KGo5LiO6YK75o6l6KGo55qE5Yy65Yir77yaXG4g5ZCO6ICF55qE5ZCM5LiA5p2h6L6555So5Lik5Liq6KGo57uT54K56KGo56S677yM6ICM5YmN6ICF5Y+q55So5LiA5Liq6KGo57uT54K56KGo56S677yb6Zmk5qCH5b+X5Z+f5aSW77yM6YK75o6l5aSa6YeN6KGo5LiO6YK75o6l6KGo6KGo6L6+55qE5L+h5oGv5piv55u45ZCM55qE77yM5Zug5q2k77yM5pON5L2c55qE5a6e546w5Lmf5Z+65pys55u45Ly844CCXG5cbiAqL1xuXG5jb25zdCBVTlZJU0lURUQgPSAwO1xuY29uc3QgVklTSVRFRCA9IDE7XG5cblxuY2xhc3MgRUJveCB7XG4gICAgLyoqXG4gICAgICog6L6555qE57uT54K56KGo56S6XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1hcmsg6K6/6Zeu5qCH6K6wIDAgLS0g5pyq6K6/6ZeuICAxID09IOW3suiuv+mXrlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpdmV4IOivpei+ueS+nemZhOeahOS4pOS4qumhtueCueeahOS9jee9rlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBqdmV4IOivpei+ueS+nemZhOeahOS4pOS4qumhtueCueeahOS9jee9rlxuICAgICAqIEBwYXJhbSB7RUJveH0gaWxpbmsg5YiG5Yir5oyH5ZCR5L6d6ZmE6L+Z5Lik5Liq6aG254K555qE5LiL5LiA5p2h6L65XG4gICAgICogQHBhcmFtIHtFQm94fSBqbGluayDliIbliKvmjIflkJHkvp3pmYTov5nkuKTkuKrpobbngrnnmoTkuIvkuIDmnaHovrlcbiAgICAgKiBAcGFyYW0geyp9IGluZm8g6K+l6L655L+h5oGvXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWFyaywgaXZleCwganZleCwgaWxpbmssIGpsaW5rLCBpbmZvKXtcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyayB8fCBVTlZJU0lURUQ7XG4gICAgICAgIHRoaXMuaXZleCA9IGl2ZXggfHwgMDtcbiAgICAgICAgdGhpcy5qdmV4ID0ganZleCB8fCAwO1xuICAgICAgICB0aGlzLmlsaW5rID0gaWxpbmsgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5qbGluayA9IGpsaW5rIHx8IG51bGw7XG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm8gfHwgbnVsbDtcbiAgICB9XG59XG5cbmNsYXNzIEFNTFZleEJveCB7XG4gICAgLyoqXG4gICAgICog6aG254K555qE57uT54K56KGo56S6XG4gICAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAgICogQHBhcmFtIHtFQm94fSBmaXJzdEVkZ2Ug5oyH5ZCR56ys5LiA5p2h5L6d6ZmE6K+l6aG254K555qE6L65XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGF0YSwgZmlyc3RFZGdlKXtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YSB8fCBudWxsO1xuICAgICAgICB0aGlzLmZpcnN0RWRnZSA9IGZpcnN0RWRnZSB8fCBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQU1MR3JhcGgge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheSB8IEFNTFZleEJveH0gYWRqTXVsaXN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZleG51bVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlZGdlbnVtXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWRqTXVsaXN0LCB2ZXhudW0sIGVkZ2VudW0pe1xuICAgICAgICB0aGlzLmFkak11bGlzdCA9IGFkak11bGlzdCB8fCBbXTtcbiAgICAgICAgdGhpcy52ZXhudW0gPSB2ZXhudW0gfHwgMDtcbiAgICAgICAgdGhpcy5lZGdlbnVtID0gZWRnZW51bSB8fCAwO1xuICAgIH1cblxuICAgIGxvY2F0ZVZleCAodikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFkak11bGlzdFtpXS5kYXRhID09PSB2KSByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgZGVsZXRlQXJjKHYsIHcpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmxvY2F0ZVZleCh2KTtcbiAgICAgICAgdmFyIGogPSB0aGlzLmxvY2F0ZVZleCh3KTtcblxuICAgICAgICBpZiAoaSA8IDAgfHwgaiA8IDApIHRocm93IG5ldyBFcnJvcignVmVydGV4IG5vdCBmb3VuZCEnKTtcblxuICAgICAgICB2YXIgcDtcbiAgICAgICAgLy8g5ZyoaemTvuihqOS4reWIoOmZpOivpei+uVxuICAgICAgICBpZiAodGhpcy5hZGpNdWxpc3RbaV0uZmlyc3RFZGdlLmp2ZXggPT09IGopIHtcbiAgICAgICAgICAgIHRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZSA9IHRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZS5pbGluaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAocCA9IHRoaXMuYWRqTXVsaXN0W2ldLmZpcnN0RWRnZTsgcCAmJiBwLmlsaW5rLmp2ZXggIT09IGo7IHAgPSBwLmlsaW5rKTtcbiAgICAgICAgICAgIGlmICghcCkgdGhyb3cgbmV3IEVycm9yKCdlZGdlIG5vdCBmb3VuZCEnKTtcbiAgICAgICAgICAgIHAuaWxpbmsgPSBwLmlsaW5rLmlsaW5rO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5ZyoaumTvuihqOS4reWIoOmZpOivpei+uVxuICAgICAgICBpZiAodGhpcy5hZGpNdWxpc3Rbal0uZmlyc3RFZGdlLml2ZXggPT09IGkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqTXVsaXN0W2pdLmZpcnN0RWRnZSA9IHRoaXMuYWRqTXVsaXN0W2pdLmZpcnN0RWRnZS5qbGluaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAocCA9IHRoaXMuYWRqTXVsaXN0W2pdLmZpcnN0RWRnZTsgcCAmJiBwLmpsaW5rLml2ZXggIT09IGk7IHAgPSBwLmpsaW5rKTtcbiAgICAgICAgICAgIGlmICghcCkgdGhyb3cgbmV3IEVycm9yKCdlZGdlIG5vdCBmb3VuZCEnKTtcbiAgICAgICAgICAgIHAuamxpbmsgPSBwLmpsaW5rLmpsaW5rO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lZGdlbnVtLS07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNyZWF0ZUdyYXBoKCkge1xuICAgICAgICB2YXIgdmV4bnVtID0gK3Byb21wdCgndmV4bnVtOiAnKTtcbiAgICAgICAgdGhpcy52ZXhudW0gPSB2ZXhudW07XG4gICAgICAgIHZhciBlZGdlbnVtID0gK3Byb21wdCgnZWRnZW51bTogJyk7XG4gICAgICAgIHRoaXMuZWRnZW51bSA9IGVkZ2VudW07XG5cbiAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCB2ZXhudW07ICsrbSkge1xuICAgICAgICAgICAgdGhpcy5hZGpNdWxpc3RbbV0gPSBuZXcgQU1MVmV4Qm94KHByb21wdCgnZGF0YTogJyksIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChtID0gMDsgbSA8IGVkZ2VudW07ICsrbSkge1xuICAgICAgICAgICAgdmFyIHQgPSBwcm9tcHQoJ3RhaWxWZXg6ICcpO1xuICAgICAgICAgICAgdmFyIGggPSBwcm9tcHQoJ2hlYWRWZXg6ICcpO1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmxvY2F0ZVZleCh0KTtcbiAgICAgICAgICAgIHZhciBqID0gdGhpcy5sb2NhdGVWZXgoaCk7XG5cbiAgICAgICAgICAgIGlmIChpIDwgMCB8fCBqIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3ZlcnRleCBub3QgZm91bmQhIFRyeSBhZ2FpbjonKTtcbiAgICAgICAgICAgICAgICBtLS07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwID0gbmV3IEVCb3goMCwgaSwgaiwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICB2YXIgcSwgcjtcblxuICAgICAgICAgICAgLy8g5o+S5YWlaemTvuihqOWwvumDqFxuICAgICAgICAgICAgaWYgKCF0aGlzLmFkak11bGlzdFtpXS5maXJzdEVkZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkak11bGlzdFtpXS5maXJzdEVkZ2UgPSBwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxID0gdGhpcy5hZGpNdWxpc3RbaV0uZmlyc3RFZGdlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChxKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocS5pdmV4ID09PSBpKSBxID0gcS5pbGluaztcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBxID0gcS5qbGluaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHIuaXZleCA9PT0gaSkgci5pbGluayA9IHA7XG4gICAgICAgICAgICAgICAgZWxzZSByLmpsaW5rID0gcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5o+S5YWlaumTvuihqOWwvumDqFxuICAgICAgICAgICAgaWYgKCF0aGlzLmFkak11bGlzdFtqXS5maXJzdEVkZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkak11bGlzdFtqXS5maXJzdEVkZ2UgPSBwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxID0gdGhpcy5hZGpNdWxpc3Rbal0uZmlyc3RFZGdlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChxKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocS5qdmV4ID09PSBqKSBxID0gcS5qbGluaztcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBxID0gcS5pbGluaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHIuanZleCA9PT0gaikgci5qbGluayA9IHA7XG4gICAgICAgICAgICAgICAgZWxzZSByLmlsaW5rID0gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy92YXIgZyA9IG5ldyBBTUxHcmFwaCgpO1xuLy9nLmNyZWF0ZUdyYXBoKCk7XG4vL2NvbnNvbGUubG9nKGcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0dyYXBoL0FNTEdyYXBoLmpzIiwiLyogQ3JlYXRlIEJ5IEx1a2UgKi9cblxuaW1wb3J0IFN0YWNrIGZyb20gJy4uL1N0YWNrL2luZGV4JztcbmltcG9ydCBRdWV1ZSBmcm9tICcuLi9RdWV1ZS9RdWV1ZSc7XG5pbXBvcnQgeyBDaGlsZFNpYmxpbmdUcmVlIH0gZnJvbSAnLi4vQmluYXJ5VHJlZS9CaW5hcnlUcmVlJztcblxuLy8g5Zu+55qE5pWw57uE77yI6YK75o6l55+p6Zi177yJ5a2Y5YKo6KGo56S6XG5jb25zdCBERyA9IDE7ICAgICAvLyDmnInlkJHlm75cbmNvbnN0IEROID0gMjsgICAgIC8vIOacieWQkee9kVxuY29uc3QgVURHID0gMzsgICAgLy8g5peg5ZCR5Zu+XG5jb25zdCBVRE4gPSA0OyAgICAvLyDml6DlkJHnvZFcblxuXG4vKlxuIOmCu+aOpemTvuihqOazlVxuXG4g5Z+65pys5oCd5oOz77ya5a+55Zu+55qE5q+P5Liq6aG254K55bu656uL5LiA5Liq5Y2V6ZO+6KGo77yM5a2Y5YKo6K+l6aG254K55omA5pyJ6YK75o6l6aG254K55Y+K5YW255u45YWz5L+h5oGv44CC5q+P5LiA5Liq5Y2V6ZO+6KGo6K6+5LiA5Liq6KGo5aS057uT54K544CCXG5cbiDnrKxp5Liq5Y2V6ZO+6KGo6KGo56S65L6d6ZmE5LqO6aG254K5VmnnmoTovrko5a+55pyJ5ZCR5Zu+5piv5Lul6aG254K5VmnkuLrlpLTmiJblsL7nmoTlvKcp44CCXG5cbiAxICDnu5Pngrnnu5PmnoTkuI7pgrvmjqXpk77ooajnpLrkvotcblxuIOmTvuihqOS4reeahOe7k+eCueensOS4uuihqOe7k+eCue+8jOavj+S4que7k+eCueeUseS4ieS4quWfn+e7hOaIkOOAguWFtuS4remCu+aOpeeCueWfnyhhZGp2ZXgp5oyH56S65LiO6aG254K5VmnpgrvmjqXnmoTpobbngrnlnKjlm77kuK3nmoTkvY3nva4o6aG254K557yW5Y+3Ke+8jOmTvuWfnyhuZXh0YXJjKeaMh+WQkeS4i+S4gOS4quS4jumhtueCuVZp6YK75o6l55qE6KGo57uT54K577yM5pWw5o2u5Z+fKGluZm8p5a2Y5YKo5ZKM6L655oiW5byn55u45YWz55qE5L+h5oGv77yM5aaC5p2D5YC8562J44CC5a+55LqO5peg5p2D5Zu+77yM5aaC5p6c5rKh5pyJ5LiO6L6555u45YWz55qE5YW25LuW5L+h5oGv77yM5Y+v55yB55Wl5q2k5Z+f44CCXG5cbiDmr4/kuKrpk77ooajorr7kuIDkuKrooajlpLTnu5Pngrko56ew5Li66aG254K557uT54K5Ke+8jOeUseS4pOS4quWfn+e7hOaIkOOAgumTvuWfnyhmaXJzdGFyYynmjIflkJHpk77ooajkuK3nmoTnrKzkuIDkuKrnu5PngrnvvIzmlbDmja7ln58oZGF0YSkg5a2Y5YKo6aG254K55ZCN5oiW5YW25LuW5L+h5oGv44CCXG5cbiDlnKjlm77nmoTpgrvmjqXpk77ooajooajnpLrkuK3vvIzmiYDmnInpobbngrnnu5PngrnnlKjkuIDkuKrlkJHph48g5Lul6aG65bqP57uT5p6E5b2i5byP5a2Y5YKo77yM5Y+v5Lul6ZqP5py66K6/6Zeu5Lu75oSP6aG254K555qE6ZO+6KGo77yM6K+l5ZCR6YeP56ew5Li66KGo5aS05ZCR6YeP77yM5ZCR6YeP55qE5LiL5qCH5oyH56S66aG254K555qE5bqP5Y+344CCXG5cbiDnlKjpgrvmjqXpk77ooajlrZjlgqjlm77ml7bvvIzlr7nml6DlkJHlm77vvIzlhbbpgrvmjqXpk77ooajmmK/llK/kuIDnmoTvvJvlr7nmnInlkJHlm77vvIzlhbbpgrvmjqXpk77ooajmnInkuKTnp43lvaLlvI/jgIJcblxuXG4gMiAg6YK75o6l6KGo5rOV55qE54m554K5XG5cbiDil4Yg6KGo5aS05ZCR6YeP5Lit5q+P5Liq5YiG6YeP5bCx5piv5LiA5Liq5Y2V6ZO+6KGo55qE5aS057uT54K577yM5YiG6YeP5Liq5pWw5bCx5piv5Zu+5Lit55qE6aG254K55pWw55uu77ybXG4g4peGIOWcqOi+ueaIluW8p+eogOeWj+eahOadoeS7tuS4i++8jOeUqOmCu+aOpeihqOihqOekuuavlOeUqOmCu+aOpeefqemYteihqOekuuiKguecgeWtmOWCqOepuumXtO+8m1xuIOKXhiDlnKjml6DlkJHlm77vvIzpobbngrlWaeeahOW6puaYr+esrGnkuKrpk77ooajnmoTnu5PngrnmlbDvvJtcbiDil4Yg5a+55pyJ5ZCR5Zu+5Y+v5Lul5bu656uL5q2j6YK75o6l6KGo5oiW6YCG6YK75o6l6KGo44CC5q2j6YK75o6l6KGo5piv5Lul6aG254K5VmnkuLrlh7rluqYo5Y2z5Li65byn55qE6LW354K5KeiAjOW7uueri+eahOmCu+aOpeihqO+8m+mAhumCu+aOpeihqOaYr+S7pemhtueCuVZp5Li65YWl5bqmKOWNs+S4uuW8p+eahOe7iOeCuSnogIzlu7rnq4vnmoTpgrvmjqXooajvvJtcbiDil4Yg5Zyo5pyJ5ZCR5Zu+5Lit77yM56ysaeS4qumTvuihqOS4reeahOe7k+eCueaVsOaYr+mhtueCuVZp55qE5Ye6ICjmiJblhaUp5bqm77yb5rGC5YWlICjmiJblh7op5bqm77yM6aG76YGN5Y6G5pW05Liq6YK75o6l6KGo77ybXG4g4peGIOWcqOmCu+aOpeihqOS4iuWuueaYk+aJvuWHuuS7u+S4gOmhtueCueeahOesrOS4gOS4qumCu+aOpeeCueWSjOS4i+S4gOS4qumCu+aOpeeCue+8m1xuXG4gKi9cblxuXG5jbGFzcyBBcmNOb2RlIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhZGpWZXhcbiAgICAgKiBAcGFyYW0ge0FyY05vZGV9IG5leHRBcmNcbiAgICAgKiBAcGFyYW0geyp9IGluZm9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZGpWZXggPSAwLCBuZXh0QXJjID0gbnVsbCwgaW5mbyA9IG51bGwpe1xuICAgICAgICAvLyDor6XlvKfmiYDmjIflkJHnmoTpobbngrnnmoTkvY3nva5cbiAgICAgICAgdGhpcy5hZGpWZXggPSBhZGpWZXg7XG4gICAgICAgIC8vIOaMh+WQkeS4i+S4gOadoeW8p+eahOaMh+mSiFxuICAgICAgICB0aGlzLm5leHRBcmMgPSBuZXh0QXJjO1xuICAgICAgICAvLyDor6XlvKfnm7jlhbPkv6Hmga/nmoTmjIfpkohcbiAgICAgICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICB9XG59XG5cbmNsYXNzIFZleE5vZGUge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAgICogQHBhcmFtIHtBcmNOb2RlfSBmaXJzdEFyY1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRlZ3JlZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGZpcnN0QXJjID0gbnVsbCwgaW5kZWdyZWUgPSAwKXtcbiAgICAgICAgLy8g6aG254K55L+h5oGvXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIC8vIOaMh+WQkeesrOS4gOadoeS+nemZhOivpemhtueCueeahOW8p+eahOaMh+mSiFxuICAgICAgICB0aGlzLmZpcnN0QXJjID0gZmlyc3RBcmM7XG4gICAgICAgIC8vICDpobbngrnnmoTluqYsIOacieWQkeWbvuaYr+WFpeW6puaIluWHuuW6puaIluayoeaciVxuICAgICAgICB0aGlzLmluZGVncmVlID0gaW5kZWdyZWU7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBZGphY2VuY3lMaXN0R3JhcGgge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheSB8IFZleE5vZGV9IHZlcnRpY2VzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZleG51bVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhcmNudW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga2luZFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZlcnRpY2VzID0gW10sIHZleG51bSA9IDAsIGFyY251bSA9IDAsIGtpbmQgPSBERyl7XG4gICAgICAgIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlcztcbiAgICAgICAgLy8g5Zu+55qE5b2T5YmN6aG254K55pWw5ZKM5byn5pWwXG4gICAgICAgIHRoaXMudmV4bnVtID0gdmV4bnVtO1xuICAgICAgICB0aGlzLmFyY251bSA9IGFyY251bTtcbiAgICAgICAgLy8g5Zu+55qE56eN57G75qCH5b+XXG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgfVxuXG4gICAgLy8g5p+l5om+6aG254K55L2N572uXG4gICAgbG9jYXRlVmV4KHZwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmVydGljZXNbaV0uZGF0YSA9PT0gdnApIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIOa3u+WKoOmhtueCuVxuICAgIGFkZFZlcnRleCh2cCkge1xuICAgICAgICBpZiAodGhpcy5sb2NhdGVWZXgodnApICE9PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggaGFzIGV4aXN0ZWQhJyk7XG5cbiAgICAgICAgdGhpcy52ZXJ0aWNlc1t0aGlzLnZleG51bSsrXSA9IG5ldyBWZXhOb2RlKHZwLCBudWxsLCAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmV4bnVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOa3u+WKoOW8p1xuICAgICAqIOWmguaenOaYr+aXoOWQkeWbvuaIluiAheaXoOWQkee9kSxhcmMx5ZKMYXJjMuaXoOmhuuW6j+imgeaxglxuICAgICAqIOWmguaenOaYr+acieWQkeWbvuaIluiAheacieWQkee9ke+8jOWPquS8mua3u+WKoGFyYzHvvIzlm6DmraTmraPpgrvmjqXooajlkozpgIbpgrvmjqXooajnmoTpobrluo/pnIDopoHms6jmhI9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJjMVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcmMyXG4gICAgICogQHBhcmFtIHsqfSBpbmZvXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgYWRkQXJjKGFyYzEsIGFyYzIsIGluZm8pIHtcbiAgICAgICAgbGV0IGsgPSB0aGlzLmxvY2F0ZVZleChhcmMxKTtcbiAgICAgICAgbGV0IGogPSB0aGlzLmxvY2F0ZVZleChhcmMyKTtcblxuICAgICAgICBpZiAoayA9PT0gLTEgfHwgaiA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignQXJjXFwncyBWZXJ0ZXggZG8gbm90IGV4aXN0ZWQhJyk7XG5cbiAgICAgICAgLy8g6L6555qE6LW35aeL6KGo57uT54K56LWL5YC8XG4gICAgICAgIGxldCBwID0gbmV3IEFyY05vZGUoaywgbnVsbCwgaW5mbyk7XG4gICAgICAgIC8vIOi+ueeahOacq+WwvuihqOe7k+eCuei1i+WAvFxuICAgICAgICBsZXQgcSA9IG5ldyBBcmNOb2RlKGosIG51bGwsIGluZm8pO1xuXG4gICAgICAgIC8vIOaYr+aXoOWQkeWbvu+8jOeUqOWktOaPkuWFpeazleaPkuWFpeWIsOS4pOS4quWNlemTvuihqFxuICAgICAgICBpZiAodGhpcy5raW5kID09PSBVREcgfHwgdGhpcy5raW5kID09PSBVRE4pIHtcbiAgICAgICAgICAgIHEubmV4dEFyYyA9IHRoaXMudmVydGljZXNba10uZmlyc3RBcmM7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW2tdLmZpcnN0QXJjID0gcTtcbiAgICAgICAgICAgIHAubmV4dEFyYyA9IHRoaXMudmVydGljZXNbal0uZmlyc3RBcmM7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW2pdLmZpcnN0QXJjID0gcDtcbiAgICAgICAgfVxuICAgICAgICAvLyDlu7rnq4vmnInlkJHlm77nmoTpgrvmjqXpk77ooajvvIznlKjlpLTmj5LlhaXms5VcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwLm5leHRBcmMgPSB0aGlzLnZlcnRpY2VzW2pdLmZpcnN0QXJjO1xuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1tqXS5maXJzdEFyYyA9IHA7XG4gICAgICAgIH1cblxuICAgICAgICArK3RoaXMuYXJjbnVtO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFRPRE8g5YW25LuW5Zu+57G75Z6L55qE5Yib5bu65pqC5pe25rKh5byEXG4gICAgY3JlYXRlR3JhcGgoKSB7XG4gICAgICAgIHRoaXMudmV4bnVtID0gK3Byb21wdCgndmV4bnVtOiAnKTtcbiAgICAgICAgdGhpcy5hcmNudW0gPSArcHJvbXB0KCdhcmNudW06ICcpO1xuICAgICAgICAvLyBpbmNJbmZv5Li6MOWImeWQhOW8p+S4jeWQq+WFtuS7luS/oeaBr1xuICAgICAgICBsZXQgaW5jSW5mbyA9ICtwcm9tcHQoJ2luY0luZm86ICcpO1xuXG4gICAgICAgIGZvciAobGV0IG0gPSAwOyBtIDwgdGhpcy52ZXhudW07ICsrbSkge1xuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1ttXSA9IG5ldyBWZXhOb2RlKCk7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW21dLmRhdGEgPSBwcm9tcHQoJ3ZlcnRleDogJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKG0gPSAwOyBtIDwgdGhpcy5hcmNudW07ICsrbSkge1xuICAgICAgICAgICAgbGV0IGggPSBwcm9tcHQoJ+W8p+WktDogJyk7XG4gICAgICAgICAgICBsZXQgdCA9IHByb21wdCgn5byn5bC+OiAnKTtcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5sb2NhdGVWZXgodCk7XG4gICAgICAgICAgICBsZXQgaiA9IHRoaXMubG9jYXRlVmV4KGgpO1xuXG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgaiA8IDApIHtcbiAgICAgICAgICAgICAgICBhbGVydCgn6aG254K55Li65om+5Yiw77yM6K+36YeN5paw6L6T5YWl77yBJyk7XG4gICAgICAgICAgICAgICAgbS0tO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcCA9IG5ldyBBcmNOb2RlKGosIG51bGwsIGluY0luZm8gJiYgcHJvbXB0KCdpbmZvOiAnKSk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy52ZXJ0aWNlc1tpXS5maXJzdEFyYykgdGhpcy52ZXJ0aWNlc1tpXS5maXJzdEFyYyA9IHA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBxID0gdGhpcy52ZXJ0aWNlc1tpXS5maXJzdEFyYzsgcS5uZXh0QXJjOyBxID0gcS5uZXh0QXJjKTtcbiAgICAgICAgICAgICAgICBxLm5leHRBcmMgPSBwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g5Yik5pat5LiA5Liq6YK75o6l6KGo5a2Y5YKo55qE5pyJ5ZCR5Zu+5piv5ZCm5Y+v5Lyg6YCSXG4gICAgaXNQYXNzKCkge1xuICAgICAgICBpZiAodGhpcy5raW5kICE9PSBERykgdGhyb3cgbmV3IEVycm9yKCdncmFwaCBraW5kIHNob3VsZCBiZSBERycpO1xuXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy52ZXhudW07ICsreCkge1xuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbeF0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICBsZXQgeSA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHEgPSB0aGlzLnZlcnRpY2VzW3ldLmZpcnN0QXJjOyBxOyBxID0gcS5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB6ID0gcS5hZGpWZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh6ICE9PSB4ICYmIHRoaXMuaXNBZGooeCwgeikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyDliKTmlq3mnInlkJHlm77mmK/lkKblrZjlnKjovrkobSxuKVxuICAgIGlzQWRqKG0sIG4pIHtcbiAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbbV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgIGlmIChwLmFkalZleCA9PT0gbikgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOa3seW6puS8mOWFiOWIpOaWrTxiPuacieWQkeWbvjxiPueahOmhtueCuWnliLDpobbngrlq5piv5ZCm5pyJ6Lev5b6E77yM5a6e5YiZ6L+U5ZuedHJ1Ze+8jOWQpuWImei/lOWbnmZhbHNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30galxuICAgICAqL1xuICAgIGV4aXN0UGF0aERGUyhpLCBqKSB7XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG4gICAgICAgIGkgPSB0aGlzLmxvY2F0ZVZleChpKTtcbiAgICAgICAgaiA9IHRoaXMubG9jYXRlVmV4KGopO1xuXG4gICAgICAgIGlmIChpIDwgMCB8fCBqIDwgMCkgdGhyb3cgbmV3IEVycm9yKCd2ZXJ0ZXggbm90IGZvdW5kIScpO1xuXG4gICAgICAgIHJldHVybiBleGlzdF9wYXRoKHRoaXMsIGksIGopO1xuXG4gICAgICAgIGZ1bmN0aW9uIGV4aXN0X3BhdGgoZ3JhcGgsIGksIGopIHtcbiAgICAgICAgICAgIGlmIChpID09PSBqKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBwID0gZ3JhcGgudmVydGljZXNbaV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICBsZXQgayA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtrXSAmJiBleGlzdF9wYXRoKGdyYXBoLCBrLCBqKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOW5v+W6puS8mOWFiOWIpOaWrTxiPuacieWQkeWbvjxiPueahOmhtueCuWnliLDpobbngrlq5piv5ZCm5pyJ6Lev5b6E77yM5a6e5YiZ6L+U5ZuedHJ1Ze+8jOWQpuWImei/lOWbnmZhbHNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30galxuICAgICAqL1xuICAgIGV4aXN0UGF0aEJGUyhpLCBqKSB7XG4gICAgICAgIGkgPSB0aGlzLmxvY2F0ZVZleChpKTtcbiAgICAgICAgaiA9IHRoaXMubG9jYXRlVmV4KGopO1xuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgcXVldWUuZW5RdWV1ZShpKTtcblxuICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xuICAgICAgICAgICAgbGV0IHUgPSBxdWV1ZS5kZVF1ZXVlKCk7XG4gICAgICAgICAgICB2aXNpdGVkW3VdID0gMTtcblxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbaV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICBsZXQgayA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgIGlmIChrID09PSBqKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRba10pIHF1ZXVlLmVuUXVldWUoayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Yik5pat6YK75o6l6KGo5pa55byP5a2Y5YKo55qE5pyJ5ZCR5Zu+55qE6aG254K5aeWIsGrmmK/lkKblrZjlnKjplb/luqbkuLpr55qE566A5Y2V6Lev5b6EXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30galxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrXG4gICAgICovXG4gICAgZXhpc3RQYXRoTGVuKGksIGosIGspIHtcbiAgICAgICAgaSA9IHRoaXMubG9jYXRlVmV4KGkpO1xuICAgICAgICBqID0gdGhpcy5sb2NhdGVWZXgoaik7XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG5cbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiByZWN1cnNlKGdyYXBoLCBpLCBqLCBrKSB7XG4gICAgICAgICAgICAvLyDmib7liLDkuobkuIDmnaHot6/lvoTvvIzkuJTplb/luqbnrKblkIhcbiAgICAgICAgICAgIGlmIChpID09PSBqICYmIGsgPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoayA+IDApIHtcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2ldID0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwID0gZ3JhcGgudmVydGljZXNbaV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGwgPSBwLmFkalZleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2xdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDliankvZnot6/lvoTplb/luqblh4/kuIBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWN1cnNlKGdyYXBoLCBsLCBqLCBrIC0gMSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIOWFgeiuuOabvue7j+iiq+iuv+mXrui/h+eahOe7k+eCueWHuueOsOWcqOWPpuS4gOadoei3r+W+hOS4ilxuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pKHRoaXMsIGksIGosIGspO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaxguacieWQkeWbvuS4remhtueCuXXliLB25LmL6Ze055qE5omA5pyJ566A5Y2V6Lev5b6E77yMa+S4uuW9k+WJjei3r+W+hOmVv+W6plxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZcbiAgICAgKiBAcGFyYW0ge051bWJlcn0ga1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgZ3JhcGguZmluZEFsbFBhdGhzKCd2MScsICd2MicsIDApO1xuICAgICAqL1xuICAgIGZpbmRBbGxQYXRocyh1LCB2LCBrKSB7XG4gICAgICAgIHUgPSB0aGlzLmxvY2F0ZVZleCh1KTtcbiAgICAgICAgdiA9IHRoaXMubG9jYXRlVmV4KHYpO1xuICAgICAgICBsZXQgcGF0aCA9IFtdO1xuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xuXG4gICAgICAgIGZpbmRQYXRoKHRoaXMsIHUsIHYsIGspO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmRQYXRoKGdyYXBoLCB1LCB2LCBrKSB7XG4gICAgICAgICAgICAvLyDliqDlhaXlvZPliY3ot6/lvoTkuK1cbiAgICAgICAgICAgIHBhdGhba10gPSB1O1xuICAgICAgICAgICAgdmlzaXRlZFt1XSA9IDE7XG5cbiAgICAgICAgICAgIC8vIOaJvuWIsOS4gOadoeeugOWNlei3r+W+hFxuICAgICAgICAgICAgaWYgKHUgPT09IHYpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgb25lIHBhdGghJyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IHBhdGhbaV07ICsraSkgY29uc29sZS5sb2cocGF0aFtpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgPSBncmFwaC52ZXJ0aWNlc1t1XS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbCA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgICAgICAvLyDnu6fnu63lr7vmib5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2xdKSBmaW5kUGF0aChncmFwaCwgbCwgdiwgayArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlzaXRlZFt1XSA9IDA7XG4gICAgICAgICAgICAvLyDlm57muq9cbiAgICAgICAgICAgIHBhdGhba10gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5rGC5pyJ5ZCR5Zu+55qE6aG254K55LmL6Ze06ZW/5bqm5Li6bGVu55qE566A5Y2V6Lev5b6E5p2h5pWwXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30galxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5cbiAgICAgKi9cbiAgICBnZXRQYXRoTnVtX2xlbihpLCBqLCBsZW4pIHtcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcblxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIHJlY3Vyc2UoZ3JhcGgsIGksIGosIGxlbikge1xuICAgICAgICAgICAgaWYgKGkgPT09IGogJiYgbGVuID09PSAwKSByZXR1cm4gMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICB2aXNpdGVkW2ldID0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwID0gZ3JhcGgudmVydGljZXNbaV0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGwgPSBwLmFkalZleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2xdKSBzdW0gKz0gcmVjdXJzZShsLCBqLCBsZW4gLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkodGhpcywgaSwgaiwgbGVuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmsYLmnInlkJHml6Dnjq/lm77nmoTmoLlcbiAgICAgKi9cbiAgICBnZXRSb290KCl7XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG5cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgIC8vIOavj+asoemDveimgeWwhuiuv+mXruaVsOe7hOa4hembtlxuICAgICAgICAgICAgZm9yIChsZXQgdyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSB2aXNpdGVkW3ddID0gZmFsc2U7XG4gICAgICAgICAgICAvLyDku47pobbngrlp5Ye65Y+R6L+b6KGM5rex5bqm5LyY5YWI6YGN5Y6GXG4gICAgICAgICAgICBkZnModGhpcywgaSk7XG5cbiAgICAgICAgICAgIGxldCBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcih3ID0gMDsgdyA8IHRoaXMudmV4bnVtOyArK3cpe1xuICAgICAgICAgICAgICAgIC8vIOWmguaenGnmmK/moLnvvIzliJnmt7HluqbkvJjlhYjpgY3ljoblj6/ku6Xorr/pl67liLDmiYDmnInnu5PngrlcbiAgICAgICAgICAgICAgICBpZighdmlzaXRlZFt3XSkgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihmbGFnKSBjb25zb2xlLmxvZygnRm91bmQgYSByb290IHZlcnRleDogJWQnLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRmcyhncmFwaCwgdil7XG4gICAgICAgICAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yKGxldCBwID0gZ3JhcGgudmVydGljZXNbdl0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpe1xuICAgICAgICAgICAgICAgIGxldCB3ID0gcC5hZGpWZXg7XG4gICAgICAgICAgICAgICAgaWYoIXZpc2l0ZWRbd10pIGRmcyhncmFwaCwgdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmsYLkuIDkuKrmnInlkJHml6Dnjq/lm77kuK3mnIDplb/nmoTot6/lvoRcbiAgICAgKi9cbiAgICBnZXRMb25nZXN0UGF0aCgpe1xuICAgICAgICBsZXQgbWxwID0gW107XG4gICAgICAgIGxldCBwYXRoID0gW107XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG4gICAgICAgIGxldCBtYXhMZW4gPSAwO1xuXG4gICAgICAgIHRoaXMuY291bnRJbmRlZ3JlZSgpO1xuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHZpc2l0ZWRbal0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIOS7juavj+S4gOS4qumbtuWFpeW6pue7k+eCueW8gOWni+a3seW6puS8mOWFiOmBjeWOhlxuICAgICAgICAgICAgaWYgKHRoaXMudmVydGljZXNbaV0uaW5kZWdyZWUgPT09IDApIGRmcyh0aGlzLCBpLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdMb25nZXN0IFBhdGg6Jyk7XG4gICAgICAgIC8vIOi+k+WHuuacgOmVv+i3r+W+hFxuICAgICAgICBmb3IoaSA9IDA7IG1scFtpXTsgKytpKSBjb25zb2xlLmxvZyhtbHAuam9pbignLCcpKTtcblxuICAgICAgICBmdW5jdGlvbiBkZnMoZ3JhcGgsIGksIGxlbil7XG4gICAgICAgICAgICB2aXNpdGVkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhdGhbbGVuXSA9IGk7XG5cbiAgICAgICAgICAgIC8vIOaWsOeahOacgOmVv+i3r+W+hFxuICAgICAgICAgICAgaWYobGVuID4gbWF4TGVuICYmICFncmFwaC52ZXJ0aWNlc1tpXS5maXJzdEFyYykge1xuICAgICAgICAgICAgICAgIC8vIOS/neWtmOS4i+adpVxuICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPD0gbGVuOyArK2opIG1scFtqXSA9IHBhdGhbal07XG4gICAgICAgICAgICAgICAgbWF4TGVuID0gbGVuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IobGV0IHAgPSBncmFwaC52ZXJ0aWNlc1tpXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYyl7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3ID0gcC5hZGpWZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmKCF2aXNpdGVkW3ddKSBkZnMoZ3JhcGgsIHcsIGxlbiArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGF0aFtpXSA9IDA7XG4gICAgICAgICAgICB2aXNpdGVkW2ldID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDpgrvmjqXooajnmoTpgJLlvZLlvI/mt7HluqbkvJjlhYjpgY3ljoZcbiAgICBERlNUcmF2ZXJzZSh2aXNpdEZuKSB7XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSBkZnModGhpcywgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZnMoZ3JhcGgsIHYpIHtcbiAgICAgICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuICAgICAgICAgICAgdmlzaXRGbi5jYWxsKGdyYXBoLCB2KTtcblxuICAgICAgICAgICAgbGV0IHAgPSBncmFwaC52ZXJ0aWNlc1t2XS5maXJzdEFyYztcbiAgICAgICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW3AuYWRqVmV4XSkgZGZzKGdyYXBoLCBwLmFkalZleCk7XG5cbiAgICAgICAgICAgICAgICBwID0gcC5uZXh0QXJjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g6YK75o6l6KGo55qE6Z2e6YCS5b2S5rex5bqm5LyY5YWI5pCc57SiXG4gICAgREZTVHJhdmVyc2VfTm9uUmVjdXJzZSh2aXNpdEZuKSB7XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG4gICAgICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHZpc2l0ZWRbaV0gPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKHRoaXMsIGkpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHY7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCh2ID0gc3RhY2sucGVlaygpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwID0gdGhpcy52ZXJ0aWNlc1t2XS5maXJzdEFyYztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFtwLmFkalZleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkW3AuYWRqVmV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKHRoaXMsIHAuYWRqVmV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHAuYWRqVmV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBzdGFjay5wb3AoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dEFyYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g6YK75o6l6KGo55qE5bm/5bqm5LyY5YWI5pCc57SiXG4gICAgQkZTVHJhdmVyc2UodmlzaXRGbikge1xuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUXVldWUoKTtcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKGkpO1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbCh0aGlzLCBpKTtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5yZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3ID0gcXVldWUuZGVRdWV1ZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcCA9IHRoaXMudmVydGljZXNbd10uZmlyc3RBcmM7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC5hZGpWZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtwLmFkalZleF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbCh0aGlzLCBwLmFkalZleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShwLmFkalZleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRBcmM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDlu7rnq4vml6DlkJHlm77nmoTmt7HluqbkvJjlhYjnlJ/miJDmo67mnpfnmoTlranlrZDlhYTlvJ/pk77ooajmoJFcbiAgICBjcmVhdGVERlNGb3Jlc3QoKSB7XG4gICAgICAgIGxldCB0cmVlID0gbnVsbDtcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XG5cbiAgICAgICAgbGV0IHE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSB7XG4gICAgICAgICAgICAgICAgLy8g5paw55qE55Sf5oiQ5qCR55qE5qC557uT54K5XG4gICAgICAgICAgICAgICAgbGV0IHAgPSBuZXcgQ2hpbGRTaWJsaW5nVHJlZSh0aGlzLnZlcnRpY2VzW2ldLmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgLy8g56ys5LiA5qO155Sf5oiQ5qCR55qE5qC5XG4gICAgICAgICAgICAgICAgaWYgKCF0cmVlKSB0cmVlID0gcDtcbiAgICAgICAgICAgICAgICAvLyDlhbblroPnlJ/miJDmoJHnmoTmoLlcbiAgICAgICAgICAgICAgICBlbHNlIHEubmV4dFNpYmxpbmcgPSBwO1xuXG4gICAgICAgICAgICAgICAgLy8gceS4uuW9k+WJjeeUn+aIkOagkeeahOaguVxuICAgICAgICAgICAgICAgIHEgPSBwO1xuICAgICAgICAgICAgICAgIC8vIOW7uueri+S7pXDkuLrmoLnnmoTnlJ/miJDmoJFcbiAgICAgICAgICAgICAgICBERlNUcmVlKHRoaXMsIGksIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRyZWU7XG5cbiAgICAgICAgLy8g5Lul56ysduS4qumhtueCueinpuWPkea3seW6puS8mOWFiOmBjeWOhuWbvu+8jOW7uueri+S7pXRyZWXkuLrmoLnnmoTnlJ/miJDmoJFcbiAgICAgICAgZnVuY3Rpb24gREZTVHJlZShncmFwaCwgdiwgdHJlZSkge1xuICAgICAgICAgICAgdmlzaXRlZFt2XSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHcgPSBncmFwaC52ZXJ0aWNlc1t2XS5maXJzdEFyYztcbiAgICAgICAgICAgIGxldCBxO1xuXG4gICAgICAgICAgICB3aGlsZSAodykge1xuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFt3LmFkalZleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFt3LmFkalZleF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcCA9IG5ldyBDaGlsZFNpYmxpbmdUcmVlKGdyYXBoLnZlcnRpY2VzW3cuYWRqVmV4XS5kYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB35pivdueahOesrOS4gOS4quacquiiq+iuv+mXrueahOmCu+aOpee7k+eCuVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWUuZmlyc3RDaGlsZCA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHfmmK9255qE5YW25a6D5pyq6KKr6K6/6Zeu55qE6YK75o6l6aG254K5XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcS5uZXh0U2libGluZyA9IHA7XG5cbiAgICAgICAgICAgICAgICAgICAgcSA9IHA7XG5cbiAgICAgICAgICAgICAgICAgICAgREZTVHJlZShncmFwaCwgdy5hZGpWZXgsIHEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHcgPSB3Lm5leHRBcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVCRlNGb3Jlc3QoKSB7XG4gICAgICAgIGxldCB0cmVlID0gbnVsbDtcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcbiAgICAgICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xuXG4gICAgICAgIGxldCBxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkge1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUoaSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IG5ldyBDaGlsZFNpYmxpbmdUcmVlKHRoaXMudmVydGljZXNbaV0uZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmVlKSB0cmVlID0gbm9kZTtcbiAgICAgICAgICAgICAgICBlbHNlIHEubmV4dFNpYmxpbmcgPSBub2RlO1xuXG4gICAgICAgICAgICAgICAgcSA9IG5vZGU7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdyA9IHF1ZXVlLmRlUXVldWUoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHAgPSB0aGlzLnZlcnRpY2VzW3ddLmZpcnN0QXJjO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJlO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC5hZGpWZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFtwLmFkalZleF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUocC5hZGpWZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUyID0gbmV3IENoaWxkU2libGluZ1RyZWUodGhpcy52ZXJ0aWNlc1twLmFkalZleF0uZGF0YSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5maXJzdENoaWxkID0gbm9kZTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcHJlLm5leHRTaWJsaW5nID0gbm9kZTI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmUgPSBub2RlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRBcmM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG5cbiAgICBmaW5kQXJ0aWN1bCgpIHtcbiAgICAgICAgbGV0IHZpc2l0ZWQgPSBbXTtcbiAgICAgICAgbGV0IGNvdW50ID0gMTtcbiAgICAgICAgbGV0IGxvdyA9IFtdO1xuICAgICAgICBsb3dbMF0gPSBjb3VudDtcbiAgICAgICAgdmlzaXRlZFswXSA9IDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IDA7XG4gICAgICAgIGxldCBwID0gdGhpcy52ZXJ0aWNlc1swXS5maXJzdEFyYztcbiAgICAgICAgbGV0IHYgPSBwLmFkalZleDtcblxuICAgICAgICBERlNBcnRpY3VsKHRoaXMsIHYpO1xuICAgICAgICBpZiAoY291bnQgPCB0aGlzLnZleG51bSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coMCArICcgICcgKyB0aGlzLnZlcnRpY2VzWzBdLmRhdGEpO1xuICAgICAgICAgICAgd2hpbGUgKHAubmV4dEFyYykge1xuICAgICAgICAgICAgICAgIHAgPSBwLm5leHRBcmM7XG4gICAgICAgICAgICAgICAgdiA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkW3ZdID09PSAwKSBERlNBcnRpY3VsKHRoaXMsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gREZTQXJ0aWN1bChncmFwaCwgdjApIHtcbiAgICAgICAgICAgIGxldCBtaW4gPSB2aXNpdGVkW3YwXSA9ICsrY291bnQ7XG4gICAgICAgICAgICBmb3IgKGxldCBwID0gZ3JhcGgudmVydGljZXNbdjBdLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgbGV0IHcgPSBwLmFkalZleDtcbiAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFt3XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBERlNBcnRpY3VsKGdyYXBoLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd1t3XSA8IG1pbikgbWluID0gbG93W3ddO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG93W3ddID49IHZpc2l0ZWRbdjBdKSBjb25zb2xlLmxvZyh2MCArICcgICcgKyBncmFwaC52ZXJ0aWNlc1t2MF0uZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aXNpdGVkW3ddIDwgbWluKSBtaW4gPSB2aXNpdGVkW3ddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG93W3YwXSA9IG1pbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIOe7n+iuoeWQhOmhtueCueWFpeW6pueahOWHveaVsFxuICAgIGNvdW50SW5kZWdyZWUoKSB7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy52ZXhudW07ICsraykgdGhpcy52ZXJ0aWNlc1trXS5pbmRlZ3JlZSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLnZleG51bTsgKytrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpcy52ZXJ0aWNlc1trXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYylcbiAgICAgICAgICAgICAgICArK3RoaXMudmVydGljZXNbcC5hZGpWZXhdLmluZGVncmVlO1xuICAgICAgICB9XG4gICAgfVxuXG4vLyDmi5PmiZHmjpLluo/nrpfms5VcbiAgICB0b3BvbG9naWNTb3J0KCkge1xuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgICAgdGhpcy50b3BvbG9naWNhbE9yZGVyID0gW107XG4gICAgICAgIHRoaXMuY291bnRJbmRlZ3JlZSgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmVydGljZXNbaV0uaW5kZWdyZWUgPT09IDApIHN0YWNrLnB1c2goaSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy50b3BvbG9naWNhbE9yZGVyLnB1c2goaSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnZlcnRpY2VzW2ldLmRhdGEpO1xuICAgICAgICAgICAgKytjb3VudDtcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW2ldLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgbGV0IGsgPSBwLmFkalZleDtcbiAgICAgICAgICAgICAgICBpZiAoLS10aGlzLnZlcnRpY2VzW2tdLmluZGVncmVlID09PSAwKSBzdGFjay5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChjb3VudCA+PSB0aGlzLnZleG51bSk7XG4gICAgfVxuXG4gICAgLy8g6L6T5Ye65pyJ5ZCR5Zu+55qE5ZCE6aG55YWz6ZSu5rS75YqoXG4gICAgY3JpdGljYWxQYXRoKCkge1xuICAgICAgICBpZiAoIXRoaXMudG9wb2xvZ2ljU29ydCgpKSB0aHJvdyBuZXcgRXJyb3IoJ0FPRee9keS4reWtmOWcqOWbnui3r++8gScpO1xuXG4gICAgICAgIGxldCB2ZSA9IFtdO1xuICAgICAgICAvLyDkuovku7bmnIDml6nlj5HnlJ/ml7bpl7TliJ3lp4vljJZcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB2ZVtqXSA9IDA7XG4gICAgICAgIC8vIOiuoeeul+avj+S4quS6i+S7tueahOacgOaXqeWPkeeUn+aXtumXtHZl5YC8XG4gICAgICAgIGZvciAobGV0IG0gPSAwOyBtIDwgdGhpcy52ZXhudW07ICsrbSkge1xuICAgICAgICAgICAgbGV0IGogPSB0aGlzLnRvcG9sb2dpY2FsT3JkZXJbbV07XG4gICAgICAgICAgICBmb3IgKGxldCBwID0gdGhpcy52ZXJ0aWNlc1tqXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYykge1xuICAgICAgICAgICAgICAgIGxldCBrID0gcC5hZGpWZXg7XG4gICAgICAgICAgICAgICAgaWYgKHZlW2pdICsgcC5pbmZvID4gdmVba10pIHZlW2tdID0gdmVbal0gKyBwLmluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZsID0gW107XG4gICAgICAgIC8vIOS6i+S7tuacgOaZmuWPkeeUn+aXtumXtOWIneWni+WMllxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHZsW2pdID0gdmVbdGhpcy52ZXhudW0gLSAxXTtcbiAgICAgICAgLy8g6K6h566X5q+P5Liq5LqL5Lu255qE5pyA5pma5Y+R55Sf5pe26Ze0dmznmoTlgLxcbiAgICAgICAgZm9yIChsZXQgbSA9IHRoaXMudmV4bnVtIC0gMTsgbSA+PSAwOyAtLW0pIHtcbiAgICAgICAgICAgIGxldCBqID0gdGhpcy50b3BvbG9naWNhbE9yZGVyW21dO1xuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbal0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICBsZXQgayA9IHAuYWRqVmV4O1xuICAgICAgICAgICAgICAgIGlmICh2bFtrXSAtIHAuaW5mbyA8IHZsW2pdKSB2bFtqXSA9IHZsW2tdIC0gcC5pbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIOi+k+WHuuaJgOacieWFs+mUrua0u+WKqFxuICAgICAgICBmb3IgKGxldCBtID0gMDsgbSA8IHRoaXMudmV4bnVtOyArK20pIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW21dLmZpcnN0QXJjOyBwOyBwID0gcC5uZXh0QXJjKSB7XG4gICAgICAgICAgICAgICAgbGV0IGsgPSBwLmFkalZleDtcbiAgICAgICAgICAgICAgICBpZiAodmVbbV0gKyBwLmluZm8gPT09IHZsW2tdKSBjb25zb2xlLmxvZygnPCVkLCAlZD4nLCBtLCBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNob3J0ZXN0UGF0aF9EaWprc3RyYSh2MCkge1xuICAgICAgICBsZXQgZGlzdCA9IFtdO1xuICAgICAgICBsZXQgcHJlID0gW107XG4gICAgICAgIGxldCBmaW5hbCA9IFtdO1xuICAgICAgICBsZXQgdztcblxuICAgICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHRoaXMudmV4bnVtOyArK3YpXG4gICAgICAgICAgICBkaXN0W3ZdID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAobGV0IHAgPSB0aGlzLnZlcnRpY2VzW3YwXS5maXJzdEFyYzsgcDsgcCA9IHAubmV4dEFyYylcbiAgICAgICAgICAgIGRpc3RbcC5hZGpWZXhdID0gcC5pbmZvO1xuXG4gICAgICAgIGxldCB2O1xuICAgICAgICBmb3IgKHYgPSAwOyB2IDwgdGhpcy52ZXhudW07ICsrdikge1xuICAgICAgICAgICAgZmluYWxbdl0gPSBmYWxzZTtcbiAgICAgICAgICAgIHByZVt2XSA9IHByZVt2XSB8fCBbXTtcbiAgICAgICAgICAgIGZvciAodyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSBwcmVbdl1bd10gPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGRpc3Rbdl0gPCBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHByZVt2XVt2MF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZVt2XVt2XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkaXN0W3YwXSA9IDA7XG4gICAgICAgIGZpbmFsW3YwXSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBsZXQgbWluID0gSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKHcgPSAwOyB3IDwgdGhpcy52ZXhudW07ICsrdykge1xuICAgICAgICAgICAgICAgIGlmICghZmluYWxbd10gJiYgZGlzdFt3XSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICB2ID0gdztcbiAgICAgICAgICAgICAgICAgICAgbWluID0gZGlzdFt3XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbmFsW3ZdID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMudmVydGljZXNbdl0uZmlyc3RBcmM7IHA7IHAgPSBwLm5leHRBcmMpIHtcbiAgICAgICAgICAgICAgICB3ID0gcC5hZGpWZXg7XG4gICAgICAgICAgICAgICAgaWYgKCFmaW5hbFt3XSAmJiBtaW4gKyBwLmluZm8gPCBkaXN0W3ddKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Rbd10gPSBtaW4gKyBwLmluZm87XG4gICAgICAgICAgICAgICAgICAgIHByZVt3XSA9IHByZVt2XTtcbiAgICAgICAgICAgICAgICAgICAgcHJlW3ddW3ddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhmaW5hbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHByZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGRpc3QpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaW5hbDogZmluYWwsXG4gICAgICAgICAgICBwcmU6IHByZSxcbiAgICAgICAgICAgIGRpc3Q6IGRpc3RcbiAgICAgICAgfTtcbiAgICB9XG59XG5cblxuLy8g5peg5ZCR5Zu+55qE6YK75o6l6KGoXG52YXIgYWRqTGlzdEdyYXBoID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgVURHKTtcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3YxJyk7XG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2MicpO1xuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjMnKTtcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3Y0Jyk7XG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2NScpO1xuXG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MScsICd2MicpO1xuYWRqTGlzdEdyYXBoLmFkZEFyYygndjEnLCAndjMnKTtcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YxJywgJ3Y0Jyk7XG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MicsICd2MycpO1xuYWRqTGlzdEdyYXBoLmFkZEFyYygndjMnLCAndjQnKTtcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YzJywgJ3Y1Jyk7XG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2NCcsICd2NScpO1xuXG5jb25zb2xlLmxvZyhhZGpMaXN0R3JhcGgpO1xuXG4vLyDmnInlkJHlm77nmoTpgIbpgrvmjqXooahcbnZhciBnID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xuZy5hZGRWZXJ0ZXgoJ3YxJyk7XG5nLmFkZFZlcnRleCgndjInKTtcbmcuYWRkVmVydGV4KCd2MycpO1xuZy5hZGRWZXJ0ZXgoJ3Y0Jyk7XG5nLmFkZFZlcnRleCgndjUnKTtcblxuZy5hZGRBcmMoJ3YxJywgJ3YyJyk7XG5nLmFkZEFyYygndjEnLCAndjQnKTtcbmcuYWRkQXJjKCd2MycsICd2MicpO1xuZy5hZGRBcmMoJ3YzJywgJ3YxJyk7XG5nLmFkZEFyYygndjQnLCAndjMnKTtcbmcuYWRkQXJjKCd2MycsICd2NScpO1xuZy5hZGRBcmMoJ3Y1JywgJ3Y0Jyk7XG5cbmNvbnNvbGUubG9nKGcpO1xuXG4vLyDmnInlkJHlm77nmoTmraPpgrvmjqXooahcbnZhciBnID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xuZy5hZGRWZXJ0ZXgoJ3YxJyk7XG5nLmFkZFZlcnRleCgndjInKTtcbmcuYWRkVmVydGV4KCd2MycpO1xuZy5hZGRWZXJ0ZXgoJ3Y0Jyk7XG5nLmFkZFZlcnRleCgndjUnKTtcblxuZy5hZGRBcmMoJ3YyJywgJ3YxJyk7XG5nLmFkZEFyYygndjQnLCAndjEnKTtcbmcuYWRkQXJjKCd2MicsICd2MycpO1xuZy5hZGRBcmMoJ3YxJywgJ3YzJyk7XG5nLmFkZEFyYygndjMnLCAndjQnKTtcbmcuYWRkQXJjKCd2NScsICd2MycpO1xuZy5hZGRBcmMoJ3Y0JywgJ3Y1Jyk7XG5cbmNvbnNvbGUubG9nKGcpO1xuXG5cblxuXG5jb25zb2xlLmxvZygnYWRqTGlzdEdyYXBoIERGU1RyYXZlcnNlOiAnKTtcbnZhciBhZGpMaXN0R3JhcGggPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCAwLCAwLCBVREcpO1xuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjEnKTtcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3YyJyk7XG5hZGpMaXN0R3JhcGguYWRkVmVydGV4KCd2MycpO1xuYWRqTGlzdEdyYXBoLmFkZFZlcnRleCgndjQnKTtcbmFkakxpc3RHcmFwaC5hZGRWZXJ0ZXgoJ3Y1Jyk7XG5cbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3Y1JywgJ3Y0Jyk7XG5hZGpMaXN0R3JhcGguYWRkQXJjKCd2MycsICd2MicpO1xuYWRqTGlzdEdyYXBoLmFkZEFyYygndjInLCAndjEnKTtcbmFkakxpc3RHcmFwaC5hZGRBcmMoJ3YzJywgJ3YxJyk7XG5cbmFkakxpc3RHcmFwaC5ERlNUcmF2ZXJzZShmdW5jdGlvbiAodikge1xuICAgIGNvbnNvbGUubG9nKHRoaXMudmVydGljZXNbdl0uZGF0YSk7XG59KTtcblxuXG5cbmNvbnNvbGUubG9nKCdhZGpMaXN0R3JhcGggREZTVHJhdmVyc2VfTm9uUmVjdXJzZTogJyk7XG5hZGpMaXN0R3JhcGguREZTVHJhdmVyc2VfTm9uUmVjdXJzZShmdW5jdGlvbiAodikge1xuICAgIGNvbnNvbGUubG9nKHRoaXMudmVydGljZXNbdl0uZGF0YSk7XG59KTtcblxuXG5cbmNvbnNvbGUubG9nKCdhZGpMaXN0R3JhcGggQkZTVHJhdmVyc2U6ICcpO1xudmFyIGcyID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xuZzIuYWRkVmVydGV4KCd2MScpO1xuZzIuYWRkVmVydGV4KCd2MicpO1xuZzIuYWRkVmVydGV4KCd2MycpO1xuZzIuYWRkVmVydGV4KCd2NCcpO1xuZzIuYWRkVmVydGV4KCd2NScpO1xuXG5nMi5hZGRBcmMoJ3Y0JywgJ3YxJyk7XG5nMi5hZGRBcmMoJ3YyJywgJ3YxJyk7XG5nMi5hZGRBcmMoJ3Y1JywgJ3YzJyk7XG5nMi5hZGRBcmMoJ3YyJywgJ3YzJyk7XG5nMi5hZGRBcmMoJ3YxJywgJ3YzJyk7XG5nMi5hZGRBcmMoJ3YzJywgJ3Y0Jyk7XG5nMi5hZGRBcmMoJ3Y0JywgJ3Y1Jyk7XG5cbmcyLkJGU1RyYXZlcnNlKGZ1bmN0aW9uICh2KSB7XG4gICAgY29uc29sZS5sb2codGhpcy52ZXJ0aWNlc1t2XS5kYXRhKTtcbn0pO1xuXG5jb25zb2xlLmxvZygnREZTOiBleHBlY3QgZmFsc2U6ICcgKyBhZGpMaXN0R3JhcGguZXhpc3RQYXRoREZTKCd2MScsICd2NCcpKTtcbmNvbnNvbGUubG9nKCdERlM6IGV4cGVjdCB0cnVlOiAnICsgYWRqTGlzdEdyYXBoLmV4aXN0UGF0aERGUygndjEnLCAndjInKSk7XG5cbmNvbnNvbGUubG9nKCdCRlMgOiBleHBlY3QgZmFsc2U6ICcgKyBhZGpMaXN0R3JhcGguZXhpc3RQYXRoQkZTKCd2MScsICd2NCcpKTtcbmNvbnNvbGUubG9nKCdCRlMgOmV4cGVjdCB0cnVlOiAnICsgYWRqTGlzdEdyYXBoLmV4aXN0UGF0aEJGUygndjEnLCAndjInKSk7XG5cblxuXG4vKlxuIOWbvueahOi/numAmuaAp+mXrumimFxuXG4g5peg5ZCR5Zu+55qE6L+e6YCa5YiG6YeP5LiO55Sf5oiQ5qCRXG5cbiAxIOaXoOWQkeWbvueahOi/numAmuWIhumHj+WSjOeUn+aIkOagkVxuIOWvueS6juaXoOWQkeWbvu+8jOWvueWFtui/m+ihjOmBjeWOhuaXtu+8mlxuIOKXhiDoi6XmmK/ov57pgJrlm77vvJrku4XpnIDku47lm77kuK3ku7vkuIDpobbngrnlh7rlj5HvvIzlsLHog73orr/pl67lm77kuK3nmoTmiYDmnInpobbngrnvvJtcbiDil4Yg6Iul5piv6Z2e6L+e6YCa5Zu+77ya6ZyA5LuO5Zu+5Lit5aSa5Liq6aG254K55Ye65Y+R44CC5q+P5qyh5LuO5LiA5Liq5paw6aG254K55Ye65Y+R5omA6K6/6Zeu55qE6aG254K56ZuG5bqP5YiX5oGw5aW95piv5ZCE5Liq6L+e6YCa5YiG6YeP55qE6aG254K56ZuG77ybXG5cbiDikbQg6IulRz0oVixFKeaYr+aXoOWQkei/numAmuWbvu+8jCDpobbngrnpm4blkozovrnpm4bliIbliKvmmK9WKEcpIO+8jEUoRykg44CC6Iul5LuOR+S4reS7u+aEj+eCueWHuuWPkemBjeWOhuaXtu+8jCBFKEcp6KKr5YiG5oiQ5Lik5Liq5LqS5LiN55u45Lqk55qE6ZuG5ZCI77yaXG4gVChHKSDvvJrpgY3ljobov4fnqIvkuK3miYDnu4/ov4fnmoTovrnnmoTpm4blkIjvvJtcbiBCKEcpIO+8mumBjeWOhui/h+eoi+S4reacque7j+i/h+eahOi+ueeahOmbhuWQiO+8m1xuIOaYvueEtu+8miBFKEcpPVQoRyniiKpCKEcpIO+8jFQoRyniiKlCKEcpPcOYXG4g5pi+54S277yM5Zu+R+KAmT0oViwgVChHKSnmmK9H55qE5p6B5bCP6L+e6YCa5a2Q5Zu+77yM5LiUR+KAmeaYr+S4gOajteagkeOAgkfigJnnp7DkuLrlm75H55qE5LiA5qO155Sf5oiQ5qCR44CCXG4g5LuO5Lu75oSP54K55Ye65Y+R5oyJREZT566X5rOV5b6X5Yiw55Sf5oiQ5qCRR+KAmeensOS4uua3seW6puS8mOWFiOeUn+aIkOagke+8m+aMiUJGU+eul+azleW+l+WIsOeahEfigJnnp7DkuLrlub/luqbkvJjlhYjnlJ/miJDmoJHjgIJcblxuIOKRtSAg6IulRz0oVixFKeaYr+aXoOWQkemdnui/numAmuWbvu+8jOWvueWbvui/m+ihjOmBjeWOhuaXtuW+l+WIsOiLpeW5suS4qui/numAmuWIhumHj+eahOmhtueCuembhu+8mlYxKEcpICxWMihHKSAs4oCmLFZuKEcp5ZKM55u45bqU5omA57uP6L+H55qE6L656ZuG77yaVDEoRykgLFQyKEcpICwg4oCmLFRuKEcpIOOAglxuIOWImeWvueW6lOeahOmhtueCuembhuWSjOi+uembhueahOS6jOWFg+e7hO+8mkdpPShWaShHKSxUaShHKSlcbiAoMeKJpmniiaZuKeaYr+WvueW6lOWIhumHj+eahOeUn+aIkOagke+8jOaJgOaciei/meS6m+eUn+aIkOagkeaehOaIkOS6huWOn+adpemdnui/numAmuWbvueahOeUn+aIkOajruael+OAglxuXG4g6K+05piO77ya5b2T57uZ5a6a5peg5ZCR5Zu+6KaB5rGC55S75Ye65YW25a+55bqU55qE55Sf5oiQ5qCR5oiW55Sf5oiQ5qOu5p6X5pe277yM5b+F6aG75YWI57uZ5Ye655u45bqU55qE6YK75o6l6KGo77yM54S25ZCO5omN6IO95qC55o2u6YK75o6l6KGo55S75Ye65YW25a+55bqU55qE55Sf5oiQ5qCR5oiW55Sf5oiQ5qOu5p6X44CCXG5cblxuIDIgIOWbvueahOeUn+aIkOagkeWSjOeUn+aIkOajruael+eul+azlVxuXG4g5a+55Zu+55qE5rex5bqm5LyY5YWI5pCc57Si6YGN5Y6GREZTKOaIlkJGUynnrpfms5XnqI3kvZzkv67mlLnvvIzlsLHlj6/lvpfliLDmnoTpgKDlm77nmoRERlPnlJ/miJDmoJHnrpfms5XjgIJcbiDlnKjnrpfms5XkuK3vvIzmoJHnmoTlrZjlgqjnu5PmnoTph4fnlKjlranlrZDigJTlhYTlvJ/ooajnpLrms5XjgILpppblhYjlu7rnq4vku47mn5DkuKrpobbngrlW5Ye65Y+R77yM5bu656uL5LiA5Liq5qCR57uT54K577yM54S25ZCO5YaN5YiG5Yir5LulVueahOmCu+aOpeeCueS4uui1t+Wni+eCue+8jOW7uueri+ebuOW6lOeahOWtkOeUn+aIkOagke+8jOW5tuWwhuWFtuS9nOS4ulYg57uT54K555qE5a2Q5qCR6ZO+5o6l5YiwVue7k+eCueS4iuOAguaYvueEtu+8jOeul+azleaYr+S4gOS4qumAkuW9kueul+azleOAglxuXG4gKi9cblxuXG5cblxuY29uc29sZS5sb2coYWRqTGlzdEdyYXBoLmNyZWF0ZURGU0ZvcmVzdCgpKTtcblxuXG5cblxuY29uc29sZS5sb2coYWRqTGlzdEdyYXBoLmNyZWF0ZUJGU0ZvcmVzdCgpKTtcblxuXG5cbi8qXG4g5Zyo5p+Q5Zu+5Lit77yM6Iul5Yig6Zmk6aG254K5VuS7peWPilbnm7jlhbPnmoTovrnlkI7vvIzlm77nmoTkuIDkuKrov57pgJrliIbph4/liIblibLkuLrkuKTkuKrmiJbkuKTkuKrku6XkuIrnmoTov57pgJrliIbph4/vvIzliJnnp7DpobbngrlW5Li66K+l5Zu+55qE5LiA5Liq5YWz6IqC54K544CC5LiA5Liq5rKh5pyJ5YWz6IqC54K555qE6L+e6YCa5Zu+56ew5Li66YeN6L+e6YCa5Zu+44CCXG4g5Zyo6YeN6L+e6YCa5Zu+5Lit77yM5Lu75oSP5LiA5a+56aG254K55LmL6Ze06Iez5bCR5a2Y5Zyo5Lik5p2h6Lev5b6E77yM5YiZ5YaN5Yig5Y675p+Q5Liq6aG254K55Y2z55u45YWz5ZCE6L655ZCO5Lmf5LiN56C05Z2P5Zu+55qE6L+e6YCa5oCn44CC6Iul5Zyo5Zu+55qE6L+e6YCa5Zu+5LiK5Yig5Y67a+S4quiKgueCueaJjeiDveegtOWdj+WbvueahOi/numAmuaAp++8jOWImeensEvkuLrmraTlm77nmoTov57pgJrluqbjgIJcbiDku5bku6zluLjluLjlnKjpgJrkv6HnvZHnu5znmoTlm77miJboiKrnqbrnvZHkuK3lupTnlKjvvIxL6LaK5aSn77yM57O757uf6LaK56iz5a6a77yM5Y+N5LmL77yM5oiY5LqJ5Lit6Iul6KaB5pGn5q+B5pWM5pa555qE6L+Q6L6T57q/77yM5Y+q6aG756C05Z2P5YW26L+Q6L6T572R5Lit55qE5YWz6IqC54K55Y2z5Y+v44CCXG4gKi9cblxuXG5cbnZhciBhcnRpY3VsVGVzdCA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIDAsIDAsIFVERyk7XG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0EnKTtcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnQicpO1xuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdDJyk7XG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0QnKTtcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnRScpO1xuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdGJyk7XG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0cnKTtcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnSCcpO1xuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdJJyk7XG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ0onKTtcbmFydGljdWxUZXN0LmFkZFZlcnRleCgnSycpO1xuYXJ0aWN1bFRlc3QuYWRkVmVydGV4KCdMJyk7XG5hcnRpY3VsVGVzdC5hZGRWZXJ0ZXgoJ00nKTtcblxuYXJ0aWN1bFRlc3QuYWRkQXJjKCdBJywgJ0InKTtcbmFydGljdWxUZXN0LmFkZEFyYygnQScsICdDJyk7XG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0EnLCAnRicpO1xuYXJ0aWN1bFRlc3QuYWRkQXJjKCdBJywgJ0wnKTtcbmFydGljdWxUZXN0LmFkZEFyYygnQycsICdCJyk7XG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0QnLCAnQicpO1xuYXJ0aWN1bFRlc3QuYWRkQXJjKCdHJywgJ0InKTtcbmFydGljdWxUZXN0LmFkZEFyYygnSCcsICdCJyk7XG5hcnRpY3VsVGVzdC5hZGRBcmMoJ00nLCAnQicpO1xuYXJ0aWN1bFRlc3QuYWRkQXJjKCdEJywgJ0UnKTtcbmFydGljdWxUZXN0LmFkZEFyYygnRycsICdIJyk7XG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0cnLCAnSScpO1xuYXJ0aWN1bFRlc3QuYWRkQXJjKCdHJywgJ0snKTtcbmFydGljdWxUZXN0LmFkZEFyYygnSCcsICdLJyk7XG5hcnRpY3VsVGVzdC5hZGRBcmMoJ0onLCAnTCcpO1xuYXJ0aWN1bFRlc3QuYWRkQXJjKCdKJywgJ00nKTtcbmFydGljdWxUZXN0LmFkZEFyYygnTCcsICdNJyk7XG5cbmFydGljdWxUZXN0LmZpbmRBcnRpY3VsKCk7XG5cblxuLypcbiDmnInlkJHml6Dnjq/lm77lj4rlhbblupTnlKhcblxuIOacieWQkeaXoOeOr+WbvihEaXJlY3RlZCBBY3ljbGluZyBHcmFwaCnvvJrmmK/lm77kuK3msqHmnInlm57ot68o546vKeeahOacieWQkeWbvuOAguaYr+S4gOexu+WFt+acieS7o+ihqOaAp+eahOWbvu+8jOS4u+imgeeUqOS6jueglOeptuW3peeoi+mhueebrueahOW3peW6j+mXrumimOOAgeW3peeoi+aXtumXtOi/m+W6pumXrumimOetieOAglxuXG4g5LiA5Liq5bel56iLKHByb2plY3Qp6YO95Y+v5YiG5Li66Iul5bmy5Liq56ew5Li65rS75YqoKGFjdGl2ZSnnmoTlrZDlt6XnqIso5oiW5bel5bqPKe+8jOWQhOS4quWtkOW3peeoi+WPl+WIsOS4gOWumueahOadoeS7tue6puadn++8muafkOS4quWtkOW3peeoi+W/hemhu+W8gOWni+S6juWPpuS4gOS4quWtkOW3peeoi+WujOaIkOS5i+WQju+8m+aVtOS4quW3peeoi+acieS4gOS4quW8gOWni+eCuSjotbfngrkp5ZKM5LiA5Liq57uI54K544CC5Lq65Lus5YWz5b+D77yaXG4g4peGIOW3peeoi+iDveWQpumhuuWIqeWujOaIkD/lvbHlk43lt6XnqIvnmoTlhbPplK7mtLvliqjmmK/ku4DkuYg/XG4g4peGIOS8sOeul+aVtOS4quW3peeoi+WujOaIkOaJgOW/hemhu+eahOacgOefreaXtumXtOaYr+WkmuWwkT9cblxuIOWvueW3peeoi+eahOa0u+WKqOWKoOS7peaKveixoe+8muWbvuS4remhtueCueihqOekuua0u+WKqO+8jOacieWQkei+ueihqOekuua0u+WKqOS5i+mXtOeahOS8mOWFiOWFs+ezu++8jOi/meagt+eahOacieWQkeWbvuensOS4uumhtueCueihqOekuua0u+WKqOeahOe9kShBY3Rpdml0eSBPbiBWZXJ0ZXggTmV0d29yayDvvIxBT1bnvZEpIOOAglxuXG5cbiDmi5PmiZHmjpLluo9cblxuIDEg5a6a5LmJXG4g5ouT5omR5o6S5bqPKFRvcG9sb2dpY2FsIFNvcnQpIO+8mueUseafkOS4qumbhuWQiOS4iueahOS4gOS4quWBj+W6j+W+l+WIsOivpembhuWQiOS4iueahOS4gOS4quWFqOW6j+eahOaTjeS9nOOAglxuXG4g4peGIOmbhuWQiOS4iueahOWFs+ezu++8mumbhuWQiEHkuIrnmoTlhbPns7vmmK/ku45B5YiwQeeahOWFs+ezuyhB74K0QSkg44CCXG4g4peGIOWFs+ezu+eahOiHquWPjeaAp++8muiLpe+AomHiiIhB5pyJKGHvvIxhKeKIiFLvvIznp7Dpm4blkIhB5LiK55qE5YWz57O7UuaYr+iHquWPjeeahOOAglxuIOKXhiDlhbPns7vnmoTlr7nnp7DmgKfvvJrlpoLmnpzlr7nkuo5h77yMYuKIiEEg77yM5Y+q6KaB5pyJKGHvvIxiKeKIiFLlsLHmnIkoYu+8jGEp4oiIUiDvvIznp7Dpm4blkIhB5LiK55qE5YWz57O7UuaYr+WvueensOeahOOAglxuIOKXhiDlhbPns7vnmoTlr7nnp7DmgKfkuI7lj43lr7nnp7DmgKfvvJrlpoLmnpzlr7nkuo5h77yMYuKIiEEg77yM5Y+q6KaB5pyJKGHvvIxiKeKIiFLlsLHmnIkoYu+8jGEp4oiIUiDvvIznp7Dpm4blkIhB5LiK55qE5YWz57O7UuaYr+WvueensOeahOOAguWmguaenOWvueS6jmHvvIxi4oiIQSDvvIzku4XlvZNhPWLml7bmnIkoYe+8jGIp4oiIUuWSjChi77yMYSniiIhSIO+8jOensOmbhuWQiEHkuIrnmoTlhbPns7tS5piv5Y+N5a+556ew55qE44CCXG4g4peGIOWFs+ezu+eahOS8oOmAkuaAp++8muiLpWHvvIxi77yMY+KIiEHvvIzoi6UoYe+8jGIp4oiIUu+8jOW5tuS4lChi77yMYyniiIhSIO+8jOWImShh77yMYyniiIhSIO+8jOensOmbhuWQiEHkuIrnmoTlhbPns7tS5piv5Lyg6YCS55qE44CCXG4g4peGIOWBj+W6j++8muiLpembhuWQiEHkuIrnmoTlhbPns7tS5piv6Ieq5Y+N55qE77yM5Y+N5a+556ew55qE5ZKM5Lyg6YCS55qE77yM5YiZ56ewUuaYr+mbhuWQiEHkuIrnmoTlgY/luo/lhbPns7vjgIJcbiDil4Yg5YWo5bqP77ya6K6+UuaYr+mbhuWQiEHkuIrnmoTlgY/luo/lhbPns7vvvIzvgKJh77yMYuKIiEHvvIzlv4XmnIlhUmLmiJZiUmHvvIwg5YiZ56ewUuaYr+mbhuWQiEHkuIrnmoTlhajluo/lhbPns7vjgIJcblxuIOWNs+WBj+W6j+aYr+aMh+mbhuWQiOS4reS7heaciemDqOWIhuWFg+e0oOS5i+mXtOWPr+S7peavlOi+g++8jOiAjOWFqOW6j+aYr+aMh+mbhuWQiOS4reS7u+aEj+S4pOS4quWFg+e0oOS5i+mXtOmDveWPr+S7peavlOi+g+OAglxuIOWcqEFPVue9keS4re+8jOiLpeacieacieWQkei+uTxpLCBqPu+8jOWImWnmmK9q55qE55u05o6l5YmN6amx77yMauaYr2nnmoTnm7TmjqXlkI7nu6fvvJvmjqjogIzlub/kuYvvvIzoi6Xku47pobbngrlp5Yiw6aG254K5auacieacieWQkei3r+W+hO+8jOWImWnmmK9q55qE5YmN6amx77yMauaYr2nnmoTlkI7nu6fjgIJcbiDlnKhBT1bnvZHkuK3vvIzkuI3og73mnInnjq/vvIzlkKbliJnvvIzmn5DpobnmtLvliqjog73lkKbov5vooYzmmK/ku6Xoh6rouqvnmoTlrozmiJDkvZzkuLrliY3mj5DmnaHku7bjgIJcbiDmo4Dmn6Xmlrnms5XvvJrlr7nmnInlkJHlm77nmoTpobbngrnov5vooYzmi5PmiZHmjpLluo/vvIzoi6XmiYDmnInpobbngrnpg73lnKjlhbbmi5PmiZHmnInluo/luo/liJfkuK3vvIzliJnml6Dnjq/jgIJcbiDmnInlkJHlm77nmoTmi5PmiZHmjpLluo/vvJrmnoTpgKBBT1bnvZHkuK3pobbngrnnmoTkuIDkuKrmi5PmiZHnur/mgKfluo/liJcoduKAmTEsduKAmTIsIOKLryx24oCZbinvvIzkvb/lvpfor6Xnur/mgKfluo/liJfkuI3ku4Xkv53mjIHljp/mnaXmnInlkJHlm77kuK3pobbngrnkuYvpl7TnmoTkvJjlhYjlhbPns7vvvIzogIzkuJTlr7nljp/lm77kuK3msqHmnInkvJjlhYjlhbPns7vnmoTpobbngrnkuYvpl7TkuZ/lu7rnq4vkuIDnp40o5Lq65Li655qEKeS8mOWFiOWFs+ezu+OAglxuXG4gMiDmi5PmiZHmjpLluo/nrpfms5VcbiDnrpfms5XmgJ3mg7NcblxuIOKRoCDlnKhBT1bnvZHkuK3pgInmi6nkuIDkuKrmsqHmnInliY3pqbHnmoTpobbngrnkuJTovpPlh7rvvJtcbiDikaEg5ZyoQU9W572R5Lit5Yig6Zmk6K+l6aG254K55Lul5Y+K5LuO6K+l6aG254K55Ye65Y+R55qEKOS7peivpemhtueCueS4uuWwvueahOW8pynmiYDmnInmnInlkJHlvKco6L65KSDvvJtcbiDikaIg6YeN5aSN4pGg44CB4pGh77yM55u05Yiw5Zu+5Lit5YWo6YOo6aG254K56YO95bey6L6T5Ye6KOWbvuS4reaXoOeOrynmiJblm77kuK3kuI3lrZjlnKjml6DliY3pqbHnmoTpobbngrko5Zu+5Lit5b+F5pyJ546vKeOAglxuXG4gMyAg566X5rOV5a6e546w6K+05piOXG4g4peGIOmHh+eUqOato+mCu+aOpemTvuS9nOS4ukFPVue9keeahOWtmOWCqOe7k+aehO+8m1xuIOKXhiDorr7nq4vloIbmoIjvvIznlKjmnaXmmoLlrZjlhaXluqbkuLow55qE6aG254K577ybXG4g4peGIOWIoOmZpOmhtueCueS7peWug+S4uuWwvueahOW8p++8muW8p+WktOmhtueCueeahOWFpeW6puWHjzHjgIJcblxuIOaVtOS4queul+azleeahOaXtumXtOWkjeadguW6puaYr08obitlKSDjgIJcblxuICovXG5cbnZhciB0b3BvbG9naWNUZXN0ID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xudG9wb2xvZ2ljVGVzdC5hZGRWZXJ0ZXgoJ3YxJyk7XG50b3BvbG9naWNUZXN0LmFkZFZlcnRleCgndjInKTtcbnRvcG9sb2dpY1Rlc3QuYWRkVmVydGV4KCd2MycpO1xudG9wb2xvZ2ljVGVzdC5hZGRWZXJ0ZXgoJ3Y0Jyk7XG50b3BvbG9naWNUZXN0LmFkZFZlcnRleCgndjUnKTtcbnRvcG9sb2dpY1Rlc3QuYWRkVmVydGV4KCd2NicpO1xuXG50b3BvbG9naWNUZXN0LmFkZEFyYygndjInLCAndjEnKTtcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2NCcsICd2MScpO1xudG9wb2xvZ2ljVGVzdC5hZGRBcmMoJ3YzJywgJ3YxJyk7XG50b3BvbG9naWNUZXN0LmFkZEFyYygndjInLCAndjMnKTtcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2NScsICd2MycpO1xudG9wb2xvZ2ljVGVzdC5hZGRBcmMoJ3Y0JywgJ3Y2Jyk7XG50b3BvbG9naWNUZXN0LmFkZEFyYygndjUnLCAndjQnKTtcbnRvcG9sb2dpY1Rlc3QuYWRkQXJjKCd2NScsICd2NicpO1xuXG5jb25zb2xlLmxvZygndG9wb2xvZ2ljU29ydDogJyk7XG5jb25zb2xlLmxvZyh0b3BvbG9naWNUZXN0LnRvcG9sb2dpY1NvcnQoKSk7XG5cblxuXG4vKlxuIOWFs+mUrui3r+W+hChDcml0aWNhbCBQYXRoKVxuXG4g5LiOQU9W572R55u45a+55bqU55qE5pivQU9FKEFjdGl2aXR5IE9uIEVkZ2UpIO+8jOaYr+i+ueihqOekuua0u+WKqOeahOacieWQkeaXoOeOr+Wbvu+8jOWmguWbvjctMjTmiYDnpLrjgILlm77kuK3pobbngrnooajnpLrkuovku7YoRXZlbnQp77yM5q+P5Liq5LqL5Lu26KGo56S65Zyo5YW25YmN55qE5omA5pyJ5rS75Yqo5bey57uP5a6M5oiQ77yM5YW25ZCO55qE5rS75Yqo5Y+v5Lul5byA5aeL77yb5byn6KGo56S65rS75Yqo77yM5byn5LiK55qE5p2D5YC86KGo56S655u45bqU5rS75Yqo5omA6ZyA55qE5pe26Ze05oiW6LS555So44CCXG5cbiAxIOS4jkFPReacieWFs+eahOeglOeptumXrumimFxuIOKXhiDlrozmiJDmlbTkuKrlt6XnqIvoh7PlsJHpnIDopoHlpJrlsJHml7bpl7Q/XG4g4peGIOWTquS6m+a0u+WKqOaYr+W9seWTjeW3peeoi+i/m+W6pijotLnnlKgp55qE5YWz6ZSuP1xuIOW3peeoi+WujOaIkOacgOefreaXtumXtO+8muS7jui1t+eCueWIsOe7iOeCueeahOacgOmVv+i3r+W+hOmVv+W6pijot6/lvoTkuIrlkITmtLvliqjmjIHnu63ml7bpl7TkuYvlkowpIOOAgumVv+W6puacgOmVv+eahOi3r+W+hOensOS4uuWFs+mUrui3r+W+hO+8jOWFs+mUrui3r+W+hOS4iueahOa0u+WKqOensOS4uuWFs+mUrua0u+WKqOOAguWFs+mUrua0u+WKqOaYr+W9seWTjeaVtOS4quW3peeoi+eahOWFs+mUruOAglxuIOiuvnYw5piv6LW354K577yM5LuOdjDliLB2aeeahOacgOmVv+i3r+W+hOmVv+W6puensOS4uuS6i+S7tnZp55qE5pyA5pep5Y+R55Sf5pe26Ze077yM5Y2z5piv5LuldmnkuLrlsL7nmoTmiYDmnInmtLvliqjnmoTmnIDml6nlj5HnlJ/ml7bpl7TjgIJcbiDoi6XmtLvliqhhaeaYr+W8pzxqLCBrPu+8jOaMgee7reaXtumXtOaYr2R1dCg8aiwgaz4p77yM6K6+77yaXG4g4peGIGUoaSnvvJrooajnpLrmtLvliqhhaeeahOacgOaXqeW8gOWni+aXtumXtO+8m1xuIOKXhiBsKGkp77ya5Zyo5LiN5b2x5ZON6L+b5bqm55qE5YmN5o+Q5LiL77yM6KGo56S65rS75YqoYWnnmoTmnIDmmZrlvIDlp4vml7bpl7TvvJsg5YiZbChpKS1lKGkp6KGo56S65rS75YqoYWnnmoTml7bpl7TkvZnph4/vvIzoi6VsKGkpLWUoaSk9MO+8jOihqOekuua0u+WKqGFp5piv5YWz6ZSu5rS75Yqo44CCXG4g4peGIHZlKGkp77ya6KGo56S65LqL5Lu2dmnnmoTmnIDml6nlj5HnlJ/ml7bpl7TvvIzljbPku47otbfngrnliLDpobbngrl2aeeahOacgOmVv+i3r+W+hOmVv+W6pu+8m1xuIOKXhiB2bChpKe+8muihqOekuuS6i+S7tnZp55qE5pyA5pma5Y+R55Sf5pe26Ze044CC5YiZ5pyJ5Lul5LiL5YWz57O777yaXG4gZShpKT12ZShqKVxuIGwoaSk9IHZsKGspLWR1dCg8aiwgaz4pXG4gMCAgICBqPTDvvIzooajnpLp2auaYr+i1t+eCuVxuIHZlKGopPVxuIE1heHt2ZShpKStkdXQoPGksIGo+KXw8dmksIHZqPuaYr+e9keS4reeahOW8p31cblxuIOWQq+S5ieaYr++8mua6kOeCueS6i+S7tueahOacgOaXqeWPkeeUn+aXtumXtOiuvuS4ujDvvJvpmaTmupDngrnlpJbvvIzlj6rmnInov5vlhaXpobbngrl2aueahOaJgOacieW8p+aJgOS7o+ihqOeahOa0u+WKqOWFqOmDqOe7k+adn+WQju+8jOS6i+S7tnZq5omN6IO95Y+R55Sf44CC5Y2z5Y+q5pyJdmrnmoTmiYDmnInliY3pqbHkuovku7Z2aeeahOacgOaXqeWPkeeUn+aXtumXtHZlKGkp6K6h566X5Ye65p2l5ZCO77yM5omN6IO96K6h566XdmUoaikg44CCXG4g5pa55rOV5piv77ya5a+55omA5pyJ5LqL5Lu26L+b6KGM5ouT5omR5o6S5bqP77yM54S25ZCO5L6d5qyh5oyJ5ouT5omR6aG65bqP6K6h566X5q+P5Liq5LqL5Lu255qE5pyA5pep5Y+R55Sf5pe26Ze044CCXG4gdmUobi0xKSAgICBqPW4tMe+8jOihqOekunZq5piv57uI54K5XG4gdmwoaik9XG4gTWlue3ZsKGspLWR1dCg8aiwgaz4pfDx2aiwgdms+5piv572R5Lit55qE5bynfVxuIOWQq+S5ieaYr++8muWPquaciXZq55qE5omA5pyJ5ZCO57un5LqL5Lu2dmvnmoTmnIDmmZrlj5HnlJ/ml7bpl7R2bChrKeiuoeeul+WHuuadpeWQju+8jOaJjeiDveiuoeeul3ZsKGopIOOAglxuIOaWueazleaYr++8muaMieaLk+aJkeaOkuW6j+eahOmAhumhuuW6j++8jOS+neasoeiuoeeul+avj+S4quS6i+S7tueahOacgOaZmuWPkeeUn+aXtumXtOOAglxuXG5cbiAyIOaxgkFPReS4reWFs+mUrui3r+W+hOWSjOWFs+mUrua0u+WKqFxuIOKRtCDnrpfms5XmgJ3mg7NcbiDikaAg5Yip55So5ouT5omR5o6S5bqP5rGC5Ye6QU9F572R55qE5LiA5Liq5ouT5omR5bqP5YiX77ybXG4g4pGhICDku47mi5PmiZHmjpLluo/nmoTluo/liJfnmoTnrKzkuIDkuKrpobbngrko5rqQ54K5KeW8gOWni++8jOaMieaLk+aJkemhuuW6j+S+neasoeiuoeeul+avj+S4quS6i+S7tueahOacgOaXqeWPkeeUn+aXtumXtHZlKGkpIO+8m1xuIOKRoiAg5LuO5ouT5omR5o6S5bqP55qE5bqP5YiX55qE5pyA5ZCO5LiA5Liq6aG254K5KOaxh+eCuSnlvIDlp4vvvIzmjInpgIbmi5PmiZHpobrluo/kvp3mrKHorqHnrpfmr4/kuKrkuovku7bnmoTmnIDmmZrlj5HnlJ/ml7bpl7R2bChpKSDvvJtcblxuIOiuvkFPRee9keaciW7kuKrkuovku7bvvIxl5Liq5rS75Yqo77yM5YiZ566X5rOV55qE5Li76KaB5omn6KGM5piv77yaXG4g4peGIOi/m+ihjOaLk+aJkeaOkuW6j++8muaXtumXtOWkjeadguW6puaYr08obitlKSDvvJtcbiDil4Yg5rGC5q+P5Liq5LqL5Lu255qEdmXlgLzlkox2bOWAvO+8muaXtumXtOWkjeadguW6puaYr08obitlKSDvvJtcbiDil4Yg5qC55o2udmXlgLzlkox2bOWAvOaJvuWFs+mUrua0u+WKqO+8muaXtumXtOWkjeadguW6puaYr08obitlKSDvvJtcbiDlm6DmraTvvIzmlbTkuKrnrpfms5XnmoTml7bpl7TlpI3mnYLluqbmmK9PKG4rZSkg44CCXG5cbiAqL1xuXG5cbnZhciBjcml0aWNhbFBhdGhUZXN0ID0gbmV3IEFkamFjZW5jeUxpc3RHcmFwaChbXSwgMCwgMCwgREcpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3YwJyk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjEnKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2MicpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3YzJyk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjQnKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2NScpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRWZXJ0ZXgoJ3Y2Jyk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZFZlcnRleCgndjcnKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkVmVydGV4KCd2OCcpO1xuXG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjEnLCAndjAnLCAzKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2MicsICd2MCcsIDEwKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NCcsICd2MScsIDEzKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NCcsICd2MicsIDEyKTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2MycsICd2MScsIDkpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y1JywgJ3YyJywgNyk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjcnLCAndjQnLCA2KTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2NycsICd2MycsIDQpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y3JywgJ3Y1JywgMTEpO1xuY3JpdGljYWxQYXRoVGVzdC5hZGRBcmMoJ3Y2JywgJ3YzJywgOCk7XG5jcml0aWNhbFBhdGhUZXN0LmFkZEFyYygndjgnLCAndjcnLCA1KTtcbmNyaXRpY2FsUGF0aFRlc3QuYWRkQXJjKCd2OCcsICd2NicsIDIpO1xuXG5jcml0aWNhbFBhdGhUZXN0LmNyaXRpY2FsUGF0aCgpO1xuXG5cblxuXG52YXIgZGlqVGVzdCA9IG5ldyBBZGphY2VuY3lMaXN0R3JhcGgoW10sIFtdLCAwLCAwLCBETik7XG5cbmRpalRlc3QuYWRkVmVydGV4KCcwJyk7XG5kaWpUZXN0LmFkZFZlcnRleCgnMScpO1xuZGlqVGVzdC5hZGRWZXJ0ZXgoJzInKTtcbmRpalRlc3QuYWRkVmVydGV4KCczJyk7XG5kaWpUZXN0LmFkZFZlcnRleCgnNCcpO1xuZGlqVGVzdC5hZGRWZXJ0ZXgoJzUnKTtcblxuZGlqVGVzdC5hZGRBcmMoJzEnLCAnMCcsIDIwKTtcbmRpalRlc3QuYWRkQXJjKCc0JywgJzAnLCAxMCk7XG5kaWpUZXN0LmFkZEFyYygnMicsICcwJywgNjApO1xuZGlqVGVzdC5hZGRBcmMoJzUnLCAnMCcsIDY1KTtcbmRpalRlc3QuYWRkQXJjKCcyJywgJzEnLCAzMCk7XG5kaWpUZXN0LmFkZEFyYygnMycsICcyJywgNDApO1xuZGlqVGVzdC5hZGRBcmMoJzInLCAnNScsIDE1KTtcbmRpalRlc3QuYWRkQXJjKCc1JywgJzQnLCAyMCk7XG5kaWpUZXN0LmFkZEFyYygnNCcsICczJywgMzUpO1xuZGlqVGVzdC5hZGRBcmMoJzMnLCAnMScsIDcwKTtcblxuZGlqVGVzdC5zaG9ydGVzdFBhdGhfRGlqa3N0cmEoMCk7XG5cblxuKGZ1bmN0aW9uKCl7XG4gICAgLyoqXG4gICAgICog6L6T5Ye65pyJ5ZCR5peg546v5Zu+5b2i5byP6KGo56S655qE6YCG5rOi5YWw5byPXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmlCb0xhbl9EQUcoZ3JhcGgpe1xuICAgICAgICBncmFwaC5jb3VudEluZGVncmVlKCk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBncmFwaC52ZXhudW07ICsraSl7XG4gICAgICAgICAgICAvLyDmib7liLDmnInlkJHml6Dnjq/lm77nmoTmoLlcbiAgICAgICAgICAgIGlmKGdyYXBoLnZlcnRpY2VzW2ldLmluZGVncmVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcHJpbnROaUJvTGFuKGdyYXBoLCBpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludE5pQm9MYW4oZ3JhcGgsIGkpe1xuICAgICAgICBsZXQgYyA9IGdyYXBoLnZlcnRpY2VzW2ldLmRhdGE7XG4gICAgICAgIGxldCBwID0gZ3JhcGgudmVydGljZXNbaV0uZmlyc3RBcmM7XG5cbiAgICAgICAgLy8g5a2Q6KGo6L6+5byPXG4gICAgICAgIGlmKHApIHtcbiAgICAgICAgICAgIHByaW50TmlCb0xhbihncmFwaCwgcC5hZGpWZXgpO1xuICAgICAgICAgICAgcHJpbnROaUJvTGFuKGdyYXBoLCBwLm5leHRBcmMuYWRqVmV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKGMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog57uZ5pyJ5ZCR5peg546v5Zu+6KGo56S655qE6KGo6L6+5byP5rGC5YC8XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZhbHVhdGVfREFHKGdyYXBoKXtcbiAgICAgICAgZ3JhcGguY291bnRJbmRlZ3JlZSgpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZ3JhcGgudmV4bnVtOyArK2kpe1xuICAgICAgICAgICAgaWYoIWdyYXBoLnZlcnRpY2VzW2ldLmluZGVncmVlKSByZXR1cm4gZXZhbHVhdGVfaW1wKGdyYXBoLCBpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV2YWx1YXRlX2ltcChnLCBpKXtcbiAgICAgICAgaWYoL15cXGQrJC8udGVzdChnLnZlcnRpY2VzW2ldLmRhdGEpKSByZXR1cm4gZy52ZXJ0aWNlc1tpXS5kYXRhO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwID0gZy52ZXJ0aWNlc1tpXS5maXJzdEFyYztcbiAgICAgICAgICAgIGxldCB2MSA9IGV2YWx1YXRlX2ltcChnLCBwLmFkalZleCk7XG4gICAgICAgICAgICBsZXQgdjIgPSBldmFsdWF0ZV9pbXAoZywgcC5uZXh0QXJjLmFkalZleCk7XG4gICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlKHYxLCBnLnZlcnRpY2VzW2ldLmRhdGEsIHYyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZShhLCBvcGVyYXRpb24sIGIpe1xuICAgICAgICAvLyDlgbfkuIDkuIvmh5IuLlxuICAgICAgICByZXR1cm4gZXZhbChhICsgb3BlcmF0aW9uICsgYik7XG4gICAgfVxuXG4gICAgLy8gKCgxICsgMikgKiAoMiAqICgzICsgNCkpICsgKDMgKyA0KSAqIDUpICogKCgzICsgNCkgKiA1KVxuICAgIGxldCBkYWcgPSBuZXcgQWRqYWNlbmN5TGlzdEdyYXBoKFtdLCAwLCAwLCBERyk7XG5cbiAgICBsZXQgYTEgPSBuZXcgU3RyaW5nKCcqJyk7XG4gICAgbGV0IGEyID0gbmV3IFN0cmluZygnKycpO1xuICAgIGxldCBhMyA9IG5ldyBTdHJpbmcoJyonKTtcbiAgICBsZXQgYTQgPSBuZXcgU3RyaW5nKCcqJyk7XG4gICAgbGV0IGE1ID0gbmV3IFN0cmluZygnKycpO1xuICAgIGxldCBhNiA9IG5ldyBTdHJpbmcoJyonKTtcbiAgICBsZXQgYTcgPSBuZXcgU3RyaW5nKCcrJyk7XG5cbiAgICAvLyAxMlxuICAgIGRhZy5hZGRWZXJ0ZXgoYTEpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTIpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTMpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTQpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTUpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTYpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoYTcpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoMSk7XG4gICAgZGFnLmFkZFZlcnRleCgyKTtcbiAgICBkYWcuYWRkVmVydGV4KDMpO1xuICAgIGRhZy5hZGRWZXJ0ZXgoNCk7XG4gICAgZGFnLmFkZFZlcnRleCg1KTtcblxuICAgIC8vIDE0XG4gICAgZGFnLmFkZEFyYyhhMiwgYTEpO1xuICAgIGRhZy5hZGRBcmMoYTQsIGExKTtcbiAgICBkYWcuYWRkQXJjKGEzLCBhMik7XG4gICAgZGFnLmFkZEFyYyhhNCwgYTIpO1xuICAgIGRhZy5hZGRBcmMoYTUsIGEzKTtcbiAgICBkYWcuYWRkQXJjKGE2LCBhMyk7XG4gICAgZGFnLmFkZEFyYyhhNywgYTYpO1xuICAgIGRhZy5hZGRBcmMoYTcsIGE0KTtcbiAgICBkYWcuYWRkQXJjKDUsIGE0KTtcbiAgICBkYWcuYWRkQXJjKDEsIGE1KTtcbiAgICBkYWcuYWRkQXJjKDIsIGE1KTtcbiAgICBkYWcuYWRkQXJjKDIsIGE2KTtcbiAgICBkYWcuYWRkQXJjKDMsIGE3KTtcbiAgICBkYWcuYWRkQXJjKDQsIGE3KTtcblxuICAgIGNvbnNvbGUubG9nKCduaUJvTGFuX0RBRzogJyk7XG4gICAgbmlCb0xhbl9EQUcoZGFnKTtcbiAgICBjb25zb2xlLmxvZygnZXZhbHVhdGVfREFHOiAnICsgZXZhbHVhdGVfREFHKGRhZykpOyAgLy8gMjY5NVxufSkoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9HcmFwaC9BZGphY2VuY3lMaXN0R3JhcGguanMiLCIvKiBjcmVhdGUgYnkgTHVrZSAqL1xuLyoqXG4gKiDlm74oR3JhcGgpXG4gKlxuICog5Zu+KEdyYXBoKeaYr+S4gOenjeavlOe6v+aAp+ihqOWSjOagkeabtOS4uuWkjeadgueahOaVsOaNrue7k+aehOOAglxuICpcbiAqIOe6v+aAp+e7k+aehO+8muaYr+eglOeptuaVsOaNruWFg+e0oOS5i+mXtOeahOS4gOWvueS4gOWFs+ezu+OAguWcqOi/meenjee7k+aehOS4re+8jOmZpOesrOS4gOS4quWSjOacgOWQjuS4gOS4quWFg+e0oOWklu+8jOS7u+S9leS4gOS4quWFg+e0oOmDveacieWUr+S4gOeahOS4gOS4quebtOaOpeWJjempseWSjOebtOaOpeWQjue7p+OAglxuICpcbiAqIOagkee7k+aehO+8muaYr+eglOeptuaVsOaNruWFg+e0oOS5i+mXtOeahOS4gOWvueWkmueahOWFs+ezu+OAguWcqOi/meenjee7k+aehOS4re+8jOavj+S4quWFg+e0oOWvueS4iyjlsYIp5Y+v5Lul5pyJMOS4quaIluWkmuS4quWFg+e0oOebuOiBlOezu++8jOWvueS4iijlsYIp5Y+q5pyJ5ZSv5LiA55qE5LiA5Liq5YWD57Sg55u45YWz77yM5pWw5o2u5YWD57Sg5LmL6Ze05pyJ5piO5pi+55qE5bGC5qyh5YWz57O744CCXG4gKlxuICog5Zu+57uT5p6E77ya5piv56CU56m25pWw5o2u5YWD57Sg5LmL6Ze055qE5aSa5a+55aSa55qE5YWz57O744CC5Zyo6L+Z56eN57uT5p6E5Lit77yM5Lu75oSP5Lik5Liq5YWD57Sg5LmL6Ze05Y+v6IO95a2Y5Zyo5YWz57O744CC5Y2z57uT54K55LmL6Ze055qE5YWz57O75Y+v5Lul5piv5Lu75oSP55qE77yM5Zu+5Lit5Lu75oSP5YWD57Sg5LmL6Ze06YO95Y+v6IO955u45YWz44CCXG4gKlxuICog5Zu+55qE5bqU55So5p6B5Li65bm/5rOb77yM5bey5riX5YWl5Yiw6K+45aaC6K+t6KiA5a2m44CB6YC76L6R5a2m44CB54mp55CG44CB5YyW5a2m44CB55S16K6v44CB6K6h566X5py656eR5a2m5Lul5Y+K5pWw5a2m55qE5YW25a6D5YiG5pSv44CCXG4gKlxuICog5Zu+55qE5Z+65pys5qaC5b+1XG4gKlxuICog5LiA5Liq5Zu+KEcp5a6a5LmJ5Li65LiA5Liq5YG25a+5KFYsRSkg77yM6K6w5Li6Rz0oVixFKSDjgILlhbbkuK3vvJogVuaYr+mhtueCuShWZXJ0ZXgp55qE6Z2e56m65pyJ6ZmQ6ZuG5ZCI77yM6K6w5Li6VihHKe+8m0XmmK/ml6Dluo/pm4ZWJlbnmoTkuIDkuKrlrZDpm4bvvIzorrDkuLpFKEcpIO+8jOWFtuWFg+e0oOaYr+WbvueahOW8pyhBcmMp44CCXG4gKiDlsIbpobbngrnpm4blkIjkuLrnqbrnmoTlm77np7DkuLrnqbrlm77jgILlhbblvaLlvI/ljJblrprkuYnkuLrvvJpcbiBHPShWIO+8jEUpXG4gVj17dnx24oiIZGF0YSBvYmplY3R9XG4gRT17PHYsdz58IHYsd+KIiFbiiKdwKHYsdyl9XG4gUCh2LHcp6KGo56S65LuO6aG254K5duWIsOmhtueCuXfmnInkuIDmnaHnm7TmjqXpgJrot6/jgIJcbiAqXG4gKiDlvKcoQXJjKSDvvJrooajnpLrkuKTkuKrpobbngrl25ZKMd+S5i+mXtOWtmOWcqOS4gOS4quWFs+ezu++8jOeUqOmhtueCueWBtuWvuTx2LHc+6KGo56S644CC6YCa5bi45qC55o2u5Zu+55qE6aG254K55YG25a+55bCG5Zu+5YiG5Li65pyJ5ZCR5Zu+5ZKM5peg5ZCR5Zu+44CCXG4gKiDmnInlkJHlm74oRGlncmFwaCnvvJog6Iul5Zu+R+eahOWFs+ezu+mbhuWQiEUoRynkuK3vvIzpobbngrnlgbblr7k8dix3PueahHblkox35LmL6Ze05piv5pyJ5bqP55qE77yM56ew5Zu+R+aYr+acieWQkeWbvuOAglxuICogICDlnKjmnInlkJHlm77kuK3vvIzoi6UgPHYsdz7iiIhFKEcpIO+8jOihqOekuuS7jumhtueCuXbliLDpobbngrl35pyJ5LiA5p2h5byn44CCIOWFtuS4re+8mnbnp7DkuLrlvKflsL4odGFpbCnmiJblp4vngrkoaW5pdGlhbCBub2RlKe+8jHfnp7DkuLrlvKflpLQoaGVhZCnmiJbnu4jngrkodGVybWluYWwgbm9kZSkg44CCXG4gKiDml6DlkJHlm74oVW5kaWdyYXBoKe+8miDoi6Xlm75H55qE5YWz57O76ZuG5ZCIRShHKeS4re+8jOmhtueCueWBtuWvuTx2LHc+55qEduWSjHfkuYvpl7TmmK/ml6Dluo/nmoTvvIznp7Dlm75H5piv5peg5ZCR5Zu+44CCXG4gKiAgIOWcqOaXoOWQkeWbvuS4re+8jOiLpe+Aojx2LHc+4oiIRShHKSDvvIzmnIk8dyx2PuKIiEUoRykg77yM5Y2zRShHKeaYr+WvueensO+8jOWImeeUqOaXoOW6j+WvuSh2LHcpIOihqOekunblkox35LmL6Ze055qE5LiA5p2h6L65KEVkZ2Up77yM5Zug5q2kKHYsdykg5ZKMKHcsdinku6PooajnmoTmmK/lkIzkuIDmnaHovrnjgIJcbiAqXG4gKiDkvosx77ya6K6+5pyJ5pyJ5ZCR5Zu+RzHlkozml6DlkJHlm75HMu+8jOW9ouW8j+WMluWumuS5ieWIhuWIq+aYr++8mlxuIEcxPShWMSDvvIxFMSlcbiBWMT17YSxiLGMsZCxlfVxuIEUxPXs8YSxiPiw8YSxjPiwgPGEsZT4sPGMsZD4sPGMsZT4gLDxkLGE+LDxkLGI+LDxlLGQ+fVxuIEcyPShWMiDvvIxFMilcbiBWMj17YSxiLGMsZH1cbiBFMj17KGEsYiksIChhLGMpLCAoYSxkKSwgKGIsZCksIChiLGMpLCAoYyxkKX1cbiAqXG4gKiDlrozlhajml6DlkJHlm77vvJrlr7nkuo7ml6DlkJHlm77vvIzoi6Xlm77kuK3pobbngrnmlbDkuLpuIO+8jOeUqGXooajnpLrovrnnmoTmlbDnm67vvIzliJllIOKIiFsw77yMbihuLTEpLzJdIOOAguWFt+aciW4obi0xKS8y5p2h6L6555qE5peg5ZCR5Zu+56ew5Li65a6M5YWo5peg5ZCR5Zu+44CCXG4g5a6M5YWo5peg5ZCR5Zu+5Y+m5aSW55qE5a6a5LmJ5piv77yaXG4gKiDlr7nkuo7ml6DlkJHlm75HPShW77yMRSnvvIzoi6XvgKJ2ae+8jHZqIOKIiFYg77yM5b2TdmniiaB2auaXtu+8jOaciSh2aSAsdmop4oiIRe+8jOWNs+WbvuS4reS7u+aEj+S4pOS4quS4jeWQjOeahOmhtueCuemXtOmDveacieS4gOadoeaXoOWQkei+ue+8jOi/meagt+eahOaXoOWQkeWbvuensOS4uuWujOWFqOaXoOWQkeWbvuOAglxuICpcbiAqIOWujOWFqOacieWQkeWbvu+8muWvueS6juacieWQkeWbvu+8jOiLpeWbvuS4remhtueCueaVsOS4um4g77yM55SoZeihqOekuuW8p+eahOaVsOebru+8jOWImWXiiIhbMO+8jG4obi0xKV0g44CC5YW35pyJbihuLTEp5p2h6L6555qE5pyJ5ZCR5Zu+56ew5Li65a6M5YWo5pyJ5ZCR5Zu+44CCXG4g5a6M5YWo5pyJ5ZCR5Zu+5Y+m5aSW55qE5a6a5LmJ5piv77yaXG4gKiDlr7nkuo7mnInlkJHlm75HPShW77yMRSnvvIzoi6XvgKJ2ae+8jHZq4oiIViDvvIzlvZN2aSDiiaB2auaXtu+8jOaciTx2aSAsdmo+4oiIReKIpzx2aiAsIHZpID7iiIhFIO+8jOWNs+WbvuS4reS7u+aEj+S4pOS4quS4jeWQjOeahOmhtueCuemXtOmDveacieS4gOadoeW8p++8jOi/meagt+eahOacieWQkeWbvuensOS4uuWujOWFqOacieWQkeWbvuOAglxuICpcbiAqIOacieW+iOWwkei+ueaIluW8p+eahOWbvu+8iGU8buOPkm7vvInnmoTlm77np7DkuLrnqIDnlo/lm77vvIzlj43kuYvnp7DkuLrnqKDlr4blm77jgIJcbiAqIOadgyhXZWlnaHQp77ya5LiO5Zu+55qE6L655ZKM5byn55u45YWz55qE5pWw44CC5p2D5Y+v5Lul6KGo56S65LuO5LiA5Liq6aG254K55Yiw5Y+m5LiA5Liq6aG254K555qE6Led56a75oiW6ICX6LS544CCXG4gKlxuICog5a2Q5Zu+5ZKM55Sf5oiQ5a2Q5Zu+77ya6K6+5pyJ5Zu+Rz0oVu+8jEUp5ZKMR+KAmT0oVuKAme+8jEXigJkp77yM6IulVuKAmeKIiFbkuJRF4oCZ4oiIRSDvvIzliJnnp7Dlm75H4oCZ5pivR+eahOWtkOWbvu+8m+iLpVbigJk9VuS4lEXigJniiIhF77yM5YiZ56ew5Zu+R+KAmeaYr0fnmoTkuIDkuKrnlJ/miJDlrZDlm77jgIJcbiAqIOmhtueCueeahOmCu+aOpShBZGphY2VudCnvvJrlr7nkuo7ml6DlkJHlm75HPShW77yMRSnvvIzoi6Xovrkodix3KeKIiEXvvIzliJnnp7Dpobbngrl25ZKMdyDkupLkuLrpgrvmjqXngrnvvIzljbN25ZKMd+ebuOmCu+aOpeOAgui+uSh2LHcp5L6d6ZmEKGluY2lkZW50KeS4jumhtueCuXblkox3IOOAglxuICog5a+55LqO5pyJ5ZCR5Zu+Rz0oViDvvIxFKe+8jOiLpeacieWQkeW8pzx2LHc+4oiIRe+8jOWImeensOmhtueCuXYg4oCc6YK75o6l5Yiw4oCd6aG254K5d++8jOmhtueCuXcg4oCc6YK75o6l6Ieq4oCd6aG254K5diDvvIzlvKc8dix3PiDkuI7pobbngrl25ZKMdyDigJznm7jlhbPogZTigJ0g44CCXG4gKlxuICog6aG254K555qE5bqm44CB5YWl5bqm44CB5Ye65bqm77ya5a+55LqO5peg5ZCR5Zu+Rz0oVu+8jEUp77yMIO+AonZp4oiIVu+8jOWbvkfkuK3kvp3pmYTkuo52aeeahOi+ueeahOaVsOebruensOS4uumhtueCuXZp55qE5bqmKGRlZ3JlZSnvvIzorrDkuLpURCh2aSnjgIJcbiDmmL7nhLbvvIzlnKjml6DlkJHlm77kuK3vvIzmiYDmnInpobbngrnluqbnmoTlkozmmK/lm77kuK3ovrnnmoQy5YCN44CCIOWNsyAgIOKIkVREKHZpKT0yZSAgICAgIGk9MSwgMiwg4oCmLCBuIO+8jGXkuLrlm77nmoTovrnmlbDjgIJcbiDlr7nmnInlkJHlm75HPShW77yMRSnvvIzoi6XvgKJ2aSDiiIhWIO+8jOWbvkfkuK3ku6V2aeS9nOS4uui1t+eCueeahOacieWQkei+uSjlvKcp55qE5pWw55uu56ew5Li66aG254K5dmnnmoTlh7rluqYoT3V0ZGVncmVlKe+8jOiusOS4uk9EKHZpKSDvvJvku6V2aeS9nOS4uue7iOeCueeahOacieWQkei+uSjlvKcp55qE5pWw55uu56ew5Li66aG254K5dmnnmoTlhaXluqYoSW5kZWdyZWUp77yM6K6w5Li6SUQodmkpIOOAgumhtueCuXZp55qE5Ye65bqm5LiO5YWl5bqm5LmL5ZKM56ew5Li6dmnnmoTluqbvvIzorrDkuLpURCh2aSkg44CC5Y2zXG4gVEQodmkpPU9EKHZpKStJRCh2aSlcbiAqXG4gKiDot6/lvoQoUGF0aCnjgIHot6/lvoTplb/luqbjgIHlm57ot68oQ3ljbGUpIO+8muWvueaXoOWQkeWbvkc9KFbvvIxFKe+8jOiLpeS7jumhtueCuXZp57uP6L+H6Iul5bmy5p2h6L656IO95Yiw6L6+dmrvvIznp7Dpobbngrl2aeWSjHZq5piv6L+e6YCa55qE77yM5Y+I56ew6aG254K5dmnliLB2auaciei3r+W+hOOAglxuIOWvueacieWQkeWbvkc9KFbvvIxFKe+8jOS7jumhtueCuXZp5YiwdmrmnInmnInlkJHot6/lvoTvvIzmjIfnmoTmmK/ku47pobbngrl2aee7j+i/h+iLpeW5suadoeacieWQkei+uSjlvKcp6IO95Yiw6L6+dmrjgIJcbiDmiJbot6/lvoTmmK/lm75H5Lit6L+e5o6l5Lik6aG254K55LmL6Ze05omA57uP6L+H55qE6aG254K55bqP5YiX44CC5Y2zXG4gUGF0aD12aTB2aTHigKZ2aW0g77yMdmlq4oiIVuS4lCh2aWotMSwgdmlqKeKIiEUgICBqPTEsMiwg4oCmLG1cbiDmiJZcbiBQYXRoPXZpMHZpMSDigKZ2aW0g77yMdmlq4oiIVuS4lDx2aWotMSwgdmlqPuKIiEUgIGo9MSwyLCDigKYsbVxuIOi3r+W+hOS4iui+ueaIluacieWQkei+uSjlvKcp55qE5pWw55uu56ew5Li66K+l6Lev5b6E55qE6ZW/5bqm44CCXG4g5Zyo5LiA5p2h6Lev5b6E5Lit77yM6Iul5rKh5pyJ6YeN5aSN55u45ZCM55qE6aG254K577yM6K+l6Lev5b6E56ew5Li6566A5Y2V6Lev5b6E77yb56ys5LiA5Liq6aG254K55ZKM5pyA5ZCO5LiA5Liq6aG254K555u45ZCM55qE6Lev5b6E56ew5Li65Zue6LevKOeOrynvvJvlnKjkuIDkuKrlm57ot6/kuK3vvIzoi6XpmaTnrKzkuIDkuKrkuI7mnIDlkI7kuIDkuKrpobbngrnlpJbvvIzlhbbkvZnpobbngrnkuI3ph43lpI3lh7rnjrDnmoTlm57ot6/np7DkuLrnroDljZXlm57ot68o566A5Y2V546vKeOAglxuICpcbiAqIOi/numAmuWbvuOAgeWbvueahOi/numAmuWIhumHj++8muWvueaXoOWQkeWbvkc9KFbvvIxFKe+8jOiLpe+AonZpIO+8jHZqIOKIiFbvvIx2aeWSjHZq6YO95piv6L+e6YCa55qE77yM5YiZ56ew5Zu+R+aYr+i/numAmuWbvu+8jOWQpuWImeensOS4uumdnui/numAmuWbvuOAguiLpUfmmK/pnZ7ov57pgJrlm77vvIzliJnmnoHlpKfnmoTov57pgJrlrZDlm77np7DkuLpH55qE6L+e6YCa5YiG6YeP44CCXG4g5a+55pyJ5ZCR5Zu+Rz0oVu+8jEUp77yM6Iul74Cidmkg77yMdmog4oiIVu+8jOmDveacieS7pXZp5Li66LW354K577yMIHZqIOS4uue7iOeCueS7peWPiuS7pXZq5Li66LW354K577yMdmnkuLrnu4jngrnnmoTmnInlkJHot6/lvoTvvIznp7Dlm75H5piv5by66L+e6YCa5Zu+77yM5ZCm5YiZ56ew5Li66Z2e5by66L+e6YCa5Zu+44CC6IulR+aYr+mdnuW8uui/numAmuWbvu+8jOWImeaegeWkp+eahOW8uui/numAmuWtkOWbvuensOS4ukfnmoTlvLrov57pgJrliIbph4/jgIJcbiDigJzmnoHlpKfigJ3nmoTlkKvkuYnvvJrmjIfnmoTmmK/lr7nlrZDlm77lho3lop7liqDlm75H5Lit55qE5YW25a6D6aG254K577yM5a2Q5Zu+5bCx5LiN5YaN6L+e6YCa44CCXG4g55Sf5oiQ5qCR44CB55Sf5oiQ5qOu5p6X77ya5LiA5Liq6L+e6YCa5Zu+KOaXoOWQkeWbvinnmoTnlJ/miJDmoJHmmK/kuIDkuKrmnoHlsI/ov57pgJrlrZDlm77vvIzlroPlkKvmnInlm77kuK3lhajpg6hu5Liq6aG254K55ZKM5Y+q5pyJ6Laz5Lul5p6E5oiQ5LiA5qO15qCR55qEbi0x5p2h6L6577yM56ew5Li65Zu+55qE55Sf5oiQ5qCR44CCXG4g5YWz5LqO5peg5ZCR5Zu+55qE55Sf5oiQ5qCR55qE5Yeg5Liq57uT6K6677yaXG4g4peGIOS4gOajteaciW7kuKrpobbngrnnmoTnlJ/miJDmoJHmnInkuJTku4XmnIluLTHmnaHovrnvvJtcbiDil4Yg5aaC5p6c5LiA5Liq5Zu+5pyJbuS4qumhtueCueWSjOWwj+S6jm4tMeadoei+ue+8jOWImeaYr+mdnui/numAmuWbvu+8m1xuIOKXhiDlpoLmnpzlpJrkuo5uLTHmnaHovrnvvIzliJnkuIDlrprmnInnjq/vvJtcbiDil4Yg5pyJbi0x5p2h6L6555qE5Zu+5LiN5LiA5a6a5piv55Sf5oiQ5qCR44CCXG5cbiDmnInlkJHlm77nmoTnlJ/miJDmo67mnpfmmK/ov5nmoLfkuIDkuKrlrZDlm77vvIznlLHoi6XlubLmo7XmnInlkJHmoJHnu4TmiJDvvIzlkKvmnInlm77kuK3lhajpg6jpobbngrnjgIJcbiDmnInlkJHmoJHmmK/lj6rmnInkuIDkuKrpobbngrnnmoTlhaXluqbkuLowIO+8jOWFtuS9memhtueCueeahOWFpeW6puWdh+S4ujHnmoTmnInlkJHlm77jgIJcblxuICpcbiAqIOe9ke+8muavj+S4qui+uSjmiJblvKcp6YO96ZmE5Yqg5LiA5Liq5p2D5YC855qE5Zu+77yM56ew5Li65bim5p2D5Zu+44CC5bim5p2D55qE6L+e6YCa5Zu+KOWMheaLrOW8sei/numAmueahOacieWQkeWbvinnp7DkuLrnvZHmiJbnvZHnu5zjgILnvZHnu5zmmK/lt6XnqIvkuIrluLjnlKjnmoTkuIDkuKrmpoLlv7XvvIznlKjmnaXooajnpLrkuIDkuKrlt6XnqIvmiJbmn5Dnp43mtYHnqItcbiAqL1xuXG4vKipcbiAqIOWbvueahOWtmOWCqOe7k+aehFxuICpcbiDlm77nmoTlrZjlgqjnu5PmnoTmr5TovoPlpI3mnYLvvIzlhbblpI3mnYLmgKfkuLvopoHooajnjrDlnKjvvJpcbiDil4Yg5Lu75oSP6aG254K55LmL6Ze05Y+v6IO95a2Y5Zyo6IGU57O777yM5peg5rOV5Lul5pWw5o2u5YWD57Sg5Zyo5a2Y5YKo5Yy65Lit55qE54mp55CG5L2N572u5p2l6KGo56S65YWD57Sg5LmL6Ze055qE5YWz57O744CCXG4g4peGIOWbvuS4remhtueCueeahOW6puS4jeS4gOagt++8jOacieeahOWPr+iDveebuOW3ruW+iOWkp++8jOiLpeaMieW6puaVsOacgOWkp+eahOmhtueCueiuvuiuoee7k+aehO+8jOWImeS8mua1qui0ueW+iOWkmuWtmOWCqOWNleWFg++8jOWPjeS5i+aMieavj+S4qumhtueCueiHquW3seeahOW6puiuvuiuoeS4jeWQjOeahOe7k+aehO+8jOWPiOS8muW9seWTjeaTjeS9nOOAglxuIOWbvueahOW4uOeUqOeahOWtmOWCqOe7k+aehOacie+8mumCu+aOpeefqemYteOAgemCu+aOpemTvuihqOOAgeWNgeWtl+mTvuihqOOAgemCu+aOpeWkmumHjeihqOWSjOi+ueihqOOAglxuICovXG5cbi8qXG4g6YK75o6l55+p6Zi1KOaVsOe7hCnooajnpLrms5VcblxuIOWfuuacrOaAneaDs++8muWvueS6juaciW7kuKrpobbngrnnmoTlm77vvIznlKjkuIDnu7TmlbDnu4R2ZXhzW25d5a2Y5YKo6aG254K55L+h5oGv77yM55So5LqM57u05pWw57uEQVtuXVtuXeWtmOWCqOmhtueCueS5i+mXtOWFs+ezu+eahOS/oeaBr+OAguivpeS6jOe7tOaVsOe7hOensOS4uumCu+aOpeefqemYteOAguWcqOmCu+aOpeefqemYteS4re+8jOS7pemhtueCueWcqHZleHPmlbDnu4TkuK3nmoTkuIvmoIfku6PooajpobbngrnvvIzpgrvmjqXnn6npmLXkuK3nmoTlhYPntKBBW2ldW2pd5a2Y5pS+55qE5piv6aG254K5aeWIsOmhtueCuWrkuYvpl7TlhbPns7vnmoTkv6Hmga/jgIJcblxuIDEgIOaXoOWQkeWbvueahOaVsOe7hOihqOekulxuXG4gKDEpICDml6DmnYPlm77nmoTpgrvmjqXnn6npmLVcbiDml6DlkJHml6DmnYPlm75HPShW77yMRSnmnIluKG7iiacxKeS4qumhtueCue+8jOWFtumCu+aOpeefqemYteaYr27pmLblr7nnp7DmlrnpmLXjgILlhbblhYPntKDnmoTlrprkuYnlpoLkuIvvvJpcbiAgICAgICAgICAgIC0tIDEgICDoi6UodmkgLCB2ainiiIhF77yM5Y2zdmkgLCB2aumCu+aOpVxuIEFbaV1bal09XG4gICAgICAgICAgICAgLS0gMCAgIOiLpSh2aSAsIHZqKeKIiUXvvIzljbN2aSAsIHZq5LiN6YK75o6lXG5cbiAoMikgIOW4puadg+WbvueahOmCu+aOpeefqemYtVxuIOaXoOWQkeW4puadg+Wbvkc9KFbvvIxFKSDnmoTpgrvmjqXnn6npmLXjgILlhbblhYPntKDnmoTlrprkuYnlpoLkuIvvvJpcbiAgICAgICAgICAgIC0tIFdpaiAgICDoi6UodmkgLCB2ainiiIhF77yM5Y2zdmkgLCB2aumCu+aOpe+8jOadg+WAvOS4undpalxuIEFbaV1bal09XG5cbiAgICAgICAgICAgIC0tIOKIniAgIOiLpSh2aSAsIHZqKeKIiUXvvIzljbN2aSAsIHZq5LiN6YK75o6l5pe2XG5cbiAoMykgIOaXoOWQkeWbvumCu+aOpeefqemYteeahOeJueaAp1xuIOKXhiDpgrvmjqXnn6npmLXmmK/lr7nnp7DmlrnpmLVcbiDil4Yg5a+55LqO6aG254K5dmnvvIzlhbbluqbmlbDmmK/nrKxp6KGM55qE6Z2eMOWFg+e0oOeahOS4quaVsO+8m1xuIOKXhiDml6DlkJHlm77nmoTovrnmlbDmmK/kuIoo5oiW5LiLKeS4ieinkuW9ouefqemYteS4remdnjDlhYPntKDkuKrmlbDjgIJcblxuIDIgIOacieWQkeWbvueahOaVsOe7hOihqOekulxuXG4gKDEpICDml6DmnYPlm77nmoTpgrvmjqXnn6npmLVcbiDoi6XmnInlkJHml6DmnYPlm75HPShW77yMRSnmnIluKG7iiacxKeS4qumhtueCue+8jOWImeWFtumCu+aOpeefqemYteaYr27pmLblr7nnp7DmlrnpmLXjgILlhYPntKDlrprkuYnlpoLkuIvvvJpcbiAgICAgICAgICAgIC0tIDEgICDoi6U8dmksIHZqPuKIiEXvvIzku452aeWIsHZq5pyJ5bynXG4gQVtpXVtqXT1cbiAgICAgICAgICAgIC0tIDAgICDoi6U8dmkgLCB2aj7iiIlFICDku452aeWIsHZqIOayoeacieW8p1xuXG4gKDIpICDluKbmnYPlm77nmoTpgrvmjqXnn6npmLVcbiDmnInlkJHluKbmnYPlm75HPShW77yMRSnnmoTpgrvmjqXnn6npmLXjgILlhbblhYPntKDnmoTlrprkuYnlpoLkuIvvvJpcbiAgICAgICAgICAgIC0tIHdpaiAgICDoi6U8dmksdmo+4oiIRe+8jOWNs3ZpICwgdmrpgrvmjqXvvIzmnYPlgLzkuLp3aWpcbiBBW2ldW2pdPVxuICAgICAgICAgICAg4oieICAg6IulPHZpLHZqPuKIiUXvvIzljbN2aSAsIHZq5LiN6YK75o6l5pe2XG5cbiDikbYg5pyJ5ZCR5Zu+6YK75o6l55+p6Zi155qE54m55oCnXG4g4peGIOWvueS6jumhtueCuXZp77yM56ysaeihjOeahOmdnjDlhYPntKDnmoTkuKrmlbDmmK/lhbblh7rluqZPRCh2aSnvvJvnrKxp5YiX55qE6Z2eMOWFg+e0oOeahOS4quaVsOaYr+WFtuWFpeW6pklEKHZpKSDjgIJcbiDil4Yg6YK75o6l55+p6Zi15Lit6Z2eMOWFg+e0oOeahOS4quaVsOWwseaYr+WbvueahOW8p+eahOaVsOebruOAglxuXG4gMyAg5Zu+55qE6YK75o6l55+p6Zi155qE5pON5L2cXG5cbiDlm77nmoTpgrvmjqXnn6npmLXnmoTlrp7njrDmr5TovoPlrrnmmJPvvIzlrprkuYnkuKTkuKrmlbDnu4TliIbliKvlrZjlgqjpobbngrnkv6Hmga8o5pWw5o2u5YWD57SgKeWSjOi+ueaIluW8p+eahOS/oeaBryjmlbDmja7lhYPntKDkuYvpl7TnmoTlhbPns7spIOOAglxuXG4gKi9cblxuaW1wb3J0IFN0YWNrIGZyb20gJy4uL1N0YWNrL2luZGV4JztcbmltcG9ydCBRdWV1ZSBmcm9tICcuLi9RdWV1ZS9RdWV1ZSc7XG5pbXBvcnQgeyBDaGlsZFNpYmxpbmdUcmVlIH0gZnJvbSAnLi4vQmluYXJ5VHJlZS9CaW5hcnlUcmVlJztcblxuLy8g5Zu+55qE5pWw57uE77yI6YK75o6l55+p6Zi177yJ5a2Y5YKo6KGo56S6XG5jb25zdCBERyA9IDE7ICAgICAvLyDmnInlkJHlm75cbmNvbnN0IEROID0gMjsgICAgIC8vIOacieWQkee9kVxuY29uc3QgVURHID0gMzsgICAgLy8g5peg5ZCR5Zu+XG5jb25zdCBVRE4gPSA0OyAgICAvLyDml6DlkJHnvZFcblxuXG5jbGFzcyBBcmNDZWxsIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhZGpcbiAgICAgKiBAcGFyYW0geyp9IGluZm9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhZGosIGluZm8gPSBudWxsKXtcbiAgICAgICAgLy8g6aG254K557G75Z6L44CC5a+55LqO5peg5p2D5Zu+77yM55SoMeaIljDooajnpLrnm7jpgrvlkKbvvJvlr7nluKbmnYPlm77vvIzliJnkuLrmnYPlgLznsbvlnotcbiAgICAgICAgdGhpcy5hZGogPSB0eXBlb2YgYWRqID09PSAnbnVtYmVyJyA/IGFkaiA6IEluZmluaXR5O1xuICAgICAgICAvLyDor6XlvKfnm7jlhbPkv6Hmga9cbiAgICAgICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWRqYWNlbmN5TWF0cml4R3JhcGgge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmV4cyDpobbngrnlkJHph49cbiAgICAgKiBAcGFyYW0ge0FycmF5IHwgQXJjQ2VsbH0gYXJjcyDpgrvmjqXnn6npmLVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmV4bnVtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyY251bVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBraW5kXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmV4cyA9IFtdLCBhcmNzID0gW10sIHZleG51bSA9IDAsIGFyY251bSA9IDAsIGtpbmQgPSBERyl7XG4gICAgICAgIC8vIOmhtueCueWQkemHj1xuICAgICAgICB0aGlzLnZleHMgPSB2ZXhzO1xuICAgICAgICAvLyDpgrvmjqXnn6npmLVcbiAgICAgICAgdGhpcy5hcmNzID0gYXJjcztcbiAgICAgICAgLy8g5Zu+55qE5b2T5YmN6aG254K55pWwXG4gICAgICAgIHRoaXMudmV4bnVtID0gdmV4bnVtO1xuICAgICAgICAvLyDlm77nmoTlvZPliY3lvKfmlbBcbiAgICAgICAgdGhpcy5hcmNudW0gPSBhcmNudW07XG4gICAgICAgIC8vIOWbvueahOenjeexu+agh+W/l1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIH1cblxuICAgIGNyZWF0ZUdyYXBoKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICAgICAgICAgICAgY2FzZSBERzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlREcodGhpcyk7ICAgICAvLyDmnoTpgKDmnInlkJHlm75cbiAgICAgICAgICAgIGNhc2UgRE46XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUROKHRoaXMpOyAgICAgLy8g5p6E6YCg5pyJ5ZCR572RXG4gICAgICAgICAgICBjYXNlIFVERzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVURHKHRoaXMpOyAgICAvLyDmnoTpgKDml6DlkJHlm75cbiAgICAgICAgICAgIGNhc2UgVUROOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVVRE4odGhpcyk7ICAgIC8vIOaehOmAoOaXoOWQkee9kVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ+mdnuacieaViOeahOWbvuexu+WeiycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5p+l5om+6aG254K5XG4gICAgICogQHBhcmFtIHsqfSB2cCDpobbngrnlkJHph49cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxvY2F0ZVZleCAodnApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52ZXhzW2ldID09PSB2cCkgcmV0dXJuIGk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5ZCR5Zu+5Lit5aKe5Yqg6aG254K5XG4gICAgICogQHBhcmFtIHsqfSB2cCDpobbngrnlkJHph49cbiAgICAgKi9cbiAgICBhZGRWZXJ0ZXgodnApIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYXRlVmV4KHZwKSAhPT0gLTEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBoYXMgZXhpc3RlZCEnKTtcblxuICAgICAgICBsZXQgayA9IHRoaXMudmV4bnVtO1xuICAgICAgICB0aGlzLnZleHNbdGhpcy52ZXhudW0rK10gPSB2cDtcblxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmtpbmQgPT09IERHIHx8IHRoaXMua2luZCA9PT0gVURHID9cbiAgICAgICAgICAgIDAgOiBJbmZpbml0eTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XG4gICAgICAgICAgICB0aGlzLmFyY3Nbal0gPSB0aGlzLmFyY3Nbal0gfHwgW107XG4gICAgICAgICAgICB0aGlzLmFyY3Nba10gPSB0aGlzLmFyY3Nba10gfHwgW107XG4gICAgICAgICAgICB0aGlzLmFyY3Nbal1ba10gPSB0aGlzLmFyY3Nbal1ba10gfHwgbmV3IEFyY0NlbGwoKTtcbiAgICAgICAgICAgIHRoaXMuYXJjc1trXVtqXSA9IHRoaXMuYXJjc1trXVtqXSB8fCBuZXcgQXJjQ2VsbCgpO1xuICAgICAgICAgICAgdGhpcy5hcmNzW2pdW2tdLmFkaiA9IHRoaXMuYXJjc1trXVtqXS5hZGogPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWQkeWbvuS4reWinuWKoOS4gOadoeW8p1xuICAgICAqIEBwYXJhbSB7Kn0gdmV4MSDpobbngrkx5ZCR6YePXG4gICAgICogQHBhcmFtIHsqfSB2ZXgyIOmhtueCuTLlkJHph49cbiAgICAgKiBAcGFyYW0ge0FyY0NlbGx9IGFyY1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGFkZEFyYyh2ZXgxLCB2ZXgyLCBhcmMpIHtcbiAgICAgICAgYXJjID0gYXJjIHx8IG5ldyBBcmNDZWxsKHRoaXMua2luZCA9PT0gREcgfHwgdGhpcy5raW5kID09PSBVREcgPyAxIDogJ3dlaWdodCcpO1xuICAgICAgICBsZXQgayA9IHRoaXMubG9jYXRlVmV4KHZleDEpO1xuICAgICAgICBsZXQgaiA9IHRoaXMubG9jYXRlVmV4KHZleDIpO1xuXG4gICAgICAgIGlmIChrID09PSAtMSB8fCBqID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJjXFwncyBWZXJ0ZXggZG8gbm90IGV4aXN0ZWQhJyk7XG5cbiAgICAgICAgdGhpcy5hcmNzW2tdW2pdLmFkaiA9IGFyYy5hZGo7XG4gICAgICAgIHRoaXMuYXJjc1trXVtqXS5pbmZvID0gYXJjLmluZm87XG4gICAgICAgIC8vIOaXoOWQkeWbvuaIluaXoOWQkee9kVxuICAgICAgICBpZiAodGhpcy5raW5kID09PSBVREcgfHwgdGhpcy5raW5kID09PSBVRE4pIHtcbiAgICAgICAgICAgIHRoaXMuYXJjc1tqXVtrXS5hZGogPSBhcmMuYWRqO1xuICAgICAgICAgICAgdGhpcy5hcmNzW2pdW2tdLmluZm8gPSBhcmMuaW5mbztcbiAgICAgICAgfVxuXG4gICAgICAgICsrdGhpcy5hcmNudW07XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Yig6Zmk6aG254K5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZleCDopoHliKDpmaTnmoTpobbngrlcbiAgICAgKi9cbiAgICBkZWxldGVWZXgodmV4KSB7XG4gICAgICAgIGxldCBuID0gdGhpcy52ZXhudW0gLSAxO1xuICAgICAgICBsZXQgbSA9IHRoaXMubG9jYXRlVmV4KHZleCk7XG5cbiAgICAgICAgaWYgKG0gPCAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgLy8g5bCG5b6F5Yig6Zmk6aG254K55Lqk5o2i5Yiw5pyA5ZCO5LiA5Liq6aG254K5XG4gICAgICAgIGxldCB0ZW1wID0gdGhpcy52ZXhzW21dO1xuICAgICAgICB0aGlzLnZleHNbbV0gPSB0aGlzLnZleHNbbl07XG4gICAgICAgIHRoaXMudmV4c1tuXSA9IHRlbXA7XG5cbiAgICAgICAgLy8g5bCG6L6555qE5YWz57O76ZqP5LmL5Lqk5o2iXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgICAgICAgdGhpcy5hcmNzW2ldW21dID0gdGhpcy5hcmNzW2ldW25dO1xuICAgICAgICAgICAgdGhpcy5hcmNzW21dW2ldID0gdGhpcy5hcmNzW25dW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hcmNzW21dW21dLmFkaiA9IDA7XG4gICAgICAgIHRoaXMudmV4cy5sZW5ndGggPSAtLXRoaXMudmV4bnVtO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDliKDpmaTovrkodiwgdylcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZGVsZXRlQXJjKHYsIHcpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLmxvY2F0ZVZleCh2KTtcbiAgICAgICAgbGV0IGogPSB0aGlzLmxvY2F0ZVZleCh3KTtcblxuICAgICAgICBpZiAoaSA8IDAgfHwgaiA8IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5hcmNzW2ldW2pdLmFkaikge1xuICAgICAgICAgICAgdGhpcy5hcmNzW2ldW2pdLmFkaiA9IDA7XG4gICAgICAgICAgICB0aGlzLmFyY251bS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8g5Yik5pat5LiA5Liq6YK75o6l55+p6Zi15a2Y5YKo55qE5pyJ5ZCR5Zu+5piv5ZCm5Y+v5Lyg6YCSXG4gICAgaXNQYXNzKCkge1xuICAgICAgICBpZiAodGhpcy5raW5kICE9PSBERykgdGhyb3cgbmV3IEVycm9yKCdncmFwaCBraW5kIHNob3VsZCBiZSBERycpO1xuXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy52ZXhudW07ICsreCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnZleG51bTsgKyt5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1t4XVt5XSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB6ID0gMDsgeiA8IHRoaXMudmV4bnVtOyArK3opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh6ICE9PSB4ICYmIHRoaXMuYXJjc1t5XVt6XSAmJiAhdGhpcy5hcmNzW3hdW3pdKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmaXJzdEFkalZleCh2KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1t2XVtpXS5hZGogIT09IDAgJiYgdGhpcy5hcmNzW3ZdW2ldLmFkaiAhPT0gSW5maW5pdHkpIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIG5leHRBZGpWZXgodiwgdykge1xuICAgICAgICBmb3IgKGxldCBpID0gdyArIDE7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcmNzW3ZdW2ldLmFkaiAhPT0gMCAmJiB0aGlzLmFyY3Nbdl1baV0uYWRqICE9PSBJbmZpbml0eSkgcmV0dXJuIGk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLy8g5a+56YK75o6l55+p6Zi15Zu+5L2c6YCS5b2S5byP5rex5bqm5LyY5YWI6YGN5Y6GXG4gICAgREZTVHJhdmVyc2UodmlzaXRGbikge1xuICAgICAgICBsZXQgdmlzaXRlZCA9IFtdO1xuICAgICAgICAvLyDorr/pl67moIflv5fmlbDnu4TliJ3lp4vljJZcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSBkZnModGhpcywgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZnMoZ3JhcGgsIHZlcnRleCkge1xuICAgICAgICAgICAgdmlzaXRlZFt2ZXJ0ZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpc2l0Rm4uY2FsbChncmFwaCwgdmVydGV4KTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncmFwaC52ZXhudW07ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChncmFwaC5hcmNzW3ZlcnRleF1bal0uYWRqICE9PSAwICYmIGdyYXBoLmFyY3NbdmVydGV4XVtqXS5hZGogIT09IEluZmluaXR5XG4gICAgICAgICAgICAgICAgICAgICYmICF2aXNpdGVkW2pdKSBkZnMoZ3JhcGgsIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g6Z2e6YCS5b2SXG4gICAgREZTVHJhdmVyc2VfTm9uUmVjdXJzZSh2aXNpdEZuKSB7XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG4gICAgICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICAvLyDorr/pl67moIflv5fmlbDnu4TliJ3lp4vljJZcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZpc2l0Rm4uY2FsbChtZSwgaSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgdmVydGV4O1xuICAgICAgICAgICAgICAgIHdoaWxlICgodmVydGV4ID0gc3RhY2sucGVlaygpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1t2ZXJ0ZXhdW2pdLmFkaiAhPT0gMCAmJiB0aGlzLmFyY3NbdmVydGV4XVtqXS5hZGogIT09IEluZmluaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgIXZpc2l0ZWRbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEZuLmNhbGwobWUsIGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbal0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Ugc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDlr7npgrvmjqXnn6npmLXlm77kvZzlub/luqbkvJjlhYjpgY3ljoZcbiAgICBCRlNUcmF2ZXJzZSh2aXNpdEZuKSB7XG4gICAgICAgIGxldCB2aXNpdGVkID0gW107XG4gICAgICAgIGxldCBxdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW2ldKSB7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmlzaXRGbi5jYWxsKHRoaXMsIGkpO1xuICAgICAgICAgICAgICAgIHF1ZXVlLmVuUXVldWUoaSk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocXVldWUucmVhcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IHF1ZXVlLmRlUXVldWUoKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmV4bnVtOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyY3NbdV1bal0uYWRqICE9PSAwICYmIHRoaXMuYXJjc1t1XVtqXS5hZGogIT09IEluZmluaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgIXZpc2l0ZWRbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkW2pdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEZuLmNhbGwodGhpcywgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5RdWV1ZShqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1pblNwYW5UcmVlX1BSSU0odSkge1xuICAgICAgICBsZXQgY2xvc2VkZ2UgPSBbXTtcblxuICAgICAgICAvLyDliJ3lp4vljJZcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XG4gICAgICAgICAgICBjbG9zZWRnZVtqXSA9IHthZGp2ZXg6IHUsIGxvd2Nvc3Q6ICt0aGlzLmFyY3Nbal1bdV0uYWRqfTtcbiAgICAgICAgfVxuICAgICAgICBjbG9zZWRnZVt1XS5sb3djb3N0ID0gMDtcblxuICAgICAgICBsZXQgdGUgPSBbXTtcbiAgICAgICAgLy8g6YCJ5oup5YW25L2ZdGhpcy52ZXhudW0gLSAx5Liq6aG254K5XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW0gLSAxOyArK2opIHtcbiAgICAgICAgICAgIGxldCBtaW4gPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGxldCBrO1xuICAgICAgICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCB0aGlzLnZleG51bTsgKyt2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlZGdlW3ZdLmxvd2Nvc3QgIT09IDAgJiYgY2xvc2VkZ2Vbdl0ubG93Y29zdCA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjbG9zZWRnZVt2XS5sb3djb3N0O1xuICAgICAgICAgICAgICAgICAgICBrID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRlW2pdID0ge1xuICAgICAgICAgICAgICAgIHZleDE6IGNsb3NlZGdlW2tdLmFkanZleCxcbiAgICAgICAgICAgICAgICB2ZXgyOiBrLFxuICAgICAgICAgICAgICAgIHdlaWdodDogY2xvc2VkZ2Vba10ubG93Y29zdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsb3NlZGdlW2tdLmxvd2Nvc3QgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCB0aGlzLnZleG51bTsgKyt2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJjc1t2XVtrXS5hZGogPCBjbG9zZWRnZVt2XS5sb3djb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlZGdlW3ZdLmxvd2Nvc3QgPSB0aGlzLmFyY3Nbdl1ba10uYWRqO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZWRnZVt2XS5hZGp2ZXggPSBrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZTtcbiAgICB9XG5cbiAgICBtaW5TcGFuVHJlZV9LcnVza2FsKCkge1xuICAgICAgICBsZXQgc2V0ID0gW107XG4gICAgICAgIGxldCB0ZSA9IFtdO1xuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSBzZXRbaV0gPSBpO1xuXG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgbGV0IG1pbiA9IEluZmluaXR5O1xuICAgICAgICBsZXQgYSA9IDA7XG4gICAgICAgIGxldCBiID0gMDtcbiAgICAgICAgd2hpbGUoayA8IHRoaXMudmV4bnVtIC0gMSl7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSl7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBqID0gaSArIDE7IGogPCB0aGlzLnZleG51bTsgKytqKXtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5hcmNzW2ldW2pdLmFkaiA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gdGhpcy5hcmNzW2ldW2pdLmFkajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHNldFthXSAhPT0gc2V0W2JdKXtcbiAgICAgICAgICAgICAgICB0ZVtrKytdID0ge1xuICAgICAgICAgICAgICAgICAgICB2ZXgxOiBhLFxuICAgICAgICAgICAgICAgICAgICB2ZXgyOiBiLFxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IHRoaXMuYXJjc1thXVtiXS5hZGpcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMudmV4bnVtOyArK2kpe1xuICAgICAgICAgICAgICAgICAgICBpZihzZXRbaV0gPT09IHNldFtiXSAmJiBpICE9PSBiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0W2ldID0gc2V0W2FdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRbYl0gPSBzZXRbYV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1pbiA9IHRoaXMuYXJjc1thXVtiXS5hZGogPSBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnlKhEaWprc3RyYeeul+azleaxguacieWQkee9keeahHYw6aG254K55Yiw5YW25L2Z6aG254K5dueahOacgOefrei3r+W+hHByZVt2XeWPiuWFtuW4puadg+mVv+W6pmRpc3Rbdl3jgIJcbiAgICAgKiDoi6VwcmVbdl1bd13kuLp0cnVl77yM5YiZd+aYr+S7jnYw5YiwduW9k+WJjeaxguW+l+acgOefrei3r+W+hOS4iueahOmhtueCueOAglxuICAgICAqIGZpbmFsW3Zd5Li6dHJ1ZeW9k+S4lOS7heW9k3biiIhT77yM5Y2z5bey57uP5rGC5b6XdjDliLB255qE5pyA55+t6Lev5b6EXG4gICAgICogQHBhcmFtIHYwXG4gICAgICovXG4gICAgc2hvcnRlc3RQYXRoX0RpamtzdHJhKHYwKSB7XG4gICAgICAgIGxldCBwcmUgPSBbXTtcbiAgICAgICAgbGV0IGRpc3QgPSBbXTtcbiAgICAgICAgbGV0IGZpbmFsID0gW107XG4gICAgICAgIGxldCB3LCB2O1xuXG4gICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgdGhpcy52ZXhudW07ICsrdikge1xuICAgICAgICAgICAgZmluYWxbdl0gPSBmYWxzZTtcbiAgICAgICAgICAgIGRpc3Rbdl0gPSB0aGlzLmFyY3NbdjBdW3ZdLmFkajtcbiAgICAgICAgICAgIHByZVt2XSA9IHByZVt2XSB8fCBbXTtcbiAgICAgICAgICAgIC8vIOiuvuepuui3r+W+hFxuICAgICAgICAgICAgZm9yICh3ID0gMDsgdyA8IHRoaXMudmV4bnVtOyArK3cpIHByZVt2XVt3XSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRpc3Rbdl0gPCBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHByZVt2XVt2MF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZVt2XVt2XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDliJ3lp4vljJbvvIx2MOmhtueCueWxnuS6jlPpm4ZcbiAgICAgICAgZGlzdFt2MF0gPSAwO1xuICAgICAgICBmaW5hbFt2MF0gPSB0cnVlO1xuXG4gICAgICAgIC8vIOW8gOWni+S4u+W+queOr++8jOavj+asoeaxguW+l3Yw5Yiw5p+Q5LiqdumhtueCueeahOacgOefrei3r+W+hO+8jOW5tuWKoHbliLBT6ZuGXG5cbiAgICAgICAgLy8g5YW25L2Z55qE6aG254K5XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgbGV0IG1pbiA9IEluZmluaXR5O1xuICAgICAgICAgICAgLy8g5b2T5YmN5omA5oyH56a7djDpobbngrnnmoTmnIDov5Hot53nprtcbiAgICAgICAgICAgIGZvciAodyA9IDA7IHcgPCB0aGlzLnZleG51bTsgKyt3KSB7XG4gICAgICAgICAgICAgICAgLy8gd+mhtueCueWcqFYgLSBT5LitXG4gICAgICAgICAgICAgICAgLy8g5LiUd+mhtueCueemu3Yw6aG254K55pu06L+RXG4gICAgICAgICAgICAgICAgaWYgKCFmaW5hbFt3XSAmJiBkaXN0W3ddIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB3O1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBkaXN0W3ddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g56a7djDpobbngrnmnIDov5HnmoR25Yqg5YWlU+mbhlxuICAgICAgICAgICAgZmluYWxbdl0gPSB0cnVlO1xuICAgICAgICAgICAgLy8g5pu05paw5b2T5YmN5pyA55+t6Lev5b6E5Y+K6Led56a7XG4gICAgICAgICAgICBmb3IgKHcgPSAwOyB3IDwgdGhpcy52ZXhudW07ICsrdykge1xuICAgICAgICAgICAgICAgIGlmICghZmluYWxbd10gJiYgbWluICsgdGhpcy5hcmNzW3ZdW3ddLmFkaiA8IGRpc3Rbd10pIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdFt3XSA9IG1pbiArIHRoaXMuYXJjc1t2XVt3XS5hZGo7XG4gICAgICAgICAgICAgICAgICAgIHByZVt3XSA9IHByZVt2XTtcbiAgICAgICAgICAgICAgICAgICAgcHJlW3ddW3ddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhmaW5hbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHByZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGRpc3QpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaW5hbDogZmluYWwsXG4gICAgICAgICAgICBwcmU6IHByZSxcbiAgICAgICAgICAgIGRpc3Q6IGRpc3RcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzaG9ydGVzdFBhdGhfRkxPWUQoKSB7XG4gICAgICAgIGxldCBhID0gW107XG4gICAgICAgIGxldCBwYXRoID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnZleG51bTsgKytqKSB7XG4gICAgICAgICAgICBhW2pdID0gYVtqXSB8fCBbXTtcbiAgICAgICAgICAgIHBhdGhbal0gPSBwYXRoW2pdIHx8IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLnZleG51bTsgKytrKSB7XG4gICAgICAgICAgICAgICAgaWYoaiA9PT0gaykgYVtqXVtrXSA9IDA7XG4gICAgICAgICAgICAgICAgZWxzZSBhW2pdW2tdID0gdGhpcy5hcmNzW2pdW2tdLmFkajtcbiAgICAgICAgICAgICAgICBwYXRoW2pdW2tdID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBtID0gMDsgbSA8IHRoaXMudmV4bnVtOyArK20pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy52ZXhudW07ICsraykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYVtqXVttXSArIGFbbV1ba10gPCBhW2pdW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhW2pdW2tdID0gYVtqXVttXSArIGFbbV1ba107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoW2pdW2tdID0gbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy52ZXhudW07ICsraikge1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLnZleG51bTsgKytrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogIT09IGspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyVk5YiwJWTnmoTmnIDnn63ot6/lvoTkuLrvvJonLCBqLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyVkICcsIGopOyBwcm5fcGFzcyhqLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJyVkICcsIGspO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn5pyA55+t6Lev5b6E6ZW/5bqm5Li677yaICVkJywgYVtqXVtrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHJuX3Bhc3Moaiwgaykge1xuICAgICAgICAgICAgaWYgKHBhdGhbal1ba10gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcHJuX3Bhc3MoaiwgcGF0aFtqXVtrXSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJywgJWQnLCBwYXRoW2pdW2tdKTtcbiAgICAgICAgICAgICAgICBwcm5fcGFzcyhwYXRoW2pdW2tdLCBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxubGV0IGNyZWF0ZURHID0gY3JlYXRlR3JhcGgoREcpO1xubGV0IGNyZWF0ZUROID0gY3JlYXRlR3JhcGgoRE4pO1xubGV0IGNyZWF0ZVVERyA9IGNyZWF0ZUdyYXBoKFVERyk7XG5sZXQgY3JlYXRlVUROID0gY3JlYXRlR3JhcGgoVUROKTtcblxuZnVuY3Rpb24gY3JlYXRlR3JhcGgoa2luZCkge1xuICAgIGxldCBhZGo7XG4gICAgbGV0IHNldE1hdHJpeFZhbHVlO1xuXG4gICAgaWYgKGtpbmQgPT09IDIgfHwga2luZCA9PT0gNCkge1xuICAgICAgICBhZGogPSBJbmZpbml0eTtcbiAgICAgICAgc2V0TWF0cml4VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbXB0KCd3ZWlnaHQ6ICcpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFkaiA9IDA7XG4gICAgICAgIHNldE1hdHJpeFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChBZGphY2VuY3lNYXRyaXhHcmFwaCkge1xuICAgICAgICBBZGphY2VuY3lNYXRyaXhHcmFwaC52ZXhudW0gPSBwYXJzZUludChwcm9tcHQoJ3ZleG51bTogJyksIDEwKTtcbiAgICAgICAgQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjbnVtID0gcGFyc2VJbnQocHJvbXB0KCdhcmNudW06ICcpLCAxMCk7XG4gICAgICAgIC8vIGluY0luZm/kuLow5YiZ5ZCE5byn5LiN5ZCr5YW25LuW5L+h5oGvXG4gICAgICAgIGxldCBpbmNJbmZvID0gcGFyc2VJbnQocHJvbXB0KCdpbmNJbmZvOiAnKSwgMTApO1xuXG4gICAgICAgIC8vIOaehOmAoOmhtueCueWQkemHj1xuICAgICAgICBsZXQgaSwgajtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IEFkamFjZW5jeU1hdHJpeEdyYXBoLnZleG51bTsgKytpKSBBZGphY2VuY3lNYXRyaXhHcmFwaC52ZXhzW2ldID0gcHJvbXB0KCfpobbngrnlkJHph492ZXg6ICcpO1xuXG4gICAgICAgIC8vIOWIneWni+WMlumCu+aOpeefqemYtVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgQWRqYWNlbmN5TWF0cml4R3JhcGgudmV4bnVtOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBBZGphY2VuY3lNYXRyaXhHcmFwaC52ZXhudW07ICsraikge1xuICAgICAgICAgICAgICAgIEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY3NbaV0gPSBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2ldIHx8IFtdO1xuICAgICAgICAgICAgICAgIEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY3NbaV1bal0gPSBuZXcgQXJjQ2VsbChhZGosIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g5p6E6YCg6YK75o6l55+p6Zi1XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjbnVtOyArK2spIHtcbiAgICAgICAgICAgIC8vIOi+k+WFpeS4gOadoei+ueS+nemZhOeahOmhtueCueWPiuadg+WAvFxuICAgICAgICAgICAgbGV0IHYxID0gcHJvbXB0KCd2MTogJyk7XG4gICAgICAgICAgICBsZXQgdjIgPSBwcm9tcHQoJ3YyOiAnKTtcblxuICAgICAgICAgICAgLy8g56Gu5a6adjHvvIx2MuWcqEfkuK3nmoTkvY3nva5cbiAgICAgICAgICAgIGkgPSBBZGphY2VuY3lNYXRyaXhHcmFwaC5sb2NhdGVWZXgodjEpO1xuICAgICAgICAgICAgaiA9IEFkamFjZW5jeU1hdHJpeEdyYXBoLmxvY2F0ZVZleCh2Mik7XG5cbiAgICAgICAgICAgIGxldCB3ID0gc2V0TWF0cml4VmFsdWUoKTtcbiAgICAgICAgICAgIC8vIOW8pzx2MSwgdjI+55qE5p2D5YC8XG4gICAgICAgICAgICBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2ldW2pdLmFkaiA9IHc7XG4gICAgICAgICAgICBpZiAoaW5jSW5mbykgQWRqYWNlbmN5TWF0cml4R3JhcGguYXJjc1tpXVtqXS5pbmZvID0gcHJvbXB0KCdpbmZvOiAnKTtcbiAgICAgICAgICAgIGlmIChraW5kID09PSAzIHx8IGtpbmQgPT09IDQpIEFkamFjZW5jeU1hdHJpeEdyYXBoLmFyY3Nbal1baV0gPSBBZGphY2VuY3lNYXRyaXhHcmFwaC5hcmNzW2ldW2pdO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8g56ys5LiA56eN5Yib5bu65Zu+5pa55rOVXG5sZXQgdmV4cyA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ107XG5sZXQgYXJjcyA9IFtcbiAgICBbXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxuICAgICAgICB7XCJhZGpcIjogXCI2XCIsIFwiaW5mb1wiOiBudWxsfSxcbiAgICAgICAge1wiYWRqXCI6IFwiMlwiLCBcImluZm9cIjogbnVsbH0sXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfVxuICAgIF0sXG4gICAgW1xuICAgICAgICB7XCJhZGpcIjogXCI2XCIsIFwiaW5mb1wiOiBudWxsfSxcbiAgICAgICAge1wiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbH0sXG4gICAgICAgIHtcImFkalwiOiBcIjNcIiwgXCJpbmZvXCI6IG51bGx9LFxuICAgICAgICB7XCJhZGpcIjogXCI0XCIsIFwiaW5mb1wiOiBudWxsfSxcbiAgICAgICAge1wiYWRqXCI6IFwiM1wiLCBcImluZm9cIjogbnVsbH1cbiAgICBdLFxuICAgIFtcbiAgICAgICAge1wiYWRqXCI6IFwiMlwiLCBcImluZm9cIjogbnVsbH0sXG4gICAgICAgIHtcImFkalwiOiBcIjNcIiwgXCJpbmZvXCI6IG51bGx9LFxuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfSxcbiAgICAgICAge1wiYWRqXCI6IFwiMVwiLCBcImluZm9cIjogbnVsbH0sXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9XG4gICAgXSxcbiAgICBbXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxuICAgICAgICB7XCJhZGpcIjogXCI0XCIsIFwiaW5mb1wiOiBudWxsfSxcbiAgICAgICAge1wiYWRqXCI6IFwiMVwiLCBcImluZm9cIjogbnVsbH0sXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxuICAgICAgICB7XCJhZGpcIjogXCI1XCIsIFwiaW5mb1wiOiBudWxsfVxuICAgIF0sXG4gICAgW1xuICAgICAgICB7XCJhZGpcIjogSW5maW5pdHksIFwiaW5mb1wiOiBudWxsfSxcbiAgICAgICAge1wiYWRqXCI6IFwiM1wiLCBcImluZm9cIjogbnVsbH0sXG4gICAgICAgIHtcImFkalwiOiBJbmZpbml0eSwgXCJpbmZvXCI6IG51bGx9LFxuICAgICAgICB7XCJhZGpcIjogXCI1XCIsIFwiaW5mb1wiOiBudWxsfSxcbiAgICAgICAge1wiYWRqXCI6IEluZmluaXR5LCBcImluZm9cIjogbnVsbH1cbiAgICBdXG5dO1xubGV0IHVkbiA9IG5ldyBBZGphY2VuY3lNYXRyaXhHcmFwaCh2ZXhzLCBhcmNzLCA1LCA3LCA0KTtcblxuLy8g56ys5LqM56eN5Yib5bu65Zu+5pa55rOVXG5sZXQgZG4gPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCAyKTtcbmRuLmFkZFZlcnRleCgnYScpO1xuZG4uYWRkVmVydGV4KCdiJyk7XG5kbi5hZGRWZXJ0ZXgoJ2MnKTtcbmRuLmFkZFZlcnRleCgnZCcpO1xuZG4uYWRkVmVydGV4KCdlJyk7XG5cbmRuLmFkZEFyYygnYScsICdiJywge1xuICAgIGFkajogNlxufSk7XG5kbi5hZGRBcmMoJ2EnLCAnYycsIHtcbiAgICBhZGo6IDJcbn0pO1xuZG4uYWRkQXJjKCdjJywgJ2InLCB7XG4gICAgYWRqOiAzXG59KTtcbmRuLmFkZEFyYygnYycsICdkJywge1xuICAgIGFkajogMVxufSk7XG5kbi5hZGRBcmMoJ2QnLCAnYicsIHtcbiAgICBhZGo6IDRcbn0pO1xuZG4uYWRkQXJjKCdiJywgJ2UnLCB7XG4gICAgYWRqOiAzXG59KTtcbmRuLmFkZEFyYygnZCcsICdlJywge1xuICAgIGFkajogNVxufSk7XG5cbmNvbnNvbGUubG9nKGRuKTtcblxuLypcblxuIC8vIOesrOS4ieenjeWIm+W7uuWbvuaWueazlVxuIGxldCBnID0gbmV3IEFkamFjZW5jeU1hdHJpeEdyYXBoKCk7XG4gZy5raW5kID0gRE47XG4gZy5jcmVhdGVHcmFwaCgpO1xuIGNvbnNvbGUubG9nKGcpO1xuXG4gKi9cblxuXG5cblxuLypcbiDlm77nmoTpgY3ljoZcblxuIOWbvueahOmBjeWOhihUcmF2ZXJpbmcgR3JhcGgp77ya5LuO5Zu+55qE5p+Q5LiA6aG254K55Ye65Y+R77yM6K6/6YGN5Zu+5Lit55qE5YW25L2Z6aG254K577yM5LiU5q+P5Liq6aG254K55LuF6KKr6K6/6Zeu5LiA5qyh44CC5Zu+55qE6YGN5Y6G566X5rOV5piv5ZCE56eN5Zu+55qE5pON5L2c55qE5Z+656GA44CCXG5cbiDil4Yg5aSN5p2C5oCn77ya5Zu+55qE5Lu75oSP6aG254K55Y+v6IO95ZKM5YW25L2Z55qE6aG254K555u46YK75o6l77yM5Y+v6IO95Zyo6K6/6Zeu5LqG5p+Q5Liq6aG254K55ZCO77yM5rK/5p+Q5p2h6Lev5b6E5pCc57Si5ZCO5Y+I5Zue5Yiw5Y6f6aG254K544CCXG4g4peGIOino+WGs+WKnuazle+8muWcqOmBjeWOhui/h+eoi+S4reiusOS4i+W3suiiq+iuv+mXrui/h+eahOmhtueCueOAguiuvue9ruS4gOS4qui+heWKqeWQkemHj1Zpc2l0ZWRbMeKApm5dKG7kuLrpobbngrnmlbAp77yM5YW25Yid5YC85Li6MO+8jOS4gOaXpuiuv+mXruS6humhtueCuXZp5ZCO77yM5L2/VmlzaXRlZFtpXeS4ujHmiJbkuLrorr/pl67nmoTmrKHluo/lj7fjgIJcbiDlm77nmoTpgY3ljobnrpfms5XmnInmt7HluqbkvJjlhYjmkJzntKLnrpfms5Xlkozlub/luqbkvJjlhYjmkJzntKLnrpfms5XjgIJcblxuIOa3seW6puS8mOWFiOaQnOe0oihEZXB0aCBGaXJzdCBTZWFyY2gtLURGUynpgY3ljobnsbvkvLzmoJHnmoTlhYjluo/pgY3ljobvvIzmmK/moJHnmoTlhYjluo/pgY3ljobnmoTmjqjlub/jgIJcblxuIOeul+azleaAneaDs1xuIOiuvuWIneWni+eKtuaAgeaXtuWbvuS4reeahOaJgOaciemhtueCueacquiiq+iuv+mXru+8jOWIme+8mlxuIOKRtCDvvJrku47lm77kuK3mn5DkuKrpobbngrl2aeWHuuWPke+8jOiuv+mXrnZp77yb54S25ZCO5om+5YiwdmnnmoTkuIDkuKrpgrvmjqXpobbngrl2aTEg77ybXG4g4pG177ya5LuOdmkx5Ye65Y+R77yM5rex5bqm5LyY5YWI5pCc57Si6K6/6Zeu5ZKMdmkx55u46YK75o6l5LiU5pyq6KKr6K6/6Zeu55qE5omA5pyJ6aG254K577ybXG4g4pG277ya6L2s4pG0IO+8jOebtOWIsOWSjHZp55u46YK75o6l55qE5omA5pyJ6aG254K56YO96KKr6K6/6Zeu5Li65q2iXG4g4pG3IO+8mue7p+e7remAieWPluWbvuS4reacquiiq+iuv+mXrumhtueCuXZq5L2c5Li66LW35aeL6aG254K577yM6L2sKDEp77yM55u05Yiw5Zu+5Lit5omA5pyJ6aG254K56YO96KKr6K6/6Zeu5Li65q2i44CCXG5cblxuIOW5v+W6puS8mOWFiOaQnOe0oihCcmVhZHRoIEZpcnN0IFNlYXJjaC0tQkZTKemBjeWOhuexu+S8vOagkeeahOaMieWxguasoemBjeWOhueahOi/h+eoi+OAglxuXG4g566X5rOV5oCd5oOzXG4g6K6+5Yid5aeL54q25oCB5pe25Zu+5Lit55qE5omA5pyJ6aG254K55pyq6KKr6K6/6Zeu77yM5YiZ77yaXG4g4pG0IO+8muS7juWbvuS4reafkOS4qumhtueCuXZp5Ye65Y+R77yM6K6/6ZeudmnvvJtcbiDikbXvvJrorr/pl652aeeahOaJgOacieebuOmCu+aOpeS4lOacquiiq+iuv+mXrueahOaJgOaciemhtueCuXZpMe+8jHZpMu+8jOKApu+8jHZpbe+8m1xuIOKRtu+8muS7pXZpMe+8jHZpMu+8jCDigKbvvIx2aW3nmoTmrKHluo/vvIzku6V2aWooMeKJpmriiaZtKeS+neatpOS9nOS4unZpIO+8jOi9rOKRtO+8m1xuIOKRtyDvvJrnu6fnu63pgInlj5blm77kuK3mnKrooqvorr/pl67pobbngrl2a+S9nOS4uui1t+Wni+mhtueCue+8jOi9rOKRtO+8jOebtOWIsOWbvuS4reaJgOaciemhtueCuemDveiiq+iuv+mXruS4uuatouOAglxuXG4g55So5bm/5bqm5LyY5YWI5pCc57Si566X5rOV6YGN5Y6G5Zu+5LiO5rex5bqm5LyY5YWI5pCc57Si566X5rOV6YGN5Y6G5Zu+55qE5ZSv5LiA5Yy65Yir5piv6YK75o6l54K55pCc57Si5qyh5bqP5LiN5ZCMLlxuICovXG5cblxuXG5jb25zb2xlLmxvZygnREZTVHJhdmVyc2U6IHVkbicpO1xuXG5sZXQgZzEgPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCBVREcpO1xuZzEuYWRkVmVydGV4KCd2MScpO1xuZzEuYWRkVmVydGV4KCd2MycpO1xuZzEuYWRkVmVydGV4KCd2MicpO1xuZzEuYWRkVmVydGV4KCd2NCcpO1xuZzEuYWRkVmVydGV4KCd2NScpO1xuXG5nMS5hZGRBcmMoJ3Y1JywgJ3Y0Jyk7XG5nMS5hZGRBcmMoJ3YzJywgJ3YxJyk7XG5nMS5hZGRBcmMoJ3YyJywgJ3YxJyk7XG5nMS5hZGRBcmMoJ3YzJywgJ3YyJyk7XG5cblxuZzEuREZTVHJhdmVyc2UoZnVuY3Rpb24gKHYpIHtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnZleHNbdl0pO1xufSk7XG5cblxuXG5cbmNvbnNvbGUubG9nKCdERlNUcmF2ZXJzZV9Ob25SZWN1cnNlOiB1ZG4nKTtcbmcxLkRGU1RyYXZlcnNlX05vblJlY3Vyc2UoZnVuY3Rpb24gKHYpIHtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnZleHNbdl0pO1xufSk7XG5cblxuXG5cbmNvbnNvbGUubG9nKCdCRlNUcmF2ZXJzZTogJyk7XG5sZXQgYnNmRyA9IG5ldyBBZGphY2VuY3lNYXRyaXhHcmFwaChbXSwgW10sIDAsIDAsIERHKTtcbmJzZkcuYWRkVmVydGV4KCd2MScpO1xuYnNmRy5hZGRWZXJ0ZXgoJ3YyJyk7XG5ic2ZHLmFkZFZlcnRleCgndjMnKTtcbmJzZkcuYWRkVmVydGV4KCd2NCcpO1xuYnNmRy5hZGRWZXJ0ZXgoJ3Y1Jyk7XG5cbmJzZkcuYWRkQXJjKCd2MScsICd2NCcpO1xuYnNmRy5hZGRBcmMoJ3YxJywgJ3YyJyk7XG5ic2ZHLmFkZEFyYygndjMnLCAndjUnKTtcbmJzZkcuYWRkQXJjKCd2MycsICd2MicpO1xuYnNmRy5hZGRBcmMoJ3YzJywgJ3YxJyk7XG5ic2ZHLmFkZEFyYygndjQnLCAndjMnKTtcbmJzZkcuYWRkQXJjKCd2NScsICd2NCcpO1xuXG5ic2ZHLkJGU1RyYXZlcnNlKGZ1bmN0aW9uICh2KSB7XG4gICAgY29uc29sZS5sb2codGhpcy52ZXhzW3ZdKTtcbn0pO1xuXG5cblxuXG4vKlxuIOacgOWwj+eUn+aIkOagkVxuXG4g5aaC5p6c6L+e6YCa5Zu+5piv5LiA5Liq5bim5p2D5Zu+77yM5YiZ5YW255Sf5oiQ5qCR5Lit55qE6L655Lmf5bim5p2D77yM55Sf5oiQ5qCR5Lit5omA5pyJ6L6555qE5p2D5YC85LmL5ZKM56ew5Li655Sf5oiQ5qCR55qE5Luj5Lu344CCXG5cbiDmnIDlsI/nlJ/miJDmoJEoTWluaW11bSBTcGFubmluZyBUcmVlKSDvvJrluKbmnYPov57pgJrlm77kuK3ku6Pku7fmnIDlsI/nmoTnlJ/miJDmoJHnp7DkuLrmnIDlsI/nlJ/miJDmoJHjgIJcblxuIOacgOWwj+eUn+aIkOagkeWcqOWunumZheS4reWFt+aciemHjeimgeeUqOmAlO+8jOWmguiuvuiuoemAmuS/oee9keOAguiuvuWbvueahOmhtueCueihqOekuuWfjuW4gu+8jOi+ueihqOekuuS4pOS4quWfjuW4guS5i+mXtOeahOmAmuS/oee6v+i3r++8jOi+ueeahOadg+WAvOihqOekuuW7uumAoOmAmuS/oee6v+i3r+eahOi0ueeUqOOAgm7kuKrln47luILkuYvpl7TmnIDlpJrlj6/ku6Xlu7pu74K0KG4tMSkvMuadoee6v+i3r++8jOWmguS9lemAieaLqeWFtuS4reeahG4tMeadoe+8jOS9v+aAu+eahOW7uumAoOi0ueeUqOacgOS9jj9cblxuIOaehOmAoOacgOWwj+eUn+aIkOagkeeahOeul+azleacieiuuOWkmu+8jOWfuuacrOWOn+WImeaYr++8mlxuIOKXhiDlsL3lj6/og73pgInlj5bmnYPlgLzmnIDlsI/nmoTovrnvvIzkvYbkuI3og73mnoTmiJDlm57ot6/vvJtcbiDil4Yg6YCJ5oupbi0x5p2h6L655p6E5oiQ5pyA5bCP55Sf5oiQ5qCR44CCXG4g5Lul5LiK55qE5Z+65pys5Y6f5YiZ5piv5Z+65LqOTVNU55qE5aaC5LiL5oCn6LSo77yaXG4g6K6+Rz0oVu+8jEUp5piv5LiA5Liq5bim5p2D6L+e6YCa5Zu+77yMVeaYr+mhtueCuembhlbnmoTkuIDkuKrpnZ7nqbrlrZDpm4bjgILoi6V14oiIVSDvvIx24oiIVi1V77yM5LiUKHUsIHYp5pivVeS4remhtueCueWIsFYtVeS4remhtueCueS5i+mXtOadg+WAvOacgOWwj+eahOi+ue+8jOWImeW/heWtmOWcqOS4gOajteWMheWQq+i+uSh1LCB2KeeahOacgOWwj+eUn+aIkOagkeOAglxuXG4g6K+B5piO77yaIOeUqOWPjeivgeazleivgeaYjuOAglxuIOiuvuWbvkfnmoTku7vkvZXkuIDmo7XmnIDlsI/nlJ/miJDmoJHpg73kuI3ljIXlkKvovrkodSx2KeOAguiuvlTmmK9H55qE5LiA5qO155Sf5oiQ5qCR77yM5YiZVOaYr+i/numAmueahO+8jOS7jnXliLB25b+F5pyJ5LiA5p2h6Lev5b6EKHUs4oCmLHYp77yM5b2T5bCG6L65KHUsdinliqDlhaXliLBU5Lit5pe25bCx5p6E5oiQ5LqG5Zue6Lev44CC5YiZ6Lev5b6EKHUsIOKApix2KeS4reW/heacieS4gOadoei+uSh14oCZLHbigJkpIO+8jOa7oei2s3XigJniiIhVIO+8jHbigJniiIhWLVUg44CC5Yig5Y676L65KHXigJksduKAmSkg5L6/5Y+v5raI6Zmk5Zue6Lev77yM5ZCM5pe25b6X5Yiw5Y+m5LiA5qO155Sf5oiQ5qCRVOKAmeOAglxuIOeUseS6jih1LHYp5pivVeS4remhtueCueWIsFYtVeS4remhtueCueS5i+mXtOadg+WAvOacgOWwj+eahOi+ue+8jOaVhSh1LHYp55qE5p2D5YC85LiN5Lya6auY5LqOKHXigJksduKAmSnnmoTmnYPlgLzvvIxU4oCZ55qE5Luj5Lu35Lmf5LiN5Lya6auY5LqOVO+8jCBU4oCZ5piv5YyF5ZCrKHUsdikg55qE5LiA5qO15pyA5bCP55Sf5oiQ5qCR77yM5LiO5YGH6K6+55+b55u+44CCXG5cbiAqL1xuXG4vKlxuIOaZrumHjOWnhihQcmltKeeul+azlVxuXG4g6YCC5ZCI6L6556ig5a+G55qE572RXG5cbiDku47ov57pgJrnvZFOPShV77yMRSnkuK3mib7mnIDlsI/nlJ/miJDmoJFUPShV77yMVEUpIOOAglxuXG4gMSDnrpfms5XmgJ3mg7NcbiDikbQgIOiLpeS7jumhtueCuXYw5Ye65Y+R5p6E6YCg77yMVT17djB977yMVEU9e33vvJtcbiDikbUg5YWI5om+5p2D5YC85pyA5bCP55qE6L65KHXvvIx2Ke+8jOWFtuS4rXXiiIhV5LiUduKIiFYtVe+8jOW5tuS4lOWtkOWbvuS4jeaehOaIkOeOr++8jOWImVU9IFXiiKp7dn3vvIxURT1UReKIqnsode+8jHYpfSDvvJtcbiDikbYg6YeN5aSN4pG1IO+8jOebtOWIsFU9VuS4uuatouOAguWImVRF5Lit5b+F5pyJbi0x5p2h6L6577yMIFQ9KFXvvIxURSnlsLHmmK/mnIDlsI/nlJ/miJDmoJHjgIJcblxuIDIu566X5rOV5a6e546w6K+05piOXG4g5Li65L6/5LqO566X5rOV5a6e546w77yM6K6+572u5LiA5Liq5LiA57u05pWw57uEY2xvc2VkZ2Vbbl3vvIznlKjmnaXkv53lrZhWLSBV5Lit5ZCE6aG254K55YiwVeS4remhtueCueWFt+acieadg+WAvOacgOWwj+eahOi+ueOAglxuIGNsb3NlZGdlW2pdLmFkanZleD1r77yM6KGo5piO6L65KHZqLCB2aynmmK9WLVXkuK3pobbngrl2auWIsFXkuK3mnYPlgLzmnIDlsI/nmoTovrnvvIzogIzpobbngrl2a+aYr+ivpei+ueaJgOS+nemZhOeahFXkuK3nmoTpobbngrnjgIIgY2xvc2VkZ2Vbal0ubG93Y29zdOWtmOaUvuivpei+ueeahOadg+WAvOOAglxuIOWBh+iuvuS7jumhtueCuXZz5byA5aeL5p6E6YCg5pyA5bCP55Sf5oiQ5qCR44CC5Yid5aeL5pe25Luk77yaXG4gQ2xvc2VkZ2Vbc10ubG93Y29zdD0wIO+8muihqOaYjumhtueCuXZz6aaW5YWI5Yqg5YWl5YiwVeS4re+8m1xuIENsb3NlZGdlW2tdLmFkanZleD1zIO+8jENsb3NlZGdlW2tdLmxvd2Nvc3Q9Y29zdChrLCBzKVxuIOihqOekulYtVeS4reeahOWQhOmhtueCueWIsFXkuK3mnYPlgLzmnIDlsI/nmoTovrkoa+KJoHMpIO+8jGNvc3QoaywgcynooajnpLrovrkodmssIHZzKSDmnYPlgLzjgIJcblxuIDMu566X5rOV5q2l6aqkXG4g4pG0ICDku45jbG9zZWRnZeS4remAieaLqeS4gOadoeadg+WAvCjkuI3kuLowKeacgOWwj+eahOi+uSh2aywgdmopIO+8jOeEtuWQjuWBmu+8mlxuIOKRoCDnva5jbG9zZWRnZVtrXS5sb3djb3N05Li6MCDvvIzooajnpLp2a+W3suWKoOWFpeWIsFXkuK3jgIJcbiDikaEgIOagueaNruaWsOWKoOWFpXZr55qE5pu05pawY2xvc2VkZ2XkuK3mr4/kuKrlhYPntKDvvJpcbiDvgKJ2aeKIiFYtVSDvvIzoi6Vjb3N0KGksIGsp4ommY29sc2VkZ2VbaV0ubG93Y29zdO+8jOihqOaYjuWcqFXkuK3mlrDliqDlhaXpobbngrl2a+WQju+8jCAodmksIHZrKeaIkOS4unZp5YiwVeS4readg+WAvOacgOWwj+eahOi+ue+8jOe9ru+8mlxuIENsb3NlZGdlW2ldLmxvd2Nvc3Q9Y29zdChpLCBrKVxuIENsb3NlZGdlW2ldLmFkanZleD1rXG4g4pG1ICDph43lpI3ikbRuLTHmrKHlsLHlvpfliLDmnIDlsI/nlJ/miJDmoJHjgIJcblxuIOeul+azleWIhuaekO+8mlxuIOiuvuW4puadg+i/numAmuWbvuaciW7kuKrpobbngrnvvIzliJnnrpfms5XnmoTkuLvopoHmiafooYzmmK/kuozph43lvqrnjq/vvJog5rGCY2xvc2VkZ2XkuK3mnYPlgLzmnIDlsI/nmoTovrnvvIzpopHluqbkuLpuLTHvvJsg5L+u5pS5Y2xvc2VkZ2XmlbDnu4TvvIzpopHluqbkuLpuIOOAguWboOatpO+8jOaVtOS4queul+azleeahOaXtumXtOWkjeadguW6puaYr08objIp77yM5LiO6L6555qE5pWw55uu5peg5YWz44CCXG5cbiAqL1xuXG51ZG4gPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCA0KTtcbnVkbi5hZGRWZXJ0ZXgoJ3YxJyk7XG51ZG4uYWRkVmVydGV4KCd2MicpO1xudWRuLmFkZFZlcnRleCgndjMnKTtcbnVkbi5hZGRWZXJ0ZXgoJ3Y0Jyk7XG51ZG4uYWRkVmVydGV4KCd2NScpO1xudWRuLmFkZFZlcnRleCgndjYnKTtcblxudWRuLmFkZEFyYygndjEnLCAndjInLCB7YWRqOiA2fSk7XG51ZG4uYWRkQXJjKCd2MScsICd2MycsIHthZGo6IDF9KTtcbnVkbi5hZGRBcmMoJ3YxJywgJ3Y0Jywge2FkajogNX0pO1xudWRuLmFkZEFyYygndjInLCAndjMnLCB7YWRqOiA1fSk7XG51ZG4uYWRkQXJjKCd2MicsICd2NScsIHthZGo6IDN9KTtcbnVkbi5hZGRBcmMoJ3YzJywgJ3Y0Jywge2FkajogNX0pO1xudWRuLmFkZEFyYygndjMnLCAndjUnLCB7YWRqOiA2fSk7XG51ZG4uYWRkQXJjKCd2MycsICd2NicsIHthZGo6IDR9KTtcbnVkbi5hZGRBcmMoJ3Y0JywgJ3Y2Jywge2FkajogMn0pO1xudWRuLmFkZEFyYygndjUnLCAndjYnLCB7YWRqOiA2fSk7XG5cbmNvbnNvbGUubG9nKCdtaW5TcGFuVHJlZV9QUklNOiAnKTtcbmNvbnNvbGUubG9nKHVkbi5taW5TcGFuVHJlZV9QUklNKDApKTtcblxuXG5cbi8qXG4g5YWL6bKB5pav5Y2h5bCUKEtydXNrYWwp566X5rOVXG5cbiDpgILlkIjovrnnqIDnlo/nmoTnvZFcblxuIDEg566X5rOV5oCd5oOzXG4g6K6+Rz0oViwgRSnmmK/lhbfmnIlu5Liq6aG254K555qE6L+e6YCa572R77yMVD0oVSwgVEUp5piv5YW25pyA5bCP55Sf5oiQ5qCR44CC5Yid5YC877yaVT1W77yMVEU9e30g44CCXG4g5a+5R+S4reeahOi+ueaMieadg+WAvOWkp+Wwj+S7juWwj+WIsOWkp+S+neasoemAieWPluOAglxuIOKRtCAgIOmAieWPluadg+WAvOacgOWwj+eahOi+uSh2ae+8jHZqKe+8jOiLpei+uSh2ae+8jHZqKeWKoOWFpeWIsFRF5ZCO5b2i5oiQ5Zue6Lev77yM5YiZ6IiN5byD6K+l6L65KOi+uSh2ae+8jHZqKSDvvJvlkKbliJnvvIzlsIbor6XovrnlubblhaXliLBUReS4re+8jOWNs1RFPVRF4oiqeyh2ae+8jHZqKX0g44CCXG4g4pG1IOmHjeWkjeKRtCDvvIznm7TliLBUReS4reWMheWQq+aciW4tMeadoei+ueS4uuatouOAglxuIOWmguWbvjctMjLmiYDmj5DnpLrjgIJcblxuIDIg566X5rOV5a6e546w6K+05piOXG4gS3J1c2thbOeul+azleWunueOsOeahOWFs+mUruaYr++8muW9k+S4gOadoei+ueWKoOWFpeWIsFRF55qE6ZuG5ZCI5ZCO77yM5aaC5L2V5Yik5pat5piv5ZCm5p6E5oiQ5Zue6LevP1xuIOeugOWNleeahOino+WGs+aWueazleaYr++8muWumuS5ieS4gOS4quS4gOe7tOaVsOe7hFZzZXRbbl0g77yM5a2Y5pS+5Zu+VOS4reavj+S4qumhtueCueaJgOWcqOeahOi/numAmuWIhumHj+eahOe8luWPt+OAglxuIOKXhiDliJ3lgLzvvJpWc2V0W2ldPWnvvIzooajnpLrmr4/kuKrpobbngrnlkIToh6rnu4TmiJDkuIDkuKrov57pgJrliIbph4/vvIzov57pgJrliIbph4/nmoTnvJblj7fnroDljZXlnLDkvb/nlKjpobbngrnlnKjlm77kuK3nmoTkvY3nva4o57yW5Y+3KeOAglxuIOKXhiDlvZPlvoBU5Lit5aKe5Yqg5LiA5p2h6L65KHZp77yMdmopIOaXtu+8jOWFiOajgOafpVZzZXRbaV3lkoxWc2V0W2pd5YC877yaXG4g4piGIOiLpVZzZXRbaV09VnNldFtqXe+8muihqOaYjnZp5ZKMdmrlpITlnKjlkIzkuIDkuKrov57pgJrliIbph4/kuK3vvIzliqDlhaXmraTovrnkvJrlvaLmiJDlm57ot6/vvJtcbiDimIYg6IulVnNldFtpXeKJoFZzZXRbal3vvIzliJnliqDlhaXmraTovrnkuI3kvJrlvaLmiJDlm57ot6/vvIzlsIbmraTovrnliqDlhaXliLDnlJ/miJDmoJHnmoTovrnpm4bkuK3jgIJcbiDil4Yg5Yqg5YWl5LiA5p2h5paw6L655ZCO77yM5bCG5Lik5Liq5LiN5ZCM55qE6L+e6YCa5YiG6YeP5ZCI5bm277ya5bCG5LiA5Liq6L+e6YCa5YiG6YeP55qE57yW5Y+35o2i5oiQ5Y+m5LiA5Liq6L+e6YCa5YiG6YeP55qE57yW5Y+344CCXG5cbiAqL1xuXG5jb25zb2xlLmxvZygnbWluU3BhblRyZWVfS3J1c2thbDogJyk7XG5jb25zb2xlLmxvZyh1ZG4ubWluU3BhblRyZWVfS3J1c2thbCgpKTtcblxuXG5cblxuLypcbiDmnIDnn63ot6/lvoRcblxuIOiLpeeUqOW4puadg+WbvuihqOekuuS6pOmAmue9ke+8jOWbvuS4remhtueCueihqOekuuWcsOeCue+8jOi+ueS7o+ihqOS4pOWcsOS5i+mXtOacieebtOaOpemBk+i3r++8jOi+ueS4iueahOadg+WAvOihqOekuui3r+eoiyjmiJbmiYDoirHotLnnlKjmiJbml7bpl7QpIOOAguS7juS4gOS4quWcsOaWueWIsOWPpuS4gOS4quWcsOaWueeahOi3r+W+hOmVv+W6puihqOekuuivpei3r+W+hOS4iuWQhOi+ueeahOadg+WAvOS5i+WSjOOAgumXrumimO+8mlxuIOKXhiDkuKTlnLDkuYvpl7TmmK/lkKbmnInpgJrot68/XG4g4peGIOWcqOacieWkmuadoemAmui3r+eahOaDheWGteS4i++8jOWTquadoeacgOefrT9cbiDogIPomZHliLDkuqTpgJrnvZHnmoTmnInlkJHmgKfvvIznm7TmjqXorqjorrrnmoTmmK/luKbmnYPmnInlkJHlm77nmoTmnIDnn63ot6/lvoTpl67popjvvIzkvYbop6PlhrPpl67popjnmoTnrpfms5XkuZ/pgILnlKjkuo7ml6DlkJHlm77jgIJcbiDlsIbkuIDkuKrot6/lvoTnmoTotbflp4vpobbngrnnp7DkuLrmupDngrnvvIzmnIDlkI7kuIDkuKrpobbngrnnp7DkuLrnu4jngrnjgIJcblxuXG4g5Y2V5rqQ54K55pyA55+t6Lev5b6EXG5cbiDlr7nkuo7nu5nlrprnmoTmnInlkJHlm75HPShW77yMRSnlj4rljZXkuKrmupDngrlWc++8jOaxglZz5YiwR+eahOWFtuS9meWQhOmhtueCueeahOacgOefrei3r+W+hOOAglxuIOmSiOWvueWNlea6kOeCueeahOacgOefrei3r+W+hOmXrumimO+8jERpamtzdHJh5o+Q5Ye65LqG5LiA56eN5oyJ6Lev5b6E6ZW/5bqm6YCS5aKe5qyh5bqP5Lqn55Sf5pyA55+t6Lev5b6E55qE566X5rOV77yM5Y2z6L+q5p2w5pav54m55ouJKERpamtzdHJhKeeul+azleOAglxuXG4gMSDln7rmnKzmgJ3mg7NcbiDku47lm77nmoTnu5nlrprmupDngrnliLDlhbblroPlkITkuKrpobbngrnkuYvpl7TlrqLop4LkuIrlupTlrZjlnKjkuIDmnaHmnIDnn63ot6/lvoTvvIzlnKjov5nnu4TmnIDnn63ot6/lvoTkuK3vvIzmjInlhbbplb/luqbnmoTpgJLlop7mrKHluo/vvIzkvp3mrKHmsYLlh7rliLDkuI3lkIzpobbngrnnmoTmnIDnn63ot6/lvoTlkozot6/lvoTplb/luqbjgIJcbiDljbPmjInplb/luqbpgJLlop7nmoTmrKHluo/nlJ/miJDlkITpobbngrnnmoTmnIDnn63ot6/lvoTvvIzljbPlhYjmsYLlh7rplb/luqbmnIDlsI/nmoTkuIDmnaHmnIDnn63ot6/lvoTvvIznhLblkI7msYLlh7rplb/luqbnrKzkuozlsI/nmoTmnIDnn63ot6/lvoTvvIzkvp3mraTnsbvmjqjvvIznm7TliLDmsYLlh7rplb/luqbmnIDplb/nmoTmnIDnn63ot6/lvoTjgIJcblxuIDIg566X5rOV5oCd5oOz6K+05piOXG4g6K6+57uZ5a6a5rqQ54K55Li6VnPvvIxT5Li65bey5rGC5b6X5pyA55+t6Lev5b6E55qE57uI54K56ZuG77yM5byA5aeL5pe25LukUz17VnN9IOOAguW9k+axguW+l+esrOS4gOadoeacgOefrei3r+W+hChWcyDvvIxWaSnlkI7vvIxT5Li6e1Zz77yMVml9IOOAguagueaNruS7peS4i+e7k+iuuuWPr+axguS4i+S4gOadoeacgOefrei3r+W+hOOAglxuIOiuvuS4i+S4gOadoeacgOefrei3r+W+hOe7iOeCueS4ulZqIO+8jOWImVZq5Y+q5pyJ77yaXG4g4peGICDmupDngrnliLDnu4jngrnmnInnm7TmjqXnmoTlvKc8VnPvvIxWaj7vvJtcbiDil4Yg5LuOVnMg5Ye65Y+R5YiwVmog55qE6L+Z5p2h5pyA55+t6Lev5b6E5omA57uP6L+H55qE5omA5pyJ5Lit6Ze06aG254K55b+F5a6a5ZyoU+S4reOAguWNs+WPquaciei/meadoeacgOefrei3r+W+hOeahOacgOWQjuS4gOadoeW8p+aJjeaYr+S7jlPlhoXmn5DkuKrpobbngrnov57mjqXliLBT5aSW55qE6aG254K5Vmog44CCXG4g6Iul5a6a5LmJ5LiA5Liq5pWw57uEZGlzdFtuXe+8jOWFtuavj+S4qmRpc3RbaV3liIbph4/kv53lrZjku45WcyDlh7rlj5HkuK3pl7Tlj6rnu4/ov4fpm4blkIhT5Lit55qE6aG254K56ICM5Yiw6L6+VmnnmoTmiYDmnInot6/lvoTkuK3plb/luqbmnIDlsI/nmoTot6/lvoTplb/luqblgLzvvIzliJnkuIvkuIDmnaHmnIDnn63ot6/lvoTnmoTnu4jngrlWauW/heWumuaYr+S4jeWcqFPkuK3kuJTlgLzmnIDlsI/nmoTpobbngrnvvIzljbPvvJpcbiBkaXN0W2ldPU1pbnsgZGlzdFtrXXwgVmviiIhWLVMgfVxuIOWIqeeUqOS4iui/sOWFrOW8j+WwseWPr+S7peS+neasoeaJvuWHuuS4i+S4gOadoeacgOefrei3r+W+hOOAglxuXG4gMyAg566X5rOV5q2l6aqkXG4g4pGgIOS7pFM9e1ZzfSDvvIznlKjluKbmnYPnmoTpgrvmjqXnn6npmLXooajnpLrmnInlkJHlm77vvIzlr7nlm77kuK3mr4/kuKrpobbngrlWaeaMieS7peS4i+WOn+WImee9ruWIneWAvO+8mlxuIDAgICAgaSA9c1xuIGRpc3RbaV0gPSAgIFdzaSAgICAgaeKJoHPkuJQ8dnMsdmk+4oiIRe+8jCB3c2nkuLrlvKfkuIrnmoTmnYPlgLxcbiDiiJ4gICBp4omgc+S4lDx2cyx2aT7kuI3lsZ7kuo5FXG4g4pGhIOmAieaLqeS4gOS4qumhtueCuVZqIO+8jOS9v+W+l++8mlxuIGRpc3Rbal09TWlueyBkaXN0W2tdfCBWa+KIiFYtUyB9XG4gVmrlsLHmmK/msYLlvpfnmoTkuIvkuIDmnaHmnIDnn63ot6/lvoTnu4jngrnvvIzlsIZWaiDlubblhaXliLBT5Lit77yM5Y2zUz1T4oiqe1ZqfSDjgIJcbiDikaIg5a+5Vi1T5Lit55qE5q+P5Liq6aG254K5Vmsg77yM5L+u5pS5ZGlzdFtrXe+8jOaWueazleaYr++8mlxuIOiLpWRpc3Rbal0rV2prPGRpc3Rba13vvIzliJnkv67mlLnkuLrvvJpcbiBkaXN0W2tdPWRpc3Rbal0rV2prICjvgKJWa+KIiFYtUyApXG4g4pGjIOmHjeWkjeKRoe+8jOKRou+8jOebtOWIsFM9VuS4uuatouOAglxuXG4gNCDnrpfms5Xlrp7njrBcbiDnlKjluKbmnYPnmoTpgrvmjqXnn6npmLXooajnpLrmnInlkJHlm77vvIwg5a+5UHJpbeeul+azleeVpeWKoOaUueWKqOWwseaIkOS6hkRpamtzdHJh566X5rOV77yM5bCGUHJpbeeul+azleS4reaxguavj+S4qumhtueCuVZr55qEbG93Y29zdOWAvOeUqGRpc3Rba13ku6Pmm7/ljbPlj6/jgIJcbiDil4YgIOiuvuaVsOe7hHByZVtuXeS/neWtmOS7jlZz5Yiw5YW25a6D6aG254K555qE5pyA55+t6Lev5b6E44CC6IulcHJlW2ldPWvvvIzooajnpLrku45WcyDliLBWaeeahOacgOefrei3r+W+hOS4re+8jFZp55qE5YmN5LiA5Liq6aG254K55pivVmvvvIzljbPmnIDnn63ot6/lvoTluo/liJfmmK8oVnMgLCDigKYsIFZrICAsIFZpKSDjgIJcbiDil4Yg6K6+5pWw57uEZmluYWxbbl3vvIzmoIfor4bkuIDkuKrpobbngrnmmK/lkKblt7LliqDlhaVT5Lit44CCXG5cbiA1ICDnrpfms5XliIbmnpBcbiBEaWprc3RyYeeul+azleeahOS4u+imgeaJp+ihjOaYr++8mlxuIOKXhiDmlbDnu4Tlj5jph4/nmoTliJ3lp4vljJbvvJrml7bpl7TlpI3mnYLluqbmmK9PKG4pIO+8m1xuIOKXhiDmsYLmnIDnn63ot6/lvoTnmoTkuozph43lvqrnjq/vvJrml7bpl7TlpI3mnYLluqbmmK9PKG4yKSDvvJtcbiDlm6DmraTvvIzmlbTkuKrnrpfms5XnmoTml7bpl7TlpI3mnYLluqbmmK9PKG4yKSDjgIJcblxuICovXG5cbmxldCBkaWpUZXN0ID0gbmV3IEFkamFjZW5jeU1hdHJpeEdyYXBoKFtdLCBbXSwgMCwgMCwgRE4pO1xuXG5kaWpUZXN0LmFkZFZlcnRleCgnMCcpO1xuZGlqVGVzdC5hZGRWZXJ0ZXgoJzEnKTtcbmRpalRlc3QuYWRkVmVydGV4KCcyJyk7XG5kaWpUZXN0LmFkZFZlcnRleCgnMycpO1xuZGlqVGVzdC5hZGRWZXJ0ZXgoJzQnKTtcbmRpalRlc3QuYWRkVmVydGV4KCc1Jyk7XG5cbmRpalRlc3QuYWRkQXJjKCcwJywgJzEnLCB7YWRqOiAyMH0pO1xuZGlqVGVzdC5hZGRBcmMoJzAnLCAnNCcsIHthZGo6IDEwfSk7XG5kaWpUZXN0LmFkZEFyYygnMCcsICcyJywge2FkajogNjB9KTtcbmRpalRlc3QuYWRkQXJjKCcwJywgJzUnLCB7YWRqOiA2NX0pO1xuZGlqVGVzdC5hZGRBcmMoJzEnLCAnMicsIHthZGo6IDMwfSk7XG5kaWpUZXN0LmFkZEFyYygnMicsICczJywge2FkajogNDB9KTtcbmRpalRlc3QuYWRkQXJjKCc1JywgJzInLCB7YWRqOiAxNX0pO1xuZGlqVGVzdC5hZGRBcmMoJzQnLCAnNScsIHthZGo6IDIwfSk7XG5kaWpUZXN0LmFkZEFyYygnMycsICc0Jywge2FkajogMzV9KTtcbmRpalRlc3QuYWRkQXJjKCcxJywgJzMnLCB7YWRqOiA3MH0pO1xuXG5kaWpUZXN0LnNob3J0ZXN0UGF0aF9EaWprc3RyYSgwKTtcblxuXG5cblxuXG4vKlxuIOavj+S4gOWvuemhtueCuemXtOeahOacgOefrei3r+W+hFxuXG4g55SoRGlqa3N0cmHnrpfms5XkuZ/lj6/ku6XmsYLlvpfmnInlkJHlm75HPShW77yMRSnkuK3mr4/kuIDlr7npobbngrnpl7TnmoTmnIDnn63ot6/lvoTjgILmlrnms5XmmK/vvJrmr4/mrKHku6XkuIDkuKrkuI3lkIznmoTpobbngrnkuLrmupDngrnph43lpI1EaWprc3RyYeeul+azleS+v+WPr+axguW+l+avj+S4gOWvuemhtueCuemXtOeahOacgOefrei3r+W+hO+8jOaXtumXtOWkjeadguW6puaYr08objMpIOOAglxuXG4g5byX572X5LyK5b63KEZsb3lkKeaPkOWHuuS6huWPpuS4gOS4queul+azle+8jOWFtuaXtumXtOWkjeadguW6puS7jeaYr08objMpIO+8jCDkvYbnrpfms5XlvaLlvI/mm7TkuLrnroDmmI7jgIJcblxuIDEg566X5rOV5oCd5oOzXG5cbiDorr7pobbngrnpm4ZTKOWIneWAvOS4uuepuinvvIznlKjmlbDnu4RB55qE5q+P5Liq5YWD57SgQVtpXVtqXeS/neWtmOS7jlZp5Y+q57uP6L+HU+S4reeahOmhtueCueWIsOi+vlZq55qE5pyA55+t6Lev5b6E6ZW/5bqm77yM5YW25oCd5oOz5piv77yaXG4g4pGgIOWIneWni+aXtuS7pFM9eyB9IO+8jCBBW2ldW2pd55qE6LWL5Yid5YC85pa55byP5piv77yaXG4gMCAgICBpID1q5pe2XG4gQVtpXVtqXT0gICAgV2lqICAgICBp4omgauS4lDx2aSx2aj7iiIhF77yMIHdpauS4uuW8p+S4iueahOadg+WAvFxuIOKIniAgIGniiaBq5LiUPHZpLHZqPuS4jeWxnuS6jkVcbiDikaEg5bCG5Zu+5Lit5LiA5Liq6aG254K5Vmsg5Yqg5YWl5YiwU+S4re+8jOS/ruaUuUFbaV1bal3nmoTlgLzvvIzkv67mlLnmlrnms5XmmK/vvJpcbiBBW2ldW2pdPU1pbntBW2ldW2pdICwgKEFbaV1ba10rQVtrXVtqXSkgfVxuIOWOn+WboO+8miDku45WauWPque7j+i/h1PkuK3nmoTpobbngrkoVmsp5Yiw6L6+VmrnmoTot6/lvoTplb/luqblj6/og73mr5Tljp/mnaXkuI3nu4/ov4dWa+eahOi3r+W+hOabtOefreOAglxuIOKRoiDph43lpI3ikaHvvIznm7TliLBH55qE5omA5pyJ6aG254K56YO95Yqg5YWl5YiwU+S4reS4uuatouOAglxuXG4gMiDnrpfms5Xlrp7njrBcblxuIOKXhiAg5a6a5LmJ5LqM57u05pWw57uEUGF0aFtuXVtuXShu5Li65Zu+55qE6aG254K55pWwKSDvvIzlhYPntKBQYXRoW2ldW2pd5L+d5a2Y5LuOVmnliLBWaueahOacgOefrei3r+W+hOaJgOe7j+i/h+eahOmhtueCueOAglxuIOKXhiDoi6VQYXRoW2ldW2pdPWvvvJrku45WaeWIsFZqIOe7j+i/h1ZrIO+8jOacgOefrei3r+W+hOW6j+WIl+aYryhWaSAsIOKApiwgVmsgLCDigKYsIFZqKSDvvIzliJnot6/lvoTlrZDluo/liJfvvJooVmkgLCDigKYsIFZrKeWSjChWayAsIOKApiwgVmop5LiA5a6a5piv5LuOVmnliLBWa+WSjOS7jlZr5YiwVmog55qE5pyA55+t6Lev5b6E44CC5LuO6ICM5Y+v5Lul5qC55o2uUGF0aFtpXVtrXeWSjFBhdGhba11bal3nmoTlgLzlho3mib7liLDor6Xot6/lvoTkuIrmiYDnu4/ov4fnmoTlhbblroPpobbngrnvvIzigKbkvp3mraTnsbvmjqjjgIJcbiDil4Yg5Yid5aeL5YyW5Li6UGF0aFtpXVtqXT0tMe+8jOihqOekuuS7jlZp5YiwVmog5LiN57uP6L+H5Lu75L2VKFPkuK3nmoTkuK3pl7Qp6aG254K544CC5b2T5p+Q5Liq6aG254K5VmvliqDlhaXliLBT5Lit5ZCO5L2/QVtpXVtqXeWPmOWwj+aXtu+8jOS7pFBhdGhbaV1bal09a+OAglxuXG5cbiAqL1xuXG5sZXQgZmxveWQgPSBuZXcgQWRqYWNlbmN5TWF0cml4R3JhcGgoW10sIFtdLCAwLCAwLCBETik7XG5mbG95ZC5hZGRWZXJ0ZXgoJ3YwJyk7XG5mbG95ZC5hZGRWZXJ0ZXgoJ3YxJyk7XG5mbG95ZC5hZGRWZXJ0ZXgoJ3YyJyk7XG5mbG95ZC5hZGRBcmMoJ3YwJywgJ3YyJywge2FkajogOH0pO1xuZmxveWQuYWRkQXJjKCd2MCcsICd2MScsIHthZGo6IDJ9KTtcbmZsb3lkLmFkZEFyYygndjEnLCAndjInLCB7YWRqOiA0fSk7XG5mbG95ZC5hZGRBcmMoJ3YyJywgJ3YwJywge2FkajogNX0pO1xuXG5mbG95ZC5zaG9ydGVzdFBhdGhfRkxPWUQoKTtcblxuLy8gaHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGd1aXN1L2FydGljbGUvZGV0YWlscy83NzE5NDI4XG4vLyDmt7vliqDjgIrlm77nmoTlupTnlKjor6bop6Mt5pWw5o2u57uT5p6E44CLXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0dyYXBoL0FkamFjZW5jeU1hdHJpeEdyYXBoLmpzIiwiLypcbiDljYHlrZfpk77ooajms5VcblxuIOWNgeWtl+mTvuihqChPcnRob2dvbmFsIExpc3Qp5piv5pyJ5ZCR5Zu+55qE5Y+m5LiA56eN6ZO+5byP5a2Y5YKo57uT5p6E77yM5piv5bCG5pyJ5ZCR5Zu+55qE5q2j6YK75o6l6KGo5ZKM6YCG6YK75o6l6KGo57uT5ZCI6LW35p2l5b6X5Yiw55qE5LiA56eN6ZO+6KGo44CCXG5cbiDlnKjov5nnp43nu5PmnoTkuK3vvIzmr4/mnaHlvKfnmoTlvKflpLTnu5PngrnlkozlvKflsL7nu5Pngrnpg73lrZjmlL7lnKjpk77ooajkuK3vvIzlubblsIblvKfnu5PngrnliIbliKvnu4Tnu4fliLDku6XlvKflsL7nu5PngrnkuLrlpLQo6aG254K5Kee7k+eCueWSjOS7peW8p+WktOe7k+eCueS4uuWktCjpobbngrkp57uT54K555qE6ZO+6KGo5Lit44CCXG5cbiDil4YgIGRhdGHln5/vvJrlrZjlgqjlkozpobbngrnnm7jlhbPnmoTkv6Hmga/vvJtcbiDil4Yg5oyH6ZKI5Z+fZmlyc3Rpbu+8muaMh+WQkeS7peivpemhtueCueS4uuW8p+WktOeahOesrOS4gOadoeW8p+aJgOWvueW6lOeahOW8p+e7k+eCue+8m1xuIOKXhiDmjIfpkojln59maXJzdG91dO+8muaMh+WQkeS7peivpemhtueCueS4uuW8p+WwvueahOesrOS4gOadoeW8p+aJgOWvueW6lOeahOW8p+e7k+eCue+8m1xuIOKXhiDlsL7ln590YWlsdmV477ya5oyH56S65byn5bC+6aG254K55Zyo5Zu+5Lit55qE5L2N572u77ybXG4g4peGIOWktOWfn2hlYWR2ZXjvvJrmjIfnpLrlvKflpLTpobbngrnlnKjlm77kuK3nmoTkvY3nva7vvJtcbiDil4Yg5oyH6ZKI5Z+faGxpbmvvvJrmjIflkJHlvKflpLTnm7jlkIznmoTkuIvkuIDmnaHlvKfvvJtcbiDil4Yg5oyH6ZKI5Z+fdGxpbmvvvJrmjIflkJHlvKflsL7nm7jlkIznmoTkuIvkuIDmnaHlvKfvvJtcbiDil4YgSW5mb+Wfn++8muaMh+WQkeivpeW8p+eahOebuOWFs+S/oeaBr++8m1xuXG4g5LuO6L+Z56eN5a2Y5YKo57uT5p6E5Zu+5Y+v5Lul55yL5Ye677yM5LuO5LiA5Liq6aG254K557uT54K555qEZmlyc3RvdXTlh7rlj5HvvIzmsr/ooajnu5PngrnnmoR0bGlua+aMh+mSiOaehOaIkOS6huato+mCu+aOpeihqOeahOmTvuihqOe7k+aehO+8jOiAjOS7juS4gOS4qumhtueCuee7k+eCueeahGZpcnN0aW7lh7rlj5HvvIzmsr/ooajnu5PngrnnmoRobGlua+aMh+mSiOaehOaIkOS6humAhumCu+aOpeihqOeahOmTvuihqOe7k+aehOOAglxuXG4gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGhlYWRWZXgg5byn55qE5aS06aG254K555qE5L2N572uXG4gKiBAcGFyYW0ge051bWJlcn0gdGFpbFZleCDlvKfnmoTlsL7pobbngrnkvY3nva5cbiAqIEBwYXJhbSB7QXJjQm94fSBoTGluayDlvKflpLTnm7jlkIznmoTlvKfnmoTpk77ln59cbiAqIEBwYXJhbSB7QXJjQm94fSB0TGluayDlvKflsL7nm7jlkIznmoTlvKfnmoTpk77ln59cbiAqIEBwYXJhbSB7Kn0gaW5mb1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEFyY0JveCh0YWlsVmV4LCBoZWFkVmV4LCBoTGluaywgdExpbmssIGluZm8pIHtcbiAgICB0aGlzLmhlYWRWZXggPSBoZWFkVmV4IHx8IDA7XG4gICAgdGhpcy50YWlsVmV4ID0gdGFpbFZleCB8fCAwO1xuICAgIHRoaXMuaExpbmsgPSBoTGluayB8fCBudWxsO1xuICAgIHRoaXMudExpbmsgPSB0TGluayB8fCBudWxsO1xuICAgIHRoaXMuaW5mbyA9IGluZm8gfHwgbnVsbDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhXG4gKiBAcGFyYW0ge0FyY0JveH0gZmlyc3RJbiDor6XpobbngrnnrKzkuIDmnaHlhaXlvKdcbiAqIEBwYXJhbSB7QXJjQm94fSBmaXJzdE91dCDor6XpobbngrnnrKzkuIDmnaHlh7rlvKdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBPTFZleE5vZGUoZGF0YSwgZmlyc3RJbiwgZmlyc3RPdXQpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IG51bGw7XG4gICAgdGhpcy5maXJzdEluID0gZmlyc3RJbiB8fCBudWxsO1xuICAgIHRoaXMuZmlyc3RPdXQgPSBmaXJzdE91dCB8fCBudWxsO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0FycmF5IHwgT0xWZXhOb2RlfSB4TGlzdCDooajlpLTlkJHph49cbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZXhudW0g5pyJ5ZCR5Zu+55qE5b2T5YmN6aG254K55pWwXG4gKiBAcGFyYW0ge051bWJlcn0gYXJjbnVtIOacieWQkeWbvueahOW9k+WJjeW8p+aVsFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE9MR3JhcGgoeExpc3QsIHZleG51bSwgYXJjbnVtKSB7XG4gICAgdGhpcy54TGlzdCA9IHhMaXN0IHx8IFtdO1xuICAgIHRoaXMudmV4bnVtID0gdmV4bnVtIHx8IDA7XG4gICAgdGhpcy5hcmNudW0gPSBhcmNudW0gfHwgMDtcbn1cbk9MR3JhcGgucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBPTEdyYXBoLFxuXG4gICAgbG9jYXRlVmV4OiBmdW5jdGlvbiAodnApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy54TGlzdFtpXS5kYXRhID09PSB2cCkgcmV0dXJuIGk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSxcblxuICAgIC8vIOWIoOmZpOmhtueCuVxuICAgIGRlbGV0ZVZlcnRleDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmxvY2F0ZVZleCh2KTtcblxuICAgICAgICBpZiAobSA8IDApIHRocm93IG5ldyBFcnJvcigndmVydGV4IG5vdCBmb3VuZCEnKTtcblxuICAgICAgICB2YXIgbiA9IHRoaXMudmV4bnVtO1xuICAgICAgICB2YXIgcSwgaSwgcDtcbiAgICAgICAgLy8g5Yig6Zmk5omA5pyJ5LulduS4uuWktOeahOi+uVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAvLyDlpoLmnpzlvoXliKDpmaTnmoTovrnmmK/lpLTpk77kuIrnmoTnrKzkuIDkuKrnu5PngrlcbiAgICAgICAgICAgIGlmICh0aGlzLnhMaXN0W2ldLmZpcnN0SW4udGFpbFZleCA9PT0gbSkge1xuICAgICAgICAgICAgICAgIHEgPSB0aGlzLnhMaXN0W2ldLmZpcnN0SW47XG4gICAgICAgICAgICAgICAgdGhpcy54TGlzdFtpXS5maXJzdEluID0gcS5oTGluaztcbiAgICAgICAgICAgICAgICB0aGlzLmFyY251bS0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHAgPSB0aGlzLnhMaXN0W2ldLmZpcnN0SW47IHAgJiYgcC5oTGluay50YWlsVmV4ICE9PSBtOyBwID0gcC5oTGluayk7XG4gICAgICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHAuaExpbms7XG4gICAgICAgICAgICAgICAgICAgIHAuaExpbmsgPSBxLmhMaW5rO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyY251bS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWIoOmZpOaJgOacieS7pXbkuLrlsL7nmoTovrlcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgLy8g5aaC5p6c5b6F5Yig6Zmk55qE6L655piv5bC+6ZO+5LiK55qE56ys5LiA5Liq57uT54K5XG4gICAgICAgICAgICBpZiAodGhpcy54TGlzdFtpXS5maXJzdE91dC5oZWFkVmV4ID09PSBtKSB7XG4gICAgICAgICAgICAgICAgcSA9IHRoaXMueExpc3RbaV0uZmlyc3RPdXQ7XG4gICAgICAgICAgICAgICAgdGhpcy54TGlzdFtpXS5maXJzdE91dCA9IHEudExpbms7XG4gICAgICAgICAgICAgICAgdGhpcy5hcmNudW0tLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChwID0gdGhpcy54TGlzdFtpXS5maXJzdE91dDsgcCAmJiBwLnRMaW5rLmhlYWRWZXggIT09IG07IHAgPSBwLnRMaW5rKTtcbiAgICAgICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgICAgICBxID0gcC50TGluaztcbiAgICAgICAgICAgICAgICAgICAgcC50TGluayA9IHEudExpbms7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJjbnVtLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g6aG65qyh55So57uT54K5beS5i+WQjueahOmhtueCueWPluS7o+WJjeS4gOS4qumhtueCuVxuICAgICAgICBmb3IgKGkgPSBtOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAvLyDkv67mlLnooajlpLTlkJHph49cbiAgICAgICAgICAgIHRoaXMueExpc3RbaV0gPSB0aGlzLnhMaXN0W2kgKyAxXTtcbiAgICAgICAgICAgIGZvciAocCA9IHRoaXMueExpc3RbaV0uZmlyc3RJbjsgcDsgcCA9IHAuaExpbmspXG4gICAgICAgICAgICAgICAgcC5oZWFkVmV4LS07XG4gICAgICAgICAgICBmb3IgKHAgPSB0aGlzLnhMaXN0W2ldLmZpcnN0T3V0OyBwOyBwID0gcC50TGluaylcbiAgICAgICAgICAgICAgICBwLnRhaWxWZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmV4bnVtLS07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBjcmVhdGVERzogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZleG51bSA9IHByb21wdCgnVmV4bnVtOiAnKTtcbiAgICAgICAgdGhpcy5hcmNudW0gPSBwcm9tcHQoJ0FyY251bTogJyk7XG4gICAgICAgIC8vIEluY0luZm/kuLow5YiZ5ZCE5byn5LiN5ZCr5YW25LuW5L+h5oGvXG4gICAgICAgIHZhciBpbmNJbmZvID0gK3Byb21wdCgnSW5jSW5mbzogJyk7XG5cbiAgICAgICAgLy8g6L6T5YWl6aG254K55YC8XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkge1xuICAgICAgICAgICAgdGhpcy54TGlzdFtpXSA9IG5ldyBPTFZleE5vZGUocHJvbXB0KCdkYXRhOiAnKSwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuYXJjbnVtOyArK2spIHtcbiAgICAgICAgICAgIHZhciB2MSA9IHByb21wdCgndjE6ICcpO1xuICAgICAgICAgICAgdmFyIHYyID0gcHJvbXB0KCd2MjogJyk7XG5cbiAgICAgICAgICAgIGkgPSB0aGlzLmxvY2F0ZVZleCh2MSk7XG4gICAgICAgICAgICB2YXIgaiA9IHRoaXMubG9jYXRlVmV4KHYyKTtcblxuICAgICAgICAgICAgaWYgKGkgPT09IC0xIHx8IGogPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ+aXoOatpOmhtueCue+8jOivt+mHjeaWsOi+k+WFpSEnKTtcbiAgICAgICAgICAgICAgICBrLS07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwID0gbmV3IEFyY0JveChpLCBqLCB0aGlzLnhMaXN0W2pdLmZpcnN0SW4sIHRoaXMueExpc3RbaV0uZmlyc3RPdXQsIGluY0luZm8gJiYgcHJvbXB0KCdpbmZvOiAnKSk7XG4gICAgICAgICAgICB0aGlzLnhMaXN0W2pdLmZpcnN0SW4gPSB0aGlzLnhMaXN0W2ldLmZpcnN0T3V0ID0gcDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDmsYLmnInlkJHlm77nmoTlvLrov57pgJrliIbph49cbiAgICAgKi9cbiAgICBnZXRTR3JhcGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZpc2l0ZWQgPSBbXTtcbiAgICAgICAgdmFyIGZpbmlzaGVkID0gW107XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XG4gICAgICAgIC8vIOesrOS4gOasoea3seW6puS8mOWFiOmBjeWOhuW7uueri2ZpbmlzaGVk5pWw57uEXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbaV0pIGRmczEodGhpcywgaSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8g5riF56m6dmlzaXRlZOaVsOe7hFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xuICAgICAgICAvLyDnrKzkuozmrKHpgIblkJHnmoTmt7HluqbkvJjlhYjpgY3ljoZcbiAgICAgICAgZm9yICh2YXIgbGVuID0gdGhpcy52ZXhudW0gLSAxOyBsZW4gPj0gMDsgLS1sZW4pIHtcbiAgICAgICAgICAgIGkgPSBmaW5pc2hlZFtpXTtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtpXSkgZGZzMih0aGlzLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRmczEoZ3JhcGgsIHYpIHtcbiAgICAgICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgcCA9IGdyYXBoLnhMaXN0W3ZdLmZpcnN0T3V0OyBwOyBwID0gcC50TGluaykge1xuICAgICAgICAgICAgICAgIHZhciB3ID0gcC5oZWFkVmV4O1xuICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZFt3XSkgZGZzMShncmFwaCwgdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5pc2hlZFsrK2NvdW50XSA9IHY7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZnMyKGdyYXBoLCB2KSB7XG4gICAgICAgICAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCclZCcsIHYpO1xuICAgICAgICAgICAgZm9yICh2YXIgcCA9IGdyYXBoLnhMaXN0W3ZdLmZpcnN0SW47IHA7IHAgPSBwLmhMaW5rKSB7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBwLnRhaWxWZXg7XG4gICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkW3ddKSBkZnMyKGdyYXBoLCB3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vdmFyIGcgPSBuZXcgT0xHcmFwaCgpO1xuLy9nLmNyZWF0ZURHKCk7XG4vL2NvbnNvbGUubG9nKGcpO1xuXG5cbi8qXG4g5pyJ5ZCR5Zu+55qE5by66L+e6YCa5YiG6YePXG5cbiDlr7nkuo7mnInlkJHlm77vvIzlnKjlhbbmr4/kuIDkuKrlvLrov57pgJrliIbph4/kuK3vvIzku7vkvZXkuKTkuKrpobbngrnpg73mmK/lj6/ovr7nmoTjgIIgVuKIiEfvvIzkuI5W5Y+v55u45LqS5Yiw6L6+55qE5omA5pyJ6aG254K55bCx5piv5YyF5ZCrVueahOW8uui/numAmuWIhumHj+eahOaJgOaciemhtueCueOAglxuXG4g6K6+5LuOVuWPr+WIsOi+viAo5LulVuS4uui1t+eCueeahOaJgOacieacieWQkei3r+W+hOeahOe7iOeCuSnnmoTpobbngrnpm4blkIjkuLpUMShHKe+8jOiAjOWIsOi+vlYgKOS7pVbkuLrnu4jngrnnmoTmiYDmnInmnInlkJHot6/lvoTnmoTotbfngrkp55qE6aG254K56ZuG5ZCI5Li6VDIoRynvvIzliJnljIXlkKtW55qE5by66L+e6YCa5YiG6YeP55qE6aG254K56ZuG5ZCI5piv77yaIFQxKEcp4oipVDIoRykg44CCXG5cbiDmsYLmnInlkJHlm75H55qE5by66L+e6YCa5YiG6YeP55qE5Z+65pys5q2l6aqk5piv77yaXG4g4pG0IOWvuUfov5vooYzmt7HluqbkvJjlhYjpgY3ljobvvIznlJ/miJBH55qE5rex5bqm5LyY5YWI55Sf5oiQ5qOu5p6XVOOAglxuIOKRtSAg5a+55qOu5p6XVOeahOmhtueCueaMieS4reW6j+mBjeWOhumhuuW6j+i/m+ihjOe8luWPt+OAglxuIOKRtiAg5pS55Y+YR+S4reavj+S4gOadoeW8p+eahOaWueWQke+8jOaehOaIkOS4gOS4quaWsOeahOacieWQkeWbvkfigJnjgIJcbiDikbcgIOaMieKRteS4reagh+WHuueahOmhtueCuee8luWPt++8jOS7jue8luWPt+acgOWkp+eahOmhtueCueW8gOWni+WvuUfigJnov5vooYzmt7HluqbkvJjlhYjmkJzntKLvvIzlvpfliLDkuIDmo7Xmt7HluqbkvJjlhYjnlJ/miJDmoJHjgILoi6XkuIDmrKHlrozmlbTnmoTmkJzntKLov4fnqIvmsqHmnInpgY3ljoZH4oCZ55qE5omA5pyJ6aG254K577yM5YiZ5LuO5pyq6K6/6Zeu55qE6aG254K55Lit6YCJ5oup5LiA5Liq57yW5Y+35pyA5aSn55qE6aG254K577yM55Sx5a6D5byA5aeL5YaN6L+b6KGM5rex5bqm5LyY5YWI5pCc57Si77yM5bm25b6X5Yiw5Y+m5LiA5qO15rex5bqm5LyY5YWI55Sf5oiQ5qCR44CC5Zyo6K+l5q2l6aqk5Lit77yM5q+P5LiA5qyh5rex5bqm5LyY5YWI5pCc57Si5omA5b6X5Yiw55qE55Sf5oiQ5qCR5Lit55qE6aG254K55bCx5pivR+eahOS4gOS4quW8uui/numAmuWIhumHj+eahOaJgOaciemhtueCueOAglxuIOKRuCAg6YeN5aSN5q2l6aqk4pG3IO+8jOebtOWIsEfigJnkuK3nmoTmiYDmnInpobbngrnpg73ooqvorr/pl67jgIJcblxuIOWcqOeul+azleWunueOsOaXtu+8jOW7uueri+S4gOS4quaVsOe7hGluX29yZGVyW25d5a2Y5pS+5rex5bqm5LyY5YWI55Sf5oiQ5qOu5p6X55qE5Lit5bqP6YGN5Y6G5bqP5YiX44CC5a+55q+P5Liq6aG254K5du+8jOWcqOiwg+eUqERGU+WHveaVsOe7k+adn+aXtu+8jOWwhumhtueCueS+neasoeWtmOaUvuWcqOaVsOe7hGluX29yZGVyW25d5Lit44CC5Zu+6YeH55So5Y2B5a2X6ZO+6KGo5L2c5Li65a2Y5YKo57uT5p6E5pyA5ZCI6YCC44CCXG5cbiAqL1xuXG4vLyB0b2RvIHRvIGJlIHRlc3RlZFxuT0xHcmFwaC5wcm90b3R5cGUuY29ubmVjdGVkX0RHID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aXNpdGVkID0gW107XG4gICAgdmFyIGluX29yZGVyID0gW107XG4gICAgdmFyIGNvdW50ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXhudW07ICsraSkgdmlzaXRlZFtpXSA9IGZhbHNlO1xuICAgIC8vIOWvueWbvuato+WQkemBjeWOhlxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB7XG4gICAgICAgIGlmICghdmlzaXRlZFtpXSkge1xuICAgICAgICAgICAgZGZzKHRoaXMsIGksIGluX29yZGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZleG51bTsgKytpKSB2aXNpdGVkW2ldID0gZmFsc2U7XG4gICAgLy8g5a+55Zu+6YCG5ZCR6YGN5Y6GXG4gICAgdmFyIGsgPSAxO1xuICAgIGZvciAodmFyIGogPSB0aGlzLnZleG51bSAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgIHZhciB2ID0gaW5fb3JkZXJbal07XG4gICAgICAgIGlmICghdmlzaXRlZFt2XSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ+esrCcgKyBrKysgKyAn5Liq6L+e6YCa5YiG6YeP6aG254K5Jyk7XG4gICAgICAgICAgICByZXZfZGZzKHRoaXMsIHYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGZzKGdyYXBoLCB2KSB7XG4gICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIHAgPSBncmFwaC54TGlzdFt2XS5maXJzdE91dDsgcDsgcCA9IHAudExpbmspIHtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtwLmhlYWRWZXhdKSB7XG4gICAgICAgICAgICAgICAgZGZzKGdyYXBoLCBwLmhlYWRWZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5fb3JkZXJbY291bnQrK10gPSB2O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJldl9kZnMoZ3JhcGgsIHYpIHtcbiAgICAgICAgdmlzaXRlZFt2XSA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKCfpobbngrnvvJonICsgdik7XG5cbiAgICAgICAgZm9yICh2YXIgcCA9IGdyYXBoLnhMaXN0W3ZdLmZpcnN0SW47IHA7IHAgPSBwLmhMaW5rKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbcC50YWlsVmV4XSkge1xuICAgICAgICAgICAgICAgIHJldl9kZnMoZ3JhcGgsIHAudGFpbFZleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9HcmFwaC9PTEdyYXBoLmpzIiwiLyoqXG4gKiBMUlUoIExlYXN0IHJlY2VudGx5IHVzZWQgKVxuICovXG5cbmltcG9ydCBEb3VibGVMaW5rZWRMaXN0IGZyb20gJy4vRG91YmxlTGlua2VkTGlzdCc7XG5cbmNvbnN0IExJTUlUID0gMjA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExSVUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihzcUxpc3QsIGxpbWl0ID0gTElNSVQpe1xuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XG4gICAgICAgIHNxTGlzdCA9IChzcUxpc3QgJiYgc3FMaXN0Lmxlbmd0aCkgPyBzcUxpc3QgJiYgc3FMaXN0LnNsaWNlKDAsIHRoaXMubGltaXQpIDogW107XG4gICAgICAgIHRoaXMuX19jYWNoZSA9IG5ldyBEb3VibGVMaW5rZWRMaXN0KHNxTGlzdCwgZnVuY3Rpb24oYSwgYil7XG4gICAgICAgICAgICByZXR1cm4gYS5rZXkgPT09IGIua2V5O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG5cbiAgICBnZXQgc2l6ZSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLnNpemU7XG4gICAgfVxuICAgIFxuICAgIHJlbW92ZShrZXkpe1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLnJlbW92ZSh7IGtleSB9KTtcbiAgICB9XG5cbiAgICBjbGVhcigpe1xuICAgICAgICByZXR1cm4gdGhpcy5fX19jYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICBcbiAgICBnZXQoa2V5KXtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5fX2NhY2hlLmluZGV4T2YoeyBrZXkgfSk7XG5cbiAgICAgICAgaWYoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9fY2FjaGUuZmluZEJ5SW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fX2NhY2hlLnJlbW92ZShkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX19jYWNoZS51bnNoaWZ0KGRhdGEpO1xuXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgYWRkKGtleSwgdmFsdWUpe1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIGlmKGRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKHRoaXMuc2l6ZSA9PT0gdGhpcy5saW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19jYWNoZS5wb3AoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fX2NhY2hlLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1N0cmluZygpe1xuICAgICAgICBsZXQgYXJyID0gW107XG4gICAgICAgIHRoaXMuX19jYWNoZS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgYXJyLnB1c2goYCR7IGRhdGEua2V5IH06JHsgZGF0YS52YWx1ZSB9YCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhcnIuam9pbignID4gJyk7XG4gICAgfVxuXG4gICAgdG9KU09OKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY2FjaGUudG9KU09OKCk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0xpc3QvTFJVLmpzIiwiLyoqXG4gKiDnur/mgKfooahcbiAqL1xuXG4vLyDnur/mgKfooajnmoTnsbvlnovlrprkuYlcbi8vIOWwhuaJgOacieWcqOaVsOe7hGLkuK3kvYbkuI3lnKjmlbDnu4Rh55qE5pWw5o2u5YWD57Sg5o+S5YWl5YiwYeS4rVxuXG52YXIgYSA9IFsxLCAyLCAzLCA0LCA1XTtcbnZhciBiID0gWzEsIDMsIDUsIDcsIDldO1xuXG5leHBvcnQgZnVuY3Rpb24gdW5pb24oYSwgYikge1xuICAgIHZhciBlbGVtLCBlcXVhbDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBiTGVuID0gYi5sZW5ndGg7IGkgPCBiTGVuOyBpKyspIHtcbiAgICAgICAgZWxlbSA9IGJbaV07XG4gICAgICAgIGVxdWFsID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGFMZW4gPSBhLmxlbmd0aDsgaiA8IGFMZW47IGorKykge1xuICAgICAgICAgICAgaWYgKGVsZW0gPT09IGFbal0pIHtcbiAgICAgICAgICAgICAgICBlcXVhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVxdWFsKSBhLnB1c2goZWxlbSk7XG4gICAgfVxufVxuXG51bmlvbihhLCBiKTtcbmNvbnNvbGUubG9nKGEpO1xuLy8gWzEsIDIsIDMsIDQsIDUsIDcsIDldXG5cbi8vIOaXtumXtOWkjeadguW6pu+8mk8oYUxlbiAqIGJMZW4pXG5cbi8vIOW3suefpeaVsOe7hGHlkozmlbDnu4Ri5Lit55qE5pWw5o2u5YWD57Sg5oyJ5YC86Z2e6YCS5YeP5o6S5YiXXG4vLyDlvZLlubZh5ZKMYuW+l+WIsOaWsOeahOaVsOe7hGPvvIxj55qE5pWw5o2u5YWD57Sg5Lmf5oyJ5YC86Z2e6YCS5YeP5o6S5YiXXG52YXIgYSA9IFszLCA1LCA4LCAxMV07XG52YXIgYiA9IFsyLCA2LCA4LCA5LCAxMSwgMTUsIDIwXTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTGlzdChhLCBiKSB7XG4gICAgdmFyIGMgPSBbXSwgYUVsZW0sIGJFbGVtO1xuICAgIHZhciBpID0gMCwgaiA9IDAsIGsgPSAwO1xuICAgIHZhciBhTGVuID0gYS5sZW5ndGg7XG4gICAgdmFyIGJMZW4gPSBiLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgYUxlbiAmJiBqIDwgYkxlbikge1xuICAgICAgICBhRWxlbSA9IGFbaV07XG4gICAgICAgIGJFbGVtID0gYltqXTtcblxuICAgICAgICBpZiAoYUVsZW0gPCBiRWxlbSkge1xuICAgICAgICAgICAgY1trKytdID0gYUVsZW07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjW2srK10gPSBiRWxlbTtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChpIDwgYUxlbikge1xuICAgICAgICBjW2srK10gPSBhW2krK107XG4gICAgfVxuXG4gICAgd2hpbGUgKGogPCBiTGVuKSB7XG4gICAgICAgIGNbaysrXSA9IGJbaisrXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbn1cblxudmFyIGMgPSBtZXJnZUxpc3QoYSwgYik7XG5jb25zb2xlLmxvZyhjKTtcbi8vIFsyLCAzLCA1LCA2LCA4LCA4LCA5LCAxMSwgMTEsIDE1LCAyMF1cblxuLy8g5pe26Ze05aSN5p2C5bqm77yaIE8oYUxlbiArIGJMZW4pXG5cbi8vIOe6v+aAp+ihqOeahOmhuuW6j+ihqOekuuWSjOWunueOsFxuLy8g5L2/55So5Lyq5pWw57uE5qih5ouf57q/5oCn6KGo5o+S5YWl5pON5L2c55qE5YmN5ZCO5pWw5o2u5YWD57Sg5Zyo5a2Y5YKo56m66Ze05Lit55qE5L2N572u5Y+Y5YyWXG52YXIgYSA9IHswOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LCA1OiA1fTtcbmEubGVuZ3RoID0gNjtcblxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydChhLCBpLCBlbGVtKSB7XG4gICAgaWYgKCFlbGVtKSByZXR1cm47XG5cbiAgICB2YXIgbGVuID0gYS5sZW5ndGg7XG4gICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICAgIHdoaWxlIChsZW4gPCBpKSB7XG4gICAgICAgICAgICBhW2xlbisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGEubGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgICAgYVtpXSA9IGVsZW07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGxlbiA+IGkpIHtcbiAgICAgICAgICAgIGFbbGVuLS1dID0gYVtsZW5dO1xuICAgICAgICB9XG4gICAgICAgIGFbaV0gPSBlbGVtO1xuICAgIH1cbiAgICBhLmxlbmd0aCsrO1xufVxuXG5pbnNlcnQoYSwgMywgOCk7XG5pbnNlcnQoYSwgMTAsIDEwKTtcbmNvbnNvbGUubG9nKGEpO1xuXG4vLyDkvb/nlKjkvKrmlbDnu4TmqKHmi5/nur/mgKfooajliKDpmaTmk43kvZznmoTliY3lkI7mlbDmja7lhYPntKDlnKjlrZjlgqjnqbrpl7TkuK3nmoTkvY3nva7lj5jljJZcblxuZXhwb3J0IGZ1bmN0aW9uIGRlbChhLCBpKSB7XG4gICAgdmFyIHRlbXAgPSBhW2ldO1xuICAgIHZhciBqID0gaSArIDE7XG4gICAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgYVtqIC0gMV0gPSBhW2orK107XG4gICAgfVxuICAgIGEubGVuZ3RoLS07XG4gICAgZGVsZXRlIGFbbGVuIC0gMV07XG5cbiAgICByZXR1cm4gdGVtcDtcbn1cblxuZGVsKGEsIDMpO1xuY29uc29sZS5sb2coYSk7XG5kZWwoYSwgMTApO1xuY29uc29sZS5sb2coYSk7XG5cbi8vIOaXtumXtOWkjeadguW6pu+8miBPKGEubGVuZ3RoKVxuXG4vLyDmr5TovoPlrZfnrKbooahB5ZKMQu+8jOW5tueUqOi/lOWbnuWAvOihqOekuue7k+aenO+8jOWAvOS4ujHvvIzooajnpLpBPkLvvIzlgLzkuLotMe+8jOihqOekukE8Qu+8jOWAvOS4ujDvvIzooajnpLpBPUJcbmV4cG9ydCBmdW5jdGlvbiBsaXN0Q29tcChhTGlzdCwgYkxpc3QpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFMaXN0Lmxlbmd0aCAmJiBpIDwgYkxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFMaXN0W2ldICE9PSBiTGlzdFtpXSkgcmV0dXJuIGFMaXN0W2ldID4gYkxpc3RbaV0gPyAxIDogLTE7XG4gICAgfVxuXG4gICAgaWYgKGFMaXN0Lmxlbmd0aCA9PSBiTGlzdC5sZW5ndGgpIHJldHVybiAwO1xuXG4gICAgcmV0dXJuIGFMaXN0Lmxlbmd0aCA+IGJMaXN0Lmxlbmd0aCA/IDEgOiAtMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2UobGlzdCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gbGlzdC5sZW5ndGggLSAxOyBpIDw9IGo7IGkrKywgai0tKSB7XG4gICAgICAgIHZhciB0ZW1wID0gbGlzdFtpXTtcbiAgICAgICAgbGlzdFtpXSA9IGxpc3Rbal07XG4gICAgICAgIGxpc3Rbal0gPSB0ZW1wO1xuICAgIH1cbn1cblxuLy8g5rGC5YWD57Sg6YCS5aKe5o6S5YiX55qE57q/5oCn6KGoQeWSjELnmoTlhYPntKDnmoTkuqTpm4blubblrZjlhaVDXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0KGFMaXN0LCBiTGlzdCkge1xuICAgIHZhciBjTGlzdCA9IFtdO1xuICAgIHZhciBpID0gMCwgaiA9IDAsIGsgPSAwO1xuXG4gICAgd2hpbGUgKGFMaXN0W2ldICYmIGJMaXN0W2pdKSB7XG4gICAgICAgIGlmIChhTGlzdFtpXSA8IGJMaXN0W2pdKSBpKys7XG4gICAgICAgIGVsc2UgaWYgKGFMaXN0W2ldID4gYkxpc3Rbal0pIGorKztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjTGlzdFtrKytdID0gYUxpc3RbaV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY0xpc3Q7XG59XG5cbmNvbnNvbGUubG9nKGludGVyc2VjdChbMSwgMywgNSwgNywgOV0sIFsxLCA1LCA5LCAxMywgMTddKSArICcnKTtcblxuLy8g5rGC5YWD57Sg6YCS5aKe5o6S5YiX55qE57q/5oCn6KGoQeWSjELnmoTlhYPntKDnmoTkuqTpm4blubblrZjlhaXlm55hXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0X3RydWUoYSwgYikge1xuICAgIHZhciBpID0gMCwgaiA9IDAsIGsgPSAwO1xuXG4gICAgd2hpbGUgKGFbaV0gJiYgYltqXSkge1xuICAgICAgICBpZiAoYVtpXSA8IGJbal0pIGkrKztcbiAgICAgICAgZWxzZSBpZiAoYVtpXSA+IGJbal0pIGorKztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhW2srK10gPSBhW2ldO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKGFba10pIGEuc3BsaWNlKGssIDEpO1xuXG4gICAgcmV0dXJuIGE7XG59XG5cbmNvbnNvbGUubG9nKGludGVyc2VjdF90cnVlKFsxLCAzLCA1LCA3LCA5XSwgWzEsIDUsIDksIDEzLCAxN10pICsgJycpO1xuXG4vLyBh77yMYu+8jGPnmoTlhYPntKDlnYfmmK/pnZ7pgJLlh4/mjpLliJdcbi8vIOaxgmHmlbDnu4TkuK3pnZ5i5pWw57uE5ZKMY+aVsOe7hOeahOS6pOmbhueahOWFg+e0oOOAglxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdF9kZWxldGUoYSwgYiwgYykge1xuICAgIHZhciBpID0gMCwgaiA9IDAsIGsgPSAwLCBtID0gMDtcblxuICAgIHdoaWxlIChpIDwgYS5sZW5ndGggJiYgaiA8IGIubGVuZ3RoICYmIGsgPCBjLmxlbmd0aCkge1xuICAgICAgICBpZiAoYltqXSA8IGNba10pIGorKztcbiAgICAgICAgZWxzZSBpZiAoYltqXSA+IGNba10pIGsrKztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyDmib7liLDkuobnm7jlkIzlhYPntKBzYW1lXG4gICAgICAgICAgICB2YXIgc2FtZSA9IGJbal07XG5cbiAgICAgICAgICAgIC8vIGrvvIxr5ZCO56e75Yiw5paw55qE5YWD57SgXG4gICAgICAgICAgICB3aGlsZSAoYltqXSA9PT0gc2FtZSkgaisrO1xuICAgICAgICAgICAgd2hpbGUgKGNba10gPT09IHNhbWUpIGsrKztcbiAgICAgICAgICAgIC8vIOmcgOS/neeVmeeahOWFg+e0oOenu+WKqOWIsOaWsOS9jee9rlxuICAgICAgICAgICAgd2hpbGUgKGkgPCBhLmxlbmd0aCAmJiBhW2ldIDwgc2FtZSkgYVttKytdID0gYVtpKytdO1xuICAgICAgICAgICAgLy8g6Lez6L+H55u45ZCM55qE5YWD57SgXG4gICAgICAgICAgICB3aGlsZSAoaSA8IGEubGVuZ3RoICYmIGFbaV0gPT09IHNhbWUpIGkrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGHnmoTliankvZnlhYPntKDph43mlrDlrZjlgqhcbiAgICB3aGlsZSAoaSA8IGEubGVuZ3RoKSBhW20rK10gPSBhW2krK107XG4gICAgYS5sZW5ndGggPSBtO1xuXG4gICAgcmV0dXJuIGE7XG59XG5cbmNvbnNvbGUubG9nKGludGVyc2VjdF9kZWxldGUoWzEsIDIsIDMsIDQsIDUsIDYsIDldLCBbMSwgMywgNSwgNywgOV0sIFsxLCA1LCA5LCAxMywgMTddKSArICcnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9MaXN0L0xpbmVhckxpc3QuanMiLCIvKipcbiAqIENyZWF0ZWQgYnkgbGRwIG9uIDIwMTUvMS8xOS5cbiAqL1xuXG4vKipcbiAqIOW+queOr+mYn+WIl1xuICogXG4gKiDnlKjlpITvvJrnuqbnkZ/lpKvnjq9cbiAqIOS8mOeCue+8muS4uuWFheWIhuWIqeeUqOWQkemHj+epuumXtO+8jOWFi+acjVwi5YGH5rqi5Ye6XCLnjrDosaHnmoTmlrnms5XmmK/vvJrlsIblkJHph4/nqbrpl7Tmg7PosaHkuLrkuIDkuKrpppblsL7nm7jmjqXnmoTlnIbnjq/vvIzlubbnp7Dov5nnp43lkJHph4/kuLrlvqrnjq/lkJHph4/jgILlrZjlgqjlnKjlhbbkuK3nmoTpmJ/liJfnp7DkuLrlvqrnjq/pmJ/liJfvvIhDaXJjdWxhciBRdWV1Ze+8ieOAglxuICogXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQ3ljbGVRdWV1ZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDeWNsZVF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhzaXplID0gMTAwKXtcbiAgICAgICAgdGhpcy5iYXNlID0ge307XG4gICAgICAgIHRoaXMuZnJvbnQgPSB0aGlzLnJlYXIgPSAwO1xuICAgICAgICB0aGlzLk1BWFFTSVpFID0gbWF4c2l6ZTtcbiAgICB9XG5cbiAgICBlblF1ZXVlKGRhdGEpIHtcbiAgICAgICAgaWYgKCh0aGlzLnJlYXIgKyAxKSAlIHRoaXMuTUFYUVNJWkUgPT09IDApIHRocm93IG5ldyBFcnJvcignY3ljbGVRdWV1ZSBpcyBhbHJlYWR5IGZ1bGwhJyk7XG5cbiAgICAgICAgdGhpcy5iYXNlW3RoaXMucmVhcl0gPSBkYXRhO1xuICAgICAgICB0aGlzLnJlYXIgPSAodGhpcy5yZWFyICsgMSkgJSB0aGlzLk1BWFFTSVpFO1xuICAgIH1cbiAgICBkZVF1ZXVlKCkge1xuICAgICAgICBpZiAodGhpcy5mcm9udCA9PT0gdGhpcy5yZWFyKSB0aHJvdyBuZXcgRXJyb3IoJ2N5Y2xlUXVldWUgaXMgYWxyZWFkeSBlbXB0eScpO1xuXG4gICAgICAgIGxldCBlbGVtID0gdGhpcy5iYXNlW3RoaXMuZnJvbnRdO1xuICAgICAgICB0aGlzLmZyb250ID0gKHRoaXMuZnJvbnQgKyAxKSAlIHRoaXMuTUFYUVNJWkU7XG5cbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmJhc2UgPSB7fTtcbiAgICAgICAgdGhpcy5mcm9udCA9IHRoaXMucmVhciA9IDA7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucmVhciAtIHRoaXMuZnJvbnQgKyB0aGlzLk1BWFFTSVpFKSAlIHRoaXMuTUFYUVNJWkU7XG4gICAgfVxuICAgIHBlZWtBdChpbmRleCA9IDApIHtcbiAgICAgICAgaW5kZXggPSAoaW5kZXggKyB0aGlzLk1BWFFTSVpFKSAlIHRoaXMuTUFYUVNJWkU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVtpbmRleCArIHRoaXMuZnJvbnRdIHx8IG51bGw7XG4gICAgfVxuICAgIGdldEhlYWQoKSB7XG4gICAgICAgIGxldCBlbGVtID0gdGhpcy5iYXNlW3RoaXMuZnJvbnRdO1xuICAgICAgICByZXR1cm4gZWxlbSA/IGVsZW0gOiBudWxsO1xuICAgIH1cbiAgICBxdWV1ZVRyYXZlcnNlKGl0ZXJhdG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyb250LCBsZW4gPSB0aGlzLnJlYXIgPSB0aGlzLmZyb250OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpdGVyYXRvcih0aGlzLmJhc2VbaV0sIGkpKSBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IGJhc2UgPSBbXS5zbGljZS5jYWxsKHRoaXMuYmFzZSk7XG5cbiAgICAgICAgcmV0dXJuIGJhc2Uuc2xpY2UodGhpcy5mcm9udCwgdGhpcy5yZWFyIC0gdGhpcy5mcm9udCk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1F1ZXVlL0N5Y2xlUXVldWUuanMiLCIvKipcbiAqIENyZWF0ZWQgYnkgTHVrZSBvbiAyMDE1LzIvMjYuXG4gKi9cblxuLypcbuS8mOWFiOmYn+WIlyhwcmlvcml0eSBxdWV1ZSlcblxu5pmu6YCa55qE6Zif5YiX5piv5LiA56eN5YWI6L+b5YWI5Ye655qE5pWw5o2u57uT5p6E77yM5YWD57Sg5Zyo6Zif5YiX5bC+6L+95Yqg77yM6ICM5LuO6Zif5YiX5aS05Yig6Zmk44CC5Zyo5LyY5YWI6Zif5YiX5Lit77yM5YWD57Sg6KKr6LWL5LqI5LyY5YWI57qn44CC5b2T6K6/6Zeu5YWD57Sg5pe277yM5YW35pyJ5pyA6auY5LyY5YWI57qn55qE5YWD57Sg5pyA5YWI5Yig6Zmk44CC5LyY5YWI6Zif5YiX5YW35pyJ5pyA6auY57qn5YWI5Ye6IO+8iGxhcmdlc3QtaW7vvIxmaXJzdC1vdXTvvInnmoTooYzkuLrnibnlvoHjgIJcblxu5LyY5YWI6Zif5YiX5pivMOS4quaIluWkmuS4quWFg+e0oOeahOmbhuWQiCzmr4/kuKrlhYPntKDpg73mnInkuIDkuKrkvJjlhYjmnYPmiJblgLws5a+55LyY5YWI6Zif5YiX5omn6KGM55qE5pON5L2c5pyJMSkg5p+l5om+OzIpIOaPkuWFpeS4gOS4quaWsOWFg+e0oDszKSDliKDpmaQu5Zyo5pyA5bCP5LyY5YWI6Zif5YiXKG1pbiBwcmlvcml0eXEgdSBlIHUgZSnkuK0s5p+l5om+5pON5L2c55So5p2l5pCc57Si5LyY5YWI5p2D5pyA5bCP55qE5YWD57SgLOWIoOmZpOaTjeS9nOeUqOadpeWIoOmZpOivpeWFg+e0oDvlr7nkuo7mnIDlpKfkvJjlhYjpmJ/liJcobWF4IHByaW9yaXR5IHF1ZXVlKSzmn6Xmib7mk43kvZznlKjmnaXmkJzntKLkvJjlhYjmnYPmnIDlpKfnmoTlhYPntKAs5Yig6Zmk5pON5L2c55So5p2l5Yig6Zmk6K+l5YWD57SgLuS8mOWFiOadg+mYn+WIl+S4reeahOWFg+e0oOWPr+S7peacieebuOWQjOeahOS8mOWFiOadgyzmn6Xmib7kuI7liKDpmaTmk43kvZzlj6/moLnmja7ku7vmhI/kvJjlhYjmnYPov5vooYwuXG5cblxu5YWl6Zif5pON5L2cXG7ikaDvvJrlrozlhajkuozlj4nmoJHnmoTmnoTlu7rmk43kvZzmmK/igJzku47kuIrliLDkuIvvvIzku47lt6bliLDlj7PigJ3nmoTlvaLlvI/vvIzmiYDku6XlhaXpmJ/nmoToioLngrnmmK/mlL7lnKjmlbDnu4TnmoTmnIDlkI7vvIzkuZ/lsLHmmK/moJHkuK3lj7blrZDlsYLnmoTmnInluo/mnIDlj7PovrnnqbrkvY3jgIJcbuKRoe+8muW9k+iKgueCueaPkuWFpeWIsOacgOWQjuaXtu+8jOacieWPr+iDveegtOWdj+S6huWghueahOaAp+i0qO+8jOatpOaXtuaIkeS7rOimgei/m+ihjOKAnOS4iua7pOaTjeS9nOKAne+8jOW9k+eEtuaXtumXtOWkjeadguW6puS4uk8obGdOKeOAglxuXG7lh7rpmJ/mk43kvZxcbuWHuumYn+aTjeS9nOaXtu+8jOaIkeS7rOmHh+WPlueahOaWueahiOaYr++8muW8ueWHuuWghumhtuWFg+e0oO+8jOeEtuWQjuWwhuWPtuWtkOWxguS4reeahOacgOWPs+WtkOiKgueCuei1i+e7meWghumhtu+8jOWQjOagt+i/meaXtuS5n+S8muWPr+iDveWtmOWcqOegtOWdj+WghueahOaAp+i0qO+8jOacgOWQjuaIkeS7rOimgeiiq+i/q+i/m+ihjOS4i+a7pOaTjeS9nOOAglxuICovXG5cbmltcG9ydCBIZWFwIGZyb20gJy4uL0hlYXAnO1xuXG4vKipcbiAqIOeUqOWghuWunueOsOS8mOWFiOmYn+WIl1xuICogXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgUHJpb3JpdHlRdWV1ZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmlvcml0eVF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oZWFwID0gbmV3IEhlYXAoZnVuY3Rpb24oYSwgYil7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldCBzaXplKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYXAuYXJyLmxlbmd0aDtcbiAgICB9XG5cbiAgICBlblF1ZXVlKHZhbHVlLCBwcmlvcml0eSA9IDApIHtcbiAgICAgICAgaWYodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdhcmd1bWVudCByZXF1aXJlZCcpO1xuXG4gICAgICAgIC8vIOWwhuW9k+WJjeiKgueCuei/veWKoOWIsOWghuWwvlxuICAgICAgICB0aGlzLmhlYXAuYWRkKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgcHJpb3JpdHlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGRlUXVldWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYXAucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgY2xlYXIoKXtcbiAgICAgICAgdGhpcy5oZWFwLmNsZWFyKCk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1F1ZXVlL1ByaW9yaXR5UXVldWUuanMiLCIvKipcbiAqIEFWTCBUUkVFIENsYXNzXG4gKlxuICogQGF1dGhvciBCcmljZSBDaGV2YWxpZXJcbiAqXG4gKlxuICogQGRlc2NcbiAqXG4gKiAgICBNZXRob2QgICAgICAgICAgICAgICAgVGltZSBDb21wbGV4aXR5XG4gKiAgICBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xuICpcbiAqICAgIGFkZCAgICAgICAgICAgICAgICAgICAgTyhsb2cyKG4pKVxuICogICAgcmVtb3ZlICAgICAgICAgICAgICAgIE8obG9nMihuKSlcbiAqICAgIGdldEZpcnN0ICAgICAgICAgICAgTygxKVxuICogICAgZ2V0TGFzdCAgICAgICAgICAgICAgICBPKDEpXG4gKiAgICBnZXRDb3VudCAgICAgICAgICAgIE8oMSlcbiAqICAgIGFwcGx5ICAgICAgICAgICAgICAgIE8obilcbiAqICAgIGNsZWFyICAgICAgICAgICAgICAgIE8obilcbiAqXG4gKiAgICBNZW1vcnkgQ29tcGxleGl0eSBpbiBPKG4pXG4gKi9cblxuZnVuY3Rpb24gTm9kZShvYmopIHtcbiAgICB0aGlzLm9iamVjdCA9IG9iajtcbiAgICB0aGlzLmhlaWdodCA9IDE7XG4gICAgdGhpcy5sZWZ0ID0gbnVsbDtcbiAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gQXZsVHJlZSgpIHtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdCA9IG51bGw7XG59XG5BdmxUcmVlLmNtcCA9IGZ1bmN0aW9uKGEsIGIpe1xuICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICBlbHNlIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgZWxzZSByZXR1cm4gMDtcbn07XG5cbkF2bFRyZWUucHJvdG90eXBlLl9hZGRMZWZ0ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAgIG5vZGUucHJldmlvdXMgPSBwYXJlbnQucHJldmlvdXM7XG4gICAgbm9kZS5uZXh0ID0gcGFyZW50O1xuICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuXG4gICAgcGFyZW50LmxlZnQgPSBub2RlO1xuICAgIHBhcmVudC5wcmV2aW91cyA9IG5vZGU7XG5cbiAgICBpZiAobm9kZS5wcmV2aW91cykge1xuICAgICAgICBub2RlLnByZXZpb3VzLm5leHQgPSBub2RlO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnQgPT09IHRoaXMuZmlyc3QpIHtcbiAgICAgICAgdGhpcy5maXJzdCA9IG5vZGU7XG4gICAgfVxufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuX2FkZFJpZ2h0ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAgIG5vZGUucHJldmlvdXMgPSBwYXJlbnQ7XG4gICAgbm9kZS5uZXh0ID0gcGFyZW50Lm5leHQ7XG4gICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICBwYXJlbnQucmlnaHQgPSBub2RlO1xuICAgIHBhcmVudC5uZXh0ID0gbm9kZTtcblxuICAgIGlmIChub2RlLm5leHQpIHtcbiAgICAgICAgbm9kZS5uZXh0LnByZXZpb3VzID0gbm9kZTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50ID09PSB0aGlzLmxhc3QpIHtcbiAgICAgICAgdGhpcy5sYXN0ID0gbm9kZTtcbiAgICB9XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdGhpcy5jb3VudCArPSAxO1xuICAgIHZhciBuZXdOb2RlID0gbmV3IE5vZGUob2JqKTtcblxuICAgIGlmICh0aGlzLnJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yb290ID0gbmV3Tm9kZTtcbiAgICAgICAgdGhpcy5maXJzdCA9IHRoaXMucm9vdDtcbiAgICAgICAgdGhpcy5sYXN0ID0gdGhpcy5yb290O1xuICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudCA9IHRoaXMucm9vdDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG5cbiAgICAgICAgdmFyIGNtcCA9IEF2bFRyZWUuY21wKG9iaiwgY3VycmVudC5vYmplY3QpO1xuICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIHRvIHRoZSBsZWZ0XG4gICAgICAgICAgICBpZiAoY3VycmVudC5sZWZ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTGVmdChuZXdOb2RlLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICBpZiAoY3VycmVudC5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFJpZ2h0KG5ld05vZGUsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRMZWZ0KG5ld05vZGUsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50LnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkUmlnaHQobmV3Tm9kZSwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnJpZ2h0LmhlaWdodCA8IGN1cnJlbnQubGVmdC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9iYWxhbmNlKG5ld05vZGUucGFyZW50KTtcblxuICAgIHJldHVybiBuZXdOb2RlO1xufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2VMZWZ0UmlnaHQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBsZWZ0ID0gbm9kZS5sZWZ0O1xuICAgIHZhciBhID0gbGVmdC5sZWZ0O1xuICAgIHZhciBiID0gbGVmdC5yaWdodC5sZWZ0O1xuXG4gICAgbGVmdC5yaWdodC5sZWZ0ID0gbGVmdDtcbiAgICBub2RlLmxlZnQgPSBsZWZ0LnJpZ2h0O1xuICAgIGxlZnQgPSBub2RlLmxlZnQ7XG4gICAgbGVmdC5wYXJlbnQgPSBub2RlO1xuXG4gICAgdmFyIGxlZnRMZWZ0ID0gbGVmdC5sZWZ0O1xuICAgIGxlZnRMZWZ0LnBhcmVudCA9IGxlZnQ7XG4gICAgbGVmdExlZnQubGVmdCA9IGE7XG4gICAgbGVmdExlZnQucmlnaHQgPSBiO1xuICAgIGlmIChhICE9PSBudWxsKSB7XG4gICAgICAgIGEucGFyZW50ID0gbGVmdExlZnQ7XG4gICAgfVxuICAgIGlmIChiICE9PSBudWxsKSB7XG4gICAgICAgIGIucGFyZW50ID0gbGVmdExlZnQ7XG4gICAgfVxuXG4gICAgbGVmdC5oZWlnaHQgPSBsZWZ0TGVmdC5oZWlnaHQgKyAxO1xufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2VMZWZ0TGVmdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGxlZnQgPSBub2RlLmxlZnQ7XG4gICAgdmFyIGMgPSBsZWZ0LnJpZ2h0O1xuXG4gICAgaWYgKG5vZGUgPT09IHRoaXMucm9vdCkge1xuICAgICAgICB0aGlzLnJvb3QgPSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub2RlLnBhcmVudC5yaWdodCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQucmlnaHQgPSBsZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnQubGVmdCA9IGxlZnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZWZ0LnJpZ2h0ID0gbm9kZTtcbiAgICBsZWZ0LnBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIG5vZGUucGFyZW50ID0gbGVmdDtcbiAgICBub2RlLmxlZnQgPSBjO1xuICAgIGlmKGMgIT09IG51bGwpIHtcbiAgICAgICAgYy5wYXJlbnQgPSBub2RlO1xuICAgIH1cblxuICAgIG5vZGUuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgLSAxO1xufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2VSaWdodExlZnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciByaWdodCA9IG5vZGUucmlnaHQ7XG4gICAgdmFyIGEgPSByaWdodC5yaWdodDtcbiAgICB2YXIgYiA9IHJpZ2h0LmxlZnQucmlnaHQ7XG5cbiAgICByaWdodC5sZWZ0LnJpZ2h0ID0gcmlnaHQ7XG4gICAgbm9kZS5yaWdodCA9IHJpZ2h0LmxlZnQ7XG4gICAgcmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgIHJpZ2h0LnBhcmVudCA9IG5vZGU7XG5cbiAgICB2YXIgcmlnaHRSaWdodCA9IHJpZ2h0LnJpZ2h0O1xuICAgIHJpZ2h0UmlnaHQucGFyZW50ID0gcmlnaHQ7XG4gICAgcmlnaHRSaWdodC5yaWdodCA9IGE7XG4gICAgcmlnaHRSaWdodC5sZWZ0ID0gYjtcbiAgICBpZiAoYSAhPT0gbnVsbCkge1xuICAgICAgICBhLnBhcmVudCA9IHJpZ2h0UmlnaHQ7XG4gICAgfVxuICAgIGlmIChiICE9PSBudWxsKSB7XG4gICAgICAgIGIucGFyZW50ID0gcmlnaHRSaWdodDtcbiAgICB9XG5cbiAgICBub2RlLnJpZ2h0LmhlaWdodCA9IHJpZ2h0UmlnaHQuaGVpZ2h0ICsgMTtcbn07XG5cblxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2VSaWdodFJpZ2h0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgcmlnaHQgPSBub2RlLnJpZ2h0O1xuICAgIHZhciBjID0gcmlnaHQubGVmdDtcblxuICAgIGlmIChub2RlID09PSB0aGlzLnJvb3QpIHtcbiAgICAgICAgdGhpcy5yb290ID0gcmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50LmxlZnQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50LmxlZnQgPSByaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50LnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByaWdodC5sZWZ0ID0gbm9kZTtcbiAgICByaWdodC5wYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICBub2RlLnBhcmVudCA9IHJpZ2h0O1xuICAgIG5vZGUucmlnaHQgPSBjO1xuICAgIGlmKGMgIT09IG51bGwpIHtcbiAgICAgICAgYy5wYXJlbnQgPSBub2RlO1xuICAgIH1cblxuICAgIG5vZGUuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgLSAxO1xufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuX2JhbGFuY2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIEJhbGFuY2luZyB0aGUgdHJlZVxuICAgIHZhciBjdXJyZW50ID0gbm9kZTtcbiAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbGVmdEhlaWdodCA9IChjdXJyZW50LmxlZnQgPT09IG51bGwpID8gMCA6IGN1cnJlbnQubGVmdC5oZWlnaHQ7XG4gICAgICAgIHZhciByaWdodEhlaWdodCA9IChjdXJyZW50LnJpZ2h0ID09PSBudWxsKSA/IDAgOiBjdXJyZW50LnJpZ2h0LmhlaWdodDtcbiAgICAgICAgdmFyIG5ld0hlaWdodCA9IDEgKyBNYXRoLm1heChsZWZ0SGVpZ2h0LCByaWdodEhlaWdodCk7XG5cbiAgICAgICAgaWYgKG5ld0hlaWdodCA+IGN1cnJlbnQuaGVpZ2h0KSB7XG4gICAgICAgICAgICBjdXJyZW50LmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICAgIGlmIChsZWZ0SGVpZ2h0IC0gcmlnaHRIZWlnaHQgPiAxKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBMZWZ0IGNhc2VcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5sZWZ0LnJpZ2h0ICE9PSBudWxsICYmIChjdXJyZW50LmxlZnQubGVmdCA9PT0gbnVsbCB8fCBjdXJyZW50LmxlZnQubGVmdC5oZWlnaHQgPCBjdXJyZW50LmxlZnQucmlnaHQuaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBMZWZ0IFJpZ2h0IENhc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmFsYW5jZUxlZnRSaWdodChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMZWZ0IExlZnQgQ2FzZVxuICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2VMZWZ0TGVmdChjdXJyZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSB0cmVlIGhhcyBiZWVuIGJhbGFuY2VkXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0SGVpZ2h0IC0gbGVmdEhlaWdodCA+IDEpIHtcblxuICAgICAgICAgICAgICAgIC8vIFJpZ2h0IGNhc2VcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5yaWdodC5sZWZ0ICE9PSBudWxsICYmIChjdXJyZW50LnJpZ2h0LnJpZ2h0ID09PSBudWxsIHx8IGN1cnJlbnQucmlnaHQucmlnaHQuaGVpZ2h0IDwgY3VycmVudC5yaWdodC5sZWZ0LmhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmlnaHQgTGVmdCBDYXNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2VSaWdodExlZnQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmlnaHQgUmlnaHQgQ2FzZVxuICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2VSaWdodFJpZ2h0KGN1cnJlbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHRyZWUgaGFzIGJlZW4gYmFsYW5jZWRcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm9kZSBpcyBiYWxhbmNlZFxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQXZsVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHRoaXMuX3JlbW92ZShvYmosIHRoaXMucm9vdCk7XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gKG9iaiwgbm9kZSkge1xuICAgIHZhciBjdXJyZW50ID0gbm9kZTtcblxuICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBjbXAgPSBBdmxUcmVlLmNtcChvYmosIGN1cnJlbnQub2JqZWN0KTtcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob2JqID09PSBjdXJyZW50Lm9iamVjdCkge1xuXG4gICAgICAgICAgICAgICAgLy8gTm9kZSByZW1vdmFsXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCAtPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQucHJldmlvdXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJzdCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzLm5leHQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Lm5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0ID0gY3VycmVudC5wcmV2aW91cztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm5leHQucHJldmlvdXMgPSBjdXJyZW50LnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2luZyB0aGUgbm9kZSBieSB0aGUgc21hbGxlc3QgZWxlbWVudCBncmVhdGVyIHRoYW4gaXRcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gY3VycmVudC5yaWdodDtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnJpZ2h0ID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmFsYW5jZShwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBjdXJyZW50LnJpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBiYWxhbmNlRnJvbTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudC5sZWZ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhbGFuY2VGcm9tID0gcmVwbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQucGFyZW50ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQubGVmdCA9IGxlZnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LnJpZ2h0ID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50ID0gcGFyZW50O1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JhbGFuY2UoYmFsYW5jZUZyb20pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQubGVmdDtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVwbGFjZW1lbnQubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LmxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50LnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnJpZ2h0LnBhcmVudCA9IHJlcGxhY2VtZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50LmxlZnQgPSByZXBsYWNlbWVudC5yaWdodDtcblxuICAgICAgICAgICAgICAgIGlmIChyaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodC5wYXJlbnQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucmlnaHQgPSByaWdodDtcblxuICAgICAgICAgICAgICAgIGJhbGFuY2VGcm9tID0gcmVwbGFjZW1lbnQucGFyZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdC5wYXJlbnQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQubGVmdCA9IGxlZnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucmlnaHQgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9iYWxhbmNlKGJhbGFuY2VGcm9tKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3JlbW92ZShvYmosIGN1cnJlbnQubGVmdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKG9iaiwgY3VycmVudC5yaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5yZW1vdmVCeVJlZiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgLy8gTm9kZSByZW1vdmFsXG4gICAgdGhpcy5jb3VudCAtPSAxO1xuXG4gICAgaWYgKG5vZGUucHJldmlvdXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5maXJzdCA9IG5vZGUubmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnByZXZpb3VzLm5leHQgPSBub2RlLm5leHQ7XG4gICAgfVxuICAgIGlmIChub2RlLm5leHQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5sYXN0ID0gbm9kZS5wcmV2aW91cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLm5leHQucHJldmlvdXMgPSBub2RlLnByZXZpb3VzO1xuICAgIH1cblxuICAgIC8vIFJlcGxhY2luZyB0aGUgbm9kZSBieSB0aGUgc21hbGxlc3QgZWxlbWVudCBncmVhdGVyIHRoYW4gaXRcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgdmFyIGxlZnQgPSBub2RlLmxlZnQ7XG4gICAgdmFyIHJpZ2h0ID0gbm9kZS5yaWdodDtcblxuICAgIGlmIChub2RlLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IGxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnJpZ2h0ID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gbGVmdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxlZnQucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYmFsYW5jZShwYXJlbnQpO1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICB2YXIgcmVwbGFjZW1lbnQgPSBub2RlLnJpZ2h0O1xuICAgIHZhciBiYWxhbmNlRnJvbTtcblxuICAgIGlmIChyZXBsYWNlbWVudC5sZWZ0ID09PSBudWxsKSB7XG4gICAgICAgIGJhbGFuY2VGcm9tID0gcmVwbGFjZW1lbnQ7XG5cbiAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxlZnQucGFyZW50ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZW1lbnQubGVmdCA9IGxlZnQ7XG5cbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnJpZ2h0ID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50ID0gcGFyZW50O1xuXG4gICAgICAgIHRoaXMuX2JhbGFuY2UoYmFsYW5jZUZyb20pO1xuXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQubGVmdDtcbiAgICB3aGlsZSAocmVwbGFjZW1lbnQubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LmxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2VtZW50LnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIHJlcGxhY2VtZW50LnJpZ2h0LnBhcmVudCA9IHJlcGxhY2VtZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmVwbGFjZW1lbnQucGFyZW50LmxlZnQgPSByZXBsYWNlbWVudC5yaWdodDtcblxuICAgIGlmIChyaWdodCAhPT0gbnVsbCkge1xuICAgICAgICByaWdodC5wYXJlbnQgPSByZXBsYWNlbWVudDtcbiAgICB9XG4gICAgcmVwbGFjZW1lbnQucmlnaHQgPSByaWdodDtcblxuICAgIGJhbGFuY2VGcm9tID0gcmVwbGFjZW1lbnQucGFyZW50O1xuXG4gICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgbGVmdC5wYXJlbnQgPSByZXBsYWNlbWVudDtcbiAgICB9XG4gICAgcmVwbGFjZW1lbnQubGVmdCA9IGxlZnQ7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJlcGxhY2VtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXJlbnQucmlnaHQgPT09IG5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IHJlcGxhY2VtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50LmxlZnQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlbWVudC5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICB0aGlzLl9iYWxhbmNlKGJhbGFuY2VGcm9tKTtcblxuICAgIHJldHVybiAxO1xufTtcblxuQXZsVHJlZS5wcm90b3R5cGUuZ2V0Rmlyc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3Q7XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5nZXRMYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxhc3Q7XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdC5oZWlnaHQ7XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5nZXRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3Q7XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5nZXRDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb3VudDtcbn07XG5cbkF2bFRyZWUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAocHJvY2Vzc2luZ0Z1bmMsIHBhcmFtcykge1xuICAgIGZvciAodmFyIGN1cnJlbnQgPSB0aGlzLmZpcnN0OyBjdXJyZW50OyBjdXJyZW50ID0gY3VycmVudC5uZXh0KSB7XG4gICAgICAgIHByb2Nlc3NpbmdGdW5jKGN1cnJlbnQub2JqZWN0LCBwYXJhbXMpO1xuICAgIH1cbn07XG5cbkF2bFRyZWUucHJvdG90eXBlLmZvckVhY2hSZXZlcnNlID0gZnVuY3Rpb24gKHByb2Nlc3NpbmdGdW5jLCBwYXJhbXMpIHtcbiAgICBmb3IgKHZhciBjdXJyZW50ID0gdGhpcy5sYXN0OyBjdXJyZW50OyBjdXJyZW50ID0gY3VycmVudC5wcmV2aW91cykge1xuICAgICAgICBwcm9jZXNzaW5nRnVuYyhjdXJyZW50Lm9iamVjdCwgcGFyYW1zKTtcbiAgICB9XG59O1xuXG5BdmxUcmVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdCA9IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF2bFRyZWU7XG5cblxuY29uc29sZS5sb2coJ1xcbkFWTCB0cmVlIGluc2VydDI6ICcpO1xudmFyIHRlc3QgPSBuZXcgQXZsVHJlZSgpO1xudGVzdC5hZGQoMyk7XG50ZXN0LmFkZCgxNCk7XG50ZXN0LmFkZCgyNSk7XG50ZXN0LmFkZCg4MSk7XG50ZXN0LmFkZCg0NCk7XG5cbi8qXG4gMTRcbiAvICAgIFxcXG4gMyAgICAgICA0NFxuIC8gICBcXFxuIDI1ICAgICA4MVxuICovXG5cblxuY29uc29sZS5sb2coJ3JlbW92ZV9SZWN1cnNpdmUgMjonKTtcblxudGVzdC5yZW1vdmUoODEpO1xudGVzdC5yZW1vdmUoMyk7XG50ZXN0LnJlbW92ZSgxNCk7XG50ZXN0LnJlbW92ZSgyNSk7XG50ZXN0LnJlbW92ZSg0NCk7XG5cblxubGV0IHN0ciA9ICdja25vYmZqdGxwcWFlZ3JtZGhzJztcbi8vdmFyIHN0ciA9ICdja2JmamxhZWdtZGgnO1xuXG5cbnRlc3QgPSBuZXcgQXZsVHJlZSgpO1xuZm9yKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSl7XG4gICAgdGVzdC5hZGQoc3RyW2ldKTtcbn1cblxuXG50ZXN0LnJlbW92ZSgnZScpO1xudGVzdC5yZW1vdmUoJ2gnKTtcbnRlc3QucmVtb3ZlKCdiJyk7XG50ZXN0LnJlbW92ZSgnbCcpO1xudGVzdC5yZW1vdmUoJ2YnKTtcbnRlc3QucmVtb3ZlKCdqJyk7XG50ZXN0LnJlbW92ZSgnZycpO1xudGVzdC5yZW1vdmUoJ2QnKTtcbnRlc3QucmVtb3ZlKCdrJyk7XG50ZXN0LnJlbW92ZSgnYScpO1xudGVzdC5yZW1vdmUoJ20nKTtcbnRlc3QucmVtb3ZlKCduJyk7XG50ZXN0LnJlbW92ZSgnbycpO1xudGVzdC5yZW1vdmUoJ3AnKTtcbnRlc3QucmVtb3ZlKCdxJyk7XG50ZXN0LnJlbW92ZSgncicpO1xudGVzdC5yZW1vdmUoJ3MnKTtcbnRlc3QucmVtb3ZlKCd0Jyk7XG50ZXN0LnJlbW92ZSgnYycpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TZWFyY2gvQVZMVHJlZS5qcyIsIi8qXG4gTUlUIExpY2Vuc2VcbiBDb3B5cmlnaHQgKGMpIDIwMTIgU2FudGFudSBCYXN1XG4gQ29weXJpZ2h0IChjKSAyMDEzIERhbmllbCBXaXJ0elxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vLyBCYXNlZCBvbiBTYW50YW51IEJhc3UncyBCUGx1c0pTXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2FudGFudWJhc3UvQlBsdXNKU1xuLy8gTW9kaWZpZWQgZm9yIHN0YW5kLWFsb25lIHVzZVxuXG4vKipcbiAqIEBsaWNlbnNlIEJUcmVlLmpzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vQlRyZWUuanMgZm9yIGRldGFpbHNcbiAqL1xuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICAgZnVuY3Rpb24gaXNEZWZpbmVkKHYpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ICE9ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIHZhciBOb2RlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMub3JkZXIgPSBvcHRpb25zLm9yZGVyIHx8IDEwMDtcbiAgICAgICAgdGhpcy5tZXJnZVRocmVzaG9sZCA9IG9wdGlvbnMubWVyZ2VUaHJlc2hvbGQgfHwgNDA7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIH07XG5cbiAgICBOb2RlLnByb3RvdHlwZS5nZXRMZWZ0UGVlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdFBlZXI7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLnNldExlZnRQZWVyID0gZnVuY3Rpb24gKGxlZnRQZWVyKSB7XG4gICAgICAgIHRoaXMubGVmdFBlZXIgPSBsZWZ0UGVlcjtcbiAgICB9O1xuXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0UmlnaHRQZWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaWdodFBlZXI7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLnNldFJpZ2h0UGVlciA9IGZ1bmN0aW9uIChyaWdodFBlZXIpIHtcbiAgICAgICAgdGhpcy5yaWdodFBlZXIgPSByaWdodFBlZXI7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLmdldFN1cnBsdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLmZsb29yKCh0aGlzLmRhdGEubGVuZ3RoIC0gdGhpcy5tZXJnZVRocmVzaG9sZCkgLyAyKSk7XG4gICAgfTtcblxuICAgIE5vZGUucHJvdG90eXBlLmdldFJpZ2h0U3VycGx1c0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdXJwbHVzID0gdGhpcy5nZXRTdXJwbHVzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuc3BsaWNlKHRoaXMuZGF0YS5sZW5ndGggLSBzdXJwbHVzKTtcbiAgICB9O1xuXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0TGVmdFN1cnBsdXNEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3VycGx1cyA9IHRoaXMuZ2V0U3VycGx1cygpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNwbGljZSgwLCBzdXJwbHVzKTtcbiAgICB9O1xuXG4gICAgdmFyIEludGVybmFsTm9kZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIE5vZGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5kYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgICAgICB0aGlzLmxlZnRQZWVyID0gb3B0aW9ucy5sZWZ0UGVlcjtcbiAgICAgICAgdGhpcy5yaWdodFBlZXIgPSBvcHRpb25zLnJpZ2h0UGVlcjtcbiAgICB9O1xuXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUpO1xuXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5maW5kSW5kZXggPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB2YXIgbGVmdCA9IDA7XG4gICAgICAgIHZhciByaWdodCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIG1pZCA9IGxlZnQgKyBNYXRoLmZsb29yKChyaWdodCAtIGxlZnQpIC8gMik7XG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBtaWQgPSBsZWZ0ICsgTWF0aC5mbG9vcigocmlnaHQgLSBsZWZ0KSAvIDIpO1xuICAgICAgICAgICAgaWYgKGRhdGFbbWlkXS5rZXkgPCBrZXkpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YVttaWRdLmtleSA+IGtleSkge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGxlZnQgPCByaWdodCAmJiAhZm91bmQpO1xuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5maW5kQ2hpbGQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICBpZiAoZWxlbWVudC5rZXkgPD0ga2V5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQucmlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQubGVmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfTtcblxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNsb2JiZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5maW5kSW5kZXgoa2V5KTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmRhdGFbaW5kZXhdO1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIHZhciBuZXdOb2RlcywgbGVmdEVsZW1lbnQsIHJpZ2h0RWxlbWVudDtcbiAgICAgICAgaWYgKGVsZW1lbnQua2V5IDw9IGtleSkge1xuICAgICAgICAgICAgY2hpbGQgPSBlbGVtZW50LnJpZ2h0O1xuICAgICAgICAgICAgbmV3Tm9kZXMgPSBjaGlsZC5pbnNlcnQoa2V5LCB2YWx1ZSwgY2xvYmJlcik7XG4gICAgICAgICAgICBpZiAobmV3Tm9kZXMubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgICAgICBsZWZ0RWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBlbGVtZW50LmtleSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZWxlbWVudC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogbmV3Tm9kZXNbMF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJpZ2h0RWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBuZXdOb2Rlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbmV3Tm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1syXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSwgbGVmdEVsZW1lbnQsIHJpZ2h0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkID0gZWxlbWVudC5sZWZ0O1xuICAgICAgICAgICAgbmV3Tm9kZXMgPSBjaGlsZC5pbnNlcnQoa2V5LCB2YWx1ZSwgY2xvYmJlcik7XG4gICAgICAgICAgICBpZiAobmV3Tm9kZXMubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgICAgICBsZWZ0RWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBuZXdOb2Rlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbmV3Tm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1syXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmlnaHRFbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGVsZW1lbnQua2V5LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBuZXdOb2Rlc1syXSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGVsZW1lbnQucmlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDEsIGxlZnRFbGVtZW50LCByaWdodEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNwbGl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld05vZGVzO1xuICAgIH07XG5cbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA8IHRoaXMub3JkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IE1hdGguZmxvb3IodGhpcy5kYXRhLmxlbmd0aCAvIDIpO1xuICAgICAgICB2YXIgbGVmdE5vZGUgPSBuZXcgSW50ZXJuYWxOb2RlKHtcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5zbGljZSgwLCBzcGxpdEluZGV4KSxcbiAgICAgICAgICAgIGxlZnRQZWVyOiB0aGlzLmxlZnRQZWVyLFxuICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJpZ2h0Tm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLnNsaWNlKHNwbGl0SW5kZXggKyAxLCB0aGlzLmRhdGEubGVuZ3RoKSxcbiAgICAgICAgICAgIHJpZ2h0UGVlcjogdGhpcy5yaWdodFBlZXIsXG4gICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkXG4gICAgICAgIH0pO1xuICAgICAgICBsZWZ0Tm9kZS5zZXRSaWdodFBlZXIocmlnaHROb2RlKTtcbiAgICAgICAgcmlnaHROb2RlLnNldExlZnRQZWVyKGxlZnROb2RlKTtcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh0aGlzLmxlZnRQZWVyKSkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0UGVlci5zZXRSaWdodFBlZXIobGVmdE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZmluZWQodGhpcy5yaWdodFBlZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0UGVlci5zZXRMZWZ0UGVlcihyaWdodE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbGVmdE5vZGUsIHRoaXMuZGF0YVtzcGxpdEluZGV4XS5rZXksIHJpZ2h0Tm9kZV07XG4gICAgfTtcblxuXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5LCBsZWZ0TWVyZ2VPcHRpb24sIHJpZ2h0TWVyZ2VPcHRpb24pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5maW5kSW5kZXgoa2V5KTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmRhdGFbaW5kZXhdO1xuICAgICAgICB2YXIgbWVyZ2VJbmRleCA9IC0xO1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIHZhciByZXR2YWw7XG4gICAgICAgIGlmIChlbGVtZW50LmtleSA8PSBrZXkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gZWxlbWVudC5yaWdodDtcbiAgICAgICAgICAgIHJldHZhbCA9IGNoaWxkLnJlbW92ZShrZXksIGVsZW1lbnQubGVmdCwgaW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoIC0gMSA/IGNoaWxkLmdldFJpZ2h0UGVlcigpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID09IDEgJiYgcmV0dmFsLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtyZXR2YWxbMF0sIHJldHZhbFszXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV0dmFsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0dmFsWzFdID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVsZW1lbnQubGVmdDtcbiAgICAgICAgICAgIHJldHZhbCA9IGNoaWxkLnJlbW92ZShrZXksIGluZGV4ID4gMCA/IGNoaWxkLmdldExlZnRQZWVyKCkgOiB1bmRlZmluZWQsIGVsZW1lbnQucmlnaHQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPT0gMSAmJiByZXR2YWwubGVuZ3RoID09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3JldHZhbFswXSwgcmV0dmFsWzNdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXR2YWwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXR2YWxbMV0gPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZUluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZUluZGV4ID0gaW5kZXggLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVyZ2VJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2VFbGVtZW50ID0gdGhpcy5kYXRhW21lcmdlSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHJldHZhbC5sZW5ndGggPT0gNSkge1xuICAgICAgICAgICAgICAgIG1lcmdlRWxlbWVudC5rZXkgPSByZXR2YWxbM107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtyZXR2YWxbMF1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobWVyZ2VJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhW21lcmdlSW5kZXggLSAxXS5yaWdodCA9IHJldHZhbFszXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlSW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbbWVyZ2VJbmRleCArIDFdLmxlZnQgPSByZXR2YWxbM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UobWVyZ2VJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtyZXR2YWxbMF1dLmNvbmNhdCh0aGlzLm1lcmdlKGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtyZXR2YWxbMF1dO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAobGVmdE1lcmdlT3B0aW9uLCByaWdodE1lcmdlT3B0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID4gdGhpcy5tZXJnZVRocmVzaG9sZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNEZWZpbmVkKGxlZnRNZXJnZU9wdGlvbikgJiYgIWlzRGVmaW5lZChyaWdodE1lcmdlT3B0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXR2YWwgPSBbXTtcbiAgICAgICAgLy8gdmFyIGRlZmljaXQgPSB0cnVlO1xuICAgICAgICB2YXIgbGVmdFN1cnBsdXMgPSAwO1xuICAgICAgICB2YXIgbGVmdERhdGE7XG4gICAgICAgIHZhciByaWdodFN1cnBsdXMgPSAwO1xuICAgICAgICB2YXIgcmlnaHREYXRhO1xuICAgICAgICB2YXIgbGVmdFBlZXIgPSB0aGlzLmxlZnRQZWVyO1xuICAgICAgICB2YXIgcmlnaHRQZWVyID0gdGhpcy5yaWdodFBlZXI7XG4gICAgICAgIGlmIChpc0RlZmluZWQobGVmdE1lcmdlT3B0aW9uKSkge1xuICAgICAgICAgICAgbGVmdERhdGEgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0RGF0YSgpO1xuICAgICAgICAgICAgbGVmdFN1cnBsdXMgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0U3VycGx1cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRNZXJnZU9wdGlvbikpIHtcbiAgICAgICAgICAgIHJpZ2h0RGF0YSA9IHJpZ2h0TWVyZ2VPcHRpb24uZ2V0RGF0YSgpO1xuICAgICAgICAgICAgcmlnaHRTdXJwbHVzID0gcmlnaHRNZXJnZU9wdGlvbi5nZXRTdXJwbHVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnRTdXJwbHVzID4gcmlnaHRTdXJwbHVzKSB7XG4gICAgICAgICAgICB2YXIgbGVmdFN1cnBsdXNEYXRhID0gbGVmdE1lcmdlT3B0aW9uLmdldFJpZ2h0U3VycGx1c0RhdGEoKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGxlZnRTdXJwbHVzRGF0YS5zbGljZSgxKS5jb25jYXQoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiB0aGlzLmRhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0U3VycGx1c0RhdGFbbGVmdFN1cnBsdXNEYXRhLmxlbmd0aCAtIDFdLnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogdGhpcy5kYXRhWzBdLmxlZnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLCB0aGlzLmRhdGEpO1xuICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XG4gICAgICAgICAgICByZXR2YWxbMV0gPSBsZWZ0TWVyZ2VPcHRpb247XG4gICAgICAgICAgICByZXR2YWxbMl0gPSBsZWZ0U3VycGx1c0RhdGFbMF0ua2V5O1xuICAgICAgICAgICAgcmV0dmFsWzNdID0gdGhpcztcbiAgICAgICAgfSBlbHNlIGlmIChyaWdodFN1cnBsdXMgPiBsZWZ0U3VycGx1cykge1xuICAgICAgICAgICAgdmFyIHJpZ2h0U3VycGx1c0RhdGEgPSByaWdodE1lcmdlT3B0aW9uLmdldExlZnRTdXJwbHVzRGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLmNvbmNhdChbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IHJpZ2h0U3VycGx1c0RhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmRhdGFbdGhpcy5kYXRhLmxlbmd0aCAtIDFdLnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogcmlnaHRTdXJwbHVzRGF0YVswXS5sZWZ0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSwgcmlnaHRTdXJwbHVzRGF0YS5zbGljZSgwLCByaWdodFN1cnBsdXNEYXRhLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XG4gICAgICAgICAgICByZXR2YWxbMV0gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dmFsWzJdID0gcmlnaHRTdXJwbHVzRGF0YVtyaWdodFN1cnBsdXNEYXRhLmxlbmd0aCAtIDFdLmtleTtcbiAgICAgICAgICAgIHJldHZhbFszXSA9IHJpZ2h0TWVyZ2VPcHRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2VkSW50ZXJuYWxOb2RlO1xuICAgICAgICAgICAgaWYgKCFpc0RlZmluZWQobGVmdERhdGEpKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlID0gbmV3IEludGVybmFsTm9kZSh7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiByaWdodERhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoIC0gMV0ucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0RGF0YVswXS5sZWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0sIHJpZ2h0RGF0YSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMF0gPSAxO1xuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZEludGVybmFsTm9kZS5nZXREYXRhKClbMF0ua2V5O1xuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZEludGVybmFsTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJpZ2h0UGVlcikgJiYgaXNEZWZpbmVkKHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpLnNldExlZnRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0UGVlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuc2V0UmlnaHRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNEZWZpbmVkKHJpZ2h0RGF0YSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRJbnRlcm5hbE5vZGUgPSBuZXcgSW50ZXJuYWxOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBsZWZ0RGF0YS5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogdGhpcy5kYXRhWzBdLmxlZnQuZ2V0RGF0YSgpWzBdLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0RGF0YVtsZWZ0RGF0YS5sZW5ndGggLSAxXS5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogdGhpcy5kYXRhWzBdLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSwgdGhpcy5kYXRhKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IC0xO1xuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZEludGVybmFsTm9kZS5nZXREYXRhKClbMF0ua2V5O1xuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZEludGVybmFsTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSAmJiBpc0RlZmluZWQobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuZ2V0TGVmdFBlZXIoKS5zZXRSaWdodFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyLmdldExlZnRQZWVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHJpZ2h0UGVlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRQZWVyLnNldExlZnRQZWVyKG1lcmdlZEludGVybmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0RGF0YS5sZW5ndGggPCBsZWZ0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRJbnRlcm5hbE5vZGUgPSBuZXcgSW50ZXJuYWxOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHJpZ2h0RGF0YVswXS5sZWZ0LmdldERhdGEoKVswXS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGggLSAxXS5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmlnaHREYXRhWzBdLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSwgcmlnaHREYXRhKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkSW50ZXJuYWxOb2RlLmdldERhdGEoKVswXS5rZXk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkSW50ZXJuYWxOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSAmJiBpc0RlZmluZWQocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkuc2V0TGVmdFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5zZXRSaWdodFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldExlZnRQZWVyKGxlZnRQZWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlZEludGVybmFsTm9kZSA9IG5ldyBJbnRlcm5hbE5vZGUoe1xuICAgICAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGxlZnREYXRhLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB0aGlzLmRhdGFbMF0ubGVmdC5nZXREYXRhKClbMF0ua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnREYXRhW2xlZnREYXRhLmxlbmd0aCAtIDFdLnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLmRhdGFbMF0ubGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLCB0aGlzLmRhdGEpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkSW50ZXJuYWxOb2RlLmdldERhdGEoKVswXS5rZXk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkSW50ZXJuYWxOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQobGVmdFBlZXIpICYmIGlzRGVmaW5lZChsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5nZXRMZWZ0UGVlcigpLnNldFJpZ2h0UGVlcihtZXJnZWRJbnRlcm5hbE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRJbnRlcm5hbE5vZGUuc2V0TGVmdFBlZXIobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuc2V0TGVmdFBlZXIobWVyZ2VkSW50ZXJuYWxOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkSW50ZXJuYWxOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH07XG5cbiAgICBJbnRlcm5hbE5vZGUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRDaGlsZChrZXkpLmZpbmQoa2V5KTtcbiAgICB9O1xuXG4gICAgSW50ZXJuYWxOb2RlLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRDaGlsZChzdGFydCkucmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgfTtcblxuICAgIEludGVybmFsTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW2luZGVudCArIFwiW2tleT1cIiArIGVsZW1lbnQua2V5LCBcIlxcblwiICsgaW5kZW50ICsgXCIgICAgTEVGVFxcblwiICsgZWxlbWVudC5sZWZ0LnRvU3RyaW5nKGluZGVudCArIFwiICAgIFwiKSwgXCJcXG5cIiArIGluZGVudCArIFwiICAgIFJJR0hUXFxuXCIgKyBlbGVtZW50LnJpZ2h0LnRvU3RyaW5nKGluZGVudCArIFwiICAgIFwiKSArIFwiXFxuXCIgKyBpbmRlbnQgKyBcIl1cIl07XG4gICAgICAgIH0pLmpvaW4oXCIsXFxuXCIpO1xuICAgIH07XG5cbiAgICB2YXIgTGVhZk5vZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBOb2RlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgICAgdGhpcy5sZWZ0UGVlciA9IG9wdGlvbnMubGVmdFBlZXI7XG4gICAgICAgIHRoaXMucmlnaHRQZWVyID0gb3B0aW9ucy5yaWdodFBlZXI7XG4gICAgfTtcblxuICAgIExlYWZOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUpO1xuXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmZpbmRJbmRleCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdCA9IDA7XG4gICAgICAgIHZhciByaWdodCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB2YXIgbWlkID0gbGVmdCArIE1hdGguZmxvb3IoKHJpZ2h0IC0gbGVmdCkgLyAyKTtcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG1pZCA9IGxlZnQgKyBNYXRoLmZsb29yKChyaWdodCAtIGxlZnQpIC8gMik7XG4gICAgICAgICAgICBpZiAoZGF0YVttaWRdLmtleSA8IGtleSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhW21pZF0ua2V5ID4ga2V5KSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBtaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobGVmdCAhPT0gcmlnaHQgJiYgIWZvdW5kKTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjbG9iYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGluZGV4ID09IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgIGlmIChjbG9iYmVyKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtlbGVtZW50LnZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgY29uZGl0aW9uIG1heSBuZXZlciBvY2N1ciwgZ2l2ZW4gdGhlIHdheSBmaW5kSW5kZXggaXMgd3JpdHRlblxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQua2V5IDwga2V5KSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKGluZGV4ICsgMSwgMCwge1xuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKGluZGV4LCAwLCB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zcGxpdCgpO1xuICAgIH07XG5cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoIDwgdGhpcy5vcmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzcGxpdEluZGV4ID0gTWF0aC5mbG9vcih0aGlzLmRhdGEubGVuZ3RoIC8gMik7XG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IG5ldyBMZWFmTm9kZSh7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuc2xpY2UoMCwgc3BsaXRJbmRleCksXG4gICAgICAgICAgICBsZWZ0UGVlcjogdGhpcy5sZWZ0UGVlcixcbiAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByaWdodE5vZGUgPSBuZXcgTGVhZk5vZGUoe1xuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLnNsaWNlKHNwbGl0SW5kZXgsIHRoaXMuZGF0YS5sZW5ndGgpLFxuICAgICAgICAgICAgcmlnaHRQZWVyOiB0aGlzLnJpZ2h0UGVlcixcbiAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGRcbiAgICAgICAgfSk7XG4gICAgICAgIGxlZnROb2RlLnNldFJpZ2h0UGVlcihyaWdodE5vZGUpO1xuICAgICAgICByaWdodE5vZGUuc2V0TGVmdFBlZXIobGVmdE5vZGUpO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHRoaXMubGVmdFBlZXIpKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnRQZWVyLnNldFJpZ2h0UGVlcihsZWZ0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmaW5lZCh0aGlzLnJpZ2h0UGVlcikpIHtcbiAgICAgICAgICAgIHRoaXMucmlnaHRQZWVyLnNldExlZnRQZWVyKHJpZ2h0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtsZWZ0Tm9kZSwgdGhpcy5kYXRhW3NwbGl0SW5kZXhdLmtleSwgcmlnaHROb2RlXTtcbiAgICB9O1xuXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXksIGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRJbmRleChrZXkpO1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuZGF0YS5sZW5ndGggJiYgZWxlbWVudC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gW2VsZW1lbnQudmFsdWVdLmNvbmNhdCh0aGlzLm1lcmdlKGxlZnRNZXJnZU9wdGlvbiwgcmlnaHRNZXJnZU9wdGlvbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExlYWZOb2RlLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChsZWZ0TWVyZ2VPcHRpb24sIHJpZ2h0TWVyZ2VPcHRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPiB0aGlzLm1lcmdlVGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0RlZmluZWQobGVmdE1lcmdlT3B0aW9uKSAmJiAhaXNEZWZpbmVkKHJpZ2h0TWVyZ2VPcHRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldHZhbCA9IFtdO1xuICAgICAgICAvLyB2YXIgZGVmaWNpdCA9IHRydWU7XG4gICAgICAgIHZhciBsZWZ0U3VycGx1cyA9IDA7XG4gICAgICAgIHZhciBsZWZ0RGF0YTtcbiAgICAgICAgdmFyIHJpZ2h0U3VycGx1cyA9IDA7XG4gICAgICAgIHZhciByaWdodERhdGE7XG4gICAgICAgIHZhciBsZWZ0UGVlciA9IHRoaXMubGVmdFBlZXI7XG4gICAgICAgIHZhciByaWdodFBlZXIgPSB0aGlzLnJpZ2h0UGVlcjtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0TWVyZ2VPcHRpb24pKSB7XG4gICAgICAgICAgICBsZWZ0RGF0YSA9IGxlZnRNZXJnZU9wdGlvbi5nZXREYXRhKCk7XG4gICAgICAgICAgICBsZWZ0U3VycGx1cyA9IGxlZnRNZXJnZU9wdGlvbi5nZXRTdXJwbHVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodE1lcmdlT3B0aW9uKSkge1xuICAgICAgICAgICAgcmlnaHREYXRhID0gcmlnaHRNZXJnZU9wdGlvbi5nZXREYXRhKCk7XG4gICAgICAgICAgICByaWdodFN1cnBsdXMgPSByaWdodE1lcmdlT3B0aW9uLmdldFN1cnBsdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdFN1cnBsdXMgPiByaWdodFN1cnBsdXMpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0U3VycGx1c0RhdGEgPSBsZWZ0TWVyZ2VPcHRpb24uZ2V0UmlnaHRTdXJwbHVzRGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbGVmdFN1cnBsdXNEYXRhLmNvbmNhdCh0aGlzLmRhdGEpO1xuICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XG4gICAgICAgICAgICByZXR2YWxbMV0gPSBsZWZ0TWVyZ2VPcHRpb247XG4gICAgICAgICAgICByZXR2YWxbMl0gPSB0aGlzLmRhdGFbMF0ua2V5O1xuICAgICAgICAgICAgcmV0dmFsWzNdID0gdGhpcztcbiAgICAgICAgfSBlbHNlIGlmIChyaWdodFN1cnBsdXMgPiBsZWZ0U3VycGx1cykge1xuICAgICAgICAgICAgdmFyIHJpZ2h0U3VycGx1c0RhdGEgPSByaWdodE1lcmdlT3B0aW9uLmdldExlZnRTdXJwbHVzRGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLmNvbmNhdChyaWdodFN1cnBsdXNEYXRhKTtcbiAgICAgICAgICAgIHJldHZhbFswXSA9IDE7XG4gICAgICAgICAgICByZXR2YWxbMV0gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dmFsWzJdID0gcmlnaHRNZXJnZU9wdGlvbi5nZXREYXRhKClbMF0ua2V5O1xuICAgICAgICAgICAgcmV0dmFsWzNdID0gcmlnaHRNZXJnZU9wdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtZXJnZWRMZWFmTm9kZTtcbiAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKGxlZnREYXRhKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlID0gbmV3IExlYWZOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEuY29uY2F0KHJpZ2h0RGF0YSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMF0gPSAxO1xuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZExlYWZOb2RlLmdldERhdGEoKVswXS5rZXk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkTGVhZk5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodFBlZXIpICYmIGlzRGVmaW5lZChyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5nZXRSaWdodFBlZXIoKS5zZXRMZWZ0UGVlcihtZXJnZWRMZWFmTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0UGVlci5zZXRSaWdodFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRGVmaW5lZChyaWdodERhdGEpKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUgPSBuZXcgTGVhZk5vZGUoe1xuICAgICAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUaHJlc2hvbGQ6IHRoaXMubWVyZ2VUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGxlZnREYXRhLmNvbmNhdCh0aGlzLmRhdGEpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzBdID0gLTE7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzFdID0gbWVyZ2VkTGVhZk5vZGUuZ2V0RGF0YSgpWzBdLmtleTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMl0gPSBtZXJnZWRMZWFmTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGxlZnRQZWVyKSAmJiBpc0RlZmluZWQobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuZ2V0TGVmdFBlZXIoKS5zZXRSaWdodFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRMZWZ0UGVlcihsZWZ0UGVlci5nZXRMZWZ0UGVlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChyaWdodFBlZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGVlci5zZXRMZWZ0UGVlcihtZXJnZWRMZWFmTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlLnNldFJpZ2h0UGVlcihyaWdodFBlZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0RGF0YS5sZW5ndGggPCBsZWZ0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZSA9IG5ldyBMZWFmTm9kZSh7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLmNvbmNhdChyaWdodERhdGEpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzBdID0gMTtcbiAgICAgICAgICAgICAgICByZXR2YWxbMV0gPSBtZXJnZWRMZWFmTm9kZS5nZXREYXRhKClbMF0ua2V5O1xuICAgICAgICAgICAgICAgIHJldHZhbFsyXSA9IG1lcmdlZExlYWZOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSAmJiBpc0RlZmluZWQocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuZ2V0UmlnaHRQZWVyKCkuc2V0TGVmdFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyLmdldFJpZ2h0UGVlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0UGVlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBlZXIuc2V0UmlnaHRQZWVyKG1lcmdlZExlYWZOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUuc2V0TGVmdFBlZXIobGVmdFBlZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlZExlYWZOb2RlID0gbmV3IExlYWZOb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGhyZXNob2xkOiB0aGlzLm1lcmdlVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBsZWZ0RGF0YS5jb25jYXQodGhpcy5kYXRhKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHZhbFswXSA9IC0xO1xuICAgICAgICAgICAgICAgIHJldHZhbFsxXSA9IG1lcmdlZExlYWZOb2RlLmdldERhdGEoKVswXS5rZXk7XG4gICAgICAgICAgICAgICAgcmV0dmFsWzJdID0gbWVyZ2VkTGVhZk5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChsZWZ0UGVlcikgJiYgaXNEZWZpbmVkKGxlZnRQZWVyLmdldExlZnRQZWVyKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRQZWVyLmdldExlZnRQZWVyKCkuc2V0UmlnaHRQZWVyKG1lcmdlZExlYWZOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTGVhZk5vZGUuc2V0TGVmdFBlZXIobGVmdFBlZXIuZ2V0TGVmdFBlZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQocmlnaHRQZWVyKSkge1xuICAgICAgICAgICAgICAgICAgICByaWdodFBlZXIuc2V0TGVmdFBlZXIobWVyZ2VkTGVhZk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRMZWFmTm9kZS5zZXRSaWdodFBlZXIocmlnaHRQZWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9O1xuXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZEluZGV4KGtleSk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5kYXRhLmxlbmd0aCAmJiBlbGVtZW50LmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XG4gICAgICAgIHZhciByYW5nZSA9IFtdO1xuICAgICAgICB3aGlsZSAoaXNEZWZpbmVkKG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IG5vZGUuZmluZEluZGV4KHN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IG5vZGUuZmluZEluZGV4KGVuZCk7XG4gICAgICAgICAgICB2YXIgbm9kZURhdGEgPSBub2RlLmdldERhdGEoKTtcbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgbm9kZURhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnB1c2gobm9kZURhdGFbaV0udmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmRJbmRleCA9PSBub2RlRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5nZXRSaWdodFBlZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICByZXR1cm4gaW5kZW50ICsgXCJbXCIgKyB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQua2V5O1xuICAgICAgICAgICAgfSkudG9TdHJpbmcoKSArIFwiXVwiO1xuICAgIH07XG5cbiAgICB2YXIgVHJlZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLm9yZGVyID0gb3B0aW9ucy5vcmRlciB8fCAxMDA7XG4gICAgICAgIHRoaXMubWVyZ2VUaHJlc2hvbGQgPSBvcHRpb25zLm1lcmdlVGhyZXNob2xkIHx8IDQwO1xuICAgICAgICB0aGlzLnJvb3QgPSBuZXcgTGVhZk5vZGUoe1xuICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsXG4gICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcbiAgICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUcmVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC50b1N0cmluZyhcIlwiKTtcbiAgICB9O1xuXG4gICAgVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNsb2JiZXIpIHtcbiAgICAgICAgdmFyIG5ld05vZGVzID0gdGhpcy5yb290Lmluc2VydChrZXksIHZhbHVlLCBjbG9iYmVyKTtcbiAgICAgICAgaWYgKG5ld05vZGVzLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXcgSW50ZXJuYWxOb2RlKHtcbiAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgICAgICAgICAgICBtZXJnZVRocmVzaG9sZDogdGhpcy5tZXJnZVRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICBkYXRhOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogbmV3Tm9kZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBuZXdOb2Rlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBuZXdOb2Rlc1syXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3Tm9kZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdOb2Rlc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIFRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHJldHZhbCA9IHRoaXMucm9vdC5yZW1vdmUoa2V5KTtcbiAgICAgICAgaWYgKHJldHZhbC5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gcmV0dmFsWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR2YWxbMF07XG4gICAgfTtcblxuICAgIFRyZWUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuZmluZChrZXkpO1xuICAgIH07XG5cbiAgICBUcmVlLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QucmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgfTtcblxuICAgIC8vIEV4cG9zZSBhbGwgdHlwZXMgb24gdG9wXG4gICAgVHJlZS5Ob2RlID0gTm9kZTtcbiAgICBUcmVlLkludGVybmFsTm9kZSA9IEludGVybmFsTm9kZTtcbiAgICBUcmVlLkxlYWZOb2RlID0gTGVhZk5vZGU7XG5cbiAgICAvLyBFbmFibGUgbW9kdWxlIGxvYWRpbmcgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSkgeyAvLyBDb21tb25KU1xuICAgICAgICBtb2R1bGVbXCJleHBvcnRzXCJdID0gVHJlZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgIT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lW1wiYW1kXCJdKSB7IC8vIEFNRFxuICAgICAgICBkZWZpbmUoXCJCUGx1c1RyZWVcIiwgW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gVHJlZTsgfSk7XG4gICAgfSBlbHNlIHsgLy8gU2hpbVxuICAgICAgICBpZiAoIWdsb2JhbFtcImRjb2RlSU9cIl0pIHtcbiAgICAgICAgICAgIGdsb2JhbFtcImRjb2RlSU9cIl0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxbXCJkY29kZUlPXCJdW1wiQlBsdXNUcmVlXCJdID0gVHJlZTtcbiAgICB9XG5cbn0pKHRoaXMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1NlYXJjaC9CUGx1c1RyZWUuanMiLCIvKlxuIENvcHlyaWdodCAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZSBidHJlZS5qcyAoYykgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxuICogc2VlOiBodHRwOi8vZ2l0aHViLmNvbS9kY29kZUlPL2J0cmVlLmpzIGZvciBkZXRhaWxzXG4gKi9cbihmdW5jdGlvbiAobW9kdWxlLCBjb25zb2xlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQ29uY2F0ZW5hdGVzIG11bHRpcGxlIGFycmF5cyBpbnRvIGEgbmV3IG9uZS5cbiAgICAgKiBAcGFyYW0gey4uLltBcnJheV19IHZhcl9hcmdzXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uY2F0KHZhcl9hcmdzKSB7XG4gICAgICAgIC8vIEFycmF5I2NvbmNhdCBiZWhhdmVzIHN0cmFuZ2VseSBmb3IgZW1wdHkgYXJyYXlzLCBzby4uLlxuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYSwgYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyBhbiBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhXG4gICAgICogQHBhcmFtIHsqfSB2XG4gICAgICogQHJldHVybnMge251bWJlcn0gSW5kZXggb3IgLTEgaWYgbm90IGZvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc2VhcmNoKGEsIHYpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBmYXN0ZXIgdGhhbiBBcnJheSNpbmRleE9mIGJlY2F1c2UgaXQncyByYXcuIEhvd2V2ZXIsIHdlXG4gICAgICAgIC8vIGNhbm5vdCB1c2UgYmluYXJ5IHNlYXJjaCBiZWNhdXNlIG5vZGVzIGRvIG5vdCBoYXZlIGEgY29tcGFyYWJsZVxuICAgICAgICAvLyBrZXkuIElmIHRoZSBjb21waWxlciBpcyBzbWFydCwgaXQgd2lsbCBpbmxpbmUgdGhpcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYVtpXSA9PT0gdikgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC1pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGJ0cmVlIG5hbWVzcGFjZS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XG4gICAgICovXG4gICAgdmFyIGJ0cmVlID0ge307XG5cbiAgICAvKipcbiAgICAgKiBTdHJpY3RseSBjb21wYXJlcyB0d28gc3RyaW5ncywgY2hhcmFjdGVyIGJ5IGNoYXJhY3Rlci4gTm8gbG9jYWxlcywgbm8gbnVtYmVyIGV4dGVuc2lvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiXG4gICAgICogQHJldHVybnMge251bWJlcn0gLTEgaWYgYSA8IGIsIDEgaWYgYSA+IGIsIDAgb3RoZXJ3aXNlXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIGJ0cmVlLnN0cmNtcCA9IGZ1bmN0aW9uIHN0cmNtcChhLCBiKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB2YXIgYWM7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB2YXIgYmM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPj0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoYWMgPSBhLmNoYXJDb2RlQXQoaSkpIDwgKGJjID0gYi5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWMgPiBiYykge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgc2FtZSwgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT0gYi5sZW5ndGggPyAwIDogLTE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHR3byBudW1iZXJzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtMSBpZiBhIDwgYiwgMSBpZiBhID4gYiwgMCBvdGhlcndpc2VcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgYnRyZWUubnVtY21wID0gZnVuY3Rpb24gaW50Y21wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAoYSA+IGIgPyAxIDogMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBCVHJlZSBjbGFzcyB1c2luZyB0aGUgZ2l2ZW4gb3JkZXIuXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHJldHVybnMgYSBjbGFzcywgbm90IGFuIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb3JkZXIgRGVmYXVsdHMgdG8gMlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oPywgPyk6bnVtYmVyPX0gY29tcGFyZSBDb21wYXJlIGltcGxlbWVudGF0aW9uIHRvIHVzZSBvbiBrZXlzXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBidHJlZS5jcmVhdGUgPSBmdW5jdGlvbiAob3JkZXIsIGNvbXBhcmUpIHtcblxuICAgICAgICAvLyBWYWxpZGF0ZSBvcmRlclxuICAgICAgICBpZiAodHlwZW9mIG9yZGVyID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvcmRlciA9IDUyOyAvLyBCZW5jaG1hcmtzIHByb29mZWQgdGhhdCB0aGlzIGlzIGNsb3NlIHRvIHRoZSBvcHRpbXVtXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9yZGVyID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvcmRlciA9IE1hdGguZmxvb3Iob3JkZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3JkZXIgPSBwYXJzZUludChvcmRlciwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRlciA8IDEpIG9yZGVyID0gMTtcbiAgICAgICAgdmFyIG1pbk9yZGVyID0gb3JkZXIgPiAxID8gTWF0aC5mbG9vcihvcmRlciAvIDIpIDogMTtcblxuICAgICAgICAvLyBVc2UgbnVtY21wIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKHR5cGVvZiBjb21wYXJlICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbXBhcmUgPSBidHJlZS5udW1jbXA7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdGVzIGEgbm9kZSBhbmQgcHJpbnRzIGRlYnVnZ2luZyBpbmZvIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgICAgICAgKiBAcGFyYW0geyFUcmVlTm9kZXwhVHJlZX0gbm9kZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSkgeyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgc3RyaXBwZWQgYnkgdGhlIGNvbXBpbGVyXG4gICAgICAgICAgICBpZiAoKG5vZGUgaW5zdGFuY2VvZiBUcmVlKSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKG5vZGUubGVhdmVzLmxlbmd0aCArIDEgIT0gbm9kZS5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SOiBJbGxlZ2FsIGxlYWYvbm9kZSBjb3VudCBpbiBcIiArIG5vZGUgKyBcIjogXCIgKyBub2RlLmxlYXZlcy5sZW5ndGggKyBcIi9cIiArIG5vZGUubm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZWF2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUubGVhdmVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IElsbGVnYWwgbGVhZiBpbiBcIiArIG5vZGUgKyBcIiBhdCBcIiArIGkgKyBcIjogXCIgKyBub2RlLmxlYXZlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUubm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUubm9kZXNbaV0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFUlJPUjogSWxsZWdhbCBub2RlIGluIFwiICsgbm9kZSArIFwiIGF0IFwiICsgaSArIFwiOiB1bmRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVHJlZU5vZGUuXG4gICAgICAgICAqIEBjbGFzcyBBIFRyZWVOb2RlLlxuICAgICAgICAgKiBAcGFyYW0geyEoVHJlZU5vZGV8VHJlZSl9IHBhcmVudCBQYXJlbnQgbm9kZVxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjwhTGVhZj49fSBsZWF2ZXMgTGVhZiBub2Rlc1xuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxUcmVlTm9kZT49fSBub2RlcyBDaGlsZCBub2Rlc1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIHZhciBUcmVlTm9kZSA9IGZ1bmN0aW9uIChwYXJlbnQsIGxlYXZlcywgbm9kZXMpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQYXJlbnQgbm9kZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHshVHJlZU5vZGV8IVRyZWV9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExlYWYgbm9kZXMgKG1heC4gb3JkZXIpLlxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48IUxlYWY+fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmxlYXZlcyA9IGxlYXZlcyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMubGVhdmVzLmZvckVhY2goZnVuY3Rpb24gKGxlYWYpIHtcbiAgICAgICAgICAgICAgICBsZWFmLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGlsZCBub2RlcyAobWF4LiBvcmRlcisxKS5cbiAgICAgICAgICAgICAqIEB0eXBlIHshQXJyYXkuPFRyZWVOb2RlPn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzIHx8IFtudWxsXTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlICE9PSBudWxsKSBub2RlLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VhcmNoZXMgZm9yIHRoZSBub2RlIHRoYXQgd291bGQgY29udGFpbiB0aGUgc3BlY2lmaWVkIGtleS5cbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XG4gICAgICAgICAqIEByZXR1cm5zIHt7bGVhZjogIUxlYWYsIGluZGV4OiBudW1iZXJ9fHtub2RlOiAhVHJlZU5vZGUsIGluZGV4OiBudW1iZXJ9fSBMZWFmIGlmIHRoZSBrZXkgZXhpc3RzLCBlbHNlIHRoZSBpbnNlcnRpb24gbm9kZVxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlYXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmxlYXZlc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShhLmtleSwga2V5KSA9PSAwKSByZXR1cm4ge2xlYWY6IGEsIGluZGV4OiAwfTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShrZXksIGEua2V5KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbMF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdLnNlYXJjaChrZXkpOyAvLyBMZWZ0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtub2RlOiB0aGlzLCBpbmRleDogMH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmxlYXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMubGVhdmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShiLmtleSwga2V5KSA9PSAwKSByZXR1cm4ge2xlYWY6IGIsIGluZGV4OiBpfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoa2V5LCBiLmtleSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1tpXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzW2ldLnNlYXJjaChrZXkpOyAvLyBJbm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtub2RlOiB0aGlzLCBpbmRleDogaX07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVzW2ldLnNlYXJjaChrZXkpOyAvLyBSaWdodFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge25vZGU6IHRoaXMsIGluZGV4OiBpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7bm9kZTogdGhpcywgaW5kZXg6IDB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleS5cbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XG4gICAgICAgICAqIEByZXR1cm5zIHsqfHVuZGVmaW5lZH0gSWYgdGhlcmUgaXMgbm8gc3VjaCBrZXksIHVuZGVmaW5lZCBpcyByZXR1cm5lZFxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNlYXJjaChrZXkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZWFmKSByZXR1cm4gcmVzdWx0LmxlYWYudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnRzIGEga2V5L3ZhbHVlIHBhaXIgaW50byB0aGlzIG5vZGUuXG4gICAgICAgICAqIEBwYXJhbSB7ISp9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG92ZXJ3cml0ZSBXaGV0aGVyIHRvIG92ZXJ3cml0ZSBleGlzdGluZyB2YWx1ZXMsIGRlZmF1bHRzIHRvIGB0cnVlYFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBzdWNjZXNzZnVsbHkgc2V0LCBmYWxzZSBpZiBhbHJlYWR5IHByZXNlbnQgYW5kIG92ZXJ3cml0ZSBpcyBgZmFsc2VgXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuc2VhcmNoKGtleSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmxlYWYpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG92ZXJ3cml0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIW92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5sZWFmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IC8vIEtleSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgdmFyIG5vZGUgPSByZXN1bHQubm9kZSxcbiAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3VsdC5pbmRleDtcbiAgICAgICAgICAgIG5vZGUubGVhdmVzLnNwbGljZShpbmRleCwgMCwgbmV3IExlYWYobm9kZSwga2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgbm9kZS5ub2Rlcy5zcGxpY2UoaW5kZXggKyAxLCAwLCBudWxsKTtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYXZlcy5sZW5ndGggPiBvcmRlcikgeyAvLyBSZWJhbGFuY2VcbiAgICAgICAgICAgICAgICBub2RlLnNwbGl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBhIGtleSBmcm9tIHRoaXMgbm9kZS5cbiAgICAgICAgICogQHBhcmFtIHshKn0ga2V5XG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBrZXkgaGFzIGJlZW4gZGVsZXRlZCwgZmFsc2UgaWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdFxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNlYXJjaChrZXkpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQubGVhZikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIGxlYWYgPSByZXN1bHQubGVhZixcbiAgICAgICAgICAgICAgICBub2RlID0gbGVhZi5wYXJlbnQsXG4gICAgICAgICAgICAgICAgaW5kZXggPSByZXN1bHQuaW5kZXgsXG4gICAgICAgICAgICAgICAgbGVmdCA9IG5vZGUubm9kZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBub2RlLmxlYXZlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIG5vZGUubm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBub2RlLmJhbGFuY2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heCA9IGxlZnQubGVhdmVzW2xlZnQubGVhdmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGxlZnQuZGVsKG1heC5rZXkpO1xuICAgICAgICAgICAgICAgIG1heC5wYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUubGVhdmVzLnNwbGljZShpbmRleCwgMSwgbWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYWxhbmNlcyB0aGlzIG5vZGUgdG8gZnVsZmlsbCBhbGwgY29uZGl0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS5iYWxhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZTogUm9vdCBoYXMganVzdCBhIHNpbmdsZSBjaGlsZCBhbmQgbm8gbGVhdmVzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVhdmVzLmxlbmd0aCA9PSAwICYmIHRoaXMubm9kZXNbMF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucm9vdCA9IHRoaXMubm9kZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnJvb3QucGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxlYXZlcy5sZW5ndGggPj0gbWluT3JkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBhc2VhcmNoKHRoaXMucGFyZW50Lm5vZGVzLCB0aGlzKSxcbiAgICAgICAgICAgICAgICBsZWZ0ID0gaW5kZXggPiAwID8gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXggLSAxXSA6IG51bGwsXG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcmVudC5ub2Rlcy5sZW5ndGggPiBpbmRleCArIDEgPyB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleCArIDFdIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBzZXAsIGxlYWYsIHJlc3Q7XG4gICAgICAgICAgICBpZiAocmlnaHQgIT09IG51bGwgJiYgcmlnaHQubGVhdmVzLmxlbmd0aCA+IG1pbk9yZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzZXBlcmF0b3IgZnJvbSBwYXJlbnQgdG8gdGhpc1xuICAgICAgICAgICAgICAgIHNlcCA9IHRoaXMucGFyZW50LmxlYXZlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgc2VwLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMucHVzaChzZXApO1xuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGJsYW5rIHdpdGggdGhlIGZpcnN0IHJpZ2h0IGxlYWZcbiAgICAgICAgICAgICAgICBsZWFmID0gcmlnaHQubGVhdmVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXhdID0gbGVhZjtcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHJpZ2h0IHJlc3QgdG8gdGhpc1xuICAgICAgICAgICAgICAgIHJlc3QgPSByaWdodC5ub2Rlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN0ICE9PSBudWxsKSByZXN0LnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHJlc3QpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSBudWxsICYmIGxlZnQubGVhdmVzLmxlbmd0aCA+IG1pbk9yZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJlcGVuZCB0aGUgc2VwZXJhdG9yIGZyb20gcGFyZW50IHRvIHRoaXNcbiAgICAgICAgICAgICAgICBzZXAgPSB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBzZXAucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcy51bnNoaWZ0KHNlcCk7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgYmxhbmsgd2l0aCB0aGUgbGFzdCBsZWZ0IGxlYWZcbiAgICAgICAgICAgICAgICBsZWFmID0gbGVmdC5sZWF2ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXggLSAxXSA9IGxlYWY7XG4gICAgICAgICAgICAgICAgLy8gUHJlcGVuZCB0aGUgbGVmdCByZXN0IHRvIHRoaXNcbiAgICAgICAgICAgICAgICByZXN0ID0gbGVmdC5ub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdCAhPT0gbnVsbCkgcmVzdC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMudW5zaGlmdChyZXN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0O1xuICAgICAgICAgICAgICAgIGlmIChyaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5lIHRoaXMgKyBzZXBlcmF0b3IgZnJvbSB0aGUgcGFyZW50ICsgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gdGhpcy5wYXJlbnQubGVhdmVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic3QgPSBuZXcgVHJlZU5vZGUodGhpcy5wYXJlbnQsIGNvbmNhdCh0aGlzLmxlYXZlcywgW3NlcF0sIHJpZ2h0LmxlYXZlcyksIGNvbmNhdCh0aGlzLm5vZGVzLCByaWdodC5ub2RlcykpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlcGVyYXRvciBmcm9tIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubGVhdmVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFuZCByZXBsYWNlIHRoZSBub2RlcyBpdCBzZXBlcmF0ZWQgd2l0aCBzdWJzdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5ub2Rlcy5zcGxpY2UoaW5kZXgsIDIsIHN1YnN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tYmluZSBsZWZ0ICsgc2VwZXJhdG9yIGZyb20gcGFyZW50ICsgdGhpc1xuICAgICAgICAgICAgICAgICAgICBzZXAgPSB0aGlzLnBhcmVudC5sZWF2ZXNbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic3QgPSBuZXcgVHJlZU5vZGUodGhpcy5wYXJlbnQsIGNvbmNhdChsZWZ0LmxlYXZlcywgW3NlcF0sIHRoaXMubGVhdmVzKSwgY29uY2F0KGxlZnQubm9kZXMsIHRoaXMubm9kZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZXBlcmF0b3IgZnJvbSB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxlYXZlcy5zcGxpY2UoaW5kZXggLSAxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQW5kIHJlcGxhY2UgdGhlIG5vZGVzIGl0IHNlcGVyYXRlZCB3aXRoIHN1YnN0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Lm5vZGVzLnNwbGljZShpbmRleCAtIDEsIDIsIHN1YnN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgZW5kIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3I6IFwiICsgdGhpcy50b1N0cmluZyh0cnVlKSArIFwiIGhhcyBuZWl0aGVyIGEgbGVmdCBub3IgYSByaWdodCBzaWJsaW5nXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuYmFsYW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmFsaWRhdGUodGhpcyk7XG4gICAgICAgICAgICAvLyB2YWxpZGF0ZSh0aGlzLnBhcmVudCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuc3BsaXRzIGEgY2hpbGQuXG4gICAgICAgICAqIEBwYXJhbSB7IUxlYWZ9IGxlYWZcbiAgICAgICAgICogQHBhcmFtIHshVHJlZU5vZGV9IHJlc3RcbiAgICAgICAgICovXG4gICAgICAgIFRyZWVOb2RlLnByb3RvdHlwZS51bnNwbGl0ID0gZnVuY3Rpb24gKGxlYWYsIHJlc3QpIHtcbiAgICAgICAgICAgIGxlYWYucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHJlc3QucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5sZWF2ZXNbMF07XG4gICAgICAgICAgICBpZiAoY29tcGFyZShsZWFmLmtleSwgYS5rZXkpIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhdmVzLnVuc2hpZnQobGVhZik7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5zcGxpY2UoMSwgMCwgcmVzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5sZWF2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmxlYXZlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUobGVhZi5rZXksIGIua2V5KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVhdmVzLnNwbGljZShpLCAwLCBsZWFmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuc3BsaWNlKGkgKyAxLCAwLCByZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09IHRoaXMubGVhdmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlYXZlcy5wdXNoKGxlYWYpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gocmVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGVhdmVzLmxlbmd0aCA+IG9yZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGxpdHMgdGhpcyBub2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZU5vZGUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcih0aGlzLmxlYXZlcy5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzID0gW1xuICAgICAgICAgICAgICAgICAgICBuZXcgVHJlZU5vZGUodGhpcywgdGhpcy5sZWF2ZXMuc2xpY2UoMCwgaW5kZXgpLCB0aGlzLm5vZGVzLnNsaWNlKDAsIGluZGV4ICsgMSkpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgVHJlZU5vZGUodGhpcywgdGhpcy5sZWF2ZXMuc2xpY2UoaW5kZXggKyAxKSwgdGhpcy5ub2Rlcy5zbGljZShpbmRleCArIDEpKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMgPSBbdGhpcy5sZWF2ZXNbaW5kZXhdXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlYWYgPSB0aGlzLmxlYXZlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3QgPSBuZXcgVHJlZU5vZGUodGhpcy5wYXJlbnQsIHRoaXMubGVhdmVzLnNsaWNlKGluZGV4ICsgMSksIHRoaXMubm9kZXMuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZXMgPSB0aGlzLmxlYXZlcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlcyA9IHRoaXMubm9kZXMuc2xpY2UoMCwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC51bnNwbGl0KGxlYWYsIHJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZS5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5jbHVkZU5vZGVzIFdoZXRoZXIgdG8gaW5jbHVkZSBzdWItbm9kZXMgb3Igbm90XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoaW5jbHVkZU5vZGVzKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVhdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsLnB1c2godGhpcy5sZWF2ZXNbaV0ua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzID0gXCJbXCIgKyB2YWwudG9TdHJpbmcoKSArIFwiXVwiICsgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgVHJlZSA/IFwiOipcIiA6IFwiOlwiICsgdGhpcy5wYXJlbnQpO1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVOb2Rlcykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgKz0gXCIgLT4gXCIgKyB0aGlzLm5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmludHMgb3V0IHRoZSBub2RlcyBsZWF2ZXMgYW5kIG5vZGVzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZW50XG4gICAgICAgICAqL1xuICAgICAgICBUcmVlTm9kZS5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICB2YXIgc3BhY2UgPSBcIlwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRlbnQ7IGkrKykgc3BhY2UgKz0gXCIgXCI7XG4gICAgICAgICAgICBmb3IgKGkgPSB0aGlzLmxlYXZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2kgKyAxXSAhPT0gbnVsbCkgdGhpcy5ub2Rlc1tpICsgMV0ucHJpbnQoaW5kZW50ICsgMik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3BhY2UgKyB0aGlzLmxlYXZlc1tpXS5rZXkgKyAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBUcmVlID8gXCIqXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlc1swXSAhPT0gbnVsbCkgdGhpcy5ub2Rlc1swXS5wcmludChpbmRlbnQgKyAyKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBMZWFmIGNvbnRhaW5pbmcgYSB2YWx1ZS5cbiAgICAgICAgICogQGNsYXNzIEEgTGVhZi5cbiAgICAgICAgICogQHBhcmFtIHshVHJlZU5vZGV9IHBhcmVudFxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIHZhciBMZWFmID0gZnVuY3Rpb24gKHBhcmVudCwga2V5LCB2YWx1ZSkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhcmVudCBub2RlLlxuICAgICAgICAgICAgICogQHR5cGUgeyFUcmVlTm9kZX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogS2V5LlxuICAgICAgICAgICAgICogQHR5cGUgeyEqfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBWYWx1ZS5cbiAgICAgICAgICAgICAqIEB0eXBlIHsqfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIExlYWYucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB0aGlzLmtleTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUcmVlLlxuICAgICAgICAgKiBAY2xhc3MgQSBUcmVlLlxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFRyZWUoKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXcgVHJlZU5vZGUodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyBhIGtleS92YWx1ZSBwYWlyIGludG8gdGhlIHRyZWUuXG4gICAgICAgICAqIEBwYXJhbSB7ISp9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG92ZXJ3cml0ZSBXaGV0aGVyIHRvIG92ZXJ3cml0ZSBleGlzdGluZyB2YWx1ZXMsIGRlZmF1bHRzIHRvIGB0cnVlYFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBzZXQsIGZhbHNlIGlmIGFscmVhZHkgcHJlc2VudCBhbmQgb3ZlcndyaXRlIGlzIGBmYWxzZWBcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBrZXkgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZFxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgb3ZlcndyaXRlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcgfHwga2V5ID09PSBudWxsKSAgdGhyb3cobmV3IEVycm9yKFwiSWxsZWdhbCBrZXk6IFwiICsga2V5KSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykgdGhyb3cobmV3IEVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIgKyB2YWx1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5wdXQoa2V5LCB2YWx1ZSwgb3ZlcndyaXRlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBrZXkuXG4gICAgICAgICAqIEBwYXJhbSB7ISp9IGtleVxuICAgICAgICAgKiBAcmV0dXJucyB7Knx1bmRlZmluZWR9IElmIHRoZXJlIGlzIG5vIHN1Y2gga2V5LCB1bmRlZmluZWQgaXMgcmV0dXJuZWRcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBrZXkgaXMgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnIHx8IGtleSA9PT0gbnVsbCkgIHRocm93KG5ldyBFcnJvcihcIklsbGVnYWwga2V5OiBcIiArIGtleSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5nZXQoa2V5KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBhIGtleSBmcm9tIHRoZSB0cmVlLlxuICAgICAgICAgKiBAcGFyYW0geyEqfSBrZXlcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGtleSBoYXMgYmVlbiBkZWxldGVkLCBmYWxzZSBpZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIFRyZWUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJyB8fCBrZXkgPT09IG51bGwpICB0aHJvdyhuZXcgRXJyb3IoXCJJbGxlZ2FsIGtleTogXCIgKyBrZXkpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3QuZGVsKGtleSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdhbGtzIHRocm91Z2ggYWxsIGtleXMgW21pbktleSwgLi4uLCBtYXhLZXldIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgICAgICogQHBhcmFtIHsqfGZ1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCl9IG1pbktleSBJZiBvbWl0dGVkIG9yIE5VTEwsIHN0YXJ0cyBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAqIEBwYXJhbSB7KCp8ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKSk9fSBtYXhLZXkgSWYgb21pdHRlZCBvciBOVUxMLCB3YWxrcyB0aWxsIHRoZSBlbmRcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbigqLCAqKTooYm9vbGVhbnx1bmRlZmluZWQpPX0gY2FsbGJhY2sgQ2FsbGJhY2sgcmVjZWl2aW5nIHRoZSBrZXkgYW5kIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGFzIGl0c1xuICAgICAgICAgKiAgcGFyYW1ldGVycy4gTWF5IGV4cGxpY2l0bHkgcmV0dXJuIHRydWUgdG8gc3RvcCB0aGUgbG9vcC5cbiAgICAgICAgICogQGV4cG9zZVxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZS5wcm90b3R5cGUud2Fsa0FzYyA9IGZ1bmN0aW9uIChtaW5LZXksIG1heEtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QubGVhdmVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtaW5LZXkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbWluS2V5O1xuICAgICAgICAgICAgICAgIG1pbktleSA9IG1heEtleSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXhLZXkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbWF4S2V5O1xuICAgICAgICAgICAgICAgIG1heEtleSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaW5LZXkgPSB0eXBlb2YgbWluS2V5ICE9ICd1bmRlZmluZWQnID8gbWluS2V5IDogbnVsbDtcbiAgICAgICAgICAgIG1heEtleSA9IHR5cGVvZiBtYXhLZXkgIT0gJ3VuZGVmaW5lZCcgPyBtYXhLZXkgOiBudWxsO1xuICAgICAgICAgICAgdmFyIHB0ciwgaW5kZXg7XG4gICAgICAgICAgICBpZiAobWluS2V5ID09PSBudWxsKSB7IC8vIElmIHRoZXJlIGlzIG5vIG1pbmltdW0gbGltaXRcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzLnJvb3Q7IC8vIHNldCBwdHIgdG8gdGhlIG91dGVyIGxlZnQgbm9kZVxuICAgICAgICAgICAgICAgIHdoaWxlIChwdHIubm9kZXNbMF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLm5vZGVzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleCA9IDA7IC8vIGFuZCBzdGFydCBhdCBpdHMgZmlyc3QgbGVhZlxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gRWxzZSBsb29rdXBcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yb290LnNlYXJjaChtaW5LZXkpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVhZikgeyAvLyBJZiB0aGUgbWluaW11bSBrZXkgaXRzZWxmIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBwdHIgPSByZXN1bHQubGVhZi5wYXJlbnQ7IC8vIHNldCBwdHIgdG8gdGhlIGNvbnRhaW5pbmcgbm9kZVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLmxlYXZlcywgcmVzdWx0LmxlYWYpOyAvLyBhbmQgc3RhcnQgYXQgaXRzIGluZGV4XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gSWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdFxuICAgICAgICAgICAgICAgICAgICBwdHIgPSByZXN1bHQubm9kZTsgLy8gc2V0IHB0ciB0byB0aGUgaW5zZXJ0aW9uIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN1bHQuaW5kZXg7IC8vIGFuZCBzdGFydCBhdCB0aGUgaW5zZXJ0aW9uIGluZGV4IChrZXkgPiBtaW5LZXkpXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBwdHIubGVhdmVzLmxlbmd0aCkgeyAvLyBvbiBvdmVycnVuLCBiZWdpbiBhdCB0aGUgc2VwYXJhdG9yIGluIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwdHIucGFyZW50IGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZW1wdHkgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gYXNlYXJjaChwdHIucGFyZW50Lm5vZGVzLCBwdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IHB0ci5wYXJlbnQubGVhdmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZW1wdHkgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwdHIvaW5kZXggbm93IHBvaW50cyBhdCBvdXIgZmlyc3QgcmVzdWx0XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXhLZXkgIT09IG51bGwgJiYgY29tcGFyZShwdHIubGVhdmVzW2luZGV4XS5rZXksIG1heEtleSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBrZXlzIGxlc3MgdGhhbiBtYXhLZXlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHB0ci5sZWF2ZXNbaW5kZXhdLmtleSwgcHRyLmxlYXZlc1tpbmRleF0udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBpZiB0aGUgdXNlciBleHBsaWNpdGx5IGJyZWFrcyB0aGUgbG9vcCBieSByZXR1cm5pbmcgdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHRyLm5vZGVzW2luZGV4ICsgMV0gIT09IG51bGwpIHsgLy8gRGVzY2VuZFxuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHRyLm5vZGVzWzBdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHB0ci5sZWF2ZXMubGVuZ3RoID4gaW5kZXggKyAxKSB7IC8vIE5leHRcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBBc2NlbmRcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwdHIucGFyZW50IGluc3RhbmNlb2YgVHJlZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLnBhcmVudC5ub2RlcywgcHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGluZGV4ID49IHB0ci5sZWF2ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWFzIG9mIHtAbGluayBUcmVlI3dhbGtBc2N9LlxuICAgICAgICAgKiBAcGFyYW0geyp8ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKX0gbWluS2V5IElmIG9taXR0ZWQgb3IgTlVMTCwgc3RhcnRzIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICogQHBhcmFtIHsoKnwoZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKSkpPX0gbWF4S2V5IElmIG9taXR0ZWQgb3IgTlVMTCwgd2Fsa3MgdGlsbCB0aGUgZW5kXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKT19IGNhbGxiYWNrIENhbGxiYWNrIHJlY2VpdmluZyB0aGUga2V5IGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBhcyBpdHNcbiAgICAgICAgICogIHBhcmFtZXRlcnMuIE1heSBleHBsaWNpdGx5IHJldHVybiB0cnVlIHRvIHN0b3AgdGhlIGxvb3AuXG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIFRyZWUucHJvdG90eXBlLndhbGsgPSBUcmVlLnByb3RvdHlwZS53YWxrQXNjO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXYWxrcyB0aHJvdWdoIGFsbCBrZXlzIFttaW5LZXksIC4uLiwgbWF4S2V5XSBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAgICAgKiBAcGFyYW0geyp8ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKX0gbWluS2V5IElmIG9taXR0ZWQgb3IgbnVsbCwgd2Fsa3MgdGlsbCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAqIEBwYXJhbSB7KCp8ZnVuY3Rpb24oKiwgKik6KGJvb2xlYW58dW5kZWZpbmVkKSk9fSBtYXhLZXkgSWYgb21pdHRlZCBvciBudWxsLCBzdGFydHMgYXQgdGhlIGVuZFxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCosICopOihib29sZWFufHVuZGVmaW5lZCk9fSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmcgdGhlIGtleSBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgYXMgaXRzXG4gICAgICAgICAqICBwYXJhbWV0ZXJzLiBNYXkgZXhwbGljaXRseSByZXR1cm4gdHJ1ZSB0byBzdG9wIHRoZSBsb29wLlxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlLnByb3RvdHlwZS53YWxrRGVzYyA9IGZ1bmN0aW9uIChtaW5LZXksIG1heEtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWluS2V5ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG1pbktleTtcbiAgICAgICAgICAgICAgICBtaW5LZXkgPSBtYXhLZXkgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWF4S2V5ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG1heEtleTtcbiAgICAgICAgICAgICAgICBtYXhLZXkgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWluS2V5ID0gdHlwZW9mIG1pbktleSAhPSAndW5kZWZpbmVkJyA/IG1pbktleSA6IG51bGw7XG4gICAgICAgICAgICBtYXhLZXkgPSB0eXBlb2YgbWF4S2V5ICE9ICd1bmRlZmluZWQnID8gbWF4S2V5IDogbnVsbDtcbiAgICAgICAgICAgIHZhciBwdHIsIGluZGV4O1xuICAgICAgICAgICAgaWYgKG1heEtleSA9PT0gbnVsbCkgeyAvLyBJZiB0aGVyZSBpcyBubyBtYXhpbXVtIGxpbWl0XG4gICAgICAgICAgICAgICAgcHRyID0gdGhpcy5yb290OyAvLyBzZXQgcHRyIHRvIHRoZSBvdXRlciByaWdodCBub2RlXG4gICAgICAgICAgICAgICAgd2hpbGUgKHB0ci5ub2Rlc1twdHIubm9kZXMubGVuZ3RoIC0gMV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLm5vZGVzW3B0ci5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSBwdHIubGVhdmVzLmxlbmd0aCAtIDE7IC8vIGFuZCBzdGFydCBhdCBpdHMgbGFzdCBsZWFmXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBFbHNlIGxvb2t1cFxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJvb3Quc2VhcmNoKG1heEtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZWFmKSB7IC8vIElmIHRoZSBtYXhpbXVtIGtleSBpdHNlbGYgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHJlc3VsdC5sZWFmLnBhcmVudDsgLy8gc2V0IHB0ciB0byB0aGUgY29udGFpbmluZyBub2RlXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gYXNlYXJjaChwdHIubGVhdmVzLCByZXN1bHQubGVhZik7IC8vIGFuZCBzdGFydCBhdCBpdHMgaW5kZXhcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBJZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0XG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHJlc3VsdC5ub2RlOyAvLyBzZXQgcHRyIHRvIHRoZSBpbnNlcnRpb24gbm9kZVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3VsdC5pbmRleCAtIDE7IC8vIGFuZCBzdGFydCBhdCB0aGUgaW5zZXJ0aW9uIGluZGV4LTEgKGtleSA8IG1heEtleSlcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgMCkgeyAvLyBvbiB1bmRlcnJ1biwgYmVnaW4gYXQgdGhlIHNlcGFyYXRvciBpbiB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHRyLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGVtcHR5IHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGFzZWFyY2gocHRyLnBhcmVudC5ub2RlcywgcHRyKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlbXB0eSByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHB0ci9pbmRleCBub3cgcG9pbnRzIGF0IG91ciBmaXJzdCByZXN1bHRcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbktleSAhPT0gbnVsbCAmJiBjb21wYXJlKHB0ci5sZWF2ZXNbaW5kZXhdLmtleSwgbWluS2V5KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGtleXMgYmlnZ2VyIHRoYW4gbWluS2V5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhwdHIubGVhdmVzW2luZGV4XS5rZXksIHB0ci5sZWF2ZXNbaW5kZXhdLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gaWYgdGhlIHVzZXIgZXhwbGljaXRseSBicmVha3MgdGhlIGxvb3AgYnkgcmV0dXJuaW5nIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHB0ci5ub2Rlc1tpbmRleF0gIT09IG51bGwpIHsgLy8gRGVzY2VuZFxuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIubm9kZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHRyLm5vZGVzW3B0ci5ub2Rlcy5sZW5ndGggLSAxXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLm5vZGVzW3B0ci5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHB0ci5sZWF2ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID4gMCkgeyAvLyBOZXh0XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gQXNjZW5kXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHRyLnBhcmVudCBpbnN0YW5jZW9mIFRyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBhc2VhcmNoKHB0ci5wYXJlbnQubm9kZXMsIHB0cikgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoaW5kZXggPCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGtleXMgYmV0d2VlbiBtaW5LZXkgYW5kIG1heEtleSAoYm90aCBpbmNsdXNpdmUpLlxuICAgICAgICAgKiBAcGFyYW0geyo9fSBtaW5LZXkgSWYgb21pdHRlZCwgY291bnRzIGZyb20gdGhlIHN0YXJ0XG4gICAgICAgICAqIEBwYXJhbSB7Kj19IG1heEtleSBJZiBvbWl0dGVkLCBjb3VudHMgdGlsbCB0aGUgZW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAqIEBleHBvc2VcbiAgICAgICAgICovXG4gICAgICAgIFRyZWUucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKG1pbktleSwgbWF4S2V5KSB7XG4gICAgICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgICAgICB0aGlzLndhbGsoXG4gICAgICAgICAgICAgICAgdHlwZW9mIG1pbktleSAhPSAndW5kZWZpbmVkJyA/IG1pbktleSA6IG51bGwsXG4gICAgICAgICAgICAgICAgdHlwZW9mIG1heEtleSAhPSAndW5kZWZpbmVkJyA/IG1heEtleSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHsgbisrOyB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaW50cyBvdXQgYWxsIG5vZGVzIGluIHRoZSB0cmVlLlxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICBUcmVlLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5wcmludCgwKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGluc3RhbmNlLlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgVHJlZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUcmVlKFwiICsgb3JkZXIgKyBcIikgXCIgKyB0aGlzLnJvb3QudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gVHJlZTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBidHJlZTtcblxufSkobW9kdWxlLCBjb25zb2xlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TZWFyY2gvQlRyZWUuanMiLCIvKlxuIOaKmOWNiuafpeaJvihCaW5hcnkgU2VhcmNoKVxuXG4g5oqY5Y2K5p+l5om+5Y+I56ew5Li65LqM5YiG5p+l5om+77yM5piv5LiA56eN5pWI546H6L6D6auY55qE5p+l5om+5pa55rOV44CCXG4g5YmN5o+Q5p2h5Lu277ya5p+l5om+6KGo5Lit55qE5omA5pyJ6K6w5b2V5piv5oyJ5YWz6ZSu5a2X5pyJ5bqPKOWNh+W6j+aIlumZjeW6jykg44CCXG4g5p+l5om+6L+H56iL5Lit77yM5YWI56Gu5a6a5b6F5p+l5om+6K6w5b2V5Zyo6KGo5Lit55qE6IyD5Zu077yM54S25ZCO6YCQ5q2l57yp5bCP6IyD5Zu0KOavj+asoeWwhuW+heafpeiusOW9leaJgOWcqOWMuumXtOe8qeWwj+S4gOWNiinvvIznm7TliLDmib7liLDmiJbmib7kuI3liLDorrDlvZXkuLrmraLjgIJcblxuIDEgIOafpeaJvuaAneaDs1xuIOeUqExvd+OAgUhpZ2jlkoxNaWTooajnpLrlvoXmn6Xmib7ljLrpl7TnmoTkuIvnlYzjgIHkuIrnlYzlkozkuK3pl7TkvY3nva7mjIfpkojvvIzliJ3lgLzkuLpMb3c9MO+8jEhpZ2g9biAtIDHjgIJcbiDikbQgIOWPluS4remXtOS9jee9rk1pZO+8mk1pZD1NYXRoLmZsb29yKChMb3crSGlnaCkvMinvvJtcbiDikbUgIOavlOi+g+S4remXtOS9jee9ruiusOW9leeahOWFs+mUruWtl+S4jue7meWumueahEvlgLzvvJpcbiDikaAgIOebuOetie+8miDmn6Xmib7miJDlip/vvJtcbiDikaEgIOWkp+S6ju+8muW+heafpeiusOW9leWcqOWMuumXtOeahOWJjeWNiuaute+8jOS/ruaUueS4iueVjOaMh+mSiO+8miBIaWdoPU1pZC0x77yM6L2s4pG0IO+8m1xuIOKRoiAg5bCP5LqO77ya5b6F5p+l6K6w5b2V5Zyo5Yy66Ze055qE5ZCO5Y2K5q6177yM5L+u5pS55LiL55WM5oyH6ZKI77yaTG93PU1pZCsx77yM6L2s4pG0IO+8m1xuIOebtOWIsOi2iueVjChMb3c+SGlnaCnvvIzmn6Xmib7lpLHotKXjgIJcblxuIDIgIOeul+azleWIhuaekFxuIOKRoCAg5p+l5om+5pe25q+P57uP6L+H5LiA5qyh5q+U6L6D77yM5p+l5om+6IyD5Zu05bCx57yp5bCP5LiA5Y2K77yM6K+l6L+H56iL5Y+v55So5LiA5qO15LqM5Y+J5qCR6KGo56S677yaXG4g4peGIOaguee7k+eCueWwseaYr+esrOS4gOasoei/m+ihjOavlOi+g+eahOS4remXtOS9jee9rueahOiusOW9le+8m1xuIOKXhiDmjpLlnKjkuK3pl7TkvY3nva7liY3pnaLnmoTkvZzkuLrlt6blrZDmoJHnmoTnu5PngrnvvJtcbiDil4Yg5o6S5Zyo5Lit6Ze05L2N572u5ZCO6Z2i55qE5L2c5Li65Y+z5a2Q5qCR55qE57uT54K577ybXG4g5a+55ZCE5a2Q5qCR5p2l6K+06YO95piv55u45ZCM55qE44CC6L+Z5qC35omA5b6X5Yiw55qE5LqM5Y+J5qCR56ew5Li65Yik5a6a5qCRKERlY2lzaW9uIFRyZWUp44CCXG4g4pGhICDlsIbkuozlj4nliKTlrprmoJHnmoTnrKxNYXRoLmZsb29yKE1hdGgubG9nKDIsIG4pKSsx5bGC5LiK55qE57uT54K56KGl6b2Q5bCx5oiQ5Li65LiA5qO15ruh5LqM5Y+J5qCR77yM5rex5bqm5LiN5Y+Y77yMaD0gTWF0aC5mbG9vcihNYXRoLmxvZygyLCBuICsgMSkpIOOAglxuIOKRoiAg55Sx5ruh5LqM5Y+J5qCR5oCn6LSo55+l77yM56ysaSDlsYLkuIrnmoTnu5PngrnmlbDkuLpNYXRoLnBvdygyLCBpLTEpKGk8PWgpIO+8jOiuvuihqOS4reavj+S4quiusOW9leeahOafpeaJvuamgueOh+ebuOetie+8jOWNs1BpPTEvbu+8jOafpeaJvuaIkOWKn+aXtueahOW5s+Wdh+afpeaJvumVv+W6pkFTTO+8mlxuIChuKzEpL24qTWF0aC5sb2coMixuKzEpLTFcbiDlvZNu5b6I5aSnIChuPjUwKeaXtu+8jCBBU0ziiYggTWF0aC5sb2coMixuKzEpLTHjgIJcblxuXG4g5pe26Ze05aSN5p2C5bqmTyhsb2duKVxuICovXG5cbi8vIOmdnumAkuW9kuW8j1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaChzVGFibGUsIGtleSkge1xuICAgIGxldCBsb3cgPSAwO1xuICAgIGxldCBoaWdoID0gc1RhYmxlLmxlbmd0aCAtIDE7XG5cbiAgICB3aGlsZShsb3cgPD0gaGlnaCl7XG4gICAgICAgIGxldCAgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XG4gICAgICAgIGxldCBlbGVtID0gc1RhYmxlW21pZF07XG5cbiAgICAgICAgaWYoZWxlbSA9PT0ga2V5KSByZXR1cm4gbWlkO1xuICAgICAgICBlbHNlIGlmKGVsZW0gPCBrZXkpIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIGVsc2UgaGlnaCA9IG1pZCAtIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufVxuXG5jb25zb2xlLmxvZygnYmluYXJ5U2VhcmNoOiAnKTtcbmNvbnNvbGUubG9nKGJpbmFyeVNlYXJjaChbMSwgMiwgMywgNCwgNV0sIDEpKTsgIC8vIDBcblxuLy8g6YCS5b2S5byPXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoUmVjdXJzaXZlKHNUYWJsZSwga2V5LCBsb3cgPSAwLCBoaWdoID0gc1RhYmxlLmxlbmd0aCAtIDEpIHtcbiAgICBpZihsb3cgPiBoaWdoKSByZXR1cm4gLTE7XG5cbiAgICBsZXQgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XG4gICAgbGV0IGVsZW0gPSBzVGFibGVbbWlkXTtcblxuICAgIGlmKGVsZW0gPT09IGtleSkgcmV0dXJuIG1pZDtcbiAgICBlbHNlIGlmKGVsZW0gPCBrZXkpIHJldHVybiBiaW5hcnlTZWFyY2hSZWN1cnNpdmUoc1RhYmxlLCBrZXksIG1pZCArIDEsIGhpZ2gpO1xuICAgIGVsc2UgcmV0dXJuIGJpbmFyeVNlYXJjaFJlY3Vyc2l2ZShzVGFibGUsIGtleSwgbG93LCBtaWQgLSAxKTtcbn1cblxuY29uc29sZS5sb2coJ2JpbmFyeVNlYXJjaFJlY3Vyc2l2ZTogJyk7XG5jb25zb2xlLmxvZyhiaW5hcnlTZWFyY2hSZWN1cnNpdmUoWzEsIDIsIDMsIDQsIDVdLCAxKSk7IC8vIDBcbmNvbnNvbGUubG9nKGJpbmFyeVNlYXJjaFJlY3Vyc2l2ZShbMSwgMiwgMywgNCwgNV0sIDYpKTsgLy8gLTFcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TZWFyY2gvQmluYXJ5U2VhcmNoLmpzIiwiLypcbiBCbG9vbSBGaWx0ZXLmmK/kuIDnp43nqbrpl7TmlYjnjoflvojpq5jnmoTpmo/mnLrmlbDmja7nu5PmnoTvvIzlroPliKnnlKjkvY3mlbDnu4TlvojnroDmtIHlnLDooajnpLrkuIDkuKrpm4blkIjvvIzlubbog73liKTmlq3kuIDkuKrlhYPntKDmmK/lkKblsZ7kuo7ov5nkuKrpm4blkIjjgIJCbG9vbSBGaWx0ZXLnmoTov5nnp43pq5jmlYjmmK/mnInkuIDlrprku6Pku7fnmoTvvJrlnKjliKTmlq3kuIDkuKrlhYPntKDmmK/lkKblsZ7kuo7mn5DkuKrpm4blkIjml7bvvIzmnInlj6/og73kvJrmiorkuI3lsZ7kuo7ov5nkuKrpm4blkIjnmoTlhYPntKDor6/orqTkuLrlsZ7kuo7ov5nkuKrpm4blkIjvvIhmYWxzZSBwb3NpdGl2Ze+8ieOAguWboOatpO+8jEJsb29tIEZpbHRlcuS4jemAguWQiOmCo+S6m+KAnOmbtumUmeivr+KAneeahOW6lOeUqOWcuuWQiOOAguiAjOWcqOiDveWuueW/jeS9jumUmeivr+eOh+eahOW6lOeUqOWcuuWQiOS4i++8jEJsb29tIEZpbHRlcumAmui/h+aegeWwkeeahOmUmeivr+aNouWPluS6huWtmOWCqOepuumXtOeahOaegeWkp+iKguecgeOAglxuXG4g5Li65LqG6ZmN5L2O5Yay56qB55qE5qaC5b+177yMQmxvb20gRmlsdGVy5L2/55So5LqG5aSa5Liq5ZOI5biM5Ye95pWw77yM6ICM5LiN5piv5LiA5Liq44CCXG5cbiBCbG9vbSBGaWx0ZXLnrpfms5XlpoLkuIvvvJpcbiDliJvlu7rkuIDkuKpt5L2NQml0U2V077yM5YWI5bCG5omA5pyJ5L2N5Yid5aeL5YyW5Li6MO+8jOeEtuWQjumAieaLqWvkuKrkuI3lkIznmoTlk4jluIzlh73mlbDjgILnrKxp5Liq5ZOI5biM5Ye95pWw5a+55a2X56ym5Liyc3Ry5ZOI5biM55qE57uT5p6c6K6w5Li6aO+8iGnvvIxzdHLvvInvvIzkuJRo77yIae+8jHN0cu+8ieeahOiMg+WbtOaYrzDliLBtLTEg44CCXG5cbiAoMSkg5Yqg5YWl5a2X56ym5Liy6L+H56iLXG4g5LiL6Z2i5piv5q+P5Liq5a2X56ym5Liy5aSE55CG55qE6L+H56iL77yM6aaW5YWI5piv5bCG5a2X56ym5Liyc3Ry4oCc6K6w5b2V4oCd5YiwQml0U2V05Lit55qE6L+H56iL77yaXG4g5a+55LqO5a2X56ym5Liyc3Ry77yM5YiG5Yir6K6h566XaO+8iDHvvIxzdHLvvInvvIxo77yIMu+8jHN0cu+8ieKApuKApiBo77yIa++8jHN0cu+8ieOAgueEtuWQjuWwhkJpdFNldOeahOesrGjvvIgx77yMc3Ry77yJ44CBaO+8iDLvvIxzdHLvvInigKbigKYgaO+8iGvvvIxzdHLvvInkvY3orr7kuLox44CCXG5cbiAoMikg5qOA5p+l5a2X56ym5Liy5piv5ZCm5a2Y5Zyo55qE6L+H56iLXG4g5LiL6Z2i5piv5qOA5p+l5a2X56ym5Liyc3Ry5piv5ZCm6KKrQml0U2V06K6w5b2V6L+H55qE6L+H56iL77yaXG4g5a+55LqO5a2X56ym5Liyc3Ry77yM5YiG5Yir6K6h566XaO+8iDHvvIxzdHLvvInvvIxo77yIMu+8jHN0cu+8ieKApuKApiBo77yIa++8jHN0cu+8ieOAgueEtuWQjuajgOafpUJpdFNldOeahOesrGjvvIgx77yMc3Ry77yJ44CBaO+8iDLvvIxzdHLvvInigKbigKYgaO+8iGvvvIxzdHLvvInkvY3mmK/lkKbkuLox77yM6Iul5YW25Lit5Lu75L2V5LiA5L2N5LiN5Li6MeWImeWPr+S7peWIpOWumnN0cuS4gOWumuayoeacieiiq+iusOW9lei/h+OAguiLpeWFqOmDqOS9jemDveaYrzHvvIzliJnigJzorqTkuLrigJ3lrZfnrKbkuLJzdHLlrZjlnKjjgIJcbiDoi6XkuIDkuKrlrZfnrKbkuLLlr7nlupTnmoRCaXTkuI3lhajkuLox77yM5YiZ5Y+v5Lul6IKv5a6a6K+l5a2X56ym5Liy5LiA5a6a5rKh5pyJ6KKrQmxvb20gRmlsdGVy6K6w5b2V6L+H44CC77yI6L+Z5piv5pi+54S255qE77yM5Zug5Li65a2X56ym5Liy6KKr6K6w5b2V6L+H77yM5YW25a+55bqU55qE5LqM6L+b5Yi25L2N6IKv5a6a5YWo6YOo6KKr6K6+5Li6MeS6hu+8iVxuIOOAgOS9huaYr+iLpeS4gOS4quWtl+espuS4suWvueW6lOeahEJpdOWFqOS4ujHvvIzlrp7pmYXkuIrmmK/kuI3og70xMDAl55qE6IKv5a6a6K+l5a2X56ym5Liy6KKrQmxvb20gRmlsdGVy6K6w5b2V6L+H55qE44CC77yI5Zug5Li65pyJ5Y+v6IO96K+l5a2X56ym5Liy55qE5omA5pyJ5L2N6YO95Yia5aW95piv6KKr5YW25LuW5a2X56ym5Liy5omA5a+55bqU77yJ6L+Z56eN5bCG6K+l5a2X56ym5Liy5YiS5YiG6ZSZ55qE5oOF5Ya177yM56ew5Li6ZmFsc2UgcG9zaXRpdmXjgIJcblxuICgzKSDliKDpmaTlrZfnrKbkuLLov4fnqItcbiDlrZfnrKbkuLLliqDlhaXkuoblsLHooqvkuI3og73liKDpmaTkuobvvIzlm6DkuLrliKDpmaTkvJrlvbHlk43liLDlhbbku5blrZfnrKbkuLLjgILlrp7lnKjpnIDopoHliKDpmaTlrZfnrKbkuLLnmoTlj6/ku6Xkvb/nlKhDb3VudGluZyBibG9vbWZpbHRlcihDQkYp77yM6L+Z5piv5LiA56eN5Z+65pysQmxvb20gRmlsdGVy55qE5Y+Y5L2T77yMQ0JG5bCG5Z+65pysQmxvb20gRmlsdGVy5q+P5LiA5LiqQml05pS55Li65LiA5Liq6K6h5pWw5Zmo77yM6L+Z5qC35bCx5Y+v5Lul5a6e546w5Yig6Zmk5a2X56ym5Liy55qE5Yqf6IO95LqG44CCXG5cbiBCbG9vbSBGaWx0ZXLot5/ljZXlk4jluIzlh73mlbBCaXQtTWFw5LiN5ZCM5LmL5aSE5Zyo5LqO77yaQmxvb20gRmlsdGVy5L2/55So5LqGa+S4quWTiOW4jOWHveaVsO+8jOavj+S4quWtl+espuS4sui3n2vkuKpiaXTlr7nlupTjgILku47ogIzpmY3kvY7kuoblhrLnqoHnmoTmpoLnjofjgIJcblxuIEJsb29tIEZpbHRlcuWPguaVsOmAieaLqVxuICgxKeWTiOW4jOWHveaVsOmAieaLqVxuIOOAgOOAgOWTiOW4jOWHveaVsOeahOmAieaLqeWvueaAp+iDveeahOW9seWTjeW6lOivpeaYr+W+iOWkp+eahO+8jOS4gOS4quWlveeahOWTiOW4jOWHveaVsOimgeiDvei/keS8vOetieamgueOh+eahOWwhuWtl+espuS4suaYoOWwhOWIsOWQhOS4qkJpdOOAgumAieaLqWvkuKrkuI3lkIznmoTlk4jluIzlh73mlbDmr5TovoPpurvng6bvvIzkuIDnp43nroDljZXnmoTmlrnms5XmmK/pgInmi6nkuIDkuKrlk4jluIzlh73mlbDvvIznhLblkI7pgIHlhaVr5Liq5LiN5ZCM55qE5Y+C5pWw44CCXG5cbiAoMikgbSxuLGvlgLzvvIzmiJHku6zlpoLkvZXlj5blgLxcbiDmiJHku6zlrprkuYnvvJpcbiDlj6/og73miorkuI3lsZ7kuo7ov5nkuKrpm4blkIjnmoTlhYPntKDor6/orqTkuLrlsZ7kuo7ov5nkuKrpm4blkIjvvIhGYWxzZSBQb3NpdGl2Ze+8iVxuIOS4jeS8muaKiuWxnuS6jui/meS4qumbhuWQiOeahOWFg+e0oOivr+iupOS4uuS4jeWxnuS6jui/meS4qumbhuWQiO+8iEZhbHNlIE5lZ2F0aXZl77yJ44CCXG5cbiDlk4jluIzlh73mlbDnmoTkuKrmlbBr44CB5L2N5pWw57uE5aSn5bCPbeOAgeWKoOWFpeeahOWtl+espuS4suaVsOmHj27nmoTlhbPns7vjgILlk4jluIzlh73mlbDkuKrmlbBr5Y+WMTDvvIzkvY3mlbDnu4TlpKflsI9t6K6+5Li65a2X56ym5Liy5Liq5pWwbueahDIw5YCN5pe277yMZmFsc2UgcG9zaXRpdmXlj5HnlJ/nmoTmpoLnjofmmK8wLjAwMDA4ODkg77yM5Y2zMTDkuIfmrKHnmoTliKTmlq3kuK3vvIzkvJrlrZjlnKg55qyh6K+v5Yik77yM5a+55LqO5LiA5aSpMeS6v+asoeeahOafpeivou+8jOivr+WIpOeahOasoeaVsOS4ujkwMDDmrKHjgIJcblxuIEJsb29tZmlsdGVyIOeahOW6lOeUqOWcuuaZr1xuIDEu6buR5ZCN5Y2VXG4g5pyA5YW45Z6L55qE5LiA5Liq5bqU55So5bCx5piv6buR5ZCN5Y2V5Yqf6IO977yM5a+555So5oi35ZCN56ew5oiW6ICFSVDmiJbogIVFbWFpbOi/m+ihjOi/h+a7pO+8jOavj+asoeajgOafpeaXtueUqGtleei/m+ihjGhhc2jlkI7vvIzlpoLmnpzkuI3lnKjpu5HlkI3ljZXlhoXnmoTvvIzogq/lrprlj6/ku6XpgJrooYzvvIzlpoLmnpzlnKjnmoTliJnkuI3lhYHorrjpgJrov4fvvIzor6/liKTmg4XlhrXlop7liqDkuIDkuKrmjpLpmaTlkI3ljZXmnaXov5vooYzmjpLpmaTjgIJcbiDor6/liKTmg4XlhrXvvJrlsIbmraPluLjnlKjmiLfliKTlrprkuLrpu5HlkI3ljZXnlKjmiLdcblxuIDIu54is6Jmr6YeN5aSNVVJM5qOA5rWLXG4g5Zyo54is5Y+W572R56uZVVJM5pe277yM6KaB5qOA5rWL6L+Z5p2hVVJM5piv5ZCm5bey57uP6K6/6Zeu6L+H44CCXG4g6K+v5Yik5oOF5Ya177ya5rKh5pyJ6K6/6Zeu6L+H55qE6K+v5Yik5Li66K6/6Zeu6L+HXG5cbiAzLuWtl+WFuOe6oOmUmVxuIOajgOafpeWNleivjeaLvOWGmeaYr+WQpuato+ehrlxuIOivr+WIpOaDheWGte+8mumUmeivr+eahOWNleivjeivr+WIpOS4uuato+ehruOAglxuXG4gNC7no4Hnm5jmlofku7bmo4DmtYtcbiDlsIbno4Hnm5jkuK3miJbogIXmlbDmja7lupPkuK3mlbDmja5rZXnlrZjlhaXor6Xnu5PmnoTkuK3vvIzmo4DmtYvopoHorr/pl67nmoTmlbDmja7mmK/lkKblnKjno4Hnm5jmiJbmlbDmja7lupPkuK3vvIznhLblkI7lho3lj5Hotbforr/pl67vvIzpgb/lhY3nqbrmn6Xor6LpgKDmiJDno4Hnm5jmiJbmlbDmja7lupPljovlipvjgIJcbiDor6/liKTmg4XlhrXvvJrkuI3lrZjlnKjor6XmlbDmja7ljbTor6/liKTkuLrmnInor6XmlbDmja7jgIJcblxuIDUuQ0RO77yIc3F1aWTvvInku6PnkIbnvJPlrZjmioDmnK9cbiDlhYjmn6Xmib7mnKzlnLDmnInml6BjYWNoZe+8jOWmguaenOayoeacieWImeWIsOWFtuS7luWFhOW8nyBjYWNoZeacjeWKoeWZqOS4iuWOu+afpeaJvuOAguS4uuS6humBv+WFjeaXoOiwk+eahOafpeivou+8jOWcqOavj+S4qmNhY2hl5pyN5Yqh5Zmo5LiK5L+d5a2Y5YW25YWE5byf5pyN5Yqh5Zmo55qE57yT5a2Y5YWz6ZSu5a2X77yM5LulYmxvb21maWx0ZXLmlrnlvI/lrZjlgqjvvIzlho3ljrvlhbbku5ZjYWNoZeacjeWKoeWZqOafpeaJvuS5i+WJje+8jOWFiOajgOafpeivpee7k+aehOaYr+WQpuaciXVybO+8jOWmguaenOacieWtmOWcqHVybO+8jOWGjeWOu+WvueW6lOacjeWKoeWZqOafpeaJvuOAglxuIOivr+WIpOaDheWGte+8miDlr7nlupTmnI3liqHlmajkuI3lrZjlnKjor6VVUkznmoTnvJPlrZjjgIJcblxuIFRoYW5rcyB0bzpcbiBodHRwOi8vYWxsZW5raW02Ny5naXRodWIuaW8vMjAxNi8wNS8xNy9ub2RlanMtYnVmZmVyLXR1dG9yaWFsLmh0bWxcbiBodHRwczovL2dpdGh1Yi5jb20vY2VlamJvdC94eC1ibG9vbVxuIGh0dHBzOi8vZ2l0aHViLmNvbS9waWVycmVjL2pzLXh4aGFzaFxuICovXG5cbmltcG9ydCB7IGgzMiBhcyB4eGhhc2ggfSBmcm9tICd4eGhhc2hqcyc7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9ICBmcm9tICdjcnlwdG8nO1xuXG5jb25zdCBMTjJfU1FVQVJFRCA9IE1hdGguTE4yICogTWF0aC5MTjI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmxvb21GaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpbml0KG9wdGlvbnMpe1xuICAgICAgICBpZihvcHRpb25zLnNlZWRzKXtcbiAgICAgICAgICAgIHRoaXMuc2VlZHMgPSBvcHRpb25zLnNlZWRzO1xuICAgICAgICAgICAgdGhpcy5oYXNoZXMgPSBvcHRpb25zLnNlZWRzLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VlZHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaGFzaGVzID0gb3B0aW9ucy5oYXNoZXMgfHwgMDtcblxuICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVTZWVkcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iaXRzID0gb3B0aW9ucy5iaXRzIHx8IDEwMjQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jKE1hdGguY2VpbCh0aGlzLmJpdHMgLyA4KSk7XG5cbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH1cblxuICAgIHN0YXRpYyBvcHRpbWl6ZShpdGVtQ291bnQsIGVycm9yUmF0ZSA9IDAuMDA1KXtcbiAgICAgICAgbGV0IGJpdHMgPSBNYXRoLnJvdW5kKC0xICogaXRlbUNvdW50ICogTWF0aC5sb2coZXJyb3JSYXRlKSAvIExOMl9TUVVBUkVEKTtcbiAgICAgICAgbGV0IGhhc2hlcyA9IE1hdGgucm91bmQoKGJpdHMgLyBpdGVtQ291bnQpICogTWF0aC5MTjIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiaXRzLFxuICAgICAgICAgICAgaGFzaGVzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZU9wdGltYWwoaXRlbUNvdW50LCBlcnJvclJhdGUpe1xuICAgICAgICBsZXQgb3B0cyA9IHRoaXMub3B0aW1pemUoaXRlbUNvdW50LCBlcnJvclJhdGUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhvcHRzKTtcbiAgICB9XG5cbiAgICBjbGVhcigpe1xuICAgICAgICAvLyAgYnVmLmZpbGwoMCkgdG8gaW5pdGlhbGl6ZSBhIEJ1ZmZlciB0byB6ZXJvZXNcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG5cbiAgICBfZ2VuZXJhdGVTZWVkcygpe1xuICAgICAgICBpZighdGhpcy5zZWVkcykgdGhpcy5zZWVkcyA9IFtdO1xuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmhhc2hlczsgKytpKXtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlcyBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcgcHNldWRvLXJhbmRvbSBkYXRhLiBHZW5lcmF0ZSA0IGJ5dGVzLlxuICAgICAgICAgICAgbGV0IGJ1ZiA9IHJhbmRvbUJ5dGVzKDQpO1xuICAgICAgICAgICAgLy8gUmVhZHMgYW4gdW5zaWduZWQgMzItYml0IGludGVnZXIgZnJvbSB0aGUgQnVmZmVyIGZyb20gaW5kZXggMFxuICAgICAgICAgICAgdGhpcy5zZWVkc1tpXSA9IGJ1Zi5yZWFkVUludDMyTEUoMCk7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBlbmQgdXAgd2l0aCB0d28gaWRlbnRpY2FsIHNlZWRzLFxuICAgICAgICAgICAgLy8gd2hpY2ggaXMgdW5saWtlbHkgYnV0IHBvc3NpYmxlLlxuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IGk7ICsrail7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5zZWVkc1tpXSA9PT0gdGhpcy5zZWVkc1tqXSl7XG4gICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkKGJ1Zikge1xuICAgICAgICBpZihBcnJheS5pc0FycmF5KGJ1Zikpe1xuICAgICAgICAgICAgZm9yKGxldCBpdGVtIG9mIGJ1Zil7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpO1xuXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5oYXNoZXM7ICsraSl7XG4gICAgICAgICAgICAgICAgbGV0IGhhc2ggPSB4eGhhc2goYnVmLCB0aGlzLnNlZWRzW2ldKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGxldCBiaXQgPSBoYXNoICUgdGhpcy5iaXRzO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEJpdChiaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFzKGl0ZW0pe1xuICAgICAgICBpdGVtID0gQnVmZmVyLmZyb20oaXRlbSk7XG5cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuaGFzaGVzOyArK2kpe1xuICAgICAgICAgICAgbGV0IGhhc2ggPSB4eGhhc2goaXRlbSwgdGhpcy5zZWVkc1tpXSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBiaXQgPSBoYXNoICUgdGhpcy5iaXRzO1xuXG4gICAgICAgICAgICBsZXQgaXNJblNldCA9IHRoaXMuX2dldEJpdChiaXQpO1xuICAgICAgICAgICAgaWYoIWlzSW5TZXQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIF9zZXRCaXQoYml0KXtcbiAgICAgICAgbGV0IHBvcyA9IE1hdGguZmxvb3IoYml0IC8gOCk7XG4gICAgICAgIGxldCBzaGlmdCA9IGJpdCAlIDg7XG5cbiAgICAgICAgbGV0IGJpdEZpZWxkID0gdGhpcy5idWZmZXJbcG9zXTtcbiAgICAgICAgYml0RmllbGQgfD0gKDB4MSA8PCBzaGlmdCk7XG4gICAgICAgIHRoaXMuYnVmZmVyW3Bvc10gPSBiaXRGaWVsZDtcbiAgICB9XG5cbiAgICBfZ2V0Qml0KGJpdCl7XG4gICAgICAgIGxldCBwb3MgPSBNYXRoLmZsb29yKGJpdCAvIDgpO1xuICAgICAgICBsZXQgc2hpZnQgPSBiaXQgJSA4O1xuXG4gICAgICAgIGxldCBiaXRGaWVsZCA9IHRoaXMuYnVmZmVyW3Bvc107XG5cbiAgICAgICAgcmV0dXJuIChiaXRGaWVsZCAmICgweDEgPDwgc2hpZnQpKSAhPT0gMDtcbiAgICB9XG59XG5cbnZhciBmaWx0ZXIgPSBuZXcgQmxvb21GaWx0ZXIoeyBoYXNoZXM6IDgsIGJpdHM6IDEwMjQgfSk7XG5maWx0ZXIuYWRkKFsnY2F0JywgJ2RvZycsICdjb2F0aScsICdyZWQgcGFuZGEnXSk7XG5jb25zb2xlLmxvZyhmaWx0ZXIuaGFzKCdjYXQnKSk7XG5jb25zb2xlLmxvZyhmaWx0ZXIuaGFzKCdjb2F0JykpO1xuY29uc29sZS5sb2coZmlsdGVyLmhhcygnbnVsbCcpKTtcblxuXG5jbGFzcyBDb3VudGluZ0Jsb29tRmlsdGVyIGV4dGVuZHMgQmxvb21GaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSl7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgIH1cblxuICAgIGluaXQob3B0cyl7XG4gICAgICAgIGlmIChvcHRzLnNlZWRzKSB7XG4gICAgICAgICAgICB0aGlzLnNlZWRzID0gb3B0cy5zZWVkcztcbiAgICAgICAgICAgIHRoaXMuaGFzaGVzID0gb3B0cy5zZWVkcy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhc2hlcyA9IG9wdHMuaGFzaGVzIHx8IDg7XG4gICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZVNlZWRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJpdHMgPSBvcHRzLmJpdHMgfHwgMTAyNDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuYWxsb2ModGhpcy5iaXRzKTtcblxuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZU9wdGltYWwoaXRlbUNvdW50LCBlcnJvclJhdGUpe1xuICAgICAgICBsZXQgb3B0cyA9IEJsb29tRmlsdGVyLm9wdGltaXplKGl0ZW1Db3VudCwgZXJyb3JSYXRlKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKG9wdHMpO1xuICAgIH1cblxuICAgIGNsZWFyKCl7XG4gICAgICAgIHN1cGVyLmNsZWFyKCk7XG5cbiAgICAgICAgdGhpcy5vdmVyZmxvdyA9IDA7XG4gICAgfVxuXG4gICAgX3NldEJpdChiaXQpe1xuICAgICAgICAvLyBuby1vcCBhdCBvdmVyZmxvd1xuICAgICAgICBpZih0aGlzLmJ1ZmZlcltiaXRdID09PSAyNTUpe1xuICAgICAgICAgICAgKyt0aGlzLm92ZXJmbG93O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgKyt0aGlzLmJ1ZmZlcltiaXRdO1xuICAgIH1cblxuICAgIF91blNldEJpdChiaXQpe1xuICAgICAgICBpZih0aGlzLmJ1ZmZlcltiaXRdID09PSAyNTUgfHwgdGhpcy5idWZmZXJbYml0XSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAtLXRoaXMuYnVmZmVyW2JpdF07XG4gICAgfVxuXG4gICAgX2dldEJpdChiaXQpe1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbYml0XSAhPT0gMDtcbiAgICB9XG5cbiAgICBnZXQgaGFzT3ZlcmZsb3dlZCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5vdmVyZmxvdyA+IDA7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGl0ZW0pe1xuICAgICAgICBpZighQnVmZmVyLmlzQnVmZmVyKGl0ZW0pKSBpdGVtID0gQnVmZmVyLmZyb20oaXRlbSk7XG5cbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuc2VlZHMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgbGV0IGhhc2ggPSB4eGhhc2goaXRlbSwgdGhpcy5zZWVkc1tpXSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBiaXQgPSBoYXNoICUgdGhpcy5iaXRzO1xuXG4gICAgICAgICAgICB0aGlzLl91blNldEJpdChiaXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc29sZS5sb2coJ0NvdW50aW5nQmxvb21GaWx0ZXInKVxudmFyIGZpbHRlciA9IG5ldyBDb3VudGluZ0Jsb29tRmlsdGVyKHsgaGFzaGVzOiA4LCBiaXRzOiAxMDI0IH0pO1xuZmlsdGVyLmFkZChbJ2NhdCcsICdkb2cnLCAnY29hdGknLCAncmVkIHBhbmRhJ10pO1xuY29uc29sZS5sb2coZmlsdGVyLmhhcygnY2F0JykpO1xuZmlsdGVyLnJlbW92ZSgnY2F0Jyk7XG5jb25zb2xlLmxvZyhmaWx0ZXIuaGFzKCdjYXQnKSk7XG5jb25zb2xlLmxvZyhmaWx0ZXIuaGFzKCdjb2F0JykpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TZWFyY2gvQmxvb21GaWx0ZXIuanMiLCIvKipcbiAqIENyZWF0ZWQgYnkgTHVrZSBvbiAyMDE1LzEvMTEuXG4gKi9cblxuLypcblxuIOWmguaenOS4gOS4quWFs+mUruWtl+WPr+S7peihqOekuuaIkOWtl+espueahOW6j+WPt++8jOWNs+Wtl+espuS4su+8jOmCo+S5iOWPr+S7peeUqOmUruagke+8iGtleXdvcmQgdHJlZe+8ie+8jOWPiOensOaVsOWtl+aQnOe0ouagke+8iGRpZ2l0YWwgc2VhcmNoIHRyZWXvvInmiJblrZfnrKbmoJHvvIzkuZ/lj6vlrZflhbjmoJHvvIzmnaXooajnpLrov5nmoLfnmoTlrZfnrKbkuLLnmoTpm4blkIjjgIJcblxuIOamguW/tVxuXG4g5aaC5p6c5LiA5Liq5YWz6ZSu5a2X5Y+v5Lul6KGo56S65oiQ5a2X56ym55qE5bqP5Y+377yM5Y2z5a2X56ym5Liy77yM6YKj5LmI5Y+v5Lul55So6ZSu5qCR77yIa2V5d29yZCB0cmVl77yJ77yM5Y+I56ew5pWw5a2X5pCc57Si5qCR77yIZGlnaXRhbCBzZWFyY2ggdHJlZe+8ieaIluWtl+espuagke+8jOadpeihqOekuui/meagt+eahOWtl+espuS4sueahOmbhuWQiOOAgumUruagkeWPiOensOS4uuaVsOWtl+afpeaJvuagke+8iERpZ2l0YWwgU2VhcmNoIFRyZWUp5oiWVHJpZeagkSh0cmll5Li6cmV0cmlldmXkuK3pl7Q05Liq5a2X56ymKe+8jOWFtue7k+aehOWPl+WQr+WPkeS6juS4gOmDqOWkp+Wei+Wtl+WFuOeahOKAnOS5pui+ueagh+ebruKAneOAguWtl+WFuOS4reagh+WHuummluWtl+avjeaYryBBLEIsQywuLi4uWueahOWNleivjeaJgOWcqOmhtSzlho3lr7nlkITpg6jliIbmoIflh7rnrKzkuozlrZfmr43kuLpBLEIsQywuLi5a55qE5Y2V6K+N5omA5Zyo55qE6aG1LCAuLi4u562J562J44CCXG5cbiDplK7moJHmmK/kuIDnp43nibnmrornmoTmn6Xmib7moJHvvIzlroPnmoTmn5DkuKroioLngrnkuI3mmK/ljIXlkKvkuIDkuKrmiJblpJrkuKrlhbPplK7lrZfvvIzogIzmmK/lj6rljIXlkKvnu4TmiJDlhbPplK7lrZfnmoTkuIDpg6jliIbvvIjlrZfnrKbmiJbmlbDlrZfvvInvvIzmr5TlpoLvvJrlpoLmnpzlhbPplK7lrZfmmK/mlbDlgLzvvIzliJnoioLngrnkuK3lj6rljIXlkKvkuIDkuKrmlbDkvY3vvJvlpoLmnpzlhbPplK7lrZfmmK/ljZXor43vvIzliJnoioLngrnkuK3lj6rljIXlkKvkuIDkuKrlrZfmr43lrZfnrKbjgIJcblxuIOaguee7k+eCueS4jeS7o+ihqOS7u+S9leWtl+espu+8jOagueS7peS4i+esrOS4gOWxgueahOe7k+eCueWvueW6lOS6juWtl+espuS4sueahOesrOS4gOS4quWtl+espu+8jOesrOS6jOWxgueahOe7k+eCueWvueW6lOS6juWtl+espuS4sueahOesrOS6jOS4quWtl+espuKApuKApuavj+S4quWtl+espuS4suWPr+eUseS4gOS4queJueauiueahOWtl+espuWmguKAnCTigJ3nrYnkvZzkuLrlrZfnrKbkuLLnmoTnu5PmnZ/nrKbvvIznlKjkuIDkuKrlj7blrZDnu5PngrnmnaXooajnpLror6XnibnmrorlrZfnrKbjgILmiorku47moLnliLDlj7blrZDnmoTot6/lvoTkuIrvvIzmiYDmnInnu5PngrnvvIjpmaTmoLnku6XlpJbvvInlr7nlupTnmoTlrZfnrKbov57mjqXotbfmnaXvvIzlsLHlvpfliLDkuIDkuKrlrZfnrKbkuLLjgILlm6DmraTvvIzmr4/kuKrlj7blrZDnu5Pngrnlr7nlupTkuIDkuKrlhbPplK7lrZfjgILlnKjlj7blrZDnu5Pngrnov5jlj6/ku6XljIXlkKvkuIDkuKrmjIfpkojvvIzmjIflkJHor6XlhbPplK7lrZfmiYDlr7nlupTnmoTlhYPntKDjgILmlbTkuKrlrZfnrKbkuLLpm4blkIjkuK3nmoTlrZfnrKbkuLLnmoTmlbDnm67nrYnkuo7lj7blrZDnu5PngrnnmoTmlbDnm67jgILlpoLmnpzkuIDkuKrpm4blkIjkuK3nmoTlhbPplK7lrZfpg73lhbfmnInov5nmoLfnmoTlrZfnrKbkuLLnibnmgKfvvIzpgqPkuYjvvIzor6XlhbPplK7lrZfpm4blkIjlsLHlj6/ph4fnlKjov5nmoLfkuIDmo7XplK7moJHmnaXooajnpLrjgILkuovlrp7kuIrvvIzov5jlj6/ku6XotYvkuojigJzlrZfnrKbkuLLigJ3mm7Tlub/ms5vnmoTlkKvkuYnvvIzlroPlj6/ku6XmmK/ku7vkvZXnsbvlnovnmoTlr7nosaHnu4TmiJDnmoTkuLLjgIJcblxuXG4g6ZSu5qCR55qE5a2Y5YKoXG4gMe+8ieWPjOmTvuagkeihqOekulxuIDIpIOWkmumHjemTvuihqOihqOekulxuXG5cbiDplK7moJHnmoTlupTnlKjlnLrmma9cblxuIFRyaWXmmK/kuIDnp43pnZ7luLjnroDljZXpq5jmlYjnmoTmlbDmja7nu5PmnoTvvIzkvYbmnInlpKfph4/nmoTlupTnlKjlrp7kvovjgIJcbiDvvIgx77yJIOWtl+espuS4suajgOe0olxuIOS6i+WFiOWwhuW3suefpeeahOS4gOS6m+Wtl+espuS4su+8iOWtl+WFuO+8ieeahOacieWFs+S/oeaBr+S/neWtmOWIsHRyaWXmoJHph4zvvIzmn6Xmib7lj6blpJbkuIDkupvmnKrnn6XlrZfnrKbkuLLmmK/lkKblh7rnjrDov4fmiJbogIXlh7rnjrDpopHnjofjgIJcbiDkuL7kvovvvJpcbiBAICDnu5nlh7pOIOS4quWNleivjee7hOaIkOeahOeGn+ivjeihqO+8jOS7peWPiuS4gOevh+WFqOeUqOWwj+WGmeiLseaWh+S5puWGmeeahOaWh+eroO+8jOivt+S9oOaMieacgOaXqeWHuueOsOeahOmhuuW6j+WGmeWHuuaJgOacieS4jeWcqOeGn+ivjeihqOS4reeahOeUn+ivjeOAglxuIEAgIOe7meWHuuS4gOS4quivjeWFuO+8jOWFtuS4reeahOWNleivjeS4uuS4jeiJr+WNleivjeOAguWNleivjeWdh+S4uuWwj+WGmeWtl+avjeOAguWGjee7meWHuuS4gOauteaWh+acrO+8jOaWh+acrOeahOavj+S4gOihjOS5n+eUseWwj+WGmeWtl+avjeaehOaIkOOAguWIpOaWreaWh+acrOS4reaYr+WQpuWQq+acieS7u+S9leS4jeiJr+WNleivjeOAguS+i+Wmgu+8jOiLpXJvYuaYr+S4jeiJr+WNleivje+8jOmCo+S5iOaWh+acrHByb2JsZW3lkKvmnInkuI3oia/ljZXor43jgIJcblxuIO+8iDLvvInlrZfnrKbkuLLmnIDplb/lhazlhbHliY3nvIBcbiBUcmll5qCR5Yip55So5aSa5Liq5a2X56ym5Liy55qE5YWs5YWx5YmN57yA5p2l6IqC55yB5a2Y5YKo56m66Ze077yM5Y+N5LmL77yM5b2T5oiR5Lus5oqK5aSn6YeP5a2X56ym5Liy5a2Y5YKo5Yiw5LiA5qO1dHJpZeagkeS4iuaXtu+8jOaIkeS7rOWPr+S7peW/q+mAn+W+l+WIsOafkOS6m+Wtl+espuS4sueahOWFrOWFseWJjee8gOOAglxuIOS4vuS+i++8mlxuIEAg57uZ5Ye6TiDkuKrlsI/lhpnoi7HmloflrZfmr43kuLLvvIzku6Xlj4pRIOS4quivoumXru+8jOWNs+ivoumXruafkOS4pOS4quS4sueahOacgOmVv+WFrOWFseWJjee8gOeahOmVv+W6puaYr+WkmuWwke+8n1xuIOino+WGs+aWueahiO+8mummluWFiOWvueaJgOacieeahOS4suW7uueri+WFtuWvueW6lOeahOWtl+avjeagkeOAguatpOaXtuWPkeeOsO+8jOWvueS6juS4pOS4quS4sueahOacgOmVv+WFrOWFseWJjee8gOeahOmVv+W6puWNs+Wug+S7rOaJgOWcqOe7k+eCueeahOWFrOWFseelluWFiOS4quaVsO+8jOS6juaYr++8jOmXrumimOWwsei9rOWMluS4uuS6huemu+e6v++8iE9mZmxpbmXvvInnmoTmnIDov5HlhazlhbHnpZblhYjvvIhMZWFzdCBDb21tb24gQW5jZXN0b3LvvIznroDnp7BMQ0HvvInpl67popjjgIJcbiDogIzmnIDov5HlhazlhbHnpZblhYjpl67popjlkIzmoLfmmK/kuIDkuKrnu4/lhbjpl67popjvvIzlj6/ku6XnlKjkuIvpnaLlh6Dnp43mlrnms5XvvJpcbiAxLiDliKnnlKjlubbmn6Xpm4bvvIhEaXNqb2ludCBTZXTvvInvvIzlj6/ku6Xph4fnlKjph4fnlKjnu4/lhbjnmoRUYXJqYW4g566X5rOV77ybXG4gMi4g5rGC5Ye65a2X5q+N5qCR55qE5qyn5ouJ5bqP5YiX77yIRXVsZXIgU2VxdWVuY2Ug77yJ5ZCO77yM5bCx5Y+v5Lul6L2s5Li657uP5YW455qE5pyA5bCP5YC85p+l6K+i77yIUmFuZ2UgTWluaW11bSBRdWVyee+8jOeugOensFJNUe+8iemXrumimOS6hu+8m1xuIO+8iOWFs+S6juW5tuafpembhu+8jFRhcmphbueul+azle+8jFJNUemXrumimO+8jOe9keS4iuacieW+iOWkmui1hOaWmeOAgu+8iVxuXG4g77yIM++8ieaOkuW6j1xuIFRyaWXmoJHmmK/kuIDmo7XlpJrlj4nmoJHvvIzlj6ropoHlhYjluo/pgY3ljobmlbTmo7XmoJHvvIzovpPlh7rnm7jlupTnmoTlrZfnrKbkuLLkvr/mmK/mjInlrZflhbjluo/mjpLluo/nmoTnu5PmnpzjgIJcbiDkuL7kvovvvJpcbiBAIOe7meS9oE4g5Liq5LqS5LiN55u45ZCM55qE5LuF55Sx5LiA5Liq5Y2V6K+N5p6E5oiQ55qE6Iux5paH5ZCN77yM6K6p5L2g5bCG5a6D5Lus5oyJ5a2X5YW45bqP5LuO5bCP5Yiw5aSn5o6S5bqP6L6T5Ye644CCXG5cbiDvvIg077yJIOS9nOS4uuWFtuS7luaVsOaNrue7k+aehOWSjOeul+azleeahOi+heWKqee7k+aehFxuIOWmguWQjue8gOagke+8jEFD6Ieq5Yqo5py6562JXG4gKi9cblxuXG4vKlxuIOWPjOmTvuagkeihqOekulxuXG4g5Lul5qCR55qE5a2p5a2Q5YWE5byf6ZO+6KGo5p2l6KGo56S66ZSu5qCR77yM5YiZ5q+P5Liq5YiG5pSv57uT54K55YyF5ous5LiJ5Liq5Z+f77yaXG4gc3ltYm9s5Z+f77ya5a2Y5YKo5YWz6ZSu5a2X55qE5LiA5Liq5a2X56ym77ybXG4gZmlyc3Tln5/vvJrlrZjlgqjmjIflkJHnrKzkuIDmo7XlrZDmoJHmoLnnmoTmjIfpkojvvJtcbiBuZXh05Z+f77ya5a2Y5YKo5oyH5ZCR5Y+z5YWE5byf55qE5oyH6ZKI44CCXG5cbiDlkIzml7bvvIzlj7blrZDnu5PngrnkuI3lkKtmaXJzdOWfn++8jOWug+eahGluZm9wdHLln5/lrZjlgqjmjIflkJHor6XlhbPplK7lrZforrDlvZXnmoTmjIfpkojjgIJcbiDmraTml7bnmoTplK7moJHlj4jnp7Dlj4zpk77moJHjgIJcbiDlnKjlj4zpk77moJHkuK3mj5LlhaXmiJbliKDpmaTkuIDkuKrlhbPplK7lrZfvvIznm7jlvZPkuo7lnKjmoJHkuK3mn5DkuKrnu5PngrnkuIrmj5LlhaXmiJbliKDpmaTkuIDmo7XlrZDmoJHjgIJcbiDnu5PngrnnmoTnu5PmnoTkuK3lj6/ku6Xorr7nva7kuIDkuKrmnprkuL7lj5jph4/ooajnpLrnu5PngrnnmoTnsbvlnovvvIzlj7blrZDnu5PngrnlkozliIbmlK/nu5PngrnjgIJcbiDlj7blrZDnu5PngrnlkozliIbmlK/nu5Pngrnpg73mnIlzeW1ib2zln5/lkoxuZXh05Z+f44CC5LiN5ZCM55qE5LiA5Liq5Z+f5Y+v5Lul55So6IGU5ZCI6KGo56S677yM5Y+25a2Q57uT54K55YyF5ZCraW5mb3B0cuaMh+WQkeiusOW9le+8jOiAjOWIhuaUr+e7k+eCueaYr2ZpcnN05Z+f5oyH5ZCR5YW256ys5LiA5qO15a2Q5qCR44CCXG5cblxuIOWPjOmTvuagkeeahOafpeaJvlxuXG4g5YGH6K6+57uZ5a6a5YC85Li6Sy5jaCgwLi5udW0tMSksIOWFtuS4rUsuY2hbMF3oh7MgSy5jaFtudW0tMl3ooajnpLrlvoXmn6XlhbPplK7lrZfkuK1udW0tMeS4quWtl+espu+8jCBLLmNoW251bS0xXeS4uue7k+adn+espiTjgIJcbiDku47lj4zpk77moJHnmoTmoLnmjIfpkojlh7rlj5HvvIzpobpmaXJzdOaMh+mSiOaJvuWIsOesrOS4gOajteWtkOagkeeahOaguee7k+eCue+8jOS7pUsuY2hbMF3lkozmraTnu5PngrnnmoRzeW1ib2zln5/mr5TovoPvvIzoi6Xnm7jnrYnvvIzliJnpobpmaXJzdOWfn+WGjeavlOi+g+S4i+S4gOWtl+espu+8jOWQpuWImeayv25leHTln5/pobrluo/mn6Xmib7jgIJcbiDoi6Xnm7Toh7Pnqbrku43mr5TovoPkuI3nrYnvvIzliJnmn6Xmib7kuI3miJDlip/jgIJcblxuIC8vIOebuOWFs+i1hOaWmVxuIGh0dHA6Ly93d3cuY25ibG9ncy5jb20vcm9sbGVuaG9sdC9hcmNoaXZlLzIwMTIvMDQvMjQvMjQ2ODkzMi5odG1sXG4gaHR0cDovL2Jsb2cuY3Nkbi5uZXQvdl9qdWx5X3YvYXJ0aWNsZS9kZXRhaWxzLzY4OTcwOTdcbiBodHRwOi8vd3d3LnJheWNoYXNlLm5ldC8xNzgzXG4gKi9cblxuY29uc3QgTEVBRiA9ICdsZWFmJztcbmNvbnN0IEJSQU5DSCA9ICdicmFuY2gnO1xuY29uc3QgVEVSTUlOQUwgPSBuZXcgU3RyaW5nKCckJyk7XG5cbmV4cG9ydCBjbGFzcyBEb3VibGVMaW5rZWRUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihzeW1ib2wgPSAncm9vdCcsIGtpbmQgPSBCUkFOQ0gsIGluZm8gPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgICAgICB0aGlzLmZpcnN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBzeW5vU2VhcmNoIChrZXkpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzLmZpcnN0O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBwICYmIGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChwICYmIHAua2luZCA9PT0gTEVBRikgYnJlYWs7XG4gICAgICAgICAgICB3aGlsZSAocCAmJiBwLnN5bWJvbCA8IGtleVtpXSkgcCA9IHAubmV4dDtcblxuICAgICAgICAgICAgaWYgKHAgJiYgcC5zeW1ib2wgPT09IGtleVtpXSlcbiAgICAgICAgICAgICAgICBwID0gcC5maXJzdDtcbiAgICAgICAgICAgIGVsc2UgcCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcCAmJiBwLmtpbmQgPT09IExFQUYgPyBwLmluZm8gOiBudWxsO1xuICAgIH1cblxuICAgIHNlYXJjaCAoa2V5KSB7XG4gICAgICAgIGxldCBwID0gdGhpcy5maXJzdDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgcCAmJiBpIDwga2V5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB3aGlsZSAocCAmJiBwLnN5bWJvbCA8IGtleVtpXSkgcCA9IHAubmV4dDtcblxuICAgICAgICAgICAgaWYgKHAgJiYgcC5zeW1ib2wgPT09IGtleVtpXSlcbiAgICAgICAgICAgICAgICBwID0gcC5maXJzdDtcbiAgICAgICAgICAgIGVsc2UgcCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcCAmJiBwLmtpbmQgPT09IExFQUYgPyBwLmluZm8gOiBudWxsO1xuICAgIH1cblxuICAgIGluc2VydChrZXksIHZhbHVlKSB7XG4gICAgICAgIGtleSArPSAnJztcbiAgICAgICAgbGV0IGN1ciA9IHRoaXM7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjID0ga2V5W2ldO1xuICAgICAgICAgICAgbGV0IHAgPSBjdXI7XG4gICAgICAgICAgICBjdXIgPSBjdXIuZmlyc3Q7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IG5ldyBEb3VibGVMaW5rZWRUcmVlKGMsIEJSQU5DSCk7XG5cbiAgICAgICAgICAgIC8vIOWmguaenOayoeacieWtkOe7k+eCueWImeWwhuaWsOe7k+eCueS9nOS4uuWtkOe7k+eCuVxuICAgICAgICAgICAgaWYgKCFjdXIpIHtcbiAgICAgICAgICAgICAgICBwLmZpcnN0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudCA9IHA7XG4gICAgICAgICAgICAgICAgY3VyID0gbm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8g5Zyo5YWE5byf57uT54K55Lit5om+5Yiw5a+55bqU57uT54K5XG4gICAgICAgICAgICAgICAgaWYoYyA8IGN1ci5zeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBjdXIucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBub2RlLm5leHQgPSBjdXI7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LmZpcnN0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoYyA+IGN1ci5zeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOebuOetie+8jOmAgOWHuuivpeW+queOr+afpeaJvuS4i+S4gOWtl+esplxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IGN1ci5zeW1ib2wpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c5bCP5LqO5b2T5YmN5a2X56ym77yM5YiZ5o+S5YWl5Yiw5b2T5YmN57uT54K55YmN6Z2iXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGMgPCBjdXIuc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBjdXIucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubmV4dCA9IGN1cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLm5leHQgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBjdXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzmsqHmnInlhYTlvJ/nu5PngrnliJnmj5LlhaXliLDlhYTlvJ/nu5PngrlcbiAgICAgICAgICAgICAgICAgICAgaWYoIWN1cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5uZXh0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gYi5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8g55Sf5oiQ5Y+25a2Q57uT54K5XG4gICAgICAgIGxldCBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGlmIChjdXIua2luZCA9PT0gQlJBTkNIKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBjdXIuZmlyc3Q7XG5cbiAgICAgICAgICAgIC8vIOWmguaenOS4jeWtmOWcqOWFs+mUruWtl+WImeivtOaYjuaPkuWFpeaIkOWKn++8jOWQpuWImeaPkuWFpeWksei0pVxuICAgICAgICAgICAgaWYoIShjaGlsZCAmJiBjaGlsZC5zeW1ib2wgPT09IFRFUk1JTkFMKSkge1xuICAgICAgICAgICAgICAgIGN1ci5maXJzdCA9IG5ldyBEb3VibGVMaW5rZWRUcmVlKFRFUk1JTkFMLCBMRUFGLCB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBrZXkpO1xuICAgICAgICAgICAgICAgIGN1ci5maXJzdC5wYXJlbnQgPSBjdXI7XG4gICAgICAgICAgICAgICAgY3VyLmZpcnN0Lm5leHQgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgIH1cblxuICAgIHJlbW92ZSAoa2V5KSB7XG4gICAgICAgIGxldCBwID0gdGhpcy5maXJzdDtcbiAgICAgICAgbGV0IGkgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwICYmIGkgPCBrZXkubGVuZ3RoKSB7XG4gICAgICAgICAgICB3aGlsZSAocCAmJiBwLnN5bWJvbCA8IGtleVtpXSkgcCA9IHAubmV4dDtcblxuICAgICAgICAgICAgaWYgKHAgJiYgcC5zeW1ib2wgPT09IGtleVtpXSkge1xuICAgICAgICAgICAgICAgIHAgPSBwLmZpcnN0O1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH0gZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGF0YSA9IHAuaW5mbztcbiAgICAgICAgd2hpbGUgKCFwLm5leHQgJiYgcC5wYXJlbnQpIHAgPSBwLnBhcmVudDtcbiAgICAgICAgbGV0IHRvcCA9IHA7XG5cbiAgICAgICAgaWYgKHRvcCA9PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0ID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHRvcC5wYXJlbnQ7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBwID0gcC5maXJzdDtcbiAgICAgICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZTtcbiAgICAgICAgICAgICAgICBpZiAocCA9PSB0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5Yig6Zmk5ZyoZmlyc3Tln5/kuIrnmoTlrZDmoJHnu5PngrlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmUpIHRvcC5wYXJlbnQuZmlyc3QgPSB0b3AucGFyZW50LmZpcnN0Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWIoOmZpOWcqG5leHTln5/nmoTlhYTlvJ/nu5PngrlcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBwcmUubmV4dCA9IHByZS5uZXh0Lm5leHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG52YXIgdGVzdCA9IG5ldyBEb3VibGVMaW5rZWRUcmVlKCk7XG50ZXN0Lmluc2VydCgnQ0FJJyk7XG50ZXN0Lmluc2VydCgnTEFOJyk7XG50ZXN0Lmluc2VydCgnQ0FPJyk7XG50ZXN0Lmluc2VydCgnQ0hBJyk7XG50ZXN0Lmluc2VydCgnQ0hBTkcnKTtcbnRlc3QuaW5zZXJ0KCdDSEFPJyk7XG50ZXN0Lmluc2VydCgnQ0hFTicpO1xudGVzdC5pbnNlcnQoJ0xJJyk7XG50ZXN0Lmluc2VydCgnTElVJyk7XG50ZXN0Lmluc2VydCgnWkhBTycpO1xudGVzdC5pbnNlcnQoJ1pIQU8nKTtcblxuY29uc29sZS5sb2coJ1xcbnNlYXJjaDogJyk7XG5jb25zb2xlLmxvZyh0ZXN0LnNlYXJjaCgnQ0FJJykpO1xuY29uc29sZS5sb2codGVzdC5zZWFyY2goJ0NIQScpKTtcbmNvbnNvbGUubG9nKHRlc3Quc2VhcmNoKCdDSEFORycpKTtcbmNvbnNvbGUubG9nKHRlc3Quc2VhcmNoKCdaSEFPeCcpKTtcblxuY29uc29sZS5sb2coJ1xcbnJlbW92ZTonKTtcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdDQUknKSk7XG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0FJJykpO1xuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0xBTicpKTtcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdDQU8nKSk7XG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0hBJykpO1xuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0NIQU5HJykpO1xuY29uc29sZS5sb2codGVzdC5yZW1vdmUoJ0NIQU8nKSk7XG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnQ0hFTicpKTtcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdMSScpKTtcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdMSVUnKSk7XG5jb25zb2xlLmxvZyh0ZXN0LnJlbW92ZSgnWkhBTycpKTtcblxuXG4vKlxuIOWkmumHjemTvuihqOihqOekulxuXG4g6Iul5Lul5qCR55qE5aSa6YeN6ZO+6KGo6KGo56S66ZSu5qCR77yM5YiZ5qCR55qE5q+P5Liq57uT54K55Lit5bqU5ZCr5pyJZOS4quaMh+mSiOWfn++8jOatpOaXtueahOmUruagkeWPiOensFRyaWXmoJHjgIJcbiDvvIhUcmll5piv5LuO5qOA57SicmV0cmlldmXkuK3lj5bkuK3pl7Tlm5vkuKrlrZfnrKbnmoTvvIzor7vpn7PlkIx0cnnvvInjgIJcbiDoi6Xku47plK7moJHkuK3mn5DkuKrnu5PngrnliLDlj7blrZDnu5PngrnnmoTot6/lvoTkuIrmr4/kuKrnu5Pngrnpg73lj6rmnInkuIDkuKrlranlrZDvvIzliJnlj6/lsIbor6Xot6/lvoTkuIrmiYDmnInnu5PngrnljovnvKnmiJDkuIDkuKrigJzlj7blrZDnu5PngrnigJ3vvIzkuJTlnKjor6Xlj7blrZDnu5PngrnkuK3lrZjlgqjlhbPplK7lrZflj4rmjIflkJHorrDlvZXnmoTmjIfpkojnrYnkv6Hmga/jgIJcbiDlnKhUcmll5qCR5Lit5pyJ5Lik56eN57uT54K577yaXG4g5YiG5pSv57uT54K577ya5ZCr5pyJZOS4quaMh+mSiOWfn+WSjOS4gOS4quaMh+ekuuivpee7k+eCueS4remdnuepuuaMh+mSiOWfn+eahOS4quaVsOeahOaVtOaVsOWfn+OAguWcqOWIhuaUr+e7k+eCueS4reS4jeiuvuaVsOaNruWfn++8jOavj+S4quWIhuaUr+e7k+eCueaJgOihqOekuueahOWtl+espuWdh+acieWFtueItue7k+eCueS4reaMh+WQkeivpee7k+eCueeahOaMh+mSiOaJgOWcqOS9jee9ruWGs+WumuOAglxuIOWPtuWtkOe7k+eCue+8muWQq+acieWFs+mUruWtl+Wfn+WSjOaMh+WQkeiusOW9leeahOaMh+mSiOWfn+OAglxuXG5cbiDlnKhUcmll5qCR5LiK6L+b6KGM5p+l5om+XG5cbiDku47moLnnu5Pngrnlh7rlj5HvvIzmsr/lkoznu5nlrprlgLznm7jlupTnmoTmjIfpkojpgJDlsYLlkJHkuIvvvIznm7Toh7Plj7blrZDnu5PngrnvvIzoi6Xlj7blrZDnu5PngrnkuK3nmoTlhbPplK7lrZflkoznu5nlrprlgLznm7jnrYnvvIzliJnmn6Xmib7miJDlip/vvIzoi6XliIbmlK/nu5PngrnkuK3lkoznu5nlrprlgLznm7jlupTnmoTmjIfpkojkuLrnqbrvvIzmiJblj7blrZDnu5PngrnkuK3nmoTlhbPplK7lrZflkoznu5nlrprlgLzkuI3nm7jnrYnvvIzliJnmn6Xmib7kuI3miJDlip/jgIJcblxuXG4g5LyY5YyWVHJpZeagkeeahOa3seW6plxuXG4g5oiR5Lus5Y+v5a+55YWz6ZSu5a2X6ZuG6YCJ5oup5LiA56eN5ZCI6YCC55qE5YiG5Ymy44CC5YWI5oyJ6aaW5a2X56ym5LiN6YCa5YiG5oiQ5aSa5Liq5a2Q6ZuG5LmL5ZCO77yM54S25ZCO5oyJ5pyA5ZCO5LiA5Liq5a2X56ym5LiN5ZCM5YiG5Ymy5q+P5Liq5a2Q6ZuG77yM5YaN5oyJ56ys5LqM5Liq5a2X56ym44CC44CC44CC5YmN5ZCO5Lqk5Y+J5YiG5Ymy44CC5LiA57yp5YePVHJpZeagkeeahOa3seW6plxuICovXG4vLyDmsYLlrZfnrKblnKjlrZfmr43ooajkuK3nmoTluo/lj7dcbmZ1bmN0aW9uIG9yZGVyKGMpIHtcbiAgICByZXR1cm4gYyA/IGMudG9Mb3dlckNhc2UoKS5jaGFyQ29kZUF0KDApIC0gJ2EnLmNoYXJDb2RlQXQoMCkgKyAxIDogMDtcbn1cblxuLy8g6YCa6L+H5Zue5rqv5rOV5riF55CGVHJpZeagkeeahOWHveaVsFxuZnVuY3Rpb24gcmVtb3ZlTm9kZSh0cmllTm9kZSwgb3JkZXIsIGNsZWFyKSB7XG4gICAgdHJpZU5vZGUuYnJhbmNoLm5vZGVzW29yZGVyXSA9IG51bGw7XG4gICAgLS10cmllTm9kZS5icmFuY2gubnVtO1xuXG4gICAgaWYgKCFjbGVhcikgcmV0dXJuO1xuXG4gICAgbGV0IG5vZGVzID0gdHJpZU5vZGUuYnJhbmNoLm5vZGVzO1xuICAgIGxldCBwYXJlbnQgPSB0cmllTm9kZS5wYXJlbnQ7XG4gICAgbGV0IHByZSA9IHRyaWVOb2RlO1xuXG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBmb3IgKGxldCBpIGluIG5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaGFzT3duUHJvcGVydHkoaSkgJiYgbm9kZXNbaV0pIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbmRleDtcbiAgICAgICAgbGV0IHBhcmVudE5vZGVzID0gcGFyZW50LmJyYW5jaC5ub2RlcztcbiAgICAgICAgZm9yIChsZXQgaSBpbiBwYXJlbnROb2Rlcykge1xuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGVzLmhhc093blByb3BlcnR5KGkpICYmIHBhcmVudE5vZGVzW2ldICYmIHBhcmVudE5vZGVzW2ldID09IHByZSlcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50LmJyYW5jaC5ub2Rlc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAtLXBhcmVudC5icmFuY2gubnVtO1xuXG4gICAgICAgIHByZSA9IHBhcmVudDtcbiAgICAgICAgbm9kZXMgPSBwYXJlbnQuYnJhbmNoLm5vZGVzO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRyaWVUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihraW5kID0gQlJBTkNIKSB7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcblxuICAgICAgICBpZiAoa2luZCA9PT0gTEVBRikge1xuICAgICAgICAgICAgdGhpcy5sZWFmID0ge1xuICAgICAgICAgICAgICAgIGtleTogbnVsbCxcbiAgICAgICAgICAgICAgICBpbmZvOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5icmFuY2ggPSB7XG4gICAgICAgICAgICAgICAgLy8g4oCcJOKAneS4uuesrOS4gOS4quWtl+espu+8jOWQjue7reS4ujI25Liq5a2X5q+NXG4gICAgICAgICAgICAgICAgbm9kZXM6IG5ldyBBcnJheSgyNyksXG4gICAgICAgICAgICAgICAgbnVtOiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VhcmNoIChrZXkpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzLCBpID0gMDtcbiAgICAgICAgZm9yICg7XG4gICAgICAgICAgICAgcCAmJiBwLmtpbmQgPT09IEJSQU5DSCAmJiBpIDwga2V5Lmxlbmd0aDtcbiAgICAgICAgICAgICBwID0gcC5icmFuY2gubm9kZXNbb3JkZXIoa2V5W2ldKV0sICsraSk7XG5cbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIGlmIChwLmtpbmQgPT09IExFQUYgJiYgcC5sZWFmLmtleSA9PT0ga2V5KSByZXR1cm4gcC5sZWFmLmluZm87XG4gICAgICAgICAgICAvLyDlkIzkuYnor41cbiAgICAgICAgICAgIGVsc2UgaWYgKHAua2luZCA9PT0gQlJBTkNIKSB7XG4gICAgICAgICAgICAgICAgcCA9IHAuYnJhbmNoLm5vZGVzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChwICYmIHAubGVhZi5rZXkgPT09IGtleSkgcmV0dXJuIHAubGVhZi5pbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaW5zZXJ0IChrZXksIHZhbHVlKSB7XG4gICAgICAgIC8vIOW7uuWPtuWtkOe7k+eCuVxuICAgICAgICBsZXQgcSA9IG5ldyBUcmllVHJlZShMRUFGKTtcbiAgICAgICAgcS5sZWFmLmtleSA9IGtleTtcbiAgICAgICAgcS5sZWFmLmluZm8gPSB2YWx1ZTtcblxuICAgICAgICAvLyDoh6rkuIrogIzkuIvmn6Xmib5cbiAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgIGxldCBwID0gdGhpcywgaSA9IDA7XG4gICAgICAgIGZvciAoO1xuICAgICAgICAgICAgIHAgJiYgcC5raW5kID09PSBCUkFOQ0ggJiYgaSA8IGtleS5sZW5ndGggJiYgcC5icmFuY2gubm9kZXNbb3JkZXIoa2V5W2ldKV07XG4gICAgICAgICAgICAgcCA9IHAuYnJhbmNoLm5vZGVzW29yZGVyKGtleVtpXSldLCArK2kpIGxhc3QgPSBwO1xuXG4gICAgICAgIC8vIOWmguaenOacgOWQjuiQveWIsOWIhuaUr+e7k+eCue+8iOaXoOWQjOS5ieivje+8iVxuICAgICAgICAvLyDnm7TmjqXov57kuIrlj7blrZBcbiAgICAgICAgaWYgKHAua2luZCA9PT0gQlJBTkNIKSB7XG4gICAgICAgICAgICBwLmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaV0pXSA9IHE7XG4gICAgICAgICAgICBxLnBhcmVudCA9IHA7XG4gICAgICAgICAgICArK3AuYnJhbmNoLm51bTtcbiAgICAgICAgfVxuICAgICAgICAvLyDlpoLmnpzmnIDlkI7okL3liLDlj7blrZDnu5PngrnvvIjmnInlkIzkuYnor43vvIlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocC5sZWFmLmtleSA9PT0ga2V5KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIOW7uueri+aWsOeahOWIhuaUr+e7k+eCuVxuICAgICAgICAgICAgbGV0IHIgPSBuZXcgVHJpZVRyZWUoQlJBTkNIKTtcbiAgICAgICAgICAgIC8vIOeUqOaWsOeahOWIhuaUr+e7k+eCueWPluS7o+iAgeWPtuWtkOe7k+eCueWSjOS4iuS4gOWxgueahOiBlOezu1xuICAgICAgICAgICAgbGFzdC5icmFuY2gubm9kZXNbb3JkZXIoa2V5W2kgLSAxXSldID0gcjtcbiAgICAgICAgICAgIHIucGFyZW50ID0gbGFzdDtcbiAgICAgICAgICAgIHIuYnJhbmNoLm51bSA9IDI7XG4gICAgICAgICAgICByLmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaV0pXSA9IHE7XG4gICAgICAgICAgICBxLnBhcmVudCA9IHI7XG4gICAgICAgICAgICAvLyDmlrDliIbmlK/nu5PngrnkuI7mlrDogIHkuKTkuKrlj7blrZDnu5Pngrnnm7jov55cbiAgICAgICAgICAgIHIuYnJhbmNoLm5vZGVzW29yZGVyKHAubGVhZi5rZXlbaV0pXSA9IHA7XG4gICAgICAgICAgICBwLnBhcmVudCA9IHI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsZWFyIOaYr+WQpumcgOimgea4heeQhue7k+eCuVxuICAgICAqIEByZXR1cm5zIHsqfSDlpoLmnpzliKDpmaTmiJDlip/ov5Tlm55pbmZv5pWw5o2u5ZCm5YiZ6L+U5ZueZmFsc2VcbiAgICAgKi9cbiAgICByZW1vdmUgKGtleSwgY2xlYXIpIHtcbiAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgIGxldCBwID0gdGhpcywgaSA9IDA7XG4gICAgICAgIC8vIOafpeaJvuW+heWIoOmZpOWFg+e0oFxuICAgICAgICBmb3IgKDtcbiAgICAgICAgICAgICBwICYmIHAua2luZCA9PT0gQlJBTkNIICYmIGkgPCBrZXkubGVuZ3RoO1xuICAgICAgICAgICAgIHAgPSBwLmJyYW5jaC5ub2Rlc1tvcmRlcihrZXlbaV0pXSwgKytpKSBsYXN0ID0gcDtcblxuICAgICAgICBpZiAoIXApIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjbGVhciA9IHR5cGVvZiBjbGVhciAhPT0gJ3VuZGVmaW5lZCcgPyBjbGVhciA6IHRydWU7XG4gICAgICAgIGxldCBkYXRhID0gbnVsbDtcblxuICAgICAgICBpZiAocC5raW5kID09PSBMRUFGICYmIHAubGVhZi5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgZGF0YSA9IHAubGVhZi5pbmZvO1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShsYXN0LCBvcmRlcihrZXlbaSAtIDFdKSwgY2xlYXIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocC5raW5kID09PSBCUkFOQ0gpIHtcbiAgICAgICAgICAgIHAgPSBwLmJyYW5jaC5ub2Rlc1swXTtcbiAgICAgICAgICAgIGlmIChwICYmIHAubGVhZi5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBwLmxlYWYuaW5mbztcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlKHAucGFyZW50LCAwLCBjbGVhcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG52YXIgdGVzdCA9IG5ldyBUcmllVHJlZSgpO1xuXG50ZXN0Lmluc2VydCgnQ0hBJyk7XG50ZXN0Lmluc2VydCgnQ0hBJyk7XG50ZXN0Lmluc2VydCgnQ0hBTkcnKTtcbnRlc3QuaW5zZXJ0KCdDQUknKTtcbnRlc3QuaW5zZXJ0KCdDSEVOJyk7XG50ZXN0Lmluc2VydCgnQ0FPJyk7XG50ZXN0Lmluc2VydCgnQ0hBTycpO1xudGVzdC5pbnNlcnQoJ0xPTkcnKTtcbnRlc3QuaW5zZXJ0KCdMSScpO1xudGVzdC5pbnNlcnQoJ0xBTicpO1xudGVzdC5pbnNlcnQoJ0xJVScpO1xudGVzdC5pbnNlcnQoJ1dBTkcnKTtcbnRlc3QuaW5zZXJ0KCdXRU4nKTtcbnRlc3QuaW5zZXJ0KCdXVScpO1xudGVzdC5pbnNlcnQoJ1lBTkcnKTtcbnRlc3QuaW5zZXJ0KCdZVU4nKTtcbnRlc3QuaW5zZXJ0KCdaSEFPJyk7XG5cbmNvbnNvbGUubG9nKCdcXG5zZWFyY2g6ICcpO1xuY29uc29sZS5sb2codGVzdC5zZWFyY2goJ1lVTicpKTtcbmNvbnNvbGUubG9nKHRlc3Quc2VhcmNoKCdaSEFPJykpO1xuY29uc29sZS5sb2codGVzdC5zZWFyY2goJ0NIQScpKTtcblxudGVzdC5yZW1vdmUoJ0xBTicpO1xudGVzdC5yZW1vdmUoJ0xJVScpO1xudGVzdC5yZW1vdmUoJ1dBTkcnKTtcbnRlc3QucmVtb3ZlKCdXRU4nKTtcbnRlc3QucmVtb3ZlKCdXVScpO1xudGVzdC5yZW1vdmUoJ1lBTkcnKTtcbnRlc3QucmVtb3ZlKCdZVU4nKTtcbnRlc3QucmVtb3ZlKCdaSEFPJyk7XG50ZXN0LnJlbW92ZSgnQ0hBJyk7XG50ZXN0LnJlbW92ZSgnQ0hBTkcnKTtcbnRlc3QucmVtb3ZlKCdDQUknKTtcbnRlc3QucmVtb3ZlKCdDSEVOJyk7XG50ZXN0LnJlbW92ZSgnQ0FPJyk7XG50ZXN0LnJlbW92ZSgnQ0hBTycpO1xudGVzdC5yZW1vdmUoJ0xPTkcnKTtcbnRlc3QucmVtb3ZlKCdMSScpO1xuXG50ZXN0Lmluc2VydCgnTEknKTtcbnRlc3QuaW5zZXJ0KCdMQU4nKTtcbnRlc3QuaW5zZXJ0KCdMSVUnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TZWFyY2gvRGlnaXRhbFNlYXJjaFRyZWUuanMiLCIvKipcbiAqIEhhc2hUYWJsZVxuICogQ3JlYXRlZCBieSBMdWtlIG9uIDIwMTQvMTIvMzAuXG4gKi9cblxuLyoqXG7lk4jluIwo5pWj5YiXKeafpeaJvlxuXG7ln7rmnKzmgJ3mg7PvvJrlnKjorrDlvZXnmoTlrZjlgqjlnLDlnYDlkozlroPnmoTlhbPplK7lrZfkuYvpl7Tlu7rnq4vkuIDkuKrnoa7lrprnmoTlr7nlupTlhbPns7vvvJvov5nmoLfvvIzkuI3nu4/ov4fmr5TovoPvvIzkuIDmrKHlrZjlj5blsLHog73lvpfliLDmiYDmn6XlhYPntKDnmoTmn6Xmib7mlrnms5XjgIJcblxu5Z+65pys5qaC5b+1XG5cbuWTiOW4jOWHveaVsO+8muWcqOiusOW9leeahOWFs+mUruWtl+S4juiusOW9leeahOWtmOWCqOWcsOWdgOS5i+mXtOW7uueri+eahOS4gOenjeWvueW6lOWFs+ezu+WPq+WTiOW4jOWHveaVsOOAglxu5ZOI5biM5Ye95pWw5piv5LiA56eN5pig6LGh77yM5piv5LuO5YWz6ZSu5a2X56m66Ze05Yiw5a2Y5YKo5Zyw5Z2A56m66Ze055qE5LiA56eN5pig6LGh44CC5Y+v5YaZ5oiQ77yaYWRkcihhaSk9SChraSkg77yM5YW25LitaeaYr+ihqOS4reS4gOS4quWFg+e0oO+8jGFkZHIoYWkp5pivYWnnmoTlnLDlnYDvvIwga2nmmK9haeeahOWFs+mUruWtl+OAglxuXG7lk4jluIzooajvvJrlupTnlKjlk4jluIzlh73mlbDvvIznlLHorrDlvZXnmoTlhbPplK7lrZfnoa7lrprorrDlvZXlnKjooajkuK3nmoTlnLDlnYDvvIzlubblsIborrDlvZXmlL7lhaXmraTlnLDlnYDvvIzov5nmoLfmnoTmiJDnmoTooajlj6vlk4jluIzooajjgIJcblxu5ZOI5biM5p+l5om+KOWPiOWPq+aVo+WIl+afpeaJvinvvJrliKnnlKjlk4jluIzlh73mlbDov5vooYzmn6Xmib7nmoTov4fnqIvlj6vlk4jluIzmn6Xmib7jgIJcblxu5Yay56qB77ya5a+55LqO5LiN5ZCM55qE5YWz6ZSu5a2Xa2njgIFrau+8jOiLpWtp74K5a2rvvIzkvYZIKGtpKT1IKGtqKeeahOeOsOixoeWPq+WGsueqgShjb2xsaXNpb24pIOOAglxuXG7lkIzkuYnor43vvJrlhbfmnInnm7jlkIzlh73mlbDlgLznmoTkuKTkuKrkuI3lkIznmoTlhbPplK7lrZfvvIznp7DkuLror6Xlk4jluIzlh73mlbDnmoTlkIzkuYnor43jgIJcbuWTiOW4jOWHveaVsOmAmuW4uOaYr+S4gOenjeWOi+e8qeaYoOixoe+8jOaJgOS7peWGsueqgeS4jeWPr+mBv+WFje+8jOWPquiDveWwvemHj+WHj+Wwke+8m+W9k+WGsueqgeWPkeeUn+aXtu+8jOW6lOivpeacieWkhOeQhuWGsueqgeeahOaWueazleOAguiuvuiuoeS4gOS4quaVo+WIl+ihqOW6lOWMheaLrO+8mlxu4pGgICDmlaPliJfooajnmoTnqbrpl7TojIPlm7TvvIzljbPnoa7lrprmlaPliJflh73mlbDnmoTlgLzln5/vvJtcbuKRoSAg5p6E6YCg5ZCI6YCC55qE5pWj5YiX5Ye95pWw77yM5L2/5b6X5a+55LqO5omA5pyJ5Y+v6IO955qE5YWD57SgKOiusOW9leeahOWFs+mUruWtlynvvIzlh73mlbDlgLzlnYflnKjmlaPliJfooajnmoTlnLDlnYDnqbrpl7TojIPlm7TlhoXvvIzkuJTlh7rnjrDlhrLnqoHnmoTlj6/og73lsL3ph4/lsI/vvJtcbuKRoiAg5aSE55CG5Yay56qB55qE5pa55rOV44CC5Y2z5b2T5Yay56qB5Ye6546w5pe25aaC5L2V6Kej5Yaz44CCXG5cblxu5ZOI5biM5Ye95pWw55qE5p6E6YCgXG5cbuWTiOW4jOWHveaVsOaYr+S4gOenjeaYoOixoe+8jOWFtuiuvuWumuW+iOeBtea0u++8jOWPquimgeS9v+S7u+S9leWFs+mUruWtl+eahOWTiOW4jOWHveaVsOWAvOmDveiQveWcqOihqOmVv+WFgeiuuOeahOiMg+WbtOS5i+WGheWNs+WPr+OAguWTiOW4jOWHveaVsOKAnOWlveWdj+KAneeahOS4u+imgeivhOS7t+WboOe0oOacie+8mlxu4peGIOaVo+WIl+WHveaVsOeahOaehOmAoOeugOWNle+8m1xu4peGIOiDveKAnOWdh+WMgOKAneWcsOWwhuaVo+WIl+ihqOS4reeahOWFs+mUruWtl+aYoOWwhOWIsOWcsOWdgOepuumXtOOAguaJgOiwk+KAnOWdh+WMgOKAnSh1bmlmb3JtKeaYr+aMh+WPkeeUn+WGsueqgeeahOWPr+iDveaAp+WwveWPr+iDveacgOWwkeOAglxuXG4xICDnm7TmjqXlrprlnYDms5VcbuWPluWFs+mUruWtl+aIluWFs+mUruWtl+eahOafkOS4que6v+aAp+WHveaVsOS9nOWTiOW4jOWcsOWdgO+8jOWNs0goa2V5KT1rZXkgICAg5oiWICAgSChrZXkpPWHCt2tleStiKGEsYuS4uuW4uOaVsClcbueJueeCue+8muebtOaOpeWumuWdgOazleaJgOW+l+WcsOWdgOmbhuWQiOS4juWFs+mUruWtl+mbhuWQiOWkp+Wwj+ebuOetie+8jOS4jeS8muWPkeeUn+WGsueqge+8jOS9huWunumZheS4reW+iOWwkeS9v+eUqOOAglxuXG4yICDmlbDlrZfliIbmnpDms5VcbuWvueWFs+mUruWtl+i/m+ihjOWIhuaekO+8jOWPluWFs+mUruWtl+eahOiLpeW5suS9jeaIlue7hOWQiOS9nOS4uuWTiOW4jOWcsOWdgOOAglxu6YCC55So5LqO5YWz6ZSu5a2X5L2N5pWw5q+U5ZOI5biM5Zyw5Z2A5L2N5pWw5aSn77yM5LiU5Y+v6IO95Ye6546w55qE5YWz6ZSu5a2X5LqL5YWI55+l6YGT55qE5oOF5Ya144CCXG7kvovvvJog6K6+5pyJODDkuKrorrDlvZXvvIzlhbPplK7lrZfkuLo45L2N5Y2B6L+b5Yi25pWw77yM5ZOI5biM5Zyw5Z2A5Li6MuS9jeWNgei/m+WItuaVsOOAglxu74KBICDvgoIg74KDICDvgoQg74KFICDvgoYg74KHICDvgohcbjggIDEgIDMgIDQgIDYgIDUgIDMgIDJcbjggIDEgIDMgIDcgIDIgIDIgIDQgIDJcbjggIDEgIDMgIDggIDcgIDQgIDIgIDJcbjggIDEgIDMgIDAgIDEgIDMgIDYgIDdcbjggIDEgIDMgIDIgIDIgIDggIDEgIDdcbjggIDEgIDMgIDMgIDggIDkgIDYgIDdcbjggIDEgIDMgIDYgIDggIDUgIDMgIDdcbjggIDEgIDQgIDEgIDkgIDMgIDUgIDVcbuWIhuaekO+8miDvgoEg5Y+q5Y+WOFxuICAgICAg74KCIOWPquWPljFcbiAgICAgIO+CgyDlj6rlj5Yz44CBNFxuICAgICAg74KIIOWPquWPljLjgIE344CBNVxuICAgICAg74KE74KF74KG74KH5pWw5a2X5YiG5biD6L+R5LmO6ZqP5py6XG7miYDku6XvvJrlj5bvgoTvgoXvgobvgofku7vmhI/kuKTkvY3miJbkuKTkvY3kuI7lj6bkuKTkvY3nmoTlj6DliqDkvZzlk4jluIzlnLDlnYBcblxuMyAg5bmz5pa55Y+W5Lit5rOVXG7lsIblhbPplK7lrZflubPmlrnlkI7lj5bkuK3pl7Tlh6DkvY3kvZzkuLrlk4jluIzlnLDlnYDjgIJcbuS4gOS4quaVsOW5s+aWueWQjuS4remXtOWHoOS9jeWSjOaVsOeahOavj+S4gOS9jemDveacieWFs++8jOWImeeUsemaj+acuuWIhuW4g+eahOWFs+mUruWtl+W+l+WIsOeahOaVo+WIl+WcsOWdgOS5n+aYr+maj+acuueahOOAguaVo+WIl+WHveaVsOaJgOWPlueahOS9jeaVsOeUseaVo+WIl+ihqOeahOmVv+W6puWGs+WumuOAgui/meenjeaWueazlemAguS6juS4jeefpemBk+WFqOmDqOWFs+mUruWtl+aDheWGte+8jOaYr+S4gOenjei+g+S4uuW4uOeUqOeahOaWueazleOAglxuXG40ICDmipjlj6Dms5VcbuWwhuWFs+mUruWtl+WIhuWJsuaIkOS9jeaVsOebuOWQjOeahOWHoOmDqOWIhijmnIDlkI7kuIDpg6jliIblj6/ku6XkuI3lkIwp77yM54S25ZCO5Y+W6L+Z5Yeg6YOo5YiG55qE5Y+g5Yqg5ZKM5L2c5Li65ZOI5biM5Zyw5Z2A44CCXG7mlbDkvY3lj6DliqDmnInnp7vkvY3lj6DliqDlkozpl7TnlYzlj6DliqDkuKTnp43jgIJcbuKXhiDnp7vkvY3lj6DliqDvvJrlsIbliIblibLlkI7nmoTlh6Dpg6jliIbkvY7kvY3lr7npvZDnm7jliqDjgIJcbuKXhiDpl7TnlYzlj6DliqDvvJrku47kuIDnq6/liLDlj6bkuIDnq6/msr/liIblibLnlYzmnaXlm57mipjov63vvIznhLblkI7lr7npvZDnm7jliqDjgIJcbumAguS6juWFs+mUruWtl+S9jeaVsOW+iOWkmu+8jOS4lOavj+S4gOS9jeS4iuaVsOWtl+WIhuW4g+Wkp+iHtOWdh+WMgOaDheWGteOAglxu5L6L77yaIOiuvuWFs+mUruWtl+S4ujA0NDIyMDU4NjTvvIzlk4jluIzlnLDlnYDkvY3mlbDkuLo0IOOAguS4pOenjeS4jeWQjOeahOWcsOWdgOiuoeeul+aWueazleWmguS4i++8mlxuICAgIDU4NjQgICAgICAgICAgICAgICAgICAgICAgICA1ODY0XG4gICAgNDIyMCAgICAgICAgICAgICAgICAgICAgICAgIDAyMjRcbiAgICAgIDA0ICAgICAgIOenu+S9jeWPoOWKoCAgICAgICAgICAgIDA0ICAgICAgICAgICDpl7TnlYzlj6DliqBcbiAtLS0tLS0tLS0gICAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tXG4gICAxMDA4OCAgICAgICAgICAgICAgICAgICAgICAgIDYwOTFcblxuNSAg6Zmk55WZ5L2Z5pWw5rOVXG7lj5blhbPplK7lrZfooqvmn5DkuKrkuI3lpKfkuo7lk4jluIzooajooajplb9t55qE5pWwcOmZpOWQjuaJgOW+l+S9meaVsOS9nOWTiOW4jOWcsOWdgO+8jOWNs0goa2V5KT1rZXkgTU9EIHAgICAgIChwPD1tKVxu5piv5LiA56eN566A5Y2V44CB5bi455So55qE5ZOI5biM5Ye95pWw5p6E6YCg5pa55rOV44CCXG7liKnnlKjov5nnp43mlrnms5XnmoTlhbPplK7mmK9w55qE6YCJ5Y+W77yMcOmAieeahOS4jeWlve+8jOWuueaYk+S6p+eUn+WQjOS5ieivjeOAgnDnmoTpgInlj5bnmoTliIbmnpDvvJpcbuKXhiAg6YCJ5Y+WcD0yaShwPD1tKe+8mui/kOeul+S+v+S6jueUqOenu+S9jeadpeWunueOsO+8jOS9huetieS6juWwhuWFs+mUruWtl+eahOmrmOS9jeW/veeVpeiAjOS7heeVmeS4i+S9juS9jeS6jOi/m+WItuaVsOOAgumrmOS9jeS4jeWQjOiAjOS9juS9jeebuOWQjOeahOWFs+mUruWtl+aYr+WQjOS5ieivjeOAglxu4peGIOmAieWPlnA9cSpmKHHjgIFm6YO95piv6LSo5Zug5pWw77yMcDw9bSnvvJrliJnmiYDmnInlkKvmnIlx5oiWZuWboOWtkOeahOWFs+mUruWtl+eahOaVo+WIl+WcsOWdgOWdh+aYr3HmiJZm55qE5YCN5pWw44CCXG7il4Yg6YCJ5Y+WcOS4uue0oOaVsOaIlnA9cSpmKHHjgIFm5piv6LSo5pWw5LiU5Z2H5aSn5LqOMjDvvIxwPD1tKe+8muW4uOeUqOeahOmAieWPluaWueazle+8jOiDveWHj+WwkeWGsueqgeWHuueOsOeahOWPr+iDveaAp+OAglxuXG42ICDpmo/mnLrmlbDms5VcbuWPluWFs+mUruWtl+eahOmaj+acuuWHveaVsOWAvOS9nOWTiOW4jOWcsOWdgO+8jOWNs0goa2V5KT1yYW5kb20oa2V5KVxu5b2T5pWj5YiX6KGo5Lit5YWz6ZSu5a2X6ZW/5bqm5LiN562J5pe277yM6K+l5pa55rOV5q+U6L6D5ZCI6YCC44CCXG5cblxuXG7pgInlj5blk4jluIzlh73mlbDvvIzogIPomZHku6XkuIvlm6DntKBcbuKXhiDorqHnrpflk4jluIzlh73mlbDmiYDpnIDml7bpl7TvvJtcbuKXhiDlhbPplK7lrZfnmoTplb/luqbvvJtcbuKXhiDlk4jluIzooajplb/luqbvvIjlk4jluIzlnLDlnYDojIPlm7TvvInvvJtcbuKXhiDlhbPplK7lrZfliIbluIPmg4XlhrXvvJtcbuKXhiDorrDlvZXnmoTmn6Xmib7popHnjofjgIJcblxuXG5cbuWGsueqgeWkhOeQhueahOaWueazlVxu5Yay56qB5aSE55CG77ya5b2T5Ye6546w5Yay56qB5pe277yM5Li65Yay56qB5YWD57Sg5om+5Yiw5Y+m5LiA5Liq5a2Y5YKo5L2N572u44CCXG5cbjEgIOW8gOaUvuWumuWdgOazlVxu5Z+65pys5pa55rOV77ya5b2T5Yay56qB5Y+R55Sf5pe277yM5b2i5oiQ5p+Q5Liq5o6i5rWL5bqP5YiX77yb5oyJ5q2k5bqP5YiX6YCQ5Liq5o6i5rWL5pWj5YiX6KGo5Lit55qE5YW25LuW5Zyw5Z2A77yM55u05Yiw5om+5Yiw57uZ5a6a55qE5YWz6ZSu5a2X5oiW5LiA5Liq56m65Zyw5Z2AKOW8gOaUvueahOWcsOWdgCnkuLrmraLvvIzlsIblj5HnlJ/lhrLnqoHnmoTorrDlvZXmlL7liLDor6XlnLDlnYDkuK3jgILmlaPliJflnLDlnYDnmoTorqHnrpflhazlvI/mmK/vvJpcbkhpKGtleSk9KEgoa2V5KStkaSkgIE1PRCBt77yMaT0xLCAyLCDigKYsIGsoazw9bS0xKVxuXG7lhbbkuK3vvJpIKGtleSnvvJrlk4jluIzlh73mlbDvvJtt77ya5pWj5YiX6KGo6ZW/5bqm77ybXG5kae+8muesrGnmrKHmjqLmtYvml7bnmoTlop7ph4/luo/liJfvvJtcbkhpKGtleSkg77ya57uP56ysaeasoeaOoua1i+WQjuW+l+WIsOeahOaVo+WIl+WcsOWdgOOAglxuXG7ikbQgIOe6v+aAp+aOoua1i+azlVxu5bCG5pWj5YiX6KGoVFswIOKApm0tMV3nnIvmiJDlvqrnjq/lkJHph4/jgILlvZPlj5HnlJ/lhrLnqoHml7bvvIzku47liJ3mrKHlj5HnlJ/lhrLnqoHnmoTkvY3nva7kvp3mrKHlkJHlkI7mjqLmtYvlhbbku5bnmoTlnLDlnYDjgIJcbuWinumHj+W6j+WIl+S4uu+8mmRpPTEsIDIsIDMsIOKApiwgbS0xXG7orr7liJ3mrKHlj5HnlJ/lhrLnqoHnmoTlnLDlnYDmmK9o77yM5YiZ5L6d5qyh5o6i5rWLVFtoKzFd77yMVFtoKzJd4oCm77yM55u05YiwVFttLTFd5pe25Y+I5b6q546v5Yiw6KGo5aS077yM5YaN5qyh5o6i5rWLVFswXe+8jFRbMV3igKbvvIznm7TliLBUW2gtMV3jgILmjqLmtYvov4fnqIvnu4jmraLnmoTmg4XlhrXmmK/vvJpcbuKXhiDmjqLmtYvliLDnmoTlnLDlnYDkuLrnqbrvvJrooajkuK3msqHmnInorrDlvZXjgILoi6XmmK/mn6Xmib7liJnlpLHotKXvvJvoi6XmmK/mj5LlhaXliJnlsIborrDlvZXlhpnlhaXliLDor6XlnLDlnYDvvJtcbuKXhiDmjqLmtYvliLDnmoTlnLDlnYDmnInnu5nlrprnmoTlhbPplK7lrZfvvJroi6XmmK/mn6Xmib7liJnmiJDlip/vvJvoi6XmmK/mj5LlhaXliJnlpLHotKXvvJtcbuKXhiDnm7TliLBUW2hd77ya5LuN5pyq5o6i5rWL5Yiw56m65Zyw5Z2A5oiW57uZ5a6a55qE5YWz6ZSu5a2X77yM5pWj5YiX6KGo5ruh44CCXG5cbuS+izEg77ya6K6+5pWj5YiX6KGo6ZW/5Li6N++8jOiusOW9leWFs+mUruWtl+e7hOS4uu+8mjE1LCAxNCwgMjgsIDI2LCA1NiwgMjPvvIzmlaPliJflh73mlbDvvJpIKGtleSk9a2V5ICAgTU9EICA377yM5Yay56qB5aSE55CG6YeH55So57q/5oCn5o6i5rWL5rOV44CCXG5IKDE1KT0xNSAgTU9EIDc9MVxuSCgxNCk9MTQgIE1PRCA3PTBcbkgoMjgpPTI4ICBNT0QgNz0wICDlhrLnqoEgICBIMSgyOCk9MSAg5Y+I5Yay56qBXG5IMigyOCk9MiAgICAgICAgICAgSCgyNik9MjYgIE1PRCA3PTVcbkgoNTYpPTU2ICBNT0QgNz0wICAgICDlhrLnqoEgICAgICBIMSg1Nik9MSAgICAg5Y+I5Yay56qBXG5IMig1Nik9MiAgIOWPiOWGsueqgSAgICBIMyg1Nik9M1xuSCgyMyk9MjMgIE1PRCA3PTIgICAgIOWGsueqgSAgICAgIEgxKDIzKT0zICAgICDlj4jlhrLnqoFcbkgzKDIzKT00XG5cbjAgICAgIDEgICAgICAyICAgICAgMyAgICAgIDQgICAgICAgNSAgICAgNlxuMTQgICAgMTUgICAgIDI4ICAgICA1NiAgICAgMjMgICAgICAyNlxuXG7nur/mgKfmjqLmtYvms5XnmoTnibnngrlcbuKXhiDkvJjngrnvvJrlj6ropoHmlaPliJfooajmnKrmu6HvvIzmgLvog73mib7liLDkuIDkuKrkuI3lhrLnqoHnmoTmlaPliJflnLDlnYDvvJtcbuKXhiDnvLrngrnvvJrmr4/kuKrkuqfnlJ/lhrLnqoHnmoTorrDlvZXooqvmlaPliJfliLDnprvlhrLnqoHmnIDov5HnmoTnqbrlnLDlnYDkuIrvvIzku47ogIzlj4jlop7liqDkuobmm7TlpJrnmoTlhrLnqoHmnLrkvJoo6L+Z56eN546w6LGh56ew5Li65Yay56qB55qE4oCc6IGa6ZuG4oCdKeOAglxuXG7ikbUgIOS6jOasoeaOoua1i+azlVxu5aKe6YeP5bqP5YiX5Li677yaZGk9McKyLC0xwrIsMsKyLC0ywrIsM8KyLOKApuKApsKxa8KyICAoazw94oyKbS8y4oyLKVxuXG7kuIrov7Dkvovpopjoi6Xph4fnlKjkuozmrKHmjqLmtYvms5Xov5vooYzlhrLnqoHlpITnkIbvvIzliJnvvJpcbkgoMTUpPTE1ICBNT0QgNz0xICAgICAgICAgSCgxNCk9MTQgIE1PRCA3PTBcbkgoMjgpPTI4ICBNT0QgNz0wICAgICDlhrLnqoEgICAgICBIMSgyOCk9MSAgICAg5Y+I5Yay56qBXG5IMigyOCk9NFxuSCgyNik9MjYgIE1PRCA3PTVcbkgoNTYpPTU2ICBNT0QgNz0wICAgICDlhrLnqoEgICAgICBIMSg1Nik9MSAgICAg5Y+I5Yay56qBXG5IMig1Nik9MCAgIOWPiOWGsueqgSAgICBIMyg1Nik9NCAgICDlj4jlhrLnqoFcbkg0KDU2KT0yXG5IKDIzKT0yMyAgTU9EIDc9MiAgICAgIOWGsueqgVxuSDEoMjMpPTNcblxu5LqM5qyh5o6i5rWL5rOV55qE54m554K5XG7il4Yg5LyY54K577ya5o6i5rWL5bqP5YiX6Lez6LeD5byP5Zyw5pWj5YiX5Yiw5pW05Liq6KGo5Lit77yM5LiN5piT5Lqn55Sf5Yay56qB55qE4oCc6IGa6ZuG4oCd546w6LGh77ybXG7il4Yg57y654K577ya5LiN6IO95L+d6K+B5o6i5rWL5Yiw5pWj5YiX6KGo55qE5omA5pyJ5Zyw5Z2A44CCXG5cbuKRtiAgIOS8qumaj+acuuaOoua1i+azlVxu5aKe6YeP5bqP5YiX5L2/55So5LiA5Liq5Lyq6ZqP5py65Ye95pWw5p2l5Lqn55Sf5LiA5Liq6JC95Zyo6Zet5Yy66Ze0WzHvvIxtLTFd55qE6ZqP5py65bqP5YiX44CCXG5cbuS+izIg77yaIOihqOmVv+S4ujEx55qE5ZOI5biM6KGo5Lit5bey5aGr5pyJ5YWz6ZSu5a2X5Li6MTfvvIw2MO+8jDI555qE6K6w5b2V77yM5pWj5YiX5Ye95pWw5Li6SChrZXkpPWtleSAgTU9EICAxMSDjgIIg546w5pyJ56ysNOS4quiusOW9le+8jOWFtuWFs+mUruWtl+S4ujM477yM5oyJ5LiJ56eN5aSE55CG5Yay56qB55qE5pa55rOV77yM5bCG5a6D5aGr5YWl6KGo5Lit44CCXG5cbigxKSAgSCgzOCk9MzggTU9EIDExPTUgICAg5Yay56qBXG4gICAgIEgxPSg1KzEpIE1PRCAxMT02ICAgIOWGsueqgVxuICAgICBIMj0oNSsyKSBNT0QgMTE9NyAgICDlhrLnqoFcbiAgICAgSDM9KDUrMykgTU9EIDExPTggICAg5LiN5Yay56qBXG4oMikgIEgoMzgpPTM4IE1PRCAxMT01ICAgICAg5Yay56qBXG4gICAgIEgxPSg1KzHCsikgTU9EIDExPTYgICAg5Yay56qBXG4gICAgIEgyPSg1LTHCsikgTU9EIDExPTQgICAgIOS4jeWGsueqgVxuKDMpICBIKDM4KT0zOCBNT0QgMTE9NSAgICDlhrLnqoFcbiAgICAg6K6+5Lyq6ZqP5py65pWw5bqP5YiX5Li6Oe+8jOWImUgxPSg1KzkpIE1PRCAxMT0zIOS4jeWGsueqgVxuXG5cbjIgIOWGjeWTiOW4jOazlVxu5p6E6YCg6Iul5bmy5Liq5ZOI5biM5Ye95pWw77yM5b2T5Y+R55Sf5Yay56qB5pe277yM5Yip55So5LiN5ZCM55qE5ZOI5biM5Ye95pWw5YaN6K6h566X5LiL5LiA5Liq5paw5ZOI5biM5Zyw5Z2A77yM55u05Yiw5LiN5Y+R55Sf5Yay56qB5Li65q2i44CC5Y2z77yaSGk9UkhpKGtleSkgICAgIGk9MSwgMiwg4oCmLCBrXG5SSGkg77ya5LiA57uE5LiN5ZCM55qE5ZOI5biM5Ye95pWw44CC56ys5LiA5qyh5Y+R55Sf5Yay56qB5pe277yM55SoUkgx6K6h566X77yM56ys5LqM5qyh5Y+R55Sf5Yay56qB5pe277yM55SoUkgy6K6h566X4oCm5L6d5q2k57G75o6o55+l6YGT5b6X5Yiw5p+Q5LiqSGnkuI3lho3lhrLnqoHkuLrmraLjgIJcbuKXhiAg5LyY54K577ya5LiN5piT5Lqn55Sf5Yay56qB55qE4oCc6IGa6ZuG4oCd546w6LGh77ybXG7il4YgIOe8uueCue+8muiuoeeul+aXtumXtOWinuWKoOOAglxuXG5cbjMgIOmTvuWcsOWdgOazlVxu5pa55rOV77ya5bCG5omA5pyJ5YWz6ZSu5a2X5Li65ZCM5LmJ6K+NKOaVo+WIl+WcsOWdgOebuOWQjCnnmoTorrDlvZXlrZjlgqjlnKjkuIDkuKrljZXpk77ooajkuK3vvIzlubbnlKjkuIDnu7TmlbDnu4TlrZjmlL7pk77ooajnmoTlpLTmjIfpkojjgIJcbuiuvuaVo+WIl+ihqOmVv+S4um3vvIzlrprkuYnkuIDkuKrkuIDnu7TmjIfpkojmlbDnu4TvvJpcblJlY05vZGUgKmxpbmtoYXNoW21d77yM5YW25LitUmVjTm9kZeaYr+e7k+eCueexu+Wei++8jOavj+S4quWIhumHj+eahOWIneWAvOS4uuepuuOAguWHoeaVo+WIl+WcsOWdgOS4umvnmoTorrDlvZXpg73mj5LlhaXliLDku6VsaW5raGFzaFtrXeS4uuWktOaMh+mSiOeahOmTvuihqOS4re+8jOaPkuWFpeS9jee9ruWPr+S7peWcqOihqOWktOaIluihqOWwvuaIluaMieWFs+mUruWtl+aOkuW6j+aPkuWFpeOAglxuXG7kvovvvJog5bey55+l5LiA57uE5YWz6ZSu5a2XKDE5LCAxNCwgMjMsIDEsIDY4LCAyMCwgODQsIDI3LCA1NSwgMTEsIDEwLCA3OSkg77yM5ZOI5biM5Ye95pWw5Li677yaSChrZXkpPWtleSBNT0QgMTPvvIznlKjpk77lnLDlnYDms5XlpITnkIblhrLnqoE6XG5cbiAwXG4gMSAgLS0+IDE0IC0+IDEgLT4gMjcgLT4gNzlcbiAyXG4gMyAgLS0+IDY4IC0+IDU1XG4gNFxuIDVcbiA2ICAtLT4gMTkgLT4gODRcbiA3ICAtLT4gMjBcbiA4XG4gOVxuIDEwIC0tPiAyMyAtPiAxMFxuIDExIC0tPiAxMVxuIDEyXG5cbiDkvJjngrnvvJrkuI3mmJPkuqfnlJ/lhrLnqoHnmoTigJzogZrpm4bigJ3vvJvliKDpmaTorrDlvZXkuZ/lvojnroDljZXjgIJcblxuXG4gNCAg5bu656uL5YWs5YWx5rqi5Ye65Yy6XG4g5pa55rOV77ya5Zyo5Z+65pys5pWj5YiX6KGo5LmL5aSW77yM5Y+m5aSW6K6+56uL5LiA5Liq5rqi5Ye66KGo5L+d5a2Y5LiO5Z+65pys6KGo5Lit6K6w5b2V5Yay56qB55qE5omA5pyJ6K6w5b2V44CCXG4g6K6+5pWj5YiX6KGo6ZW/5Li6be+8jOiuvueri+WfuuacrOaVo+WIl+ihqGhhc2h0YWJsZVttXe+8jOavj+S4quWIhumHj+S/neWtmOS4gOS4quiusOW9le+8m+a6ouWHuuihqG92ZXJ0YWJsZVttXe+8jOS4gOaXpuafkOS4quiusOW9leeahOaVo+WIl+WcsOWdgOWPkeeUn+WGsueqge+8jOmDveWhq+WFpea6ouWHuuihqOS4reOAglxuXG4g5L6L77yaIOW3suefpeS4gOe7hOWFs+mUruWtlygxNSwgNCwgMTgsIDcsIDM3LCA0Nykg77yM5pWj5YiX6KGo6ZW/5bqm5Li6NyDvvIzlk4jluIzlh73mlbDkuLrvvJpIKGtleSk9a2V5IE1PRCA377yM55So5bu656uL5YWs5YWx5rqi5Ye65Yy65rOV5aSE55CG5Yay56qB44CC5b6X5Yiw55qE5Z+65pys6KGo5ZKM5rqi5Ye66KGo5aaC5LiL77yaXG4gICAgICAgICAgICAgICAgICAgIOaVo+WIl+WcsOWdgCAgICAwICAgICAxICAgICAyICAgICAzICAgICA0ICAgICA1ICAgICA2XG4gSGFzaHRhYmxl6KGo77yaXG4gICAgICAgICAgICAgICAgICAgIOWFs+mUruWtlyAgICAgNyAgICAgMTUgICAgMzcgICAgICAgICAgNCAgICAgNDdcblxuICAgICAgICAgICAgICAgICAgICDmuqLlh7rlnLDlnYAgICAgMCAgICAgMSAgICAgMiAgICAgMyAgICAgNCAgICAgNSAgICAgNlxuIG92ZXJ0YWJsZeihqO+8mlxuICAgICAgICAgICAgICAgICAgICAg5YWz6ZSu5a2XICAgIDE4XG5cblxuXG5cbiDlk4jluIzmn6Xmib7ov4fnqIvlj4rliIbmnpBcblxuIDEgICDlk4jluIzmn6Xmib7ov4fnqItcbiDlk4jluIzooajnmoTkuLvopoHnm67nmoTmmK/nlKjkuo7lv6vpgJ/mn6Xmib7vvIzkuJTmj5LlhaXlkozliKDpmaTmk43kvZzpg73opoHnlKjliLDmn6Xmib7jgILnlLHkuo7mlaPliJfooajnmoTnibnmrornu4Tnu4flvaLlvI/vvIzlhbbmn6Xmib7mnInnibnmrornmoTmlrnms5XjgIJcblxuIOe7meWumkvlgLzvvIzmoLnmja7pgKDooajml7borr7lrprnmoTlk4jluIzlh73mlbDmsYLlvpflk4jluIzlnLDlnYDvvIzoi6XooajkuK3mraTkvY3nva7kuIrmsqHmnInorrDlvZXvvIzliJnmn6Xmib7kuI3miJDlip/vvJvlkKbliJnmr5TovoPlhbPplK7lrZfvvIzoi6Xlkoznu5nlrprlhbPplK7lrZfnm7jnrYnvvIzliJnmn6Xmib7miJDlip/vvJvlkKbliJnmoLnmja7pgKDooajml7borr7lrprnmoTlpITnkIblhrLnqoHnmoTmlrnms5Xmib7igJzkuIvkuIDlnLDlnYDigJ3vvIznm7TliLDlk4jluIzooajkuK3mn5DkuKrkvY3nva7kuLrnqbrmiJbogIXooajkuK3miYDloavorrDlvZXnmoTlhbPplK7lrZfnrYnkuo7nu5nlrprlgLzml7bkuLrmraLjgIJcblxuXG5cbiDlk4jluIzmn6Xmib7liIbmnpBcblxuIOS7juWTiOW4jOafpeaJvui/h+eoi+WPr+inge+8muWwveeuoeaVo+WIl+ihqOWcqOWFs+mUruWtl+S4juiusOW9leeahOWtmOWCqOWcsOWdgOS5i+mXtOW7uueri+S6huebtOaOpeaYoOixoe+8jOS9hueUseS6juKAnOWGsueqgeKAne+8jOafpeaJvui/h+eoi+S7jeaYr+S4gOS4que7meWumuWAvOS4juWFs+mUruWtl+i/m+ihjOavlOi+g+eahOi/h+eoi++8jOivhOS7t+WTiOW4jOafpeaJvuaViOeOh+S7jeimgeeUqEFTTOOAglxuIOWTiOW4jOafpeaJvuaXtuWFs+mUruWtl+S4jue7meWumuWAvOavlOi+g+eahOasoeaVsOWPluWGs+S6ju+8mlxuIOKXhiDlk4jluIzlh73mlbDvvJtcbiDil4Yg5aSE55CG5Yay56qB55qE5pa55rOV77ybXG4g4peGIOWTiOW4jOihqOeahOWhq+a7oeWboOWtkM6xIOOAguWhq+a7oeWboOWtkM6x55qE5a6a5LmJ5piv77yaXG5cbiDOsSA9IOihqOS4reWhq+WFpeeahOiusOW9leaVsCAvIOWTiOW4jOihqOmVv+W6plxuXG5cbiDlkITnp43mlaPliJflh73mlbDmiYDmnoTpgKDnmoTmlaPliJfooajnmoRBU0zlpoLkuIvvvJpcblxuIOKRtCAgIOe6v+aAp+aOoua1i+azleeahOW5s+Wdh+afpeaJvumVv+W6puaYr++8mlxuIFPmiJDlip8g57qm562J5LqOIDEgLyAyICogKDEgKyAxIC8gKDEgLSDOsSkpXG4gU+Wksei0pSDnuqbnrYnkuo4gMSAvIDIgKiAoMSArIDEgLyAoMSAtIM6xKSAqICgxIC0gzrEpKVxuXG4g4pG1ICAg5LqM5qyh5o6i5rWL44CB5Lyq6ZqP5py65o6i5rWL44CB5YaN5ZOI5biM5rOV55qE5bmz5Z2H5p+l5om+6ZW/5bqm5piv77yaXG4gU+aIkOWKnyDnuqbnrYnkuo4gLTEgLyDOsSAqIGxuKDEgLSDOsSlcbiBT5aSx6LSlIOe6puetieS6jiAxIC8gKDEgLSDOsSlcblxuIOKRtiAgIOeUqOmTvuWcsOWdgOazleino+WGs+WGsueqgeeahOW5s+Wdh+afpeaJvumVv+W6puaYr++8mlxuIFPmiJDlip8g57qm562J5LqOIDEgKyDOsSAvIDJcbiBT5aSx6LSlIOe6puetieS6jiDOsSArIGXnmoQtzrHmrKHluYJcblxuXG4gKi9cblxuaW1wb3J0IExpbmtlZExpc3QgZnJvbSAnLi4vTGlzdC9MaW5rZWRMaXN0JztcblxuXG5sZXQgaGFzaFNpemUgPSBidWlsZEhhc2hTaXplKDk3NywgMjApO1xuXG5leHBvcnQgY2xhc3MgSGFzaFRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIC8vIOW9k+WJjeaVsOaNruWFg+e0oOS4quaVsDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIC8vIOW9k+WJjeWuuemHj1xuICAgICAgICB0aGlzLnNpemVJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgLy8g5L2/55So57q/5oCn5o6i5rWL5rOV6Kej5Yaz5Yay56qBXG4gICAgc2VhcmNoKGtleSkge1xuICAgICAgICBsZXQgbWF4ID0gaGFzaFNpemVbdGhpcy5zaXplSW5kZXhdO1xuICAgICAgICBsZXQgcCA9IGhhc2goa2V5LCBtYXgpO1xuICAgICAgICBsZXQgYyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHAgPCBtYXggJiYgdGhpcy5kYXRhW3BdICE9IG51bGwgJiYga2V5ICE9PSB0aGlzLmRhdGFbcF0pIHtcbiAgICAgICAgICAgIHAgPSBjb2xsaXNpb24oa2V5LCArK2MsIG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2Vzczoga2V5ID09PSB0aGlzLmRhdGFbcF0sXG4gICAgICAgICAgICBjb2xsaXNpb25UaW1lczogYyxcbiAgICAgICAgICAgIGluZGV4OiBwXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaW5zZXJ0KGtleSkge1xuICAgICAgICBsZXQgbWF4ID0gaGFzaFNpemVbdGhpcy5zaXplSW5kZXhdO1xuICAgICAgICBpZiAodGhpcy5jb3VudCA+PSBtYXgpIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcm1zZzogJ3RhYmxlIG92ZXJmbG93ZWQnIH07XG5cbiAgICAgICAgbGV0IHJldCA9IHRoaXMuc2VhcmNoKGtleSk7XG4gICAgICAgIGxldCBwID0gcmV0LmluZGV4O1xuICAgICAgICBsZXQgYyA9IHJldC5jb2xsaXNpb25UaW1lcztcblxuICAgICAgICBpZiAocmV0LnN1Y2Nlc3MpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAoYyA8IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XSAvIDIpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtwXSA9IGtleTtcbiAgICAgICAgICAgICsrdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWNyZWF0ZUhhc2hUYWJsZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlKGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuY291bnQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBsZXQgbWF4ID0gaGFzaFNpemVbdGhpcy5zaXplSW5kZXhdO1xuICAgICAgICBsZXQgcCA9IGhhc2goa2V5LCBtYXgpO1xuICAgICAgICBsZXQgYyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGtleSAhPT0gdGhpcy5kYXRhW3BdKVxuICAgICAgICAgICAgcCA9IGNvbGxpc2lvbihrZXksICsrYywgbWF4KTtcblxuXG4gICAgICAgIGlmIChrZXkgPT09IHRoaXMuZGF0YVtwXSkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGFbcF07XG4gICAgICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKHAsIDEpO1xuICAgICAgICAgICAgLS10aGlzLmNvdW50O1xuXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZWNyZWF0ZUhhc2hUYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICsrdGhpcy5zaXplSW5kZXggPCBoYXNoU2l6ZS5sZW5ndGg7XG4gICAgfVxuXG59O1xuXG4vLyBFTEZoYXNo5a2X56ym5Liy5pWj5YiX5Ye95pWwXG5mdW5jdGlvbiBoYXNoKHN0ciwgbWF4KSB7XG4gICAgbGV0IGhhc2ggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSArIGhhc2ggKyBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaGFzaCA9IGhhc2ggJiBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICAgICAgaGFzaCA9IE1hdGguYWJzKGhhc2gpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaCAlIG1heDtcbn1cblxuZnVuY3Rpb24gY29sbGlzaW9uKGtleSwgdGltZXMsIG1heCkge1xuICAgIC8vIOe6v+aAp+aOoua1i+azlVxuICAgIHJldHVybiAoaGFzaChrZXksIG1heCkgKyB0aW1lcykgJSBtYXg7XG59XG5cbmZ1bmN0aW9uIGlzUHJpbWUobikge1xuICAgIGlmIChuIDw9IDMpIHJldHVybiBuID4gMTtcbiAgICBpZiAobiAlIDIgPT09IDAgfHwgbiAlIDMgPT09IDApIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gNTsgaSAqIGkgPD0gbjsgaSArPSA2KSB7XG4gICAgICAgIGlmIChuICUgaSA9PT0gMCB8fCBuICUgKGkgKyAyKSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBidWlsZEhhc2hTaXplKGJlZ2luLCBsZW5ndGgpIHtcbiAgICBsZXQgaGFzaFNpemUgPSBbXTtcblxuICAgIHdoaWxlICgxKSB7XG4gICAgICAgIGlmIChoYXNoU2l6ZS5sZW5ndGggPj0gbGVuZ3RoKSBicmVhaztcbiAgICAgICAgaWYgKGlzUHJpbWUoYmVnaW4pKSBoYXNoU2l6ZS5wdXNoKGJlZ2luKTtcbiAgICAgICAgKytiZWdpbjtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaFNpemU7XG59XG5cbi8vIOW8gOaUvuWumuWdgOazlVxuLy9oYXNoU2l6ZSA9IFs1LCA3XTsgLy8gZm9yIHRlc3QuIHdpbGwgYmUgZGVsZXRlZFxubGV0IHRlc3QgPSBuZXcgSGFzaFRhYmxlKCk7XG50ZXN0Lmluc2VydCgnMTcnKTtcbnRlc3QuaW5zZXJ0KCc2MCcpO1xudGVzdC5pbnNlcnQoJzI5Jyk7XG50ZXN0Lmluc2VydCgnMzgnKTtcbnRlc3QuaW5zZXJ0KCczOScpO1xudGVzdC5pbnNlcnQoJzQwJyk7XG5cbnRlc3QucmVtb3ZlKCcxNycpO1xudGVzdC5yZW1vdmUoJzYwJyk7XG50ZXN0LnJlbW92ZSgnMjknKTtcbnRlc3QucmVtb3ZlKCczOCcpO1xudGVzdC5yZW1vdmUoJzM5Jyk7XG50ZXN0LnJlbW92ZSgnNDAnKTtcblxuXG4vLyDkvb/nlKjpk77lnLDlnYDms5Xop6PlhrPlhrLnqoHnmoTlk4jluIzooahcblxuZXhwb3J0IGNsYXNzIExpbmtlZExpc3RIYXNoVGFibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyDlvZPliY3mlbDmja7lhYPntKDkuKrmlbA7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICAvLyDlvZPliY3lrrnph49cbiAgICAgICAgdGhpcy5zaXplSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmhOb2RlcyA9IFtdO1xuICAgIH1cblxuICAgIHNlYXJjaChrZXkpIHtcbiAgICAgICAgbGV0IG1heCA9IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XTtcbiAgICAgICAgbGV0IGkgPSBoYXNoKGtleSwgbWF4KTtcbiAgICAgICAgbGV0IHQgPSB0aGlzLmhOb2RlcztcblxuICAgICAgICBpZiAodFtpXSA9PSBudWxsKSByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgaW5kZXg6IGkgfTtcblxuICAgICAgICBsZXQgcCA9IHRbaV07XG4gICAgICAgIGxldCBkYXRhID0gbnVsbDtcblxuICAgICAgICBwLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBub2RlLmRhdGE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGRhdGEgPT09IGtleSwgaW5kZXg6IGkgfTtcbiAgICB9XG5cbiAgICBpbnNlcnQoa2V5KSB7XG4gICAgICAgIGxldCBtYXggPSBoYXNoU2l6ZVt0aGlzLnNpemVJbmRleF07XG4gICAgICAgIGlmICh0aGlzLmNvdW50ID49IG1heCkgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9ybXNnOiAndGFibGUgb3ZlcmZsb3dlZCcgfTtcblxuICAgICAgICBsZXQgcmV0ID0gdGhpcy5zZWFyY2goa2V5KTtcbiAgICAgICAgbGV0IGluZGV4ID0gcmV0LmluZGV4O1xuXG4gICAgICAgIGlmIChyZXQuc3VjY2VzcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGlmICghdGhpcy5oTm9kZXNbaW5kZXhdKSB0aGlzLmhOb2Rlc1tpbmRleF0gPSBuZXcgTGlua2VkTGlzdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmhOb2Rlc1tpbmRleF0uc2l6ZSA8IGhhc2hTaXplW3RoaXMuc2l6ZUluZGV4XSAvIDIpIHtcbiAgICAgICAgICAgIHRoaXMuaE5vZGVzW2luZGV4XS5vcmRlckluc2VydChrZXkpO1xuICAgICAgICAgICAgKyt0aGlzLmNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlY3JlYXRlSGFzaFRhYmxlKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5jb3VudCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGxldCByZXQgPSB0aGlzLnNlYXJjaChrZXkpO1xuXG4gICAgICAgIGlmIChyZXQuc3VjY2Vzcykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gcmV0LmluZGV4O1xuICAgICAgICAgICAgbGV0IGRhdGEgPSByZXQuZGF0YTtcbiAgICAgICAgICAgIHRoaXMuaE5vZGVzW2luZGV4XVsncmVtb3ZlJ10oa2V5KTtcbiAgICAgICAgICAgIC0tdGhpcy5jb3VudDtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJlY3JlYXRlSGFzaFRhYmxlKCkge1xuICAgICAgICByZXR1cm4gKyt0aGlzLnNpemVJbmRleCA8IGhhc2hTaXplLmxlbmd0aDtcbiAgICB9XG59O1xuXG5sZXQgdGVzdDIgPSBuZXcgTGlua2VkTGlzdEhhc2hUYWJsZSgpO1xudGVzdDIuaW5zZXJ0KCcxNycpO1xudGVzdDIuaW5zZXJ0KCc2MCcpO1xudGVzdDIuaW5zZXJ0KCcyOScpO1xudGVzdDIuaW5zZXJ0KCczOCcpO1xudGVzdDIuaW5zZXJ0KCczOScpO1xudGVzdDIuaW5zZXJ0KCc0MCcpO1xuXG50ZXN0Mi5yZW1vdmUoJzE3Jyk7XG50ZXN0Mi5yZW1vdmUoJzYwJyk7XG50ZXN0Mi5yZW1vdmUoJzI5Jyk7XG50ZXN0Mi5yZW1vdmUoJzM4Jyk7XG50ZXN0Mi5yZW1vdmUoJzM5Jyk7XG50ZXN0Mi5yZW1vdmUoJzQwJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU2VhcmNoL0hhc2hUYWJsZS5qcyIsIi8qKlxuICogUmVkIEJsYWNrIFRyZWVcbiAqIENyZWF0ZWQgYnkgTHVrZSBvbiAyMDE0LzEyLzMwLlxuICovXG4vKlxuIGh0dHA6Ly9ibG9nLmNzZG4ubmV0L3ZfanVseV92L2FydGljbGUvZGV0YWlscy82MTA1NjMwXG5cbiDnuqLpu5HmoJHvvIzkuIDnp43kuozlj4nmn6Xmib7moJHvvIzkvYblnKjmr4/kuKrnu5PngrnkuIrlop7liqDkuIDkuKrlrZjlgqjkvY3ooajnpLrnu5PngrnnmoTpopzoibLvvIzlj6/ku6XmmK9SZWTmiJZCbGFja+OAglxuIOmAmui/h+WvueS7u+S9leS4gOadoeS7juagueWIsOWPtuWtkOeahOi3r+W+hOS4iuWQhOS4que7k+eCueedgOiJsuaWueW8j+eahOmZkOWItu+8jOe6oum7keagkeehruS/neayoeacieS4gOadoei3r+W+hOS8muavlOWFtuS7lui3r+W+hOmVv+WHuuS/qeWAje+8jOWboOiAjOaYr+aOpei/keW5s+ihoeeahOOAglxuXG4g57qi6buR5qCR6Jm954S25pys6LSo5LiK5piv5LiA5qO15LqM5Y+J5p+l5om+5qCR77yM5L2G5a6D5Zyo5LqM5Y+J5p+l5om+5qCR55qE5Z+656GA5LiK5aKe5Yqg5LqG552A6Imy5ZKM55u45YWz55qE5oCn6LSo5L2/5b6X57qi6buR5qCR55u45a+55bmz6KGh77yM5LuO6ICM5L+d6K+B5LqG57qi6buR5qCR55qE5p+l5om+44CB5o+S5YWl44CB5Yig6Zmk55qE5pe26Ze05aSN5p2C5bqm5pyA5Z2P5Li6Tyhsb2cgbinjgIJcblxuIOe6oum7keagkeeahDXkuKrmgKfotKjvvJpcbiAxLuavj+S4que7k+eCueimgeS5iOaYr+e6oueahOimgeS5iOaYr+m7keeahOOAglxuIDIu5qC557uT54K55piv6buR55qE44CCXG4gMy7mr4/kuKrlj7bnu5PngrnvvIjlj7bnu5PngrnljbPmjIfmoJHlsL7nq69OSUzmjIfpkojmiJZOVUxM57uT54K577yJ6YO95piv6buR55qE44CCXG4gNC7lpoLmnpzkuIDkuKrnu5PngrnmmK/nuqLnmoTvvIzpgqPkuYjlroPnmoTkuKTkuKrlhL/lrZDpg73mmK/pu5HnmoTjgIJcbiA1LuWvueS6juS7u+aEj+e7k+eCueiAjOiogO+8jOWFtuWIsOWPtue7k+eCueagkeWwvuerr05JTOaMh+mSiOeahOavj+adoei3r+W+hOmDveWMheWQq+ebuOWQjOaVsOebrueahOm7kee7k+eCueOAglxuXG4g5q2j5piv57qi6buR5qCR55qE6L+ZNeadoeaAp+i0qO+8jOS9v+S4gOajtW7kuKrnu5PngrnnmoTnuqLpu5HmoJHlp4vnu4jkv53mjIHkuoZsb2du55qE6auY5bqm77yM5LuO6ICM5Lmf5bCx6Kej6YeK5LqG5LiK6Z2i5omA6K+055qE4oCc57qi6buR5qCR55qE5p+l5om+44CB5o+S5YWl44CB5Yig6Zmk55qE5pe26Ze05aSN5p2C5bqm5pyA5Z2P5Li6Tyhsb2cgbinigJ3ov5nkuIDnu5PorrrmiJDnq4vnmoTljp/lm6DjgIJcblxuXG4g5qCR55qE5peL6L2sXG5cbuW9k+WcqOWvuee6oum7keagkei/m+ihjOaPkuWFpeWSjOWIoOmZpOetieaTjeS9nOaXtu+8jOWvueagkeWBmuS6huS/ruaUueWPr+iDveS8muegtOWdj+e6oum7keagkeeahOaAp+i0qOOAguS4uuS6hue7p+e7reS/neaMgee6oum7keagkeeahOaAp+i0qO+8jOWPr+S7pemAmui/h+Wvuee7k+eCuei/m+ihjOmHjeaWsOedgOiJsu+8jOS7peWPiuWvueagkei/m+ihjOebuOWFs+eahOaXi+i9rOaTjeS9nO+8jOWNs+mAmui/h+S/ruaUueagkeS4reafkOS6m+e7k+eCueeahOminOiJsuWPiuaMh+mSiOe7k+aehO+8jOadpei+vuWIsOWvuee6oum7keagkei/m+ihjOaPkuWFpeaIluWIoOmZpOe7k+eCueetieaTjeS9nOWQjue7p+e7reS/neaMgeWug+eahOaAp+i0qOaIluW5s+ihoeeahOebrueahOOAglxuXG7moJHnmoTml4vovazliIbkuLrlt6bml4vlkozlj7Pml4tcblxu5qCR5Zyo57uP6L+H5bem5peL5Y+z5peL5LmL5ZCO77yM5qCR55qE5pCc57Si5oCn6LSo5L+d5oyB5LiN5Y+Y77yM5L2G5qCR55qE57qi6buR5oCn6LSo5YiZ6KKr56C05Z2P5LqG77yM5omA5Lul77yM57qi6buR5qCR5o+S5YWl5ZKM5Yig6Zmk5pWw5o2u5ZCO77yM6ZyA6KaB5Yip55So5peL6L2s5LiO6aKc6Imy6YeN5raC5p2l6YeN5paw5oGi5aSN5qCR55qE57qi6buR5oCn6LSo44CCXG5cblxu57qi6buR5qCR55qE5o+S5YWlXG5cbuWmguaenOaPkuWFpeeahOaYr+aguee7k+eCue+8jOeUseS6juWOn+agkeaYr+epuuagke+8jOatpOaDheWGteWPquS8mui/neWPjeaAp+i0qDLvvIzlm6DmraTnm7TmjqXmiormraTnu5PngrnmtoLkuLrpu5HoibLvvJvlpoLmnpzmj5LlhaXnmoTnu5PngrnnmoTniLbnu5PngrnmmK/pu5HoibLvvIznlLHkuo7mraTkuI3kvJrov53lj43mgKfotKgy5ZKM5oCn6LSoNO+8jOe6oum7keagkeayoeacieiiq+egtOWdj++8jOaJgOS7peatpOaXtuS7gOS5iOS5n+S4jeWBmuOAglxu5L2G5b2T6YGH5Yiw5LiL6L+wM+enjeaDheWGteaXtuWPiOivpeWmguS9leiwg+aVtOWRou+8n1xu4pePIOaPkuWFpeS/ruWkjeaDheWGtTHvvJrlpoLmnpzlvZPliY3nu5PngrnnmoTniLbnu5PngrnmmK/nuqLoibLkuJTnpZbniLbnu5PngrnnmoTlj6bkuIDkuKrlrZDnu5PngrnvvIjlj5Tnu5PngrnvvInmmK/nuqLoibJcbuatpOaXtueItue7k+eCueeahOeItue7k+eCueS4gOWumuWtmOWcqO+8jOWQpuWImeaPkuWFpeWJjeWwseW3suS4jeaYr+e6oum7keagkeOAguS4juatpOWQjOaXtu+8jOWPiOWIhuS4uueItue7k+eCueaYr+ellueItue7k+eCueeahOW3puWtqeWtkOi/mOaYr+WPs+WtqeWtkO+8jOagueaNruWvueensOaAp++8jOaIkeS7rOWPquimgeino+W8gOS4gOS4quaWueWQkeWwseWPr+S7peS6huOAgui/memHjOWPquiAg+iZkeeItue7k+eCueS4uuellueItuW3puWtqeWtkOeahOaDheWGtVxu5a+55q2k77yM5oiR5Lus55qE6Kej5Yaz562W55Wl5piv77ya5bCG5b2T5YmN6IqC54K555qE54i26IqC54K55ZKM5Y+U5Y+U6IqC54K55raC6buR77yM56WW54i257uT54K55raC57qi77yM5oqK5b2T5YmN57uT54K55oyH5ZCR56WW54i26IqC54K577yM5LuO5paw55qE5b2T5YmN6IqC54K56YeN5paw5byA5aeL566X5rOV44CCXG7kuo7mmK/vvIzmj5LlhaXkv67lpI3mg4XlhrUx6L2s5o2i5oiQ5LqG5o+S5YWl5L+u5aSN5oOF5Ya1MlxuXG7il48g5o+S5YWl5L+u5aSN5oOF5Ya1Mu+8muW9k+WJjeiKgueCueeahOeItuiKgueCueaYr+e6ouiJsizlj5ToioLngrnmmK/pu5HoibLvvIzlvZPliY3oioLngrnmmK/lhbbniLboioLngrnnmoTlj7PlrZBcbuatpOaXtu+8jOino+WGs+WvueetluaYr++8muW9k+WJjeiKgueCueeahOeItuiKgueCueWBmuS4uuaWsOeahOW9k+WJjeiKgueCue+8jOS7peaWsOW9k+WJjeiKgueCueS4uuaUr+eCueW3puaXi+OAglxu5LuO6ICM5o+S5YWl5L+u5aSN5oOF5Ya1Mui9rOaNouaIkOS6huaPkuWFpeS/ruWkjeaDheWGtTPjgIJcblxu4pePIOaPkuWFpeS/ruWkjeaDheWGtTPvvJrlvZPliY3oioLngrnnmoTniLboioLngrnmmK/nuqLoibIs5Y+U6IqC54K55piv6buR6Imy77yM5b2T5YmN6IqC54K55piv5YW254i26IqC54K555qE5bem5a2QXG7op6PlhrPlr7nnrZbmmK/vvJrniLboioLngrnlj5jkuLrpu5HoibLvvIznpZbniLboioLngrnlj5jkuLrnuqLoibLvvIzlnKjnpZbniLboioLngrnkuLrmlK/ngrnlj7Pml4vvvIxcbuacgOWQju+8jOaKiuaguee7k+eCuea2guS4uum7keiJsu+8jOaVtOajtee6oum7keagkeS+v+mHjeaWsOaBouWkjeS6huW5s+ihoeOAglxuXG7nu4/ov4fkuIrpnaLmg4XlhrUz44CB5oOF5Ya1NOOAgeaDheWGtTXnrYkz56eN5o+S5YWl5L+u5aSN5oOF5Ya155qE5pON5L2c56S65oSP5Zu+77yM6K+76ICF6Ieq5Lya5Y+R546w77yM5ZCO6Z2i55qE5oOF5Ya1NOOAgeaDheWGtTXpg73mmK/pkojlr7nmg4XlhrUz5o+S5YWl6IqC54K5NOS7peWQju+8jOi/m+ihjOeahOS4gOezu+WIl+aPkuWFpeS/ruWkjeaDheWGteaTjeS9nO+8jOS4jei/h++8jOaMh+WQkeW9k+WJjeiKgueCuU7mjIfpkojkuIDnm7TlnKjlj5jljJbjgILmiYDku6XvvIzkvaDlj6/ku6Xmg7PlvZPnhLbnmoTorqTkuLrvvJrmlbTkuKrkuIvmnaXvvIzmg4XlhrUz44CBNOOAgTXlsLHmmK/kuIDkuKrlrozmlbTnmoTmj5LlhaXkv67lpI3mg4XlhrXnmoTmk43kvZzmtYHnqItcblxuXG7nuqLpu5HmoJHnmoTliKDpmaRcblxu5Zyo5Yig6Zmk6IqC54K55ZCO77yM5Y6f57qi6buR5qCR55qE5oCn6LSo5Y+v6IO96KKr5pS55Y+Y77yM5aaC5p6c5Yig6Zmk55qE5piv57qi6Imy6IqC54K577yM6YKj5LmI5Y6f57qi6buR5qCR55qE5oCn6LSo5L6d5pen5L+d5oyB77yM5q2k5pe25LiN55So5YGa5L+u5q2j5pON5L2c77yM5aaC5p6c5Yig6Zmk55qE6IqC54K55piv6buR6Imy6IqC54K577yM5Y6f57qi6buR5qCR55qE5oCn6LSo5Y+v6IO95Lya6KKr5pS55Y+Y77yM5oiR5Lus6KaB5a+55YW25YGa5L+u5q2j5pON5L2c44CC6YKj5LmI5ZOq5Lqb5qCR55qE5oCn6LSo5Lya5Y+R55Sf5Y+Y5YyW5ZGi77yM5aaC5p6c5Yig6Zmk6IqC54K55LiN5piv5qCR5ZSv5LiA6IqC54K577yM6YKj5LmI5Yig6Zmk6IqC54K555qE6YKj5LiA5Liq5pSv55qE5Yiw5ZCE5Y+26IqC54K555qE6buR6Imy6IqC54K55pWw5Lya5Y+R55Sf5Y+Y5YyW77yM5q2k5pe25oCn6LSoNeiiq+egtOWdj+OAguWmguaenOiiq+WIoOiKgueCueeahOWUr+S4gOmdnuepuuWtkOiKgueCueaYr+e6ouiJsu+8jOiAjOiiq+WIoOiKgueCueeahOeItuiKgueCueS5n+aYr+e6ouiJsu+8jOmCo+S5iOaAp+i0qDTooqvnoLTlnY/jgILlpoLmnpzooqvliKDoioLngrnmmK/moLnoioLngrnvvIzogIzlroPnmoTllK/kuIDpnZ7nqbrlrZDoioLngrnmmK/nuqLoibLvvIzliJnliKDpmaTlkI7mlrDmoLnoioLngrnlsIblj5jmiJDnuqLoibLvvIzov53og4zmgKfotKgy44CCXG5cbuS4iumdoueahOS/ruWkjeaDheWGteeci+i1t+adpeacieS6m+Wkjeadgu+8jOS4i+mdouaIkeS7rOeUqOS4gOS4quWIhuaekOaKgOW3p++8muaIkeS7rOS7juiiq+WIoOiKgueCueWQjuadpemhtuabv+Wug+eahOmCo+S4quiKgueCueW8gOWni+iwg+aVtO+8jOW5tuiupOS4uuWug+aciemineWklueahOS4gOmHjem7keiJsuOAgui/memHjOmineWkluS4gOmHjem7keiJsuaYr+S7gOS5iOaEj+aAneWRou+8jOaIkeS7rOS4jeaYr+aKiue6oum7keagkeeahOiKgueCueWKoOS4iumZpOe6ouS4jum7keeahOWPpuS4gOenjeminOiJsu+8jOi/memHjOWPquaYr+S4gOenjeWBh+iuvu+8jOaIkeS7rOiupOS4uuaIkeS7rOW9k+WJjeaMh+WQkeWug++8jOWboOatpOepuuaciemineWkluS4gOenjem7keiJsu+8jOWPr+S7peiupOS4uuWug+eahOm7keiJsuaYr+S7juWug+eahOeItuiKgueCueiiq+WIoOmZpOWQjue7p+aJv+e7meWug+eahO+8jOWug+eOsOWcqOWPr+S7peWuuee6s+S4pOenjeminOiJsu+8jOWmguaenOWug+WOn+adpeaYr+e6ouiJsu+8jOmCo+S5iOeOsOWcqOaYr+e6oivpu5HvvIzlpoLmnpzljp/mnaXmmK/pu5HoibLvvIzpgqPkuYjlroPnjrDlnKjnmoTpopzoibLmmK/pu5Er6buR44CC5pyJ5LqG6L+Z6YeN6aKd5aSW55qE6buR6Imy77yM5Y6f57qi6buR5qCR5oCn6LSoNeWwseiDveS/neaMgeS4jeWPmOOAgueOsOWcqOWPquimgeaBouWkjeWFtuWug+aAp+i0qOWwseWPr+S7peS6hu+8jOWBmuazlei/mOaYr+WwvemHj+WQkeagueenu+WKqOWSjOept+S4vuaJgOacieWPr+iDveaAp+OAglxuXG4g5aaC5p6c5piv5Lul5LiL5oOF5Ya177yM5oGi5aSN5q+U6L6D566A5Y2V77yaXG4gYSnlvZPliY3oioLngrnmmK/nuqIr6buR6ImyXG4g6Kej5rOV77yM55u05o6l5oqK5b2T5YmN6IqC54K55p+T5oiQ6buR6Imy77yM57uT5p2f5q2k5pe257qi6buR5qCR5oCn6LSo5YWo6YOo5oGi5aSN44CCXG4gYinlvZPliY3oioLngrnmmK/pu5Er6buR5LiU5piv5qC56IqC54K577yMIOino+azle+8muS7gOS5iOmDveS4jeWBmu+8jOe7k+adn+OAglxuXG4g5L2G5aaC5p6c5piv5Lul5LiL5oOF5Ya15ZGi77yf77yaXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1Me+8muW9k+WJjeiKgueCueaYr+m7kSvpu5HkuJTlhYTlvJ/oioLngrnkuLrnuqLoibIo5q2k5pe254i26IqC54K55ZKM5YWE5byf6IqC54K555qE5a2Q6IqC54K55YiG5Li66buRKVxuIOWIoOmZpOS/ruWkjeaDheWGtTLvvJrlvZPliY3oioLngrnmmK/pu5HliqDpu5HkuJTlhYTlvJ/mmK/pu5HoibLkuJTlhYTlvJ/oioLngrnnmoTkuKTkuKrlrZDoioLngrnlhajkuLrpu5HoibJcbiDliKDpmaTkv67lpI3mg4XlhrUz77ya5b2T5YmN6IqC54K56aKc6Imy5piv6buRK+m7ke+8jOWFhOW8n+iKgueCueaYr+m7keiJsu+8jOWFhOW8n+eahOW3puWtkOaYr+e6ouiJsu+8jOWPs+WtkOaYr+m7keiJslxuIOWIoOmZpOS/ruWkjeaDheWGtTTvvJrlvZPliY3oioLngrnpopzoibLmmK/pu5Et6buR6Imy77yM5a6D55qE5YWE5byf6IqC54K55piv6buR6Imy77yM5L2G5piv5YWE5byf6IqC54K555qE5Y+z5a2Q5piv57qi6Imy77yM5YWE5byf6IqC54K55bem5a2Q55qE6aKc6Imy5Lu75oSPXG4g5q2k5pe277yM5oiR5Lus6ZyA6KaB6LCD55SoUkItREVMRVRFLUZJWFVQKFQsIHgp77yM5p2l5oGi5aSN5LiO5L+d5oyB57qi6buR5oCn6LSo55qE5bel5L2c44CCXG5cbiDkuIvpnaLvvIzlkrHku6zkvr/mnaXliIbliKvlpITnkIbov5k056eN5Yig6Zmk5L+u5aSN5oOF5Ya144CCXG5cbiDliKDpmaTkv67lpI3mg4XlhrUx77ya5b2T5YmN6IqC54K55piv6buRK+m7keS4lOWFhOW8n+iKgueCueS4uue6ouiJsijmraTml7bniLboioLngrnlkozlhYTlvJ/oioLngrnnmoTlrZDoioLngrnliIbkuLrpu5Ep44CCXG4g6Kej5rOV77ya5oqK54i26IqC54K55p+T5oiQ57qi6Imy77yM5oqK5YWE5byf57uT54K55p+T5oiQ6buR6Imy77yM5LmL5ZCO6YeN5paw6L+b5YWl566X5rOV77yI5oiR5Lus5Y+q6K6o6K665b2T5YmN6IqC54K55piv5YW254i26IqC54K55bem5a2p5a2Q5pe255qE5oOF5Ya177yJ44CC5q2k5Y+Y5o2i5ZCO5Y6f57qi6buR5qCR5oCn6LSoNeS4jeWPmO+8jOiAjOaKiumXrumimOi9rOWMluS4uuWFhOW8n+iKgueCueS4uum7keiJsueahOaDheWGtSjms6jvvJrlj5jljJbliY3vvIzljp/mnKzlsLHmnKrov53lj43mgKfotKg177yM5Y+q5piv5Li65LqG5oqK6Zeu6aKY6L2s5YyW5Li65YWE5byf6IqC54K55Li66buR6Imy55qE5oOF5Ya1KeOAglxuXG4g5Yig6Zmk5L+u5aSN5oOF5Ya1Mu+8muW9k+WJjeiKgueCueaYr+m7keWKoOm7keS4lOWFhOW8n+aYr+m7keiJsuS4lOWFhOW8n+iKgueCueeahOS4pOS4quWtkOiKgueCueWFqOS4uum7keiJsuOAglxuIOino+azle+8muaKiuW9k+WJjeiKgueCueWSjOWFhOW8n+iKgueCueS4reaKveWPluS4gOmHjem7keiJsui/veWKoOWIsOeItuiKgueCueS4iu+8jOaKiueItuiKgueCueW9k+aIkOaWsOeahOW9k+WJjeiKgueCue+8jOmHjeaWsOi/m+WFpeeul+azleOAgu+8iOatpOWPmOaNouWQjuaAp+i0qDXkuI3lj5jvvIlcblxuIOWIoOmZpOS/ruWkjeaDheWGtTPvvJrlvZPliY3oioLngrnpopzoibLmmK/pu5Er6buR77yM5YWE5byf6IqC54K55piv6buR6Imy77yM5YWE5byf55qE5bem5a2Q5piv57qi6Imy77yM5Y+z5a2Q5piv6buR6Imy44CCXG4g6Kej5rOV77ya5oqK5YWE5byf57uT54K55p+T57qi77yM5YWE5byf5bem5a2Q6IqC54K55p+T6buR77yM5LmL5ZCO5YaN5Zyo5YWE5byf6IqC54K55Li65pSv54K56Kej5Y+z5peL77yM5LmL5ZCO6YeN5paw6L+b5YWl566X5rOV44CC5q2k5piv5oqK5b2T5YmN55qE5oOF5Ya16L2s5YyW5Li65oOF5Ya1NO+8jOiAjOaAp+i0qDXlvpfku6Xkv53mjIFcblxuIOWIoOmZpOS/ruWkjeaDheWGtTTvvJrlvZPliY3oioLngrnpopzoibLmmK/pu5Et6buR6Imy77yM5a6D55qE5YWE5byf6IqC54K55piv6buR6Imy77yM5L2G5piv5YWE5byf6IqC54K555qE5Y+z5a2Q5piv57qi6Imy77yM5YWE5byf6IqC54K55bem5a2Q55qE6aKc6Imy5Lu75oSP44CCXG4g6Kej5rOV77ya5oqK5YWE5byf6IqC54K55p+T5oiQ5b2T5YmN6IqC54K554i26IqC54K555qE6aKc6Imy77yM5oqK5b2T5YmN6IqC54K554i26IqC54K55p+T5oiQ6buR6Imy77yM5YWE5byf6IqC54K55Y+z5a2Q5p+T5oiQ6buR6Imy77yM5LmL5ZCO5Lul5b2T5YmN6IqC54K555qE54i26IqC54K55Li65pSv54K56L+b6KGM5bem5peL77yM5q2k5pe2566X5rOV57uT5p2f77yM57qi6buR5qCR5omA5pyJ5oCn6LSo6LCD5pW05q2j56GuXG5cblxuIOacgOWQjuWAvOW+l+S4gOaPkOeahOaYr+S4iui/sOWIoOmZpOS/ruWkjeeahOaDheWGtTF+NOmDveWPquaYr+agkeeahOWxgOmDqO+8jOW5tumdnuagkeeahOaVtOS9k+WFqOmDqO+8jOS4lOWIoOmZpOS/ruWkjeaDheWGtTPjgIE05Zyo57uP6L+H5LiK6Z2i55qE6LCD5pW05ZCO77yM6LCD5pW06L+Y5rKh57uT5p2fLOi/mOW+l+e7p+e7reiwg+aVtOebtOiHs+mHjeaWsOaBouWkjeW5s+ihoVxuKi9cbmltcG9ydCBCU1ROb2RlIGZyb20gJy4vQmluYXJ5U29ydGVkVHJlZSc7XG5cbmNvbnN0IFJFRCA9ICdyZWQnO1xuY29uc3QgQkxBQ0sgPSAnYmxhY2snO1xuXG5jbGFzcyBSZWRCbGFja05vZGUgZXh0ZW5kcyBCU1ROb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgLi4ucmVzdCl7XG4gICAgICAgIHN1cGVyKGRhdGEsIC4uLnJlc3QpO1xuXG4gICAgICAgIHRoaXMubGVmdENoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5yaWdodENoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY29sb3IgPSBSRUQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuXG5jbGFzcyBSZWRCbGFja0xlYWYge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuY29sb3IgPSBCTEFDSztcbiAgICAgICAgdGhpcy5sZWZ0Q2hpbGQgPSB0aGlzO1xuICAgICAgICB0aGlzLnJpZ2h0Q2hpbGQgPSB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVkQmxhY2tUcmVlIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICAvLyDlk6jlhbVcbiAgICAgICAgdGhpcy5uaWwgPSBuZXcgUmVkQmxhY2tMZWFmKCk7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMubmlsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOe6oum7keagkeeahOmAkuW9kuafpeaJvueul+azlVxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgZmluZChkYXRhKXtcbiAgICAgICAgbGV0IHogPSB0aGlzLnJvb3Q7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiBmaW5kKHosIGRhdGEpe1xuICAgICAgICAgICAgaWYoeiA9PSBtZS5uaWwgfHwgZGF0YSA9PT0gei5kYXRhKSByZXR1cm4gejtcblxuICAgICAgICAgICAgaWYoZGF0YSA8IHouZGF0YSkgcmV0dXJuIGZpbmQoei5sZWZ0Q2hpbGQsIGRhdGEpO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gZmluZCh6LnJpZ2h0Q2hpbGQsIGRhdGEpO1xuICAgICAgICB9KSh6LCBkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnuqLpu5HmoJHnmoTmj5LlhaVcbiAgICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICAgKi9cbiAgICBhZGQoZGF0YSl7XG4gICAgICAgIGxldCB6ID0gbmV3IFJlZEJsYWNrTm9kZShkYXRhKTtcbiAgICAgICAgei5sZWZ0Q2hpbGQgPSB0aGlzLm5pbDtcbiAgICAgICAgei5yaWdodENoaWxkID0gdGhpcy5uaWw7XG4gICAgICAgIGxldCB5ID0gdGhpcy5uaWw7XG4gICAgICAgIGxldCB4ID0gdGhpcy5yb290O1xuXG4gICAgICAgIC8vIOaJvuWIsOimgeaPkuWFpeS9jee9rueahOe7k+eCuXlcbiAgICAgICAgd2hpbGUoeCAhPSB0aGlzLm5pbCl7XG4gICAgICAgICAgICB5ID0geDtcblxuICAgICAgICAgICAgaWYoei5kYXRhIDwgeC5kYXRhKSB4ID0geC5sZWZ0Q2hpbGQ7XG4gICAgICAgICAgICBlbHNlIHggPSB4LnJpZ2h0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICB6LnBhcmVudCA9IHk7XG5cbiAgICAgICAgLy8g5aaC5p6ceeS4jeaYr+aguee7k+eCue+8jOagueaNruWkp+Wwj+aPkuWFpeWIsOW3puaIluWPs+WtkOagkVxuICAgICAgICBpZih5ICE9IHRoaXMubmlsKSB7XG4gICAgICAgICAgICBpZih6LmRhdGEgPCB5LmRhdGEpIHkubGVmdENoaWxkID0gejtcbiAgICAgICAgICAgIGVsc2UgeS5yaWdodENoaWxkID0gejtcbiAgICAgICAgfVxuICAgICAgICAvLyDlkKbliJnmj5LlhaXliLDmoLnnu5PngrlcbiAgICAgICAgZWxzZSB0aGlzLnJvb3QgPSB6ID09IHRoaXMubmlsID8gbnVsbCA6IHo7XG5cbiAgICAgICAgLy8g5o+S5YWl5L+u5aSN5pON5L2cXG4gICAgICAgIHRoaXMuX2FkZEZpeHVwKHopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaPkuWFpeeul+azleS/ruWkjVxuICAgICAqIEBwYXJhbSB7UmVkQmxhY2tOb2RlfSB6IOW+heaPkuWFpeeahOe7k+eCuVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZEZpeHVwKHope1xuXG4gICAgICAgIHdoaWxlKHogIT0gdGhpcy5yb290ICYmIHoucGFyZW50LmNvbG9yID09PSBSRUQpe1xuICAgICAgICAgICAgaWYoei5wYXJlbnQgPT0gei5wYXJlbnQucGFyZW50LmxlZnRDaGlsZClcbiAgICAgICAgICAgICAgICBsZWZ0QWRkRml4dXAodGhpcywgeik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmlnaHRBZGRGaXh1cCh0aGlzLCB6KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOacgOWQju+8jOaKiuaguee7k+eCuea2guS4uum7keiJsu+8jOaVtOajtee6oum7keagkeS+v+mHjeaWsOaBouWkjeS6huW5s+ihoVxuICAgICAgICB0aGlzLnJvb3QuY29sb3IgPSBCTEFDSztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnuqLpu5HmoJHnmoTliKDpmaTnrpfms5VcbiAgICAgKiBAcGFyYW0ge1JlZEJsYWNrTm9kZX0geiDlvoXliKDpmaTnu5PngrlcbiAgICAgKi9cbiAgICByZW1vdmVOb2RlKHope1xuICAgICAgICBsZXQgeCwgeTtcblxuICAgICAgICAvLyDmib7liLDlvoXliKDpmaTnu5PngrnnmoTniLbnu5PngrnmiJbnm7jpgrvlvoXmm7/mjaLnu5PngrlcbiAgICAgICAgaWYoei5sZWZ0Q2hpbGQgPT0gdGhpcy5uaWwgfHwgei5yaWdodENoaWxkID09IHRoaXMubmlsKVxuICAgICAgICAgICAgeSA9IHo7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHkgPSB0aGlzLnN1Y2Nlc3Nvcih6KTtcblxuICAgICAgICBpZih5LmxlZnRDaGlsZCAhPSB0aGlzLm5pbCkgeCA9IHkubGVmdENoaWxkO1xuICAgICAgICBlbHNlIHggPSB5LnJpZ2h0Q2hpbGQ7XG5cbiAgICAgICAgeC5wYXJlbnQgPSB5LnBhcmVudDtcblxuICAgICAgICAvLyDliKDpmaTmk43kvZxcbiAgICAgICAgaWYoeS5wYXJlbnQgPT0gdGhpcy5uaWwpIHRoaXMucm9vdCA9IHg7XG4gICAgICAgIGVsc2UgaWYoeSA9PSB5LnBhcmVudC5sZWZ0Q2hpbGQpIHkucGFyZW50LmxlZnRDaGlsZCA9IHg7XG4gICAgICAgIGVsc2UgeS5wYXJlbnQucmlnaHRDaGlsZCA9IHg7XG5cbiAgICAgICAgaWYoeSAhPSB6KSB6LmRhdGEgPSB5LmRhdGE7XG5cbiAgICAgICAgLy8g5Yig6Zmk5L+u5aSNXG4gICAgICAgIGlmKHkuY29sb3IgPT09IEJMQUNLKSB0aGlzLl9yZW1vdmVGaXh1cCh4KTtcbiAgICB9XG5cbiAgICAvLyDnrpfms5Xlr7zorrrkuIrnmoTliKDpmaTnu5PngrlcbiAgICByZW1vdmVOb2RlMih6KXtcbiAgICAgICAgbGV0IHkgPSB6O1xuICAgICAgICBsZXQgb3JpZ2luYWxZQ29sb3IgPSB5LmNvbG9yO1xuICAgICAgICBsZXQgeDtcblxuICAgICAgICBpZih6LmxlZnRDaGlsZCA9PSB0aGlzLm5pbCkge1xuICAgICAgICAgICAgeCA9IHoucmlnaHRDaGlsZDtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcGxhbnQoeiwgei5yaWdodENoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmKHoucmlnaHRDaGlsZCA9PSB0aGlzLm5pbCkge1xuICAgICAgICAgICAgeCA9IHoubGVmdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNwbGFudCh6LCB6LmxlZnRDaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5ID0gdGhpcy5taW4oei5yaWdodENoaWxkKTtcbiAgICAgICAgICAgIG9yaWdpbmFsWUNvbG9yID0geS5jb2xvcjtcbiAgICAgICAgICAgIHggPSB5LnJpZ2h0Q2hpbGQ7XG5cbiAgICAgICAgICAgIGlmKHkucGFyZW50ID09IHopIHgucGFyZW50ID0geTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zcGxhbnQoeSwgeS5yaWdodENoaWxkKTtcbiAgICAgICAgICAgICAgICB5LnJpZ2h0Q2hpbGQgPSB6LnJpZ2h0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgeS5yaWdodENoaWxkLnBhcmVudCA9IHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcGxhbnQoeiwgeSk7XG4gICAgICAgICAgICB5LmxlZnRDaGlsZCA9IHoubGVmdENoaWxkO1xuICAgICAgICAgICAgeS5sZWZ0Q2hpbGQucGFyZW50ID0geTtcbiAgICAgICAgICAgIHkuY29sb3IgPSB6LmNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYob3JpZ2luYWxZQ29sb3IgPT09IEJMQUNLKSB0aGlzLl9yZW1vdmVGaXh1cCh4KTtcbiAgICB9XG5cbiAgICBfdHJhbnNwbGFudCh1LCB2KXtcbiAgICAgICAgaWYodS5wYXJlbnQgPT0gdGhpcy5uaWwpIHRoaXMucm9vdCA9IHY7XG4gICAgICAgIGVsc2UgaWYodSA9PSB1LnBhcmVudC5sZWZ0Q2hpbGQpIHUucGFyZW50LmxlZnRDaGlsZCA9IHY7XG4gICAgICAgIGVsc2UgdS5wYXJlbnQucmlnaHRDaGlsZCA9IHY7XG5cbiAgICAgICAgdi5wYXJlbnQgPSB1LnBhcmVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDliKDpmaTkv67lpI1cbiAgICAgKiBAcGFyYW0ge1JlZEJsYWNrTm9kZX0gelxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUZpeHVwKHope1xuICAgICAgICB3aGlsZSh6ICE9PSB0aGlzLnJvb3QgJiYgei5jb2xvciA9PT0gQkxBQ0spe1xuICAgICAgICAgICAgaWYoeiA9PSB6LnBhcmVudC5sZWZ0Q2hpbGQpXG4gICAgICAgICAgICAgICAgbGVmdFJlbW92ZUZpeHVwKHRoaXMsIHopO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJpZ2h0UmVtb3ZlRml4dXAodGhpcywgeik7XG4gICAgICAgIH1cblxuICAgICAgICB6LmNvbG9yID0gQkxBQ0s7XG4gICAgfVxuXG4gICAgc3VjY2Vzc29yKHope1xuICAgICAgICBpZih6LnJpZ2h0Q2hpbGQgIT0gdGhpcy5uaWwpIHJldHVybiB0aGlzLm1pbih6LnJpZ2h0Q2hpbGQpO1xuXG4gICAgICAgIGxldCB5ID0gei5wYXJlbnQ7XG5cbiAgICAgICAgd2hpbGUoeSAhPSB0aGlzLm5pbCAmJiB6ID09IHkucmlnaHRDaGlsZCl7XG4gICAgICAgICAgICB6ID0geTtcbiAgICAgICAgICAgIHkgPSB5LnBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB5O1xuICAgIH1cblxuICAgIG1pbih6KXtcbiAgICAgICAgd2hpbGUoei5sZWZ0Q2hpbGQgIT0gdGhpcy5uaWwpe1xuICAgICAgICAgICAgeiA9IHoubGVmdENoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHo7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5qC55o2ua2V55YC85Yig6Zmk57uT54K5XG4gICAgICogQHBhcmFtIHsqfSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICByZW1vdmUoa2V5KXtcbiAgICAgICAgbGV0IHogPSB0aGlzLmZpbmQoa2V5KTtcblxuICAgICAgICBpZih6ID09IHRoaXMubmlsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTm9kZSh6KTtcbiAgICB9XG59XG5cblJlZEJsYWNrVHJlZS5wcm90b3R5cGUuX3JvdGF0ZUxlZnQgPSByb3RhdGUoJ2xlZnQnKTtcblJlZEJsYWNrVHJlZS5wcm90b3R5cGUuX3JvdGF0ZVJpZ2h0ID0gcm90YXRlKCdyaWdodCcpO1xuXG5mdW5jdGlvbiByb3RhdGUoZGlyKXtcbiAgICBsZXQgYzEsIGMyO1xuICAgIGlmKCBkaXIgPT09ICdsZWZ0Jykge1xuICAgICAgICBjMSA9ICdyaWdodENoaWxkJztcbiAgICAgICAgYzIgPSAnbGVmdENoaWxkJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjMSA9ICdsZWZ0Q2hpbGQnO1xuICAgICAgICBjMiA9ICdyaWdodENoaWxkJztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oeCl7XG4gICAgICAgIGxldCB5ID0geFtjMV07XG4gICAgICAgIHhbYzFdID0geVtjMl07XG5cbiAgICAgICAgaWYoeVtjMl0gIT0gdGhpcy5uaWwpIHlbYzJdLnBhcmVudCA9IHg7XG4gICAgICAgIHkucGFyZW50ID0geC5wYXJlbnQ7XG5cbiAgICAgICAgaWYoeC5wYXJlbnQgPT0gdGhpcy5uaWwpIHRoaXMucm9vdCA9IHk7XG4gICAgICAgIGVsc2UgaWYoeCA9PSB4LnBhcmVudFtjMl0pIHgucGFyZW50W2MyXSA9IHk7XG4gICAgICAgIGVsc2UgeC5wYXJlbnRbYzFdID0geTtcblxuICAgICAgICB5W2MyXSA9IHg7XG4gICAgICAgIHgucGFyZW50ID0geTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhZGRGaXh1cChkaXIpe1xuICAgIGxldCBjMSwgYzIsIHJvdGF0ZTEsIHJvdGF0ZTI7XG4gICAgaWYoIGRpciA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGMxID0gJ3JpZ2h0Q2hpbGQnO1xuICAgICAgICBjMiA9ICdsZWZ0Q2hpbGQnO1xuICAgICAgICByb3RhdGUxID0gJ19yb3RhdGVMZWZ0JztcbiAgICAgICAgcm90YXRlMiA9ICdfcm90YXRlUmlnaHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGMxID0gJ2xlZnRDaGlsZCc7XG4gICAgICAgIGMyID0gJ3JpZ2h0Q2hpbGQnO1xuICAgICAgICByb3RhdGUxID0gJ19yb3RhdGVSaWdodCc7XG4gICAgICAgIHJvdGF0ZTIgPSAnX3JvdGF0ZUxlZnQnO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbih0cmVlLCB6KXtcbiAgICAgICAgLy8gbm90ZTog5rOo6YeK5Lul5bem6L655Li65oOF5Ya1XG5cbiAgICAgICAgLy8g5Y+U57uT54K5XG4gICAgICAgIGxldCB5ID0gei5wYXJlbnQucGFyZW50W2MxXTtcblxuICAgICAgICAvLyDmj5LlhaXkv67lpI3mg4XlhrUx77ya5aaC5p6c5b2T5YmN57uT54K555qE54i257uT54K55piv57qi6Imy5LiU56WW54i257uT54K555qE5Y+m5LiA5Liq5a2Q57uT54K577yI5Y+U57uT54K577yJ5piv57qi6ImyXG4gICAgICAgIC8vIOWwhuW9k+WJjeiKgueCueeahOeItuiKgueCueWSjOWPlOWPlOiKgueCuea2gum7ke+8jOellueItue7k+eCuea2gue6ou+8jOaKiuW9k+WJjee7k+eCueaMh+WQkeellueItuiKgueCue+8jOS7juaWsOeahOW9k+WJjeiKgueCuemHjeaWsOW8gOWni+eul+azleOAglxuICAgICAgICBpZih5LmNvbG9yID09PSBSRUQpIHtcbiAgICAgICAgICAgIHoucGFyZW50LmNvbG9yID0gQkxBQ0s7XG4gICAgICAgICAgICB5LmNvbG9yID0gQkxBQ0s7XG4gICAgICAgICAgICB6LnBhcmVudC5wYXJlbnQuY29sb3IgPSBSRUQ7XG4gICAgICAgICAgICB6ID0gei5wYXJlbnQucGFyZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8g5o+S5YWl5L+u5aSN5oOF5Ya1Mu+8muW9k+WJjeiKgueCueeahOeItuiKgueCueaYr+e6ouiJsizlj5ToioLngrnmmK/pu5HoibLvvIzlvZPliY3oioLngrnmmK/lhbbniLboioLngrnnmoTlj7PlrZBcbiAgICAgICAgICAgIC8vIOino+WGs+WvueetluaYr++8muW9k+WJjeiKgueCueeahOeItuiKgueCueWBmuS4uuaWsOeahOW9k+WJjeiKgueCue+8jOS7peaWsOW9k+WJjeiKgueCueS4uuaUr+eCueW3puaXi+OAglxuICAgICAgICAgICAgLy8g5LuO6ICM5o+S5YWl5L+u5aSN5oOF5Ya1Mui9rOaNouaIkOS6huaPkuWFpeS/ruWkjeaDheWGtTPjgIJcbiAgICAgICAgICAgIGlmKHogPT09IHoucGFyZW50W2MxXSkge1xuICAgICAgICAgICAgICAgIHogPSB6LnBhcmVudDtcbiAgICAgICAgICAgICAgICB0cmVlW3JvdGF0ZTFdKHopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDmj5LlhaXkv67lpI3mg4XlhrUz77ya5b2T5YmN6IqC54K555qE54i26IqC54K55piv57qi6ImyLOWPlOiKgueCueaYr+m7keiJsu+8jOW9k+WJjeiKgueCueaYr+WFtueItuiKgueCueeahOW3puWtkFxuICAgICAgICAgICAgLy8g6Kej5Yaz5a+5562W5piv77ya54i26IqC54K55Y+Y5Li66buR6Imy77yM56WW54i26IqC54K55Y+Y5Li657qi6Imy77yM5Zyo56WW54i26IqC54K55Li65pSv54K55Y+z5peL77yMXG4gICAgICAgICAgICB6LnBhcmVudC5jb2xvciA9IEJMQUNLO1xuICAgICAgICAgICAgei5wYXJlbnQucGFyZW50LmNvbG9yID0gUkVEO1xuICAgICAgICAgICAgdHJlZVtyb3RhdGUyXSh6LnBhcmVudC5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxubGV0IGxlZnRBZGRGaXh1cCA9IGFkZEZpeHVwKCdsZWZ0Jyk7XG5sZXQgcmlnaHRBZGRGaXh1cCA9IGFkZEZpeHVwKCdyaWdodCcpO1xubGV0IGxlZnRSZW1vdmVGaXh1cCA9IHJlbW92ZUZpeHVwKCdsZWZ0Jyk7XG5sZXQgcmlnaHRSZW1vdmVGaXh1cCA9IHJlbW92ZUZpeHVwKCdyaWdodCcpO1xuXG5mdW5jdGlvbiByZW1vdmVGaXh1cChkaXIpe1xuICAgIGxldCBjMSwgYzIsIHIxLCByMjtcbiAgICBpZihkaXIgPT09ICdsZWZ0Jykge1xuICAgICAgICBjMSA9ICdyaWdodENoaWxkJztcbiAgICAgICAgYzIgPSAnbGVmdENoaWxkJztcbiAgICAgICAgcjEgPSAnX3JvdGF0ZUxlZnQnO1xuICAgICAgICByMiA9ICdfcm90YXRlUmlnaHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGMxID0gJ2xlZnRDaGlsZCc7XG4gICAgICAgIGMyID0gJ3JpZ2h0Q2hpbGQnO1xuICAgICAgICByMSA9ICdfcm90YXRlUmlnaHQnO1xuICAgICAgICByMiA9ICdfcm90YXRlTGVmdCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRyZWUsIHope1xuICAgICAgICAvLyBub3RlOiDms6jph4rku6Xlt6bovrnkuLrmg4XlhrVcblxuICAgICAgICAvLyDlj5Tnu5PngrlcbiAgICAgICAgbGV0IHcgPSB6LnBhcmVudFtjMV07XG5cbiAgICAgICAgLy8g5Yig6Zmk5L+u5aSN5oOF5Ya1Me+8muW9k+WJjeiKgueCueaYr+m7kSvpu5HkuJTlhYTlvJ/oioLngrnkuLrnuqLoibIo5q2k5pe254i26IqC54K55ZKM5YWE5byf6IqC54K555qE5a2Q6IqC54K55YiG5Li66buRKeOAglxuICAgICAgICAvLyDop6Pms5XvvJrmiorniLboioLngrnmn5PmiJDnuqLoibLvvIzmiorlhYTlvJ/nu5Pngrnmn5PmiJDpu5HoibLvvIzkuYvlkI7ph43mlrDov5vlhaXnrpfms5VcbiAgICAgICAgaWYody5jb2xvciA9PT0gUkVEKXtcbiAgICAgICAgICAgIHcuY29sb3IgPSBCTEFDSztcbiAgICAgICAgICAgIHoucGFyZW50LmNvbG9yID0gUkVEO1xuICAgICAgICAgICAgdHJlZVtyMV0oei5wYXJlbnQpO1xuICAgICAgICAgICAgdyA9IHoucGFyZW50W2MxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIOWIoOmZpOS/ruWkjeaDheWGtTLvvJrlvZPliY3oioLngrnmmK/pu5HliqDpu5HkuJTlhYTlvJ/mmK/pu5HoibLkuJTlhYTlvJ/oioLngrnnmoTkuKTkuKrlrZDoioLngrnlhajkuLrpu5HoibLjgIJcbiAgICAgICAgLy8g6Kej5rOV77ya5oqK5b2T5YmN6IqC54K55ZKM5YWE5byf6IqC54K55Lit5oq95Y+W5LiA6YeN6buR6Imy6L+95Yqg5Yiw54i26IqC54K55LiK77yM5oqK54i26IqC54K55b2T5oiQ5paw55qE5b2T5YmN6IqC54K577yM6YeN5paw6L+b5YWl566X5rOV44CCXG4gICAgICAgIGlmKHdbYzJdLmNvbG9yID09PSBCTEFDSyAmJiB3W2MxXS5jb2xvciA9PT0gQkxBQ0spe1xuICAgICAgICAgICAgdy5jb2xvciA9IFJFRDtcbiAgICAgICAgICAgIHogPSB6LnBhcmVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIOWIoOmZpOS/ruWkjeaDheWGtTPvvJrlvZPliY3oioLngrnpopzoibLmmK/pu5Er6buR77yM5YWE5byf6IqC54K55piv6buR6Imy77yM5YWE5byf55qE5bem5a2Q5piv57qi6Imy77yM5Y+z5a2Q5piv6buR6Imy44CCXG4gICAgICAgICAgICAvLyDop6Pms5XvvJrmiorlhYTlvJ/nu5Pngrnmn5PnuqLvvIzlhYTlvJ/lt6blrZDoioLngrnmn5Ppu5HvvIzkuYvlkI7lho3lnKjlhYTlvJ/oioLngrnkuLrmlK/ngrnop6Plj7Pml4vvvIzkuYvlkI7ph43mlrDov5vlhaXnrpfms5XjgIJcbiAgICAgICAgICAgIGlmKHdbYzFdLmNvbG9yID09PSBCTEFDSykge1xuICAgICAgICAgICAgICAgIHdbYzJdLmNvbG9yID0gQkxBQ0s7XG4gICAgICAgICAgICAgICAgdy5jb2xvciA9IFJFRDtcbiAgICAgICAgICAgICAgICB0cmVlW3IyXSh3KTtcbiAgICAgICAgICAgICAgICB3ID0gei5wYXJlbnRbYzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDliKDpmaTkv67lpI3mg4XlhrU077ya5b2T5YmN6IqC54K56aKc6Imy5piv6buRLem7keiJsu+8jOWug+eahOWFhOW8n+iKgueCueaYr+m7keiJsu+8jOS9huaYr+WFhOW8n+iKgueCueeahOWPs+WtkOaYr+e6ouiJsu+8jOWFhOW8n+iKgueCueW3puWtkOeahOminOiJsuS7u+aEj+OAglxuICAgICAgICAgICAgLy8g6Kej5rOV77ya5oqK5YWE5byf6IqC54K55p+T5oiQ5b2T5YmN6IqC54K554i26IqC54K555qE6aKc6Imy77yM5oqK5b2T5YmN6IqC54K554i26IqC54K55p+T5oiQ6buR6Imy77yM5YWE5byf6IqC54K55Y+z5a2Q5p+T5oiQ6buR6Imy77yM5LmL5ZCO5Lul5b2T5YmN6IqC54K555qE54i26IqC54K55Li65pSv54K56L+b6KGM5bem5peL77yM5q2k5pe2566X5rOV57uT5p2f77yM57qi6buR5qCR5omA5pyJ5oCn6LSo6LCD5pW05q2j56GuXG4gICAgICAgICAgICB3LmNvbG9yID0gei5wYXJlbnQuY29sb3I7XG4gICAgICAgICAgICB6LnBhcmVudC5jb2xvciA9IEJMQUNLO1xuICAgICAgICAgICAgd1tjMV0uY29sb3IgPSBCTEFDSztcbiAgICAgICAgICAgIHRyZWVbcjFdKHoucGFyZW50KTtcbiAgICAgICAgICAgIHogPSB0cmVlLnJvb3Q7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbmxldCB0ZXN0ID0gbmV3IFJlZEJsYWNrVHJlZSgpO1xudGVzdC5hZGQoMTMpO1xudGVzdC5hZGQoOCk7XG50ZXN0LmFkZCgxNyk7XG50ZXN0LmFkZCgxKTtcbnRlc3QuYWRkKDYpO1xudGVzdC5hZGQoMTEpO1xudGVzdC5hZGQoMTUpO1xudGVzdC5hZGQoMjIpO1xudGVzdC5hZGQoMjUpO1xudGVzdC5hZGQoMjcpO1xuXG50ZXN0LnJlbW92ZSgxMyk7XG50ZXN0LnJlbW92ZSg4KTtcbnRlc3QucmVtb3ZlKDE3KTtcbnRlc3QucmVtb3ZlKDEpO1xudGVzdC5yZW1vdmUoNik7XG50ZXN0LnJlbW92ZSgxMSk7XG50ZXN0LnJlbW92ZSgxNSk7XG50ZXN0LnJlbW92ZSgyMik7XG50ZXN0LnJlbW92ZSgyNSk7XG50ZXN0LnJlbW92ZSgyNyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU2VhcmNoL1JlZEJsYWNrVHJlZS5qcyIsIi8qXG4g6Z2Z5oCB5qyh5LyY5p+l5om+5qCRXG5cbiDpgILlkIjlkITorrDlvZXnmoTmn6Xmib7mpoLnjofkuI3nrYnnmoTmg4XlhrVcblxuIOafpeaJvuaViOeOh+acgOmrmOWNs+W5s+Wdh+afpeaJvumVv+W6puacgOWwj++8jOaIkeS7rOWPr+S7pee7meWHuuacieW6j+ihqOWcqOmdnuetieamgueOh+aDheWGteS4i+W6lOmBteW+queahOS4pOS4quWOn+WIme+8mlxuIDHjgIHmnIDlhYjorr/pl67nmoTnu5PngrnlupTmmK/orr/pl67mpoLnjofmnIDlpKfnmoTnu5PngrnvvJtcbiAy44CB5q+P5qyh6K6/6Zeu5bqU5L2/57uT54K55Lik6L655bCa5pyq6K6/6Zeu55qE57uT54K555qE6KKr6K6/5qaC546H5LmL5ZKM5bC95Y+v6IO955u4562J44CCXG5cblxuIOi/meS4pOS4quWOn+WImeWPr+eUqOS4gOWPpeivneadpeihqOekuu+8jOWNs+WIpOWumuagkeS4uuW4puadg+WGhei3r+W+hOmVv+W6puS5i+WSjOacgOWwj+eahOS6jOWPieagke+8jOS6puWNs++8mlBIID0g4oiRd2loaSAg5pyA5bCP77yM5YW25LitIG4g5Li65pyJ5bqP6KGo6ZW/5bqm77yMaGkg5Li656ysIGkg5Liq57uT54K55Zyo5Yik5a6a5qCR5LiK55qE5bGC5qyh5pWw77yMd2kgPSBjcGnvvIxjIOS4uuafkOS4quW4uOaVsO+8jHBpIOS4uuesrCBpIOS4que7k+eCueeahOafpeaJvuamgueOh+OAglxuXG5cbiDov5nmoLfnmoTmoJHnp7DkuLrpnZnmgIHmnIDkvJjmn6Xmib7moJHvvIhzdGF0aWMgb3B0aW1hbCBzZWFyY2ggdHJlZe+8ie+8jOaehOmAoOi/meagt+S4gOajteagkeeahOaXtumXtOS7o+S7t+WkquWkp++8jOS6puWNs+aXtumXtOWkjeadguW6puW+iOWkp++8jOWboOatpOaIkeS7rOmAmuW4uOaYr+aehOmAoOasoeS8mOafpeaJvuagke+8iG5lYXJseSBvcHRpbWFsIHNlYXJjaCB0cmVl77yJ77yM5p6E6YCg5a6D55qE5pe26Ze05Luj5Lu36L+c6L+c5L2O5LqO5p6E6YCg5pyA5LyY5p+l5om+5qCR77yM5L2G5p+l5om+5oCn6IO95Y+q5q+U5pyA5LyY5p+l5om+5qCR5beuMSV+MiXvvIzlvojlsJHlt64zJeS7peS4iuOAglxuXG4g5qyh5LyY5p+l5om+5qCR55qE5p6E6YCg77yaXG5cbiDorr7mnInluo/ooajmr4/kuKrorrDlvZXnmoTmnYPlgLzkuLogd2wsd2wrMSzigKYsd2jvvIznrKzkuIDkuKrlupTorr/pl67nmoTnu5Pngrnlj7fkuLogaSDvvIzliJnmnInvvJpcbiDOlHBpID0gICDiiJF3aiAtIOKIkXdqICAg5pyA5bCP77yM5Y2zIM6UcGkgPSBNaW4ge86UcGogfVxuIOWGjeWIhuWIq+WvuSB7cmwscmwrMSzigKYscmktMX0g5ZKMIHtyaSsxLHJpKzIs4oCmLHJofSDliIbliKvmnoTpgKDmrKHkvJjmn6Xmib7moJFcbiAqL1xuaW1wb3J0IHsgQmluYXJ5VHJlZSB9IGZyb20gJy4uL0JpbmFyeVRyZWUvQmluYXJ5VHJlZSc7XG5cbi8qKlxuICog55Sx5pyJ5bqP6KGoc1RhYmxlW2xvdy4uaGlnaF3lj4rlhbbntK/orqHmnYPlgLzooah3ZWlnaHRz6YCS5b2S5p6E6YCg5qyh5LyY5p+l5om+5qCRXG4gKiBAcGFyYW0ge0JpbmFyeVRyZWV9IHRyZWVcbiAqIEBwYXJhbSB7QXJyYXl9IHNUYWJsZVxuICogQHBhcmFtIHtBcnJheX0gc1dlaWdodHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWNvbmRPcHRpbWFsKHRyZWUsIHNUYWJsZSwgc1dlaWdodHMsIGxvdywgaGlnaCkge1xuICAgIGxldCBpID0gbG93O1xuICAgIGxldCBtaW4gPSBNYXRoLmFicyhzV2VpZ2h0c1toaWdoXSAtIHNXZWlnaHRzW2xvd10pO1xuICAgIGxldCBkdyA9IHNXZWlnaHRzW2hpZ2hdICsgKHNXZWlnaHRzW2xvdyAtIDFdIHx8IDApO1xuXG4gICAgLy8g6YCJ5oup5pyA5bCP55qE4pazUGnlgLxcbiAgICBmb3IgKGxldCBqID0gbG93ICsgMTsgaiA8PSBoaWdoOyArK2opIHtcbiAgICAgICAgbGV0IHQgPSBNYXRoLmFicyhkdyAtIHNXZWlnaHRzW2pdIC0gc1dlaWdodHNbaiAtIDFdKTtcbiAgICAgICAgaWYgKHQgPCBtaW4pIHtcbiAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgbWluID0gdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIOiwg+aVtOagkeagueadg++8jOmAieaLqemCu+i/keadg+WAvOi+g+Wkp+eahOWFs+mUruWtl1xuICAgIGxldCBhID0gMCwgYiwgYyA9IDA7XG4gICAgaWYgKGkgLSAxID49IGxvdykgIGIgPSBzV2VpZ2h0c1tpXSAtIHNXZWlnaHRzW2kgLSAxXTtcbiAgICBpZiAoaSAtIDIgPj0gbG93KSBhID0gc1dlaWdodHNbaSAtIDFdIC0gc1dlaWdodHNbaSAtIDJdO1xuICAgIGlmIChpICsgMSA8IGhpZ2gpIGMgPSBzV2VpZ2h0c1tpICsgMV0gLSBzV2VpZ2h0c1tpXTtcbiAgICBpZiAodHlwZW9mIGIgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChhID4gYyAmJiBhID4gYikgLS1pO1xuICAgICAgICBlbHNlIGlmIChhIDwgYyAmJiBjID4gYikgICsraTtcbiAgICB9XG5cbiAgICB0cmVlLmRhdGEgPSBzVGFibGVbaV07XG4gICAgLy/lt6blrZDmoJFcbiAgICBpZiAoaSA9PT0gbG93KSB0cmVlLmxlZnRDaGlsZCA9IG51bGw7XG4gICAgZWxzZSB7XG4gICAgICAgIHRyZWUubGVmdENoaWxkID0gbmV3IEJpbmFyeVRyZWUoKTtcbiAgICAgICAgc2Vjb25kT3B0aW1hbCh0cmVlLmxlZnRDaGlsZCwgc1RhYmxlLCBzV2VpZ2h0cywgbG93LCBpIC0gMSk7XG4gICAgfVxuICAgIC8vIOWPs+WtkOagkVxuICAgIGlmIChpID09PSBoaWdoKSB0cmVlLnJpZ2h0Q2hpbGQgPSBudWxsO1xuICAgIGVsc2Uge1xuICAgICAgICB0cmVlLnJpZ2h0Q2hpbGQgPSBuZXcgQmluYXJ5VHJlZSgpO1xuICAgICAgICBzZWNvbmRPcHRpbWFsKHRyZWUucmlnaHRDaGlsZCwgc1RhYmxlLCBzV2VpZ2h0cywgaSArIDEsIGhpZ2gpO1xuICAgIH1cbn1cblxubGV0IHRyZWUgPSBuZXcgQmluYXJ5VHJlZSgpO1xuc2Vjb25kT3B0aW1hbCh0cmVlLCBbJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJ10sIFsxLCAyLCA0LCA5LCAxMiwgMTYsIDIwLCAyMywgMjhdLCAwLCA4KTtcbmNvbnNvbGUubG9nKHRyZWUpO1xuXG5cbi8qKlxuICog55Sx5pyJ5bqP6KGo5p6E6YCg5LiA5qO15qyh5LyY5p+l5om+5qCRXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIOacieW6j+ihqO+8jOaVsOaNruWFg+e0oOWQq+acieadg+Wfn3dlaWdodFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU09TVHJlZShvYmopIHtcbiAgICBsZXQgdHJlZTtcbiAgICBpZiAob2JqLmVsZW1zLmxlbmd0aCA9PT0gMCkgdHJlZSA9IG51bGw7XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIOaxgue0r+iuoeadg+WAvOihqFxuICAgICAgICBsZXQgc3cgPSBmaW5kU1cob2JqLndlaWdodHMpO1xuICAgICAgICB0cmVlID0gbmV3IEJpbmFyeVRyZWUoKTtcbiAgICAgICAgc2Vjb25kT3B0aW1hbCh0cmVlLCBvYmouZWxlbXMsIHN3LCAwLCBvYmouZWxlbXMubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyZWU7XG59XG5cbmZ1bmN0aW9uIGZpbmRTVyhzVGFibGUpIHtcbiAgICBsZXQgc3cgPSBbc1RhYmxlWzBdXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc1RhYmxlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHN3W2ldID0gc3dbaSAtIDFdICsgc1RhYmxlW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBzdztcbn1cblxubGV0IHNvc1RyZWUgPSBjcmVhdGVTT1NUcmVlKHtcbiAgICBlbGVtczogWydBJywgJ0InLCAnQycsICdEJywgJ0UnXSxcbiAgICB3ZWlnaHRzOiBbMSwgMzAsIDIsIDI5LCAzXVxufSk7XG5zb3NUcmVlLmluT3JkZXJSZWN1cnNpdmUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgY29uc29sZS5sb2coJ2luT3JkZXI6ICcgKyB2YWx1ZSk7XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TZWFyY2gvU09TVHJlZS5qcyIsIi8qXG7lkI7nvIDmoJHnrpfmmK/lvojluLjop4HnmoTlrZfnrKbkuLLmlbDmja7nu5PmnoTkuYvkuIDkuobvvIzlroPlnKjmqKHlvI/ljLnphY3kuK3nmoTlupTnlKjpnZ7luLjlpJrvvIzmr5TlpoJETkHluo/liJfmo4DmtYvnrYnjgIJcblxu5ZCO57yA5qCR55qE5Z+65pys5oCd6Lev5piv5piv5a+55LiA5Liq5a2X56ym5Liy55qE5omA5pyJ5ZCO57yA5a2Q5Liy5LulVHJpZXPnmoTmlrnlvI/ov5vooYzmj4/ov7DvvIzku47ogIzlj6/ku6Xov4XpgJ/lnLDlnKjlkI7nvIDmoJHkuIrmib7lh7rlrZfnrKbkuLLnmoTku7vmhI/lrZDkuLLjgIJcblxu5omA5Lul5a+55LqO5bey57uP5bu656uL5LqG5ZCO57yA5qCR55qE5a2X56ym5Liy77yM5YGa5a2X56ym5Liy5p+l5om+5bey57uP566X5piv6Z2e5bi4566A5Y2V55qE5Lu75Yqh5LqG77yM5ZCM5pe255Sx5LqOVHJpZXPnmoTnibnngrnvvIzov5nnp43nu5PmnoTlj6/ku6Xlvojmlrnkvr/lnLDlpITnkIbliY0v5ZCO5Lu75oSP5a2X56ym5Liy5Yy56YWN77yI5q+U5aaC4oCcKkFCQ+KAneWSjOKAnEFCQyrigJ3vvInvvIzkuLrkuobopoHlpITnkIbkuK3pl7TnmoR3aWxkY2FyZO+8jOavlOWmgkFCQypERUbvvIzlj6/ku6XliIbliKvmn6Xmib5BQkMq5ZKMKkRFRu+8jOeEtuWQjuWGjeWPluS6pOmbhuWNs+WPr+OAglxuXG7lkI7nvIDmoJHkuZ/lvojpgILlkIjkuo7lpJrmqKHljLnphY3pl67popjvvIzkvYblroPpgILnlKjnmoTlnLrmma/kuLvopoHmmK/lvoXljLnphY3lrZfnrKbkuLLlm7rlrprvvIzogIzmqKHlvI/kuLLmnKrlrprnmoTlnLrmma/jgIJcblxu5LiA5Liq5Yip55So5ZCO57yA5qCR55qE5YW45Z6L5bqU55So5pivTENT77yITG9uZ2VzdCBDb21tb24gU3Vic3RyaW5n77yJ5pyA5aSn5YWs5YWx5a2Q5Liy6Zeu6aKY44CC6YeH55So5Yqo5oCB6KeE5YiS5Lmf5Y+v5Lul5b6I5a655piT5Zyw6Kej5YazTENT6Zeu6aKY77yM5L2G5a6D55qE5pe256m65aSN5p2C5bqm5Z2H5Li6TyhOKk0p77yM5a+55LqO5aSn5aSa5pWw5bqU55So5piv5aSf5LqG77yM5Y+v5piv77yM5aaC5p6c5Lik5Liq5a2X56ym5Liy5pivRE5B5bqP5YiX77yM6KaB5LuO5Lit6Ze05om+5Ye65YWs5YWx5a2Q5Liy77yMTyhOKk0p55qE5pe256m65aSN5p2C5bqm5pi+54S25piv5peg5rOV5o6l5Y+X55qE44CC6ICM6YeH55So5ZCO57yA5qCR77yM5aSN5p2C5bqm5bCx5Y+q5piv5ZCO57yA5qCR5Yib5bu655qE5aSN5p2C5bqm77yM5Y2zTyhOKVxuXG7lkI7nvIDmoJHnmoTlupTnlKhcblxuMS7mn6Xmib7lrZfnrKbkuLIgUGF0dGVybiDmmK/lkKblnKjkuo7lrZfnrKbkuLIgVGV4dCDkuK1cbiAgICDmlrnmoYjvvJrnlKggVGV4dCDmnoTpgKDlkI7nvIDmoJHvvIzmjInlnKggVHJpZSDkuK3mkJzntKLlrZfkuLLnmoTmlrnms5XmkJzntKIgUGF0dGVybiDljbPlj6/jgILoi6UgUGF0dGVybiDlnKggVGV4dCDkuK3vvIzliJkgUGF0dGVybiDlv4XnhLbmmK8gVGV4dCDnmoTmn5DkuKrlkI7nvIDnmoTliY3nvIDjgIJcbjIu6K6h566X5oyH5a6a5a2X56ym5LiyIFBhdHRlcm4g5Zyo5a2X56ym5LiyIFRleHQg5Lit55qE5Ye6546w5qyh5pWwXG4gICAg5pa55qGI77ya55SoIFRleHQrJyQnIOaehOmAoOWQjue8gOagke+8jOaQnOe0oiBQYXR0ZXJuIOaJgOWcqOiKgueCueS4i+eahOWPtuiKgueCueaVsOebruWNs+S4uumHjeWkjeasoeaVsOOAguWmguaenCBQYXR0ZXJuIOWcqCBUZXh0IOS4remHjeWkjeS6hiBjIOasoe+8jOWImSBUZXh0IOW6lOaciSBjIOS4quWQjue8gOS7pSBQYXR0ZXJuIOS4uuWJjee8gOOAglxuMy7mn6Xmib7lrZfnrKbkuLIgVGV4dCDkuK3nmoTmnIDplb/ph43lpI3lrZDkuLJcbiAgICDmlrnmoYjvvJrnlKggVGV4dCsnJCcg5p6E6YCg5ZCO57yA5qCR77yM5pCc57SiIFBhdHRlcm4g5omA5Zyo6IqC54K55LiL55qE5pyA5rex55qE6Z2e5Y+26IqC54K544CC5LuOIHJvb3Qg5Yiw6K+l6IqC54K55omA57uP5Y6G6L+H55qE5a2X56ym5Liy5bCx5piv5pyA6ZW/6YeN5aSN5a2Q5Liy44CCXG40LuafpeaJvuS4pOS4quWtl+espuS4siBUZXh0MSDlkowgVGV4dDIg55qE5pyA6ZW/5YWs5YWx6YOo5YiGXG4gICAg5pa55qGI77ya6L+e5o6lIFRleHQxKycjJyArIFRleHQyKyckJyDlvaLmiJDmlrDnmoTlrZfnrKbkuLLlubbmnoTpgKDlkI7nvIDmoJHvvIzmib7liLDmnIDmt7HnmoTpnZ7lj7boioLngrnvvIzkuJTor6XoioLngrnnmoTlj7boioLngrnml6LmnIkgJyMnIOS5n+aciSAnJCfjgIJcbjUu5p+l5om+57uZ5a6a5a2X56ym5LiyIFRleHQg6YeM55qE5pyA6ZW/5Zue5paHXG7lm57mlofmjIfvvJpcImFiY2RlZmdmZWRcIiDkuK3lr7nnp7DnmoTlrZfnrKbkuLIgXCJkZWZnZmVkXCLjgIJcbuWbnuaWh+WNiuW+hOaMh++8muWbnuaWhyBcImRlZmdmZWRcIiDnmoTlm57mlofljYrlvoQgXCJkZWZnXCIg6ZW/5bqm5Li6IDTvvIzljYrlvoTkuK3lv4PkuLrlrZfmr40gXCJnXCLjgIJcbiAgICDmlrnmoYjvvJrlsIYgVGV4dCDmlbTkvZPlj43ovazlvaLmiJDmlrDnmoTlrZfnrKbkuLIgVGV4dDLvvIzkvovlpoIgXCJhYmNkZWZnZmVkXCIgPT4gXCJkZWZnZmVkY2JhXCLjgILov57mjqUgVGV4dCsnIycgKyBUZXh0MisnJCcg5b2i5oiQ5paw55qE5a2X56ym5Liy5bm25p6E6YCg5ZCO57yA5qCR77yM54S25ZCO5bCG6Zeu6aKY6L2s5Y+Y5Li65p+l5om+IFRleHQg5ZKMIFRleHQxIOeahOacgOmVv+WFrOWFsemDqOWIhuOAglxuXG5odHRwOi8vd3d3LmNuYmxvZ3MuY29tL2dhb2NodW5kb25nL3Avc3VmZml4X3RyZWUuaHRtbFxuaHR0cDovL3ZpY2t5cWkuY29tLzIwMTUvMTEvMjcvJUU2JTk1JUIwJUU2JThEJUFFJUU3JUJCJTkzJUU2JTlFJTg0JUU3JUIzJUJCJUU1JTg4JTk3JUUyJTgwJTk0JUUyJTgwJTk0JUU1JTkwJThFJUU3JUJDJTgwJUU2JUEwJTkxSmF2YSVFNSVBRSU5RSVFNyU4RSVCMCVFNCVCQiVBMyVFNyVBMCU4MS9cbiovXG5cbmNsYXNzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIC8vIHRoZSBpbmRleCBvZiBhIG5vZGUgd2l0aCBhIG1hdGNoaW5nIHN1ZmZpeCwgcmVwcmVzZW50aW5nIGEgc3VmZml4IGxpbmsuXG4gICAgICAgIC8vIC0xIGluZGljYXRlcyB0aGlzIG5vZGUgaGFzIG5vIHN1ZmZpeCBsaW5rLlxuICAgICAgICB0aGlzLnN1ZmZpeE5vZGUgPSAtMTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpe1xuICAgICAgICByZXR1cm4gYE5vZGUoc3VmZml4IGxpbms6ICR7IHRoaXMuc3VmZml4Tm9kZSB9KWA7XG4gICAgfVxufVxuXG5jbGFzcyBFZGdlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEVkZ2UuXG4gICAgICogQHBhcmFtIHthbnl9IGZpcnN0Q2hhckluZGV4ICBpbmRleCBvZiBzdGFydCBvZiBzdHJpbmcgcGFydCByZXByZXNlbnRlZCBieSB0aGlzIGVkZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gbGFzdENoYXJJbmRleCBpbmRleCBvZiBlbmQgb2Ygc3RyaW5nIHBhcnQgcmVwcmVzZW50ZWQgYnkgdGhpcyBlZGdlXG4gICAgICogQHBhcmFtIHthbnl9IHNvdXJjZU5vZGVJbmRleCBuZGV4IG9mIHNvdXJjZSBub2RlIG9mIGVkZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gZGVzdE5vZGVJbmRleCBpbmRleCBvZiBkZXN0aW5hdGlvbiBub2RlIG9mIGVkZ2VcbiAgICAgKiBcbiAgICAgKiBAbWVtYmVyT2YgRWRnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZpcnN0Q2hhckluZGV4LCBsYXN0Q2hhckluZGV4LCBzb3VyY2VOb2RlSW5kZXgsIGRlc3ROb2RlSW5kZXgpe1xuICAgICAgICB0aGlzLmZpcnN0Q2hhckluZGV4ID0gZmlyc3RDaGFySW5kZXg7XG4gICAgICAgIHRoaXMubGFzdENoYXJJbmRleCA9IGxhc3RDaGFySW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZUluZGV4ID0gc291cmNlTm9kZUluZGV4O1xuICAgICAgICB0aGlzLmRlc3ROb2RlSW5kZXggPSBkZXN0Tm9kZUluZGV4O1xuICAgIH1cblxuICAgIGdldCBsZW5ndGggKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDaGFySW5kZXggLSB0aGlzLmZpcnN0Q2hhckluZGV4O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCl7XG4gICAgICAgIHJldHVybiBgRWRnZSgke3RoaXMuc291cmNlTm9kZUluZGV4fSwgJHt0aGlzLmRlc3ROb2RlSW5kZXh9LCAke3RoaXMuZmlyc3RDaGFySW5kZXh9LCAke3RoaXMubGFzdENoYXJJbmRleH0pYDtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdWZmaXggZnJvbSBmaXJzdF9jaGFyX2luZGV4IHRvIGxhc3RfY2hhcl9pbmRleC5cbiAqIFxuICogQGNsYXNzIFN1ZmZpeFxuICovXG5jbGFzcyBTdWZmaXgge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgU3VmZml4LlxuICAgICAqIEBwYXJhbSB7YW55fSBzb3VyY2VOb2RlSW5kZXggaW5kZXggb2Ygbm9kZSB3aGVyZSB0aGlzIHN1ZmZpeCBzdGFydHNcbiAgICAgKiBAcGFyYW0ge2FueX0gZmlyc3RDaGFySW5kZXggaW5kZXggb2Ygc3RhcnQgb2Ygc3VmZml4IGluIHN0cmluZ1xuXG4gICAgICogQHBhcmFtIHthbnl9IGxhc3RDaGFySW5kZXggaW5kZXggb2YgZW5kIG9mIHN1ZmZpeCBpbiBzdHJpbmdcbiAgICAgKiBcbiAgICAgKiBAbWVtYmVyT2YgU3VmZml4XG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc291cmNlTm9kZUluZGV4LCBmaXJzdENoYXJJbmRleCwgbGFzdENoYXJJbmRleCl7XG4gICAgICAgIHRoaXMuc291cmNlTm9kZUluZGV4ID0gc291cmNlTm9kZUluZGV4O1xuICAgICAgICB0aGlzLmZpcnN0Q2hhckluZGV4ID0gZmlyc3RDaGFySW5kZXg7XG4gICAgICAgIHRoaXMubGFzdENoYXJJbmRleCA9IGxhc3RDaGFySW5kZXg7XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q2hhckluZGV4IC0gdGhpcy5maXJzdENoYXJJbmRleDtcbiAgICB9XG5cbiAgICBnZXQgZXhwbGljaXQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RDaGFySW5kZXggPiB0aGlzLmxhc3RDaGFySW5kZXhcbiAgICB9XG5cbiAgICBnZXQgaW1wbGljaXQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENoYXJJbmRleCA+PSB0aGlzLmZpcnN0Q2hhckluZGV4O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIHN1ZmZpeCB0cmVlIGZvciBzdHJpbmcgbWF0Y2hpbmcuIFVzZXMgVWtrb25lbidzIGFsZ29yaXRobVxuICAgIGZvciBjb25zdHJ1Y3Rpb24uXG4gKiBcbiAqIEBjbGFzcyBTdWZmaXhUcmVlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1ZmZpeFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZywgY2FzZUluc2Vuc2l0aXZlKXtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMuY2FzZUluc2Vuc2l0aXZlID0gY2FzZUluc2Vuc2l0aXZlO1xuICAgICAgICB0aGlzLk4gPSBzdHJpbmcubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtuZXcgTm9kZSgpXTtcbiAgICAgICAgdGhpcy5lZGdlcyA9IHt9O1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IG5ldyBTdWZmaXgoMCwgMCwgLTEpO1xuXG4gICAgICAgIGlmKGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdGhpcy5hZGRQcmVmaXgoaSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0cyBlZGdlcyBpbiB0aGUgc3VmZml4IHRyZWVcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBcbiAgICAgKiBcbiAgICAgKiBAbWVtYmVyT2YgU3VmZml4VHJlZVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCl7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLk47XG4gICAgICAgIGxldCBzID0gYFxcdFN0YXJ0IFxcdEVuZCBcXHRTdWYgXFx0Rmlyc3QgXFx0TGFzdCBcXHRTdHJpbmdcXG5gO1xuICAgICAgICBsZXQgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyh0aGlzLmVkZ2VzKTtcbiAgICAgICAgdmFsdWVzLnNvcnQoKGEsIGIpID0+IGEuc291cmNlTm9kZUluZGV4IC0gYi5zb3VyY2VOb2RlSW5kZXgpO1xuXG4gICAgICAgIGZvcihsZXQgZWRnZSBvZiB2YWx1ZXMpe1xuICAgICAgICAgICAgaWYoZWRnZS5zb3VyY2VOb2RlSW5kZXggPT09IC0xKSBjb250aW51ZTtcblxuICAgICAgICAgICAgcyArPSBgXFx0JHtlZGdlLnNvdXJjZU5vZGVJbmRleH0gXFx0JHtlZGdlLmRlc3ROb2RlSW5kZXh9IFxcdCR7dGhpcy5ub2Rlc1tlZGdlLmRlc3ROb2RlSW5kZXhdLnN1ZmZpeE5vZGV9IFxcdCR7ZWRnZS5maXJzdENoYXJJbmRleH0gXFx0JHtlZGdlLmxhc3RDaGFySW5kZXh9IFxcdGA7XG5cbiAgICAgICAgICAgIGxldCB0b3AgPSBNYXRoLm1pbihjdXJyZW50SW5kZXgsIGVkZ2UubGFzdENoYXJJbmRleCk7XG4gICAgICAgICAgICBzICs9IHRoaXMuc3RyaW5nLnN1YnN0cmluZyhlZGdlLmZpcnN0Q2hhckluZGV4LCB0b3AgKyAxKSArICdcXG4nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvcmUgY29uc3RydWN0aW9uIG1ldGhvZC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2FueX0gbGFzdENoYXJJbmRleCBcbiAgICAgKiBcbiAgICAgKiBAbWVtYmVyT2YgU3VmZml4VHJlZVxuICAgICAqL1xuICAgIGFkZFByZWZpeChsYXN0Q2hhckluZGV4KXtcbiAgICAgICAgbGV0IGxhc3RQYXJlbnROb2RlID0gLTE7XG4gICAgICAgIGxldCBlID0gbnVsbDtcbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSAtMTtcblxuICAgICAgICB3aGlsZSh0cnVlKXtcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSB0aGlzLmFjdGl2ZS5zb3VyY2VOb2RlSW5kZXg7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuYWN0aXZlLmV4cGxpY2l0KXtcbiAgICAgICAgICAgICAgICAvLyBwcmVmaXggaXMgYWxyZWFkeSBpbiB0cmVlXG4gICAgICAgICAgICAgICAgaWYodGhpcy5lZGdlc1tgJHt0aGlzLmFjdGl2ZS5zb3VyY2VOb2RlSW5kZXh9LSR7dGhpcy5zdHJpbmdbbGFzdENoYXJJbmRleF19YF0pIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlID0gdGhpcy5lZGdlc1tgJHt0aGlzLmFjdGl2ZS5zb3VyY2VOb2RlSW5kZXh9LSR7dGhpcy5zdHJpbmdbdGhpcy5hY3RpdmUuZmlyc3RDaGFySW5kZXhdfWBdO1xuXG4gICAgICAgICAgICAgICAgLy8gcHJlZml4IGlzIGFscmVhZHkgaW4gdHJlZVxuICAgICAgICAgICAgICAgIGlmKHRoaXMuc3RyaW5nW2UuZmlyc3RDaGFySW5kZXggKyB0aGlzLmFjdGl2ZS5sZW5ndGgrIDFdID09PSB0aGlzLnN0cmluZ1tsYXN0Q2hhckluZGV4XSkgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gdGhpcy5fc3BsaXRFZGdlKGUsIHRoaXMuYWN0aXZlKTs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgTm9kZSgpKTtcbiAgICAgICAgICAgIGUgPSBuZXcgRWRnZShsYXN0Q2hhckluZGV4LCB0aGlzLk4sIHBhcmVudE5vZGUsIHRoaXMubm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB0aGlzLl9pbnNlcnRFZGdlKGUpO1xuXG4gICAgICAgICAgICBpZihsYXN0UGFyZW50Tm9kZSA+IDApe1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXNbbGFzdFBhcmVudE5vZGVdLnN1ZmZpeE5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdFBhcmVudE5vZGUgPSBwYXJlbnROb2RlO1xuXG4gICAgICAgICAgICBpZih0aGlzLmFjdGl2ZS5zb3VyY2VOb2RlSW5kZXggPT09IDApe1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlLmZpcnN0Q2hhckluZGV4ICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlLnNvdXJjZU5vZGVJbmRleCA9IHRoaXMubm9kZXNbdGhpcy5hY3RpdmUuc291cmNlTm9kZUluZGV4XS5zdWZmaXhOb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9jYW5vbml6ZVN1ZmZpeCh0aGlzLmFjdGl2ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihsYXN0UGFyZW50Tm9kZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubm9kZXNbbGFzdFBhcmVudE5vZGVdLnN1ZmZpeE5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hY3RpdmUubGFzdENoYXJJbmRleCArPSAxO1xuICAgICAgICB0aGlzLl9jYW5vbml6ZVN1ZmZpeCh0aGlzLmFjdGl2ZSk7XG4gICAgfVxuXG4gICAgX2luc2VydEVkZ2UoZWRnZSl7XG4gICAgICAgIHRoaXMuZWRnZXNbYCR7ZWRnZS5zb3VyY2VOb2RlSW5kZXh9LSR7dGhpcy5zdHJpbmdbZWRnZS5maXJzdENoYXJJbmRleF19YF0gPSBlZGdlO1xuICAgIH1cblxuICAgIF9yZW1vdmVFZGdlKGVkZ2Upe1xuICAgICAgICBkZWxldGUgdGhpcy5lZGdlc1tgJHtlZGdlLnNvdXJjZU5vZGVJbmRleH0tJHt0aGlzLnN0cmluZ1tlZGdlLmZpcnN0Q2hhckluZGV4XX1gXTtcbiAgICB9XG5cbiAgICBfc3BsaXRFZGdlKGVkZ2UsIHN1ZmZpeCl7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgTm9kZSgpKTtcbiAgICAgICAgbGV0IGUgPSBuZXcgRWRnZShlZGdlLmZpcnN0Q2hhckluZGV4LCBlZGdlLmZpcnN0Q2hhckluZGV4ICsgc3VmZml4Lmxlbmd0aCwgc3VmZml4LnNvdXJjZU5vZGVJbmRleCwgdGhpcy5ub2Rlcy5sZW5ndGggLSAxKTtcblxuICAgICAgICB0aGlzLl9yZW1vdmVFZGdlKGVkZ2UpO1xuICAgICAgICB0aGlzLl9pbnNlcnRFZGdlKGUpO1xuICAgICAgICBcbiAgICAgICAgLy8gbmVlZCB0byBhZGQgbm9kZSBmb3IgZWFjaCBlZGdlXG4gICAgICAgIHRoaXMubm9kZXNbZS5kZXN0Tm9kZUluZGV4XS5zdWZmaXhOb2RlID0gc3VmZml4LnNvdXJjZU5vZGVJbmRleDtcbiAgICAgICAgZWRnZS5maXJzdENoYXJJbmRleCArPSBzdWZmaXgubGVuZ3RoICsgMTtcbiAgICAgICAgZWRnZS5zb3VyY2VOb2RlSW5kZXggPSBlLmRlc3ROb2RlSW5kZXg7XG5cbiAgICAgICAgdGhpcy5faW5zZXJ0RWRnZShlZGdlKTtcblxuICAgICAgICByZXR1cm4gZS5kZXN0Tm9kZUluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgY2Fub25pemVzIHRoZSBzdWZmaXgsIHdhbGtpbmcgYWxvbmcgaXRzIHN1ZmZpeCBzdHJpbmcgdW50aWwgaXQgXG4gICAgICAgIGlzIGV4cGxpY2l0IG9yIHRoZXJlIGFyZSBubyBtb3JlIG1hdGNoZWQgbm9kZXNcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2FueX0gc3VmZml4IFxuICAgICAqIFxuICAgICAqIEBtZW1iZXJPZiBTdWZmaXhUcmVlXG4gICAgICovXG4gICAgX2Nhbm9uaXplU3VmZml4KHN1ZmZpeCl7XG4gICAgICAgIGlmKCFzdWZmaXguZXhwbGljaXQpe1xuICAgICAgICAgICAgbGV0IGUgPSB0aGlzLmVkZ2VzW2Ake3N1ZmZpeC5zb3VyY2VOb2RlSW5kZXh9LSR7dGhpcy5zdHJpbmdbc3VmZml4LmZpcnN0Q2hhckluZGV4XX1gXTtcbiAgICAgICAgICAgIGlmKGUubGVuZ3RoIDw9IHN1ZmZpeC5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIHN1ZmZpeC5maXJzdENoYXJJbmRleCArPSBlLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgc3VmZml4LnNvdXJjZU5vZGVJbmRleCA9IGUuZGVzdE5vZGVJbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5vbml6ZVN1ZmZpeChzdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2Ygc3Vic3RyaW5nIGluIHN0cmluZyBvciAtMSBpZiBpdFxuICAgICAgICBpcyBub3QgZm91bmQuXG4gICAgICogXG4gICAgICogQHBhcmFtIHthbnl9IHN1YnN0ciBcbiAgICAgKiBcbiAgICAgKiBAbWVtYmVyT2YgU3VmZml4VHJlZVxuICAgICAqL1xuICAgIGZpbmQoc3Vic3RyKXtcbiAgICAgICAgaWYoIXN1YnN0cikgcmV0dXJuIC0xO1xuXG4gICAgICAgIGlmKHRoaXMuY2FzZUluc2Vuc2l0aXZlKSBzdWJzdHIgPSBzdWJzdHIudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBsZXQgY3VycmVudE5vZGUgPSAwO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBsbiA9IDA7XG4gICAgICAgIGxldCBlZGdlID0gbnVsbDtcblxuICAgICAgICB3aGlsZShpIDwgc3Vic3RyLmxlbmd0aCl7XG4gICAgICAgICAgICBlZGdlID0gdGhpcy5lZGdlc1tgJHtjdXJyZW50Tm9kZX0tJHtzdWJzdHJbaV19YF07XG5cbiAgICAgICAgICAgIGlmKCFlZGdlKSByZXR1cm4gLTE7XG5cbiAgICAgICAgICAgIGxuID0gTWF0aC5taW4oZWRnZS5sZW5ndGggKyAxLCBzdWJzdHIubGVuZ3RoIC0gaSk7XG5cbiAgICAgICAgICAgIGlmKHN1YnN0ci5zdWJzdHJpbmcoaSwgaSArIGxuKSAhPT0gdGhpcy5zdHJpbmcuc3Vic3RyaW5nKGVkZ2UuZmlyc3RDaGFySW5kZXgsIGVkZ2UuZmlyc3RDaGFySW5kZXggKyBsbikpIHJldHVybiAtMTtcblxuICAgICAgICAgICAgaSArPSBlZGdlLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGVkZ2UuZGVzdE5vZGVJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlZGdlLmZpcnN0Q2hhckluZGV4IC0gc3Vic3RyLmxlbmd0aCArIGxuO1xuICAgIH1cbn1cblxubGV0IHN0ciA9ICdJIG5lZWQgdG8gYmUgc2VhcmNoZWQnO1xubGV0IHRyZWUgPSBuZXcgU3VmZml4VHJlZShzdHIpO1xuY29uc29sZS5sb2codHJlZS5maW5kKCdzZWFyJykpO1xuY29uc29sZS5sb2codHJlZSArICcnKTtcblxubGV0IHRyZWUyID0gbmV3IFN1ZmZpeFRyZWUoJ21pc3Npc3NpcHBpJyk7XG5jb25zb2xlLmxvZyh0cmVlMiArICcnKTtcbmNvbnNvbGUubG9nKHRyZWUyLmZpbmQoJ3BwJykpO1xuXG5sZXQgdHJlZTMgPSBuZXcgU3VmZml4VHJlZSgnYWJjYWJ4YWJjZCcpO1xuY29uc29sZS5sb2codHJlZTMgKyAnJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU2VhcmNoL1N1ZmZpeFRyZWUuanMiLCIvKlxuIEZpYm9uYWNjaeafpeaJvlxuXG4gRmlib25hY2Np5p+l5om+5pa55rOV5piv5qC55o2uRmlib25hY2Np5pWw5YiX55qE54m554K55a+55p+l5om+6KGo6L+b6KGM5YiG5Ymy44CCRmlib25hY2Np5pWw5YiX55qE5a6a5LmJ5piv77yaXG4gRigwKT0w77yMRigxKT0x77yMRihqKT1GKGotMSkrRihqLTIpIOOAglxuXG4gMSAg5p+l5om+5oCd5oOzXG4g6K6+5p+l5om+6KGo5Lit55qE6K6w5b2V5pWw5q+U5p+Q5LiqRmlib25hY2Np5pWw5bCPMe+8jOWNs+iuvm49RihqKS0x44CC55SoTG9344CBSGlnaOWSjE1pZOihqOekuuW+heafpeaJvuWMuumXtOeahOS4i+eVjOOAgeS4iueVjOWSjOWIhuWJsuS9jee9ru+8jOWIneWAvOS4ukxvdz0w77yMSGlnaD1uIC0gMeOAglxuIOKRtCAgIOWPluWIhuWJsuS9jee9rk1pZO+8mk1pZD1GKGotMSkg77ybXG4g4pG1ICAg5q+U6L6D5YiG5Ymy5L2N572u6K6w5b2V55qE5YWz6ZSu5a2X5LiO57uZ5a6a55qES+WAvO+8mlxuIOKRoCDnm7jnrYnvvJog5p+l5om+5oiQ5Yqf77ybXG4g4pGhICDlpKfkuo7vvJrlvoXmn6XorrDlvZXlnKjljLrpl7TnmoTliY3ljYrmrrUo5Yy66Ze06ZW/5bqm5Li6RihqLTEpLTEp77yM5L+u5pS55LiK55WM5oyH6ZKI77yaIEhpZ2g9TWlkLTHvvIzovazikbQg77ybXG4g4pGiICDlsI/kuo7vvJrlvoXmn6XorrDlvZXlnKjljLrpl7TnmoTlkI7ljYrmrrUo5Yy66Ze06ZW/5bqm5Li6RihqLTIpLTEp77yM5L+u5pS55LiL55WM5oyH6ZKI77yaTG93PU1pZCsx77yM6L2s4pG0IO+8m+ebtOWIsOi2iueVjChMb3c+SGlnaCnvvIzmn6Xmib7lpLHotKXjgIJcblxuIDIgIOeul+azleWunueOsFxuIOWcqOeul+azleWunueOsOaXtu+8jOS4uuS6humBv+WFjemikee5geiuoeeul0ZpYm9uYWNjaeaVsO+8jOWPr+eUqOS4pOS4quWPmOmHj2Yx5ZKMZjLkv53lrZjlvZPliY3nm7jpgrvnmoTkuKTkuKpGaWJvbmFjY2nmlbDvvIzov5nmoLflnKjku6XlkI7nmoTorqHnrpfkuK3lj6/ku6Xkvp3mrKHpgJLmjqjorqHnrpflh7rjgIJcblxuIDMgIOeul+azleWIhuaekFxuIOeUseeul+azleefpe+8jEZpYm9uYWNjaeafpeaJvuWcqOacgOWdj+aDheWGteS4i+aAp+iDveavlOaKmOWNiuafpeaJvuW3ru+8jOS9huW5s+Wdh+aQnOe0ouasoeaVsOWwkeS6juaKmOWNiuafpeaJvu+8jOiAjOS4lOaKmOWNiuafpeaJvuimgeaxguiusOW9leaMieWFs+mUruWtl+acieW6j++8m0ZpYm9uYWNjaeafpeaJvueahOS8mOeCueaYr+WIhuWJsuaXtuWPqumcgOi/m+ihjOWKoOOAgeWHj+i/kOeul+OAglxuXG4gKi9cblxuZnVuY3Rpb24gZmliKG4pIHtcbiAgICBpZiAobiA9PT0gMCkgcmV0dXJuIDA7XG4gICAgaWYgKG4gPT09IDEpIHJldHVybiAxO1xuICAgIGxldCBmO1xuICAgIGxldCBmMCA9IDA7XG4gICAgbGV0IGYxID0gMTtcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8PSBuOyArK2kpIHtcbiAgICAgICAgZiA9IGYwICsgZjE7XG4gICAgICAgIGYwID0gZjE7XG4gICAgICAgIGYxID0gZjtcbiAgICB9XG4gICAgcmV0dXJuIGY7XG59XG5cbi8qKlxuICog5Zyo5pyJ5bqP6KGoU1TkuK3nlKhGaWJvbmFjY2nmlrnms5Xmn6Xmib7lhbPplK7lrZfkuLprZXnnmoTorrDlvZVcbiAqIEBwYXJhbSBzVGFibGVcbiAqIEBwYXJhbSBrZXlcbiAqIEBwYXJhbSBuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpYm9uYWNjaVNlYXJjaChzVGFibGUsIGtleSwgbiA9IHNUYWJsZS5sZW5ndGgpIHtcbiAgICBsZXQgbG93ID0gMDtcbiAgICBsZXQgaGlnaCA9IG4gLSAxO1xuICAgIGxldCBmMSA9IGZpYihuKTtcbiAgICBsZXQgZjIgPSBmaWIobiAtIDEpO1xuXG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICAgIGxldCBtaWQgPSBsb3cgKyBmMSAtIDE7XG4gICAgICAgIGlmIChzVGFibGVbbWlkXSA9PT0ga2V5KSByZXR1cm4gbWlkO1xuICAgICAgICBlbHNlIGlmIChrZXkgPCBzVGFibGVbbWlkXSkge1xuICAgICAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICAgICAgICBmMiA9IGYxIC0gZjI7XG4gICAgICAgICAgICBmMSA9IGYxIC0gZjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgZjEgPSBmMSAtIGYyO1xuICAgICAgICAgICAgZjIgPSBmMiAtIGYxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuY29uc29sZS5sb2coJ2ZpYm9uYWNjaVNlYXJjaDogJyk7XG5jb25zb2xlLmxvZyhmaWJvbmFjY2lTZWFyY2goWzEsIDIsIDMsIDQsIDVdLCA1KSk7IC8vIDRcbmNvbnNvbGUubG9nKGZpYm9uYWNjaVNlYXJjaChbMSwgMiwgMywgNCwgNV0sIDYpKTsgLy8gLTFcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TZWFyY2gvZmlib25hY2NpU2VhcmNoLmpzIiwiLypcbiDpnZnmgIHmn6Xmib5cblxuIOe6v+aAp+ihqOaYr+afpeaJvuihqOacgOeugOWNleeahOS4gOenjee7hOe7h+aWueW8j1xuXG4g6aG65bqP5p+l5om+KFNlcXVlbnRpYWwgU2VhcmNoKVxuIDEgIOafpeaJvuaAneaDs1xuIOS7juihqOeahOS4gOerr+W8gOWni+mAkOS4quWwhuiusOW9leeahOWFs+mUruWtl+WSjOe7meWumkvlgLzov5vooYzmr5TovoPvvIzoi6Xmn5DkuKrorrDlvZXnmoTlhbPplK7lrZflkoznu5nlrppL5YC855u4562J77yM5p+l5om+5oiQ5Yqf77yb5ZCm5YiZ77yM6Iul5omr5o+P5a6M5pW05Liq6KGo77yM5LuN54S25rKh5pyJ5om+5Yiw55u45bqU55qE6K6w5b2V77yM5YiZ5p+l5om+5aSx6LSl44CCXG5cbiAyICDnrpfms5XliIbmnpBcbiDkuI3lpLHkuIDoiKzmgKfvvIzorr7mn6Xmib7mr4/kuKrorrDlvZXmiJDlip/nmoTmpoLnjofnm7jnrYnvvIzljbNQaT0xL27vvJvmn6Xmib7nrKxp5Liq5YWD57Sg5oiQ5Yqf55qE5q+U6L6D5qyh5pWwQ2k9bi1p77ybXG4g4peGIOafpeaJvuaIkOWKn+aXtueahOW5s+Wdh+afpeaJvumVv+W6pkFTTO+8mihuKzEpLzJcbiDil4Yg5YyF5ZCr5p+l5om+5LiN5oiQ5Yqf5pe277ya5p+l5om+5aSx6LSl55qE5q+U6L6D5qyh5pWw5Li6bu+8jOiLpeaIkOWKn+S4juS4jeaIkOWKn+eahOamgueOh+ebuOetie+8jOWvueavj+S4quiusOW9leeahOafpeaJvuamgueOh+S4ulBpPTEvKDJuKe+8jOWImeW5s+Wdh+afpeaJvumVv+W6pkFTTO+8mjPvvIhuKzHvvIkvNFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNlcXVlbnRpYWxTZWFyY2goc1RhYmxlLCBrZXkpIHtcbiAgICBmb3IgKHZhciBpID0gc1RhYmxlLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiBzVGFibGVbaV0gIT09IGtleTsgLS1pKTtcbiAgICByZXR1cm4gaTtcbn1cblxuY29uc29sZS5sb2coc2VxdWVudGlhbFNlYXJjaChbMSwgMiwgMywgNCwgNV0sIDYpKTsgIC8vIC0xXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU2VhcmNoL3NlcXVlbnRpYWxTZWFyY2guanMiLCIvKipcbiAqIENyZWF0ZWQgYnkgbGRwIG9uIDIwMTUvMi8xOC5cbiAqL1xuXG5pbXBvcnQgeyBxdWlja1NvcnQgfSBmcm9tICcuLi9leGNoYW5nZS9pbmRleCc7XG5cbi8qXG4g6K6h5pWw5o6S5bqPXG5cbiDorqHmlbDmjpLluo/vvIhDb3VudGluZyBzb3J077yJ5piv5LiA56eN56iz5a6a55qE57q/5oCn5pe26Ze05o6S5bqP566X5rOV44CC6K6h5pWw5o6S5bqP5L2/55So5LiA5Liq6aKd5aSW55qE5pWw57uEQ++8jOWFtuS4reesrGnkuKrlhYPntKDmmK/lvoXmjpLluo/mlbDnu4RB5Lit5YC8562J5LqOaeeahOWFg+e0oOeahOS4quaVsOOAgueEtuWQjuagueaNruaVsOe7hEPmnaXlsIZB5Lit55qE5YWD57Sg5o6S5Yiw5q2j56Gu55qE5L2N572u44CCXG5cbiDorqHmlbDmjpLluo/nmoTnibnlvoFcblxuIOW9k+i+k+WFpeeahOWFg+e0oOaYr27kuKow5Yiwa+S5i+mXtOeahOaVtOaVsOaXtu+8jOWug+eahOi/kOihjOaXtumXtOaYr86YKG4gKyBrKeOAguiuoeaVsOaOkuW6j+S4jeaYr+avlOi+g+aOkuW6j++8jOaOkuW6j+eahOmAn+W6puW/q+S6juS7u+S9leavlOi+g+aOkuW6j+eul+azleOAglxuIOeUseS6jueUqOadpeiuoeaVsOeahOaVsOe7hEPnmoTplb/luqblj5blhrPkuo7lvoXmjpLluo/mlbDnu4TkuK3mlbDmja7nmoTojIPlm7TvvIjnrYnkuo7lvoXmjpLluo/mlbDnu4TnmoTmnIDlpKflgLzkuI7mnIDlsI/lgLznmoTlt67liqDkuIox77yJ77yM6L+Z5L2/5b6X6K6h5pWw5o6S5bqP5a+55LqO5pWw5o2u6IyD5Zu05b6I5aSn55qE5pWw57uE77yM6ZyA6KaB5aSn6YeP5pe26Ze05ZKM5YaF5a2Y44CC5L6L5aaC77ya6K6h5pWw5o6S5bqP5piv55So5p2l5o6S5bqPMOWIsDEwMOS5i+mXtOeahOaVsOWtl+eahOacgOWlveeahOeul+azle+8jOS9huaYr+Wug+S4jemAguWQiOaMieWtl+avjemhuuW6j+aOkuW6j+S6uuWQjeOAguS9huaYr++8jOiuoeaVsOaOkuW6j+WPr+S7peeUqOWcqOWfuuaVsOaOkuW6j+S4reeahOeul+azleadpeaOkuW6j+aVsOaNruiMg+WbtOW+iOWkp+eahOaVsOe7hOOAglxuIOmAmuS/l+WcsOeQhuino++8jOS+i+WmguaciTEw5Liq5bm06b6E5LiN5ZCM55qE5Lq677yM57uf6K6h5Ye65pyJOOS4quS6uueahOW5tOm+hOavlEHlsI/vvIzpgqNB55qE5bm06b6E5bCx5o6S5Zyo56ysOeS9je+8jOeUqOi/meS4quaWueazleWPr+S7peW+l+WIsOWFtuS7luavj+S4quS6uueahOS9jee9ru+8jOS5n+WwseaOkuWlveS6huW6j+OAguW9k+eEtu+8jOW5tOm+hOaciemHjeWkjeaXtumcgOimgeeJueauiuWkhOeQhu+8iOS/neivgeeos+WumuaAp++8ie+8jOi/meWwseaYr+S4uuS7gOS5iOacgOWQjuimgeWPjeWQkeWhq+WFheebruagh+aVsOe7hO+8jOS7peWPiuWwhuavj+S4quaVsOWtl+eahOe7n+iuoeWHj+WOuzHnmoTljp/lm6DjgILnrpfms5XnmoTmraXpqqTlpoLkuIvvvJpcbiAxLuaJvuWHuuW+heaOkuW6j+eahOaVsOe7hOS4reacgOWkp+WSjOacgOWwj+eahOWFg+e0oFxuIDIu57uf6K6h5pWw57uE5Lit5q+P5Liq5YC85Li6aeeahOWFg+e0oOWHuueOsOeahOasoeaVsO+8jOWtmOWFpeaVsOe7hEPnmoTnrKxp6aG5XG4gMy7lr7nmiYDmnInnmoTorqHmlbDntK/liqDvvIjku45D5Lit55qE56ys5LiA5Liq5YWD57Sg5byA5aeL77yM5q+P5LiA6aG55ZKM5YmN5LiA6aG555u45Yqg77yJXG4gNC7lj43lkJHloavlhYXnm67moIfmlbDnu4TvvJrlsIbmr4/kuKrlhYPntKBp5pS+5Zyo5paw5pWw57uE55qE56ysQyhpKemhue+8jOavj+aUvuS4gOS4quWFg+e0oOWwseWwhkMoaSnlh4/ljrsxXG4gXG4g566A6KaB5YiG5p6Q77yaXG4gMS7orqHmlbDmjpLluo/ku4XpgILlkIjkuo7lsI/ojIPlm7TnmoTmlbDmja7ov5vooYzmjpLluo9cbiAyLuS4jeiDveWvuea1rueCueaVsOi/m+ihjOaOkuW6j1xuIDMu5pe26Ze05aSN5p2C5bqm5Li6IE8obilcbiA0LuiuoeaVsOaOkuW6j+aYr+eos+WumueahO+8iOaOkuW6j+WQjuWAvOebuOWQjOeahOWFg+e0oOebuOWvueS6juWOn+WFiOeahOS9jee9ruaYr+S4jeS8muWPkeeUn+WPmOWMlueahO+8iVxuICovXG5cbmZ1bmN0aW9uIG1heEVsZW0oYXJyKXtcbiAgICBsZXQgbWF4ID0gYXJyWzBdO1xuXG4gICAgZm9yKGxldCBpID0gMSwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgKytpKVxuICAgICAgICBpZihtYXggPCBhcnJbaV0pIG1heCA9IGFycltpXTtcblxuICAgIHJldHVybiBtYXg7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNxTGlzdCDopoHmjpLluo/nmoTmlbDnu4RcbiAqIEBwYXJhbSB7TnVtYmVyfSBrIOaVsOe7hOS4reacgOWkp+eahOWFg+e0oOWAvFxuICogQHJldHVybnMge0FycmF5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY291bnRTb3J0KHNxTGlzdCA9IFtdLCBrID0gbWF4RWxlbShzcUxpc3QpKXtcbiAgICBsZXQgbGVuID0gc3FMaXN0Lmxlbmd0aDtcbiAgICBsZXQgYyA9IFtdO1xuICAgIGxldCBiID0gW107XG5cbiAgICAvLyDliJ3lp4vljJbovoXliqnmlbDnu4RcbiAgICBmb3IobGV0IGkgPSAwOyBpIDw9IGs7ICsraSkgY1tpXSA9IDA7XG4gICAgLy8g6K6h5pWw5pWw57uEQeS4reWAvOetieS6jkPmlbDnu4TkuIvmoIfnmoTkuKrmlbBcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIGNbc3FMaXN0W2ldXSsrO1xuICAgIC8vIOiuoeaVsOaVsOe7hEHkuK3lgLzlsI/kuo7nrYnkuo5D5pWw57uE5LiL5qCH55qE5Liq5pWwXG4gICAgZm9yKGxldCBpID0gMTsgaSA8PSBrOyArK2kpIGNbaV0gKz0gY1tpIC0gMV07XG4gICAgZm9yKGxldCBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgYltjW3NxTGlzdFtpXV0gLSAxXSA9IHNxTGlzdFtpXTtcbiAgICAgICAgLS1jW3NxTGlzdFtpXV07XG4gICAgfVxuXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSBzcUxpc3RbaV0gPSBiW2ldO1xufVxuXG52YXIgYXJyID0gWzEwMCwgOTMsIDk3LCA5MiwgOTYsIDk5LCA5MiwgODksIDkzLCA5NywgOTAsIDk0LCA5MiwgOTVdO1xuY291bnRTb3J0KGFyciwgMTAwKTtcbmNvbnNvbGUubG9nKGFyciArICcnKTtcblxuXG4vKlxuIOWfuuaVsOaOkuW6j1xuXG4g5Z+65pWw5o6S5bqP77yI6Iux6K+t77yaUmFkaXggc29ydO+8ieaYr+S4gOenjemdnuavlOi+g+Wei+aVtOaVsOaOkuW6j+eul+azle+8jOWFtuWOn+eQhuaYr+WwhuaVtOaVsOaMieS9jeaVsOWIh+WJsuaIkOS4jeWQjOeahOaVsOWtl++8jOeEtuWQjuaMieavj+S4quS9jeaVsOWIhuWIq+avlOi+g+OAgueUseS6juaVtOaVsOS5n+WPr+S7peihqOi+vuWtl+espuS4su+8iOavlOWmguWQjeWtl+aIluaXpeacn++8ieWSjOeJueWumuagvOW8j+eahOa1rueCueaVsO+8jOaJgOS7peWfuuaVsOaOkuW6j+S5n+S4jeaYr+WPquiDveS9v+eUqOS6juaVtOaVsOOAguWfuuaVsOaOkuW6j+eahOWPkeaYjuWPr+S7pei/vea6r+WIsDE4ODflubTotavlsJTmm7zCt+S9leS5kOekvOWcqOaJk+WtlOWNoeeJh+WItuihqOacuu+8iFRhYnVsYXRpb24gTWFjaGluZe+8ieS4iueahOi0oeeMruOAglxuIOWug+aYr+i/meagt+WunueOsOeahO+8muWwhuaJgOacieW+heavlOi+g+aVsOWAvO+8iOato+aVtOaVsO+8iee7n+S4gOS4uuWQjOagt+eahOaVsOS9jemVv+W6pu+8jOaVsOS9jei+g+efreeahOaVsOWJjemdouihpembtuOAgueEtuWQju+8jOS7juacgOS9juS9jeW8gOWni++8jOS+neasoei/m+ihjOS4gOasoeaOkuW6j+OAgui/meagt+S7juacgOS9juS9jeaOkuW6j+S4gOebtOWIsOacgOmrmOS9jeaOkuW6j+WujOaIkOS7peWQju+8jOaVsOWIl+WwseWPmOaIkOS4gOS4quacieW6j+W6j+WIl+OAglxuIOWfuuaVsOaOkuW6j+eahOaWueW8j+WPr+S7pemHh+eUqExTRO+8iExlYXN0IHNpZ25pZmljYW50IGRpZ2l0YWzvvInmiJZNU0TvvIhNb3N0IHNpZ25pZmljYW50IGRpZ2l0YWzvvInvvIxMU0TnmoTmjpLluo/mlrnlvI/nlLHplK7lgLznmoTmnIDlj7PovrnlvIDlp4vvvIzogIxNU0TliJnnm7jlj43vvIznlLHplK7lgLznmoTmnIDlt6bovrnlvIDlp4vjgIJcblxuIOaViOeOh1xuXG4g5Z+65pWw5o6S5bqP55qE5pe26Ze05aSN5p2C5bqm5pivTyhrwrduKe+8jOWFtuS4rW7mmK/mjpLluo/lhYPntKDkuKrmlbDvvIxr5piv5pWw5a2X5L2N5pWw44CC5rOo5oSP6L+Z5LiN5piv6K+06L+Z5Liq5pe26Ze05aSN5p2C5bqm5LiA5a6a5LyY5LqOTyhuwrdsb2cobikp77yMa+eahOWkp+Wwj+WPluWGs+S6juaVsOWtl+S9jeeahOmAieaLqe+8iOavlOWmguavlOeJueS9jeaVsO+8ie+8jOWSjOW+heaOkuW6j+aVsOaNruaJgOWxnuaVsOaNruexu+Wei+eahOWFqOmbhueahOWkp+Wwj++8m2vlhrPlrprkuobov5vooYzlpJrlsJHova7lpITnkIbvvIzogIxu5piv5q+P6L2u5aSE55CG55qE5pON5L2c5pWw55uu44CCXG4g5Lul5o6S5bqPbuS4quS4jeWQjOaVtOaVsOadpeS4vuS+i++8jOWBh+Wumui/meS6m+aVtOaVsOS7pULkuLrlupXvvIzov5nmoLfmr4/kvY3mlbDpg73mnIlC5Liq5LiN5ZCM55qE5pWw5a2X77yMayA9IGxvZ0IoTinvvIxO5piv5b6F5o6S5bqP5pWw5o2u57G75Z6L5YWo6ZuG55qE5Yq/44CC6Jm954S25pyJQuS4quS4jeWQjOeahOaVsOWtl++8jOmcgOimgULkuKrkuI3lkIznmoTmobbvvIzkvYblnKjmr4/kuIDova7lpITnkIbkuK3vvIzliKTmlq3mr4/kuKrlvoXmjpLluo/mlbDmja7pobnlj6rpnIDopoHkuIDmrKHorqHnrpfnoa7lrprlr7nlupTmlbDkvY3nmoTlgLzvvIzlm6DmraTlnKjmr4/kuIDova7lpITnkIbnmoTml7blgJnpg73pnIDopoHlubPlnYdu5qyh5pON5L2c5p2l5oqK5pW05pWw5pS+5Yiw5ZCI6YCC55qE5qG25Lit5Y6777yM5omA5Lul5bCx5pyJ77yaXG4ga+e6puetieS6jmxvZ0IoTilcbiDmiYDku6XvvIzln7rmlbDmjpLluo/nmoTlubPlnYfml7bpl7RU5bCx5piv77yaXG4gVO+9nj0gbG9nQihOKcK3blxuIOWFtuS4reWJjeS4gOmhueaYr+S4gOS4quS4jui+k+WFpeaVsOaNruaXoOWFs+eahOW4uOaVsO+8jOW9k+eEtuivpemhueS4jeS4gOWumuWwj+S6jmxvZ25cbiDlpoLmnpzogIPomZHlkozmr5TovoPmjpLluo/ov5vooYzlr7nnhafvvIzln7rmlbDmjpLluo/nmoTlvaLlvI/lpI3mnYLluqbomb3nhLbkuI3kuIDlrprmm7TlsI/vvIzkvYbnlLHkuo7kuI3ov5vooYzmr5TovoPvvIzlm6DmraTlhbbln7rmnKzmk43kvZznmoTku6Pku7fovoPlsI/vvIzogIzkuJTlnKjpgILlvZPpgInmi6nnmoRC5LmL5LiL77yMa+S4gOiIrOS4jeWkp+S6jmxvZ27vvIzmiYDku6Xln7rmlbDmjpLluo/kuIDoiKzopoHlv6vov4fln7rkuo7mr5TovoPnmoTmjpLluo/vvIzmr5TlpoLlv6vpgJ/mjpLluo/jgIJcblxuIOWBh+iuvuaIkeS7rOacieS4gOS6m+S6jOWFg+e7hChhLGIp77yM6KaB5a+55a6D5Lus6L+b6KGM5LulYeS4uummluimgeWFs+mUruWtl++8jGLnmoTmrKHopoHlhbPplK7lrZfnmoTmjpLluo/jgILmiJHku6zlj6/ku6XlhYjmiorlroPku6zlhYjmjInnhafpppbopoHlhbPplK7lrZfmjpLluo/vvIzliIbmiJDpppbopoHlhbPplK7lrZfnm7jlkIznmoToi6XlubLloIbjgILnhLblkI7vvIzlnKjmjInnhafmrKHopoHlhbPplK7lgLzliIbliKvlr7nmr4/kuIDloIbov5vooYzljZXni6zmjpLluo/jgILmnIDlkI7lho3miorov5nkupvloIbkuLLov57liLDkuIDotbfvvIzkvb/pppbopoHlhbPplK7lrZfovoPlsI/nmoTkuIDloIbmjpLlnKjkuIrpnaLjgILmjInov5nnp43mlrnlvI/nmoTln7rmlbDmjpLluo/np7DkuLpNU0QoTW9zdCBTaWduaWZpY2FudCBEaWdodCnmjpLluo/jgILnrKzkuoznp43mlrnlvI/mmK/ku47mnIDkvY7mnInmlYjlhbPplK7lrZflvIDlp4vmjpLluo/vvIznp7DkuLpMU0QoTGVhc3QgU2lnbmlmaWNhbnQgRGlnaHQp5o6S5bqP44CC6aaW5YWI5a+55omA5pyJ55qE5pWw5o2u5oyJ54Wn5qyh6KaB5YWz6ZSu5a2X5o6S5bqP77yM54S25ZCO5a+55omA5pyJ55qE5pWw5o2u5oyJ54Wn6aaW6KaB5YWz6ZSu5a2X5o6S5bqP44CC6KaB5rOo5oSP55qE5piv77yM5L2/55So55qE5o6S5bqP566X5rOV5b+F6aG75piv56iz5a6a55qE77yM5ZCm5YiZ5bCx5Lya5Y+W5raI5YmN5LiA5qyh5o6S5bqP55qE57uT5p6c44CC55Sx5LqO5LiN6ZyA6KaB5YiG5aCG5a+55q+P5aCG5Y2V54us5o6S5bqP77yMTFNE5pa55rOV5b6A5b6A5q+UTVNE566A5Y2V6ICM5byA6ZSA5bCP44CC5LiL5paH5LuL57uN55qE5pa55rOV5YWo6YOo5piv5Z+65LqOTFNE55qE44CCXG5cbiDln7rmlbDmjpLluo/nmoTnroDljZXmj4/ov7DlsLHmmK/lsIbmlbDlrZfmi4bliIbkuLrkuKrkvY3ljYHkvY3nmb7kvY3vvIzmr4/kuKrkvY3kvp3mrKHmjpLluo/jgILlm6DkuLrov5nlr7nnrpfms5XnqLPlrpropoHmsYLpq5jvvIzmiYDku6XmiJHku6zlr7nmlbDkvY3mjpLluo/nlKjliLDkuIrkuIDkuKrmjpLluo/mlrnms5XorqHmlbDmjpLluo/jgILlm6DkuLrln7rmlbDmjpLluo/opoHnu4/ov4dkICjmlbDmja7plb/luqYp5qyh5o6S5bqP77yMIOavj+asoeS9v+eUqOiuoeaVsOaOkuW6j++8jCDorqHmlbDmjpLluo/nmoTlpI3mnYLluqbkuLogT24pLCAgZCDnm7jlvZPkuo7luLjph4/lkoxO5peg5YWz77yM5omA5Lul5Z+65pWw5o6S5bqP5Lmf5pivIE8obinjgILln7rmlbDmjpLluo/omb3nhLbmmK/nur/mgKflpI3mnYLluqbvvIwg5Y2z5a+5buS4quaVsOWtl+WkhOeQhuS6hm7mrKHvvIzkvYbmmK/mr4/kuIDmrKHku6Pku7fpg73mr5TovoPpq5jvvIwg6ICM5LiU5L2/55So6K6h5pWw5o6S5bqP55qE5Z+65pWw5o6S5bqP5LiN6IO96L+b6KGM5Y6f5Zyw5o6S5bqP77yM6ZyA6KaB5pu05aSa55qE5YaF5a2Y77yMIOW5tuS4lOW/q+mAn+aOkuW6j+WPr+iDveabtOWlveWcsOWIqeeUqOehrOS7tueahOe8k+WtmO+8jCDmiYDku6Xmr5TovoPotbfmnaXvvIzlg4/lv6vpgJ/mjpLluo/ov5nkupvljp/lnLDmjpLluo/nrpfms5Xmm7Tlj6/lj5bjgILlr7nkuo7kuIDkuKrkvY3mlbDmnInpmZDnmoTljYHov5vliLbmlbDvvIzmiJHku6zlj6/ku6XmiorlroPnnIvkvZzkuIDkuKrlpJrlhYPnu4TvvIzku47pq5jkvY3liLDkvY7kvY3lhbPplK7lrZfph43opoHnqIvluqbkvp3mrKHpgJLlh4/jgILlj6/ku6Xkvb/nlKjln7rmlbDmjpLluo/lr7nkuIDkupvkvY3mlbDmnInpmZDnmoTljYHov5vliLbmlbDmjpLluo/jgIJcbiAqL1xuXG4vLyDmsYLmlbDmja7nmoTmnIDlpKfkvY3mlbBcbmZ1bmN0aW9uIG1heEJpdChhcnIpe1xuICAgIGxldCBkID0gMTtcbiAgICBsZXQgcCA9IDEwO1xuXG4gICAgZm9yKGxldCBpID0gMCwgbiA9IGFyci5sZW5ndGg7IGkgPCBuOyArK2kpe1xuICAgICAgICB3aGlsZShhcnJbaV0gPj0gcCl7XG4gICAgICAgICAgICBwICo9IDEwO1xuICAgICAgICAgICAgKytkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYWRpeFNvcnQoYXJyID0gW10sIGQgPSBtYXhCaXQoYXJyKSl7XG4gICAgbGV0IG4gPSBhcnIubGVuZ3RoO1xuICAgIGxldCB0ZW1wID0gW107XG4gICAgLy8g6K6h5pWw5ZmoXG4gICAgbGV0IGNvdW50ID0gW107XG4gICAgbGV0IHJhZGl4ID0gMTtcblxuICAgIC8vIOi/m+ihjGTmrKHmjpLluo9cbiAgICBmb3IobGV0IGkgPSAxOyBpIDw9IGQ7ICsraSl7XG4gICAgICAgIC8vIOavj+asoeWIhumFjeWJjea4heepuuiuoeaVsOWZqFxuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgMTA7ICsrailcbiAgICAgICAgICAgIGNvdW50W2pdID0gMDtcbiAgICAgICAgLy8g57uf6K6h5q+P5Liq5qG25Lit55qE6K6w5b2V5pWwXG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBuOyArK2ope1xuICAgICAgICAgICAgbGV0IGsgPSBNYXRoLmZsb29yKGFycltqXSAvIHJhZGl4KSAlIDEwO1xuICAgICAgICAgICAgKytjb3VudFtrXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGogPSAxOyBqIDwgMTA7ICsrailcbiAgICAgICAgICAgIGNvdW50W2pdICs9IGNvdW50W2ogLSAxXTtcbiAgICAgICAgLy8g5bCG5omA5pyJ5qG25Lit6K6w5b2V5L6d5qyh5pS26ZuG5YiwdG1w5LitXG4gICAgICAgIGZvcihsZXQgaiA9IG4gLSAxOyBqID49IDA7IC0tail7XG4gICAgICAgICAgICBsZXQgayA9IE1hdGguZmxvb3IoYXJyW2pdIC8gcmFkaXgpICUgMTA7XG4gICAgICAgICAgICB0ZW1wWy0tY291bnRba11dID0gYXJyW2pdO1xuICAgICAgICB9XG4gICAgICAgIC8v5bCG5Li05pe25pWw57uE55qE5YaF5a655aSN5Yi25YiwYXJy5LitXG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBuOyArK2opXG4gICAgICAgICAgICBhcnJbal0gPSB0ZW1wW2pdO1xuXG4gICAgICAgIHJhZGl4ICo9IDEwO1xuICAgIH1cbn1cblxudmFyIGFyciA9IFsxMDAsIDkzLCA5NywgOTIsIDk2LCA5OSwgOTIsIDg5LCA5MywgOTcsIDkwLCA5NCwgOTIsIDk1XTtcbnJhZGl4U29ydChhcnIsIDEwMCk7XG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XG5cblxuXG4vKlxuIOahtuaOkuW6j1xuXG4g5qG25o6S5bqP77yIQnVja2V0IHNvcnTvvInmiJbmiYDosJPnmoTnrrHmjpLluo/vvIzmmK/kuIDkuKrmjpLluo/nrpfms5XvvIzlt6XkvZznmoTljp/nkIbmmK/lsIbmlbDnu4TliIbliLDmnInpmZDmlbDph4/nmoTmobblrZDph4zjgILmr4/kuKrmobblrZDlho3kuKrliKvmjpLluo/vvIjmnInlj6/og73lho3kvb/nlKjliKvnmoTmjpLluo/nrpfms5XmiJbmmK/ku6XpgJLlvZLmlrnlvI/nu6fnu63kvb/nlKjmobbmjpLluo/ov5vooYzmjpLluo/vvInjgILmobbmjpLluo/mmK/puL3lt6LmjpLluo/nmoTkuIDnp43lvZLnurPnu5PmnpzjgILlvZPopoHooqvmjpLluo/nmoTmlbDnu4TlhoXnmoTmlbDlgLzmmK/lnYfljIDliIbphY3nmoTml7blgJnvvIzmobbmjpLluo/kvb/nlKjnur/mgKfml7bpl7TvvIjOmChuKe+8ieOAguS9huahtuaOkuW6j+W5tuS4jeaYr+avlOi+g+aOkuW6j++8jOS7luS4jeWPl+WIsE8obiBsb2cgbinkuIvpmZDnmoTlvbHlk43jgIJcblxuIOWfuuacrOaAneaDs1xuXG4g5YGH6K6+5pyJ5LiA57uE6ZW/5bqm5Li6TueahOW+heaOkuWFs+mUruWtl+W6j+WIl0tbMS4uLi5uXeOAgummluWFiOWwhui/meS4quW6j+WIl+WIkuWIhuaIkE3kuKrnmoTlrZDljLrpl7Qo5qG2KSDjgILnhLblkI7ln7rkuo7mn5Dnp43mmKDlsITlh73mlbAg77yM5bCG5b6F5o6S5bqP5YiX55qE5YWz6ZSu5a2Xa+aYoOWwhOWIsOesrGnkuKrmobbkuK0o5Y2z5qG25pWw57uEQueahOS4i+aghyBpKSDvvIzpgqPkuYjor6XlhbPplK7lrZdr5bCx5L2c5Li6QltpXeS4reeahOWFg+e0oCjmr4/kuKrmobZCW2ld6YO95piv5LiA57uE5aSn5bCP5Li6Ti9N55qE5bqP5YiXKeOAguaOpeedgOWvueavj+S4quahtkJbaV3kuK3nmoTmiYDmnInlhYPntKDov5vooYzmr5TovoPmjpLluo8o5Y+v5Lul5L2/55So5b+r5o6SKeOAgueEtuWQjuS+neasoeaemuS4vui+k+WHukJbMF0uLi4uQltNXeS4reeahOWFqOmDqOWGheWuueWNs+aYr+S4gOS4quacieW6j+W6j+WIl+OAglxuIOWBh+WmguW+heaOkuW6j+WIl0s9IHs0OeOAgSAzOCDjgIEgMzXjgIEgOTcg44CBIDc244CBIDczIOOAgSAyN+OAgSA0OSB944CC6L+Z5Lqb5pWw5o2u5YWo6YOo5ZyoMeKAlDEwMOS5i+mXtOOAguWboOatpOaIkeS7rOWumuWItjEw5Liq5qG277yM54S25ZCO56Gu5a6a5pig5bCE5Ye95pWwZihrKT1rLzEw44CC5YiZ56ys5LiA5Liq5YWz6ZSu5a2XNDnlsIblrprkvY3liLDnrKw05Liq5qG25LitKDQ5LzEwPTQp44CC5L6d5qyh5bCG5omA5pyJ5YWz6ZSu5a2X5YWo6YOo5aCG5YWl5qG25Lit77yM5bm25Zyo5q+P5Liq6Z2e56m655qE5qG25Lit6L+b6KGM5b+r6YCf5o6S5bqP44CCXG5cbiDliIbmnpBcblxuIOahtuaOkuW6j+WIqeeUqOWHveaVsOeahOaYoOWwhOWFs+ezu++8jOWHj+WwkeS6huWHoOS5juaJgOacieeahOavlOi+g+W3peS9nOOAguWunumZheS4iu+8jOahtuaOkuW6j+eahGYoaynlgLznmoTorqHnrpfvvIzlhbbkvZznlKjlsLHnm7jlvZPkuo7lv6vmjpLkuK3liJLliIbvvIzlt7Lnu4/miorlpKfph4/mlbDmja7liIblibLmiJDkuobln7rmnKzmnInluo/nmoTmlbDmja7lnZco5qG2KeOAgueEtuWQjuWPqumcgOimgeWvueahtuS4reeahOWwkemHj+aVsOaNruWBmuWFiOi/m+eahOavlOi+g+aOkuW6j+WNs+WPr+OAglxuIOWvuU7kuKrlhbPplK7lrZfov5vooYzmobbmjpLluo/nmoTml7bpl7TlpI3mnYLluqbliIbkuLrkuKTkuKrpg6jliIbvvJpcbiAgICAgKDEpIOW+queOr+iuoeeul+avj+S4quWFs+mUruWtl+eahOahtuaYoOWwhOWHveaVsO+8jOi/meS4quaXtumXtOWkjeadguW6puaYr08oTinjgIJcbiAgICAgKDIpIOWIqeeUqOWFiOi/m+eahOavlOi+g+aOkuW6j+eul+azleWvueavj+S4quahtuWGheeahOaJgOacieaVsOaNrui/m+ihjOaOkuW6j++8jOWFtuaXtumXtOWkjeadguW6puS4uiDiiJEgTyhOaSpsb2dOaSkg44CC5YW25LitTmkg5Li656ysaeS4quahtueahOaVsOaNrumHj+OAglxuIOW+iOaYvueEtu+8jOesrCgyKemDqOWIhuaYr+ahtuaOkuW6j+aAp+iDveWlveWdj+eahOWGs+WumuWboOe0oOOAguWwvemHj+WHj+WwkeahtuWGheaVsOaNrueahOaVsOmHj+aYr+aPkOmrmOaViOeOh+eahOWUr+S4gOWKnuazlSjlm6DkuLrln7rkuo7mr5TovoPmjpLluo/nmoTmnIDlpb3lubPlnYfml7bpl7TlpI3mnYLluqblj6rog73ovr7liLBPKE4qbG9nTinkuoYp44CC5Zug5q2k77yM5oiR5Lus6ZyA6KaB5bC96YeP5YGa5Yiw5LiL6Z2i5Lik54K577yaXG4gICAgICgxKSDmmKDlsITlh73mlbBmKGsp6IO95aSf5bCGTuS4quaVsOaNruW5s+Wdh+eahOWIhumFjeWIsE3kuKrmobbkuK3vvIzov5nmoLfmr4/kuKrmobblsLHmnIlbTi9NXeS4quaVsOaNrumHj+OAglxuICAgICAoMikg5bC96YeP55qE5aKe5aSn5qG255qE5pWw6YeP44CC5p6B6ZmQ5oOF5Ya15LiL5q+P5Liq5qG25Y+q6IO95b6X5Yiw5LiA5Liq5pWw5o2u77yM6L+Z5qC35bCx5a6M5YWo6YG/5byA5LqG5qG25YaF5pWw5o2u55qE4oCc5q+U6L6D4oCd5o6S5bqP5pON5L2c44CCIOW9k+eEtu+8jOWBmuWIsOi/meS4gOeCueW+iOS4jeWuueaYk++8jOaVsOaNrumHj+W3qOWkp+eahOaDheWGteS4i++8jGYoaynlh73mlbDkvJrkvb/lvpfmobbpm4blkIjnmoTmlbDph4/lt6jlpKfvvIznqbrpl7TmtarotLnkuKXph43jgILov5nlsLHmmK/kuIDkuKrml7bpl7Tku6Pku7flkoznqbrpl7Tku6Pku7fnmoTmnYPooaHpl67popjkuobjgIJcblxuIOWvueS6jk7kuKrlvoXmjpLmlbDmja7vvIxN5Liq5qG277yM5bmz5Z2H5q+P5Liq5qG2W04vTV3kuKrmlbDmja7nmoTmobbmjpLluo/lubPlnYfml7bpl7TlpI3mnYLluqbkuLrvvJpcbiBPKE4pK08oTSooTi9NKSpsb2coTi9NKSk9TyhOK04qKGxvZ04tbG9nTSkpPU8oTitOKmxvZ04tTipsb2dNKVxuIOW9k049TeaXtu+8jOWNs+aegemZkOaDheWGteS4i+avj+S4quahtuWPquacieS4gOS4quaVsOaNruaXtuOAguahtuaOkuW6j+eahOacgOWlveaViOeOh+iDveWkn+i+vuWIsE8oTinjgIJcblxuIOaAu+e7k++8miDmobbmjpLluo/nmoTlubPlnYfml7bpl7TlpI3mnYLluqbkuLrnur/mgKfnmoRPKE4rQynvvIzlhbbkuK1DPU4qKGxvZ04tbG9nTSnjgILlpoLmnpznm7jlr7nkuo7lkIzmoLfnmoRO77yM5qG25pWw6YePTei2iuWkp++8jOWFtuaViOeOh+i2iumrmO+8jOacgOWlveeahOaXtumXtOWkjeadguW6pui+vuWIsE8oTinjgIIg5b2T54S25qG25o6S5bqP55qE56m66Ze05aSN5p2C5bqmIOS4uk8oTitNKe+8jOWmguaenOi+k+WFpeaVsOaNrumdnuW4uOW6nuWkp++8jOiAjOahtueahOaVsOmHj+S5n+mdnuW4uOWkmu+8jOWImeepuumXtOS7o+S7t+aXoOeWkeaYr+aYgui0teeahOOAguatpOWklu+8jOahtuaOkuW6j+aYr+eos+WumueahOOAglxuICovXG5cbmNvbnN0IEJVQ0tFVFNOVU0gPSAxMDtcblxuZnVuY3Rpb24gYnVja2V0U29ydChzcUxpc3Qpe1xuICAgIGxldCAgbiA9IHNxTGlzdC5sZW5ndGg7XG4gICAgbGV0IGJ1Y2tldEEgPSBbXTtcbiAgICBsZXQgYiA9IFtdO1xuXG4gICAgLy8g5Yid5aeL5YyW5qG2XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IEJVQ0tFVFNOVU07ICsraSl7XG4gICAgICAgIGJbaV0gPSBbXTtcbiAgICAgICAgYnVja2V0QVtpXSA9IDA7XG5cbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IG47ICsrailcbiAgICAgICAgICAgIGJbaV1bal0gPSBJbmZpbml0eTtcbiAgICB9XG5cbiAgICAvLyDnu5nmobbloavoo4XmlbDmja5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbjsgKytpKXtcbiAgICAgICAgbGV0IGRhdGEgPSBzcUxpc3RbaV07XG4gICAgICAgIC8vIG5vdG86IOi/memHjOeahOaYoOWwhOWHveaVsOaYr+mSiOWvuTEtMTAw5LmL6Ze055qE5a6e5pWwXG4gICAgICAgIGxldCBidWNrZXQgPSBNYXRoLmZsb29yKGRhdGEgLyBCVUNLRVRTTlVNKTtcbiAgICAgICAgYltidWNrZXRdW2J1Y2tldEFbYnVja2V0XV0gPSBkYXRhO1xuICAgICAgICArK2J1Y2tldEFbYnVja2V0XTtcbiAgICB9XG5cbiAgICAvLyDpkojlr7nmr4/kuKrmobbov5vooYzlv6vpgJ/mjpLluo9cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgQlVDS0VUU05VTTsgKytpKXtcbiAgICAgICAgaWYoYnVja2V0QVtpXSAhPT0gMCkge1xuICAgICAgICAgICAgcXVpY2tTb3J0KGJbaV0sIDAsIGJ1Y2tldEFbaV0gLSAxKTtcbiAgICAgICAgICAgIC8vZm9yKGxldCBqID0gMTsgaiA8IGJ1Y2tldEFbaV07ICsrail7XG4gICAgICAgICAgICAvLyAgICBsZXQgcCA9IGJbaV1bal07XG4gICAgICAgICAgICAvLyAgICBsZXQgaztcbiAgICAgICAgICAgIC8vICAgIGZvcihrID0gaiAtIDE7IGsgPj0gMCAmJiBwIDwgYltpXVtrXTsgLS1rKXtcbiAgICAgICAgICAgIC8vICAgICAgICBiW2ldW2sgKyAxXSA9IGJbaV1ba107XG4gICAgICAgICAgICAvLyAgICB9XG4gICAgICAgICAgICAvLyAgICBiW2ldW2sgKyAxXSA9IHA7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vY29uc29sZS5sb2coYik7XG4gICAgLy9jb25zb2xlLmxvZyhidWNrZXRBKTtcblxuICAgIC8vIOWkjeWItuWbnuWOu1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBCVUNLRVRTTlVNOyArK2kpe1xuICAgICAgICBpZihidWNrZXRBW2ldICE9PSAwKSB7XG4gICAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgYnVja2V0QVtpXTsgKytqKXtcbiAgICAgICAgICAgICAgICBzcUxpc3RbbnVtKytdID0gYltpXVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuYnVja2V0U29ydCA9IGJ1Y2tldFNvcnQ7XG5cbnZhciBhcnIgPSBbNTEuMiwgOTMsIDEsIDkyLjIsIDgsIDk5LjUsIDkyLjAsIDg5LCA5MywgOTcsIDkwLCA5NCwgOTIuMSwgOTVdO1xuYnVja2V0U29ydChhcnIpO1xuY29uc29sZS5sb2coYXJyICsgJycpO1xuXG52YXIgYXJyID0gWzUxLjIsIDkzLCAxLCA5Mi4yLCA4LCA5OS41LCA5Mi4wLCA4OSwgOTMsIDk3LCA5MCwgOTQsIDkyLjEsIDk1LCBJbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5XTtcbnF1aWNrU29ydChhcnIpO1xuY29uc29sZS5sb2coYXJyICsgJycpO1xuXG5cbi8qXG4g5oCn6IO95YiG5p6QXG4g5b6I5piO5pi+77yM5Z+65pWw5o6S5bqP55qE5oCn6IO95q+U5qG25o6S5bqP6KaB55Wl5beu44CC5q+P5LiA5qyh5YWz6ZSu5a2X55qE5qG25YiG6YWN6YO96ZyA6KaBTyhOKeeahOaXtumXtOWkjeadguW6pu+8jOiAjOS4lOWIhumFjeS5i+WQjuW+l+WIsOaWsOeahOWFs+mUruWtl+W6j+WIl+WPiOmcgOimgU8oTinnmoTml7bpl7TlpI3mnYLluqbjgILlgYflpoLlvoXmjpLmlbDmja7lj6/ku6XliIbkuLpk5Liq5YWz6ZSu5a2X77yM5YiZ5Z+65pWw5o6S5bqP55qE5pe26Ze05aSN5p2C5bqm5bCG5pivTyhkKjJOKSDvvIzlvZPnhLZk6KaB6L+c6L+c5bCP5LqOTu+8jOWboOatpOWfuuacrOS4iui/mOaYr+e6v+aAp+e6p+WIq+eahOOAguWfuuaVsOaOkuW6j+eahOepuumXtOWkjeadguW6puS4uk8oTitNKe+8jOWFtuS4rU3kuLrmobbnmoTmlbDph4/jgILkuIDoiKzmnaXor7ROPj5N77yM5Zug5q2k6aKd5aSW56m66Ze06ZyA6KaB5aSn5qaCTuS4quW3puWPs+OAglxuIOS9huaYr++8jOWvueavlOahtuaOkuW6j++8jOWfuuaVsOaOkuW6j+avj+asoemcgOimgeeahOahtueahOaVsOmHj+W5tuS4jeWkmuOAguiAjOS4lOWfuuaVsOaOkuW6j+WHoOS5juS4jemcgOimgeS7u+S9leKAnOavlOi+g+KAneaTjeS9nO+8jOiAjOahtuaOkuW6j+WcqOahtuebuOWvuei+g+WwkeeahOaDheWGteS4i++8jOahtuWGheWkmuS4quaVsOaNruW/hemhu+i/m+ihjOWfuuS6juavlOi+g+aTjeS9nOeahOaOkuW6j+OAguWboOatpO+8jOWcqOWunumZheW6lOeUqOS4re+8jOWfuuaVsOaOkuW6j+eahOW6lOeUqOiMg+WbtOabtOWKoOW5v+azm+OAglxuICovXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1NvcnQvZGlzdHJpYnV0aW9uL2luZGV4LmpzIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IEx1a2Ugb24gMjAxNS8yLzIuXG4gKi9cblxuaW1wb3J0IFN0YXRpY0xpbmtlZExpc3QgZnJvbSAnLi4vLi4vTGlzdC9TdGF0aWNMaW5rZWRMaXN0JztcbmltcG9ydCBkZWZhdWx0Q29tcGFyZSBmcm9tICcuLi9kZWZhdWx0Q29tcGFyaXNpb24nO1xuXG4vKlxuIOaPkuWFpeaOkuW6j1xuXG4g6YeH55So55qE5piv5LulIOKAnOeOqeahpeeJjOiAheKAneeahOaWueazleS4uuWfuuehgOeahOOAguWNs+WcqOiAg+Wvn+iusOW9lVJp5LmL5YmN77yM6K6+5Lul5YmN55qE5omA5pyJ6K6w5b2VUjEsIFIyICzigKYuLCBSaS0x5bey5o6S5aW95bqP77yM54S25ZCO5bCGUmnmj5LlhaXliLDlt7LmjpLlpb3luo/nmoTor7jorrDlvZXnmoTpgILlvZPkvY3nva5cblxuIOacgOWfuuacrOeahOaPkuWFpeaOkuW6j+aYr+ebtOaOpeaPkuWFpeaOkuW6jyhTdHJhaWdodCBJbnNlcnRpb24gU29ydCkg44CCXG5cblxuIOebtOaOpeaPkuWFpeaOkuW6j1xuXG4gMSAg5o6S5bqP5oCd5oOzXG4g5bCG5b6F5o6S5bqP55qE6K6w5b2VUmnvvIzmj5LlhaXliLDlt7LmjpLlpb3luo/nmoTorrDlvZXooahSMSwgUjIgLOKApi4sIFJpLTHkuK3vvIzlvpfliLDkuIDkuKrmlrDnmoTjgIHorrDlvZXmlbDlop7liqAx55qE5pyJ5bqP6KGo44CCIOebtOWIsOaJgOacieeahOiusOW9lemDveaPkuWFpeWujOS4uuatouOAglxuIOiuvuW+heaOkuW6j+eahOiusOW9lemhuuW6j+WtmOaUvuWcqOaVsOe7hFJbMeKApm5d5Lit77yM5Zyo5o6S5bqP55qE5p+Q5LiA5pe25Yi777yM5bCG6K6w5b2V5bqP5YiX5YiG5oiQ5Lik6YOo5YiG77yaXG4g4peGIFJbMeKApmktMV3vvJrlt7LmjpLlpb3luo/nmoTmnInluo/pg6jliIbvvJtcbiDil4YgUltp4oCmbl3vvJrmnKrmjpLlpb3luo/nmoTml6Dluo/pg6jliIbjgIJcbiDmmL7nhLbvvIzlnKjliJrlvIDlp4vmjpLluo/ml7bvvIxSWzFd5piv5bey57uP5o6S5aW95bqP55qE44CCXG5cbiAyLueul+azleWunueOsFxuXG4gMy7nrpfms5XliIbmnpBcbiDikbQg5pyA5aW95oOF5Ya177ya6Iul5b6F5o6S5bqP6K6w5b2V5oyJ5YWz6ZSu5a2X5LuO5bCP5Yiw5aSn5o6S5YiXKOato+W6jynvvIznrpfms5XkuK3nmoTlhoXlvqrnjq/ml6DpobvmiafooYzvvIzliJnkuIDotp/mjpLluo/ml7bvvJrlhbPplK7lrZfmr5TovoPmrKHmlbAx5qyh77yM6K6w5b2V56e75Yqo5qyh5pWwMuasoShSW2ld4oaSUlswXSwgUlswXeKGklJbaisxXSnjgIJcbiDliJnmlbTkuKrmjpLluo/nmoTlhbPplK7lrZfmr5TovoPmrKHmlbDlkozorrDlvZXnp7vliqjmrKHmlbDliIbliKvmmK/vvJpcbiDmr5TovoPmrKHmlbDvvJpuIC0gMSAgICAgICAgICDnp7vliqjmrKHmlbDvvJogMiAqIChuIC0gMSlcblxuIOKRtSDmnIDlnY/mg4XlhrXvvJroi6XlvoXmjpLluo/orrDlvZXmjInlhbPplK7lrZfku47lpKfliLDlsI/mjpLliJco6YCG5bqPKe+8jOWImeS4gOi2n+aOkuW6j+aXtu+8mueul+azleS4reeahOWGheW+queOr+S9k+aJp+ihjGktMe+8jOWFs+mUruWtl+avlOi+g+asoeaVsGnmrKHvvIzorrDlvZXnp7vliqjmrKHmlbBpKzHjgIJcbiDliJnlsLHmlbTkuKrmjpLluo/ogIzoqIDvvJpcbiDmr5TovoPmrKHmlbDvvJogKG4gLSAxKSAqIChuICsgMSkgLyAyICAgICDnp7vliqjmrKHmlbA6IChuIC0gMSkgKiAobiArIDQpIC8gMlxuXG4g5LiA6Iis5Zyw77yM6K6k5Li65b6F5o6S5bqP55qE6K6w5b2V5Y+v6IO95Ye6546w55qE5ZCE56eN5o6S5YiX55qE5qaC546H55u45ZCM77yM5YiZ5Y+W5Lul5LiK5Lik56eN5oOF5Ya155qE5bmz5Z2H5YC877yM5L2c5Li65o6S5bqP55qE5YWz6ZSu5a2X5q+U6L6D5qyh5pWw5ZKM6K6w5b2V56e75Yqo5qyh5pWw77yM57qm5Li6bjIvNO+8jOWImeWkjeadguW6puS4uk8objIpIOOAglxuXG5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyYWlnaHRJbnNlcnRTb3J0KHNxTGlzdCwgY29tcCA9IGRlZmF1bHRDb21wYXJlKSB7XG4gICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHNxTGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAvLyDorr7nva7lk6jlhbUsIOW9k+iuvue9rnNxTGlzdFstMV0gPSBzcUxpc3RbaV3ml7bvvIznu4/mtYvor5XmlYjnjofmm7TmhaJcbiAgICAgICAgLy8g5Zug5Li6anPph4zpnaLnmoTlj5jph4/kvZznlKjln5/lnKjlh73mlbDlhoXnmoRcbiAgICAgICAgbGV0IHRlbXAgPSBzcUxpc3RbaV07XG4gICAgICAgIC8vIOafpeaJvuaPkuWFpeS9jee9ru+8jOW5tuWwhuiusOW9leWQjuenu1xuICAgICAgICBsZXQgaiA9IGkgLSAxO1xuICAgICAgICBmb3IoOyBqID49IDAgJiYgY29tcCh0ZW1wLCBzcUxpc3Rbal0pIDwgMDsgLS1qKVxuICAgICAgICAgICAgc3FMaXN0W2ogKyAxXSA9IHNxTGlzdFtqXTtcblxuICAgICAgICAvLyDmj5LlhaXliLDmraPnoa7kvY3nva5cbiAgICAgICAgc3FMaXN0W2ogKyAxXSA9IHRlbXA7XG4gICAgfVxufVxuXG52YXIgYSA9IFs3LCA0LCAtMiwgMTksIDEzLCA2XTtcbnN0cmFpZ2h0SW5zZXJ0U29ydChhKTtcbmNvbnNvbGUubG9nKGEgKyAnJyk7XG5cblxuLypcbiDlhbblroPmj5LlhaXmjpLluo9cblxuIDEgIOaKmOWNiuaPkuWFpeaOkuW6j1xuIOW9k+WwhuW+heaOkuW6j+eahOiusOW9lVJbaV0g5o+S5YWl5Yiw5bey5o6S5aW95bqP55qE6K6w5b2V5a2Q6KGoUlsx4oCmaS0xXeS4reaXtu+8jOeUseS6jlIxLCBSMiAs4oCmLCBSaS0x5bey5o6S5aW95bqP77yM5YiZ5p+l5om+5o+S5YWl5L2N572u5Y+v5Lul55So4oCc5oqY5Y2K5p+l5om+4oCd5a6e546w77yM5YiZ55u05o6l5o+S5YWl5o6S5bqP5bCx5Y+Y5oiQ5Li65oqY5Y2K5o+S5YWl5o6S5bqP44CCXG5cbiDku47ml7bpl7TkuIrmr5TovoPvvIzmipjljYrmj5LlhaXmjpLluo/ku4Xku4Xlh4/lsJHkuoblhbPplK7lrZfnmoTmr5TovoPmrKHmlbDvvIzljbTmsqHmnInlh4/lsJHorrDlvZXnmoTnp7vliqjmrKHmlbDvvIzmlYXml7bpl7TlpI3mnYLluqbku43nhLbkuLpPKG4yKSDjgIJcblxuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeUluc2VydFNvcnQoc3FMaXN0LCBjb21wID0gZGVmYXVsdENvbXBhcmUpIHtcbiAgICBmb3IgKGxldCBpID0gMSwgbGVuID0gc3FMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGxldCB0ZW1wID0gc3FMaXN0W2ldO1xuICAgICAgICBsZXQgbG93ID0gMDtcbiAgICAgICAgbGV0IGhpZ2ggPSBpIC0gMTtcblxuICAgICAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcblxuICAgICAgICAgICAgaWYgKGNvbXAodGVtcCwgc3FMaXN0W21pZF0pIDwgMCkgaGlnaCA9IG1pZCAtIDE7XG4gICAgICAgICAgICBlbHNlIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBqID0gaSAtIDE7IGogPj0gaGlnaCArIDE7IC0taikge1xuICAgICAgICAgICAgc3FMaXN0W2ogKyAxXSA9IHNxTGlzdFtqXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNxTGlzdFtoaWdoICsgMV0gPSB0ZW1wO1xuICAgIH1cbn1cblxudmFyIGIgPSBbMzAsIDEzLCA3MCwgODUsIDM5LCA0MiwgNiwgMjBdO1xuYmluYXJ5SW5zZXJ0U29ydChiKTtcbmNvbnNvbGUubG9nKGIgKyAnJyk7XG5cblxuLypcbiAyLei3r+aPkuWFpeaOkuW6j1xuXG4g5piv5a+55oqY5Y2K5o+S5YWl5o6S5bqP55qE5pS56L+b77yM5Lul5YeP5bCR5o6S5bqP6L+H56iL5Lit56e75Yqo6K6w5b2V55qE5qyh5pWw44CC6ZmE5YqgbuS4quiusOW9leeahOi+heWKqeepuumXtO+8jOaWueazleaYr++8mlxuIOKRoCAg5Y+m6K6+5LiA5Liq5pWw57uEZO+8jExbMV3otYvnu5lkWzFd77yM5bCGZFsxXeeci+aIkOaYr+aOkuWlveW6j+eahOW6j+WIl+S4reS4remXtOS9jee9rueahOiusOW9le+8m1xuIOKRoSAg5YiG5Yir5bCGTFsgXeS4reeahOesrGnkuKrorrDlvZXkvp3mrKHmj5LlhaXliLBkWzFd5LmL5YmN5oiW5LmL5ZCO55qE5pyJ5bqP5bqP5YiX5Lit77yM5YW35L2T5pa55rOV77yaXG4g4peGICBMW2ldLmtleTxkWzFdLmtlee+8miBMW2ld5o+S5YWl5YiwZFsxXeS5i+WJjeeahOacieW6j+ihqOS4re+8m1xuIOKXhiBMW2ldLmtleeKJpWRbMV0ua2V577yaIExbaV3mj5LlhaXliLBkWzFd5LmL5ZCO55qE5pyJ5bqP6KGo5Lit77ybXG4g5YWz6ZSu54K577ya5a6e546w5pe25bCG5ZCR6YePZOeci+aIkOaYr+W+queOr+WQkemHj++8jOW5tuiuvuS4pOS4quaMh+mSiGZpcnN05ZKMZmluYWzliIbliKvmjIfnpLrmjpLluo/ov4fnqIvkuK3lvpfliLDnmoTmnInluo/luo/liJfkuK3nmoTnrKzkuIDkuKrlkozmnIDlkI7kuIDkuKrorrDlvZXjgIJcblxuIOWcqDIt6Lev5o+S5YWl5o6S5bqP5Lit77yM56e75Yqo6K6w5b2V55qE5qyh5pWw57qm5Li6bjIvOCDjgILkvYblvZNMWzFd5piv5b6F5o6S5bqP6K6w5b2V5Lit5YWz6ZSu5a2X5pyA5aSn5oiW5pyA5bCP55qE6K6w5b2V5pe277yMMi3ot6/mj5LlhaXmjpLluo/lsLHlrozlhajlpLHljrvkuobkvJjotormgKfjgIJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGF0aDJJbnNlcnRTb3J0KHNxTGlzdCwgY29tcCA9IGRlZmF1bHRDb21wYXJlKSB7XG4gICAgbGV0IGQgPSBbc3FMaXN0WzBdXTtcbiAgICAvLyBmaXJzdOOAgWZpbmFs5YiG5Yir5oyH56S6ZOS4reaOkuWlveW6j+eahOiusOW9leeahOesrDHkuKrlkozmnIDlkI4x5Liq6K6w5b2V55qE5L2N572u44CCXG4gICAgbGV0IGZpcnN0ID0gMDtcbiAgICBsZXQgZmluYWwgPSAwO1xuICAgIGxldCBsZW4gPSBzcUxpc3QubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBsZXQgaXRlbSA9IHNxTGlzdFtpXTtcblxuICAgICAgICAvLyDlvoXmj5LlhaXorrDlvZXlsI/kuo5k5Lit5pyA5bCP5YC877yM5o+S5YWl5YiwZFtmaXJzdF3kuYvliY3vvIjkuI3pnIDnp7vliqhk5pWw57uE55qE5YWD57Sg77yJ44CCXG4gICAgICAgIGlmIChjb21wKGl0ZW0sIGRbZmlyc3RdKSA8IDApIHtcbiAgICAgICAgICAgIGZpcnN0ID0gKGZpcnN0IC0gMSkgJSBsZW47XG4gICAgICAgICAgICBkW2ZpcnN0XSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgLy8g5b6F5o+S5YWl6K6w5b2V5aSn5LqOZOS4reacgOWwj+WAvO+8jOaPkuWFpeWIsGRbZmluYWxd5LmL5ZCO77yI5LiN6ZyA56e75YqoZOaVsOe7hOeahOWFg+e0oO+8ieOAglxuICAgICAgICBlbHNlIGlmIChjb21wKGl0ZW0sIGRbZmluYWxdKSA+IDApIHtcbiAgICAgICAgICAgIGRbKytmaW5hbF0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIC8vIOW+heaPkuWFpeiusOW9leWkp+S6jmTkuK3mnIDlsI/lgLzvvIzlsI/kuo5k5Lit5pyA5aSn5YC877yM5o+S5YWl5YiwZOeahOS4remXtO+8iOmcgOimgeenu+WKqGTmlbDnu4TnmoTlhYPntKDvvInjgIJcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyDnp7vliqhk5bC+6YOo5YWD57Sg5Lul5L6/5oyJ5bqP5o+S5YWl6K6w5b2V44CCXG4gICAgICAgICAgICBsZXQgaiA9IGZpbmFsKys7XG4gICAgICAgICAgICB3aGlsZSAoY29tcChpdGVtLCBkW2pdKSA8IDApIHtcbiAgICAgICAgICAgICAgICBkWyhqICsgMSkgJSBsZW5dID0gZFtqXTtcbiAgICAgICAgICAgICAgICBqID0gKGogLSAxKSAlIGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRbKGogKyAxKSAlIGxlbl0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g5b6q546v5oqKZOi1i+e7mXNxTGlzdFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgc3FMaXN0W2ldID0gZFsoaSArIGZpcnN0KSAlIGxlbl07XG4gICAgfVxufVxuXG52YXIgYyA9IFs0OSwgMzgsIDY1LCAxMywgOTcsIDI3LCA3NiwgNSwgMTAwLCA3OCwgMTUsIDE1LCAyMF07XG5wYXRoMkluc2VydFNvcnQoYyk7XG5jb25zb2xlLmxvZyhjICsgJycpO1xuXG5cbi8qXG7ooajmj5LlhaXmjpLluo9cblxu5YmN6Z2i55qE5o+S5YWl5o6S5bqP5LiN5Y+v6YG/5YWN5Zyw6KaB56e75Yqo6K6w5b2V77yM6Iul5LiN56e75Yqo6K6w5b2V5bCx6ZyA6KaB5pS55Y+Y5pWw5o2u57uT5p6E44CCXG7liJ3lp4vljJbvvJrkuIvmoIflgLzkuLow55qE5YiG6YeP5L2c5Li66KGo5aS057uT54K577yM5YWz6ZSu5a2X5Y+W5Li65pyA5aSn5YC877yM5ZCE5YiG6YeP55qE5oyH6ZKI5YC85Li656m677ybXG7ikaAgIOWwhumdmeaAgemTvuihqOS4reaVsOe7hOS4i+agh+WAvOS4ujHnmoTliIbph48o57uT54K5KeS4juihqOWktOe7k+eCueaehOaIkOS4gOS4quW+queOr+mTvuihqO+8m1xu4pGhIGk9MiDvvIzlsIbliIbph49SW2ld5oyJ5YWz6ZSu5a2X6YCS5YeP5o+S5YWl5Yiw5b6q546v6ZO+6KGo77ybXG7ikaIgIOWinuWKoGkg77yM6YeN5aSN4pGh77yM55u05Yiw5YWo6YOo5YiG6YeP5o+S5YWl5Yiw5b6q546v6ZO+6KGo44CCXG5cbuWSjOebtOaOpeaPkuWFpeaOkuW6j+ebuOavlO+8jOS4jeWQjOeahOaYr+S/ruaUuTJu5qyh5oyH6ZKI5YC85Lul5Luj5pu/56e75Yqo6K6w5b2V77yM6ICM5YWz6ZSu5a2X55qE5q+U6L6D5qyh5pWw55u45ZCM77yM5pWF5pe26Ze05aSN5p2C5bqm5Li6TyhuMinjgIJcblxu6KGo5o+S5YWl5o6S5bqP5b6X5Yiw5LiA5Liq5pyJ5bqP6ZO+6KGo77yM5a+55YW25Y+v5Lul5pa55L6/5Zyw6L+b6KGM6aG65bqP5p+l5om+77yM5L2G5LiN6IO95a6e546w6ZqP5py65p+l5om+44CC5Li65LqG6IO95a6e546w5pyJ5bqP6KGo55qE5oqY5Y2K5p+l5om+5qC55o2u6ZyA6KaB77yM5Y+v5Lul5a+56K6w5b2V6L+b6KGM6YeN5o6SLlxuXG7ph43mjpLorrDlvZXnmoTlgZrms5XmmK/vvJrpobrluo/miavmj4/mnInluo/pk77ooajvvIzlsIbpk77ooajkuK3nrKxp5Liq57uT54K556e75Yqo6Iez5pWw57uE55qE56ysaeS4quWIhumHj+S4reOAglxuXG7kvovlrZDkuK3vvIzpk77ooajkuK3nrKzkuIDkuKrnu5PngrnvvIzljbPlhbPplK7lrZfmnIDlsI/nmoTnu5PngrnmmK/mlbDnu4TkuK3kuIvmoIfkuLo255qE5YiG6YeP77yM5YW25Lit6K6w5b2V5bqU56e76Iez5pWw57uE55qE56ys5LiA5Liq5YiG6YeP77yM5YiZ5bCGbGlzdFsxXeWSjGxpc3RbNl3kupLmjaLvvIzlubbkuLrkuobkuI3kuK3mlq3pnZnmgIHpk77ooajkuK3nmoTpk77vvIzljbPlnKjnu6fnu63pobrpk77ooajmiavmj4/ml7bku43og73mib7liLDkupLmjaLkuYvliY3lnKhsaXN0WzFd5Lit55qE57uT54K577yM5Luk5LqS5o2i5LmL5ZCO55qEbGlzdFsxXeS4reeahOa4uOagh+aUueS4ujZcblxu5o6o5bm/6Iez5LiA6Iis5oOF5Ya177yM6Iul56ysaeS4quacgOWwj+WFs+mUruWtl+eahOe7k+eCueaYr+aVsOe7hOS4reS4i+agh+S4unDkuJRwID4gaeeahOWIhumHj++8jOWImeS6kuaNomxpc3RbaV3lkoxsaXN0W3Bd77yM5LiU5LukbGlzdFtpXeS4reeahOa4uOagh+aUueS4unDvvJtcbueUseS6juatpOaXtuaVsOe7hOS4reaJgOacieWwj+S6jmnnmoTliIbph4/kuK3lt7LmmK/liLDkvY3orrDlvZXvvIzliJnlvZNwPGnml7bvvIzlupTpobrpk77nu6fnu63mn6Xmib7nm7TliLBwPj1p5Li65q2i44CCXG4gKi9cblxuXG4vLyDooajmj5LlhaXmjpLluo9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0aWNMaW5rZWRMaXN0SW5zZXJ0U29ydChzbGxpc3QsIGNvbXAgPSBkZWZhdWx0Q29tcGFyZSkge1xuICAgIC8vIOaehOaIkOW+queOr+mTvuihqFxuICAgIHNsbGlzdFswXS5jdXIgPSAxO1xuICAgIHNsbGlzdFsxXS5jdXIgPSAwO1xuXG4gICAgbGV0IHAsIHE7XG4gICAgZm9yIChsZXQgaSA9IDIsIGxlbiA9IHNsbGlzdC5sZW5ndGg7IGkgPD0gbGVuOyArK2kpIHtcbiAgICAgICAgcCA9IDA7XG4gICAgICAgIGxldCB4ID0gc2xsaXN0W2ldLmRhdGE7XG5cbiAgICAgICAgd2hpbGUgKHNsbGlzdFtwXS5jdXIgJiYgY29tcChzbGxpc3Rbc2xsaXN0W3BdLmN1cl0uZGF0YSwgeCkgPCAwKVxuICAgICAgICAgICAgcCA9IHNsbGlzdFtwXS5jdXI7XG5cbiAgICAgICAgLy8g5b2T6YGH5Yiw5aSn5LqO5b2T5YmN5YWz6ZSu5a2X55qE5LiL5qCH5pe277yM5o+S5YWl5Yiw5YW25YmN6amx5ZKM5ZCO57un55qE5Lit6Ze0XG4gICAgICAgIHEgPSBzbGxpc3RbcF0uY3VyO1xuICAgICAgICBzbGxpc3RbcF0uY3VyID0gaTtcbiAgICAgICAgc2xsaXN0W2ldLmN1ciA9IHE7XG4gICAgfVxufVxuZXhwb3J0cy5zdGF0aWNMaW5rZWRMaXN0SW5zZXJ0U29ydCA9IHN0YXRpY0xpbmtlZExpc3RJbnNlcnRTb3J0O1xuXG4vLyDph43mjpLpnZnmgIHpk77ooajvvIzpnZnmgIHpk77ooajkuIvmoIflt7LmjpLlpb3luo9cbmZ1bmN0aW9uIGFycmFuZ2Uoc2xsaXN0KSB7XG4gICAgbGV0IHAgPSBzbGxpc3RbMF0uY3VyO1xuXG4gICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHNsbGlzdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAvLyDnrKxp5Liq6K6w5b2V5ZyobGlzdOS4reeahOW9k+WJjeS9jee9ruW6lOS4jeWwj+S6jmlcbiAgICAgICAgLy8g5om+5Yiw56ysaeS4quiusOW9le+8jOW5tueUqHDmjIfnpLrlhbblnKhsaXN05Lit5b2T5YmN5L2N572uXG4gICAgICAgIHdoaWxlIChwIDwgaSkgcCA9IHNsbGlzdFtwXS5jdXI7XG4gICAgICAgIC8vIHHmjIflkJHlsJrmnKrosIPmlbTnmoTooajlsL5cbiAgICAgICAgbGV0IHEgPSBzbGxpc3RbcF0uY3VyO1xuXG4gICAgICAgIGlmIChwICE9PSBpKSB7XG4gICAgICAgICAgICAvLyDkuqTmjaLorrDlvZXvvIzkvb/nrKxp5Liq6K6w5b2V5Yiw5L2NXG4gICAgICAgICAgICBsZXQgdGVtcCA9IHNsbGlzdFtwXTtcbiAgICAgICAgICAgIHNsbGlzdFtwXSA9IHNsbGlzdFtpXTtcbiAgICAgICAgICAgIHNsbGlzdFtpXSA9IHRlbXA7XG4gICAgICAgICAgICAvLyDmjIflkJHooqvnp7votbDnmoTorrDlvZXvvIzkvb/lvpfku6XlkI7lj6/mnIl3aGlsZeW+queOr+aJvuWIsFxuICAgICAgICAgICAgc2xsaXN0W2ldLmN1ciA9IHA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBw5oyH5ZCR5bCa5pyq6LCD5pW055qE6KGo5bC+XG4gICAgICAgIHAgPSBxO1xuICAgIH1cbn1cblxuXG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA1Ml07XG52YXIgZCA9IG5ldyBTdGF0aWNMaW5rZWRMaXN0KCk7XG5kLmNyZWF0ZShhcnIpO1xuc3RhdGljTGlua2VkTGlzdEluc2VydFNvcnQoZCk7XG5jb25zb2xlLmxvZyhkKTtcbmFycmFuZ2UoZCk7XG5jb25zb2xlLmxvZyhkKTtcblxuXG4vKlxu5biM5bCU5o6S5bqPXG5cbuW4jOWwlOaOkuW6jyhTaGVsbCBTb3J077yM5Y+I56ew57yp5bCP5aKe6YeP5rOVKeaYr+S4gOenjeWIhue7hOaPkuWFpeaOkuW6j+aWueazleOAglxuXG4xICDmjpLluo/mgJ3mg7NcbuKRoCAgIOWFiOWPluS4gOS4quato+aVtOaVsGQxKGQxPG4p5L2c5Li656ys5LiA5Liq5aKe6YeP77yM5bCG5YWo6YOobuS4quiusOW9leWIhuaIkGQx57uE77yM5oqK5omA5pyJ55u46ZqUZDHnmoTorrDlvZXmlL7lnKjkuIDnu4TkuK3vvIzljbPlr7nkuo7mr4/kuKprKGs9MSwgMiwgIOKApiBkMSnvvIxSW2tdLCBSW2QxK2tdLCBSWzJkMStrXSAsIOKApuWIhuWcqOWQjOS4gOe7hOS4re+8jOWcqOWQhOe7hOWGhei/m+ihjOebtOaOpeaPkuWFpeaOkuW6j+OAgui/meagt+S4gOasoeWIhue7hOWSjOaOkuW6j+i/h+eoi+ensOS4uuS4gOi2n+W4jOWwlOaOkuW6j++8m1xu4pGhICAg5Y+W5paw55qE5aKe6YePZDI8ZDHvvIzph43lpI3ikaDnmoTliIbnu4TlkozmjpLluo/mk43kvZzvvJvnm7Toh7PmiYDlj5bnmoTlop7ph49kaT0x5Li65q2i77yM5Y2z5omA5pyJ6K6w5b2V5pS+6L+b5LiA5Liq57uE5Lit5o6S5bqP5Li65q2i44CCXG5cbjIgIOaOkuW6j+ekuuS+i1xu6K6+5pyJMTDkuKrlvoXmjpLluo/nmoTorrDlvZXvvIzlhbPplK7lrZfliIbliKvkuLo5LCAxMywgOCwgMiwgNSwgMTMsIDcsIDEsIDE1LCAxMe+8jOWinumHj+W6j+WIl+aYrzUsIDMsIDHvvIzluIzlsJTmjpLluo/nmoTov4fnqIs6XG7liJ3lp4vlhbPplK7lrZfluo/liJc6ICAgIDkgICAgIDEzICAgICA4ICAgICAgMiAgICAgIDUgICAgICAxMyAgICAgIDcgICAgICAxICAgICAgMTUgICAgICAxMVxu56ys5LiA6Laf5o6S5bqP5ZCOOiAgICAgIDkgICAgIDcgICAgICAxICAgICAgMiAgICAgIDUgICAgICAxMyAgICAgIDEzICAgICA4ICAgICAgMTUgICAgICAxMVxu56ys5LqM6Laf5o6S5bqP5ZCOOiAgICAgIDIgICAgIDUgICAgICAxICAgICAgOSAgICAgIDcgICAgICAxMyAgICAgIDExICAgICA4ICAgICAgMTUgICAgICAxM1xu56ys5LiJ6Laf5o6S5bqP5ZCOOiAgICAgIDEgICAgIDIgICAgICA1ICAgICAgNyAgICAgIDggICAgICA5ICAgICAgMTEgICAgIDEzICAgICAgMTMgICAgICAxNVxuXG5cbuW4jOWwlOaOkuW6j+eahOWIhuaekOavlOi+g+Wkjeadgu+8jOa2ieWPiuS4gOS6m+aVsOWtpuS4iueahOmXrumimO+8jOWFtuaXtumXtOaYr+aJgOWPlueahOKAnOWinumHj+KAneW6j+WIl+eahOWHveaVsOOAglxuXG7luIzlsJTmjpLluo/nibnngrlcbuWtkOW6j+WIl+eahOaehOaIkOS4jeaYr+eugOWNleeahOKAnOmAkOauteWIhuWJsuKAne+8jOiAjOaYr+WwhuebuOmalOafkOS4quWinumHj+eahOiusOW9lee7hOaIkOS4gOS4quWtkOW6j+WIl+OAglxu5biM5bCU5o6S5bqP5Y+v5o+Q6auY5o6S5bqP6YCf5bqm77yM5Y6f5Zug5piv77yaXG7il4Yg5YiG57uE5ZCObuWAvOWHj+Wwj++8jG7CsuabtOWwj++8jOiAjFQobik9TyhuwrIpLOaJgOS7pVQobinku47mgLvkvZPkuIrnnIvmmK/lh4/lsI/kuobvvJtcbuKXhiDlhbPplK7lrZfovoPlsI/nmoTorrDlvZXot7Pot4PlvI/liY3np7vvvIzlnKjov5vooYzmnIDlkI7kuIDotp/lop7ph4/kuLox55qE5o+S5YWl5o6S5bqP5pe277yM5bqP5YiX5bey5Z+65pys5pyJ5bqP44CCXG5cbuWinumHj+W6j+WIl+WPluazlVxu4peGIOaXoOmZpDHku6XlpJbnmoTlhazlm6DlrZDvvJtcbuKXhiDmnIDlkI7kuIDkuKrlop7ph4/lgLzlv4XpobvkuLox44CCXG5cbuebuOWFs+i1hOaWme+8miBodHRwOi8vd2Vua3UuYmFpZHUuY29tL2xpbms/dXJsPXE3a3pPeFhxYzBCTGFHVVZEWTQzRlFPaDJhWDFVcUJIa2tZZDNWTXdKaEpvNnJ2NFNpVTY4NlJXM2tRQ1NxR0VLeXRsMTJTOGZCT3B3aHEtcnVuaFhfcGJaY2c2QmVELW1pWU1QZ0RoWHhLXG4gKi9cblxuZnVuY3Rpb24gc2hlbGxJbnNlcnQoc3FMaXN0LCBkaywgY29tcCkge1xuICAgIGZvciAobGV0IGkgPSBkaywgbGVuID0gc3FMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGxldCB0ZW1wID0gc3FMaXN0W2ldO1xuICAgICAgICBpZiAoY29tcCh0ZW1wLCBzcUxpc3RbaSAtIGRrXSkgPCAwKSB7XG4gICAgICAgICAgICBsZXQgaiA9IGkgLSBkaztcbiAgICAgICAgICAgIGZvciAoOyBqID49IDAgJiYgY29tcCh0ZW1wLCBzcUxpc3Rbal0pIDwgMDsgaiAtPSBkaylcbiAgICAgICAgICAgICAgICBzcUxpc3RbaiArIGRrXSA9IHNxTGlzdFtqXTtcblxuICAgICAgICAgICAgc3FMaXN0W2ogKyBka10gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hlbGxTb3J0KHNxTGlzdCwgY29tcCA9IGRlZmF1bHRDb21wYXJlKSB7XG4gICAgbGV0IGRlbHRhID0gY3JlYXRlRGVsdGEoc3FMaXN0Lmxlbmd0aCk7XG4gICAgLy9jb25zb2xlLmxvZyhkZWx0YSk7XG4gICAgZm9yIChsZXQgayA9IDAsIHQgPSBkZWx0YS5sZW5ndGg7IGsgPCB0OyArK2spIHtcbiAgICAgICAgc2hlbGxJbnNlcnQoc3FMaXN0LCBkZWx0YVtrXSwgY29tcCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWx0YShuKSB7XG4gICAgbGV0IGFyciA9IFtdO1xuICAgIGxldCB0ID0gKE1hdGgubG9nKG4gLSAxKSAvIE1hdGgubG9nKDIpKSB8IDA7ICAvLyBNYXRoLmxvZyhuIC0gMSkgLyBNYXRoLmxvZygyKSwgTWF0aC5sb2cobiArIDEpIC8gTWF0aC5sb2coMilcbiAgICBmb3IobGV0IGsgPSAwOyBrIDw9IHQ7ICsraylcbiAgICAgICAgYXJyW2tdID0gTWF0aC5wb3coMiwgdCAtIGspICsgMTsgICAgLy8gTWF0aC5wb3coMiwgdCAtIGkgKyAxKSAtIDEsIE1hdGgucG93KDIsIHQgLSBpKSArIDFcblxuICAgIGFyclthcnIubGVuZ3RoXSA9IDE7XG5cbiAgICByZXR1cm4gYXJyO1xufVxuXG5cbmNvbnNvbGUubG9nKCdcXG5cXG5TaGVsbCBTb3J0OicpO1xudmFyIGFyciA9IFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDksIDU1LCA0XTtcbnNoZWxsU29ydChhcnIpO1xuY29uc29sZS5sb2coYXJyICsgJycpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Tb3J0L2luc2VydGlvbi9pbmRleC5qcyIsIi8qKlxuICogQ3JlYXRlZCBieSBsZHAgb24gMjAxNS8yLzcuXG4gKi9cbmltcG9ydCBMaW5rZWRMaXN0IGZyb20gJy4uLy4uL0xpc3QvTGlua2VkTGlzdCc7XG5pbXBvcnQgUXVldWUgZnJvbSAnLi4vLi4vUXVldWUvUXVldWUnO1xuaW1wb3J0IGRlZmF1bHRDb21wYXJlIGZyb20gJy4uL2RlZmF1bHRDb21wYXJpc2lvbic7XG5cbi8qXG4g5b2S5bm25o6S5bqPXG5cbiDlvZLlubYoTWVyZ2luZykg77ya5piv5oyH5bCG5Lik5Liq5oiW5Lik5Liq5Lul5LiK55qE5pyJ5bqP5bqP5YiX5ZCI5bm25oiQ5LiA5Liq5pyJ5bqP5bqP5YiX44CC6Iul6YeH55So57q/5oCn6KGoKOaXoOiuuuaYr+mCo+enjeWtmOWCqOe7k+aehCnmmJPkuo7lrp7njrDvvIzlhbbml7bpl7TlpI3mnYLluqbkuLpPKG0rbikg44CCXG4g5b2S5bm25oCd5oOz5a6e5L6L77ya5Lik5aCG5omR5YWL54mM77yM6YO95bey5LuO5bCP5Yiw5aSn5o6S5aW95bqP77yM6KaB5bCG5Lik5aCG5ZCI5bm25Li65LiA5aCG5LiU6KaB5rGC5LuO5bCP5Yiw5aSn5o6S5bqP44CCXG4g4peGICDlsIbkuKTloIbmnIDkuIrpnaLnmoTmir3lh7oo6K6+5Li6QzHvvIxDMinmr5TovoPlpKflsI/vvIzlsIblsI/ogIXnva7kuo7kuIDovrnkvZzkuLrmlrDnmoTkuIDloIYo5LiN5aao6K6+QzE8QzIp77yb5YaN5LuO56ys5LiA5aCG5Lit5oq95Ye65LiA5byg57un57ut5LiOQzLov5vooYzmr5TovoPvvIzlsIbovoPlsI/nmoTmlL7nva7lnKjmlrDloIbnmoTmnIDkuIvpnaLvvJtcbiDil4Yg6YeN5aSN5LiK6L+w6L+H56iL77yM55u05Yiw5p+Q5LiA5aCG5bey5oq95a6M77yM54S25ZCO5bCG5Ymp5LiL5LiA5aCG5Lit55qE5omA5pyJ54mM6L2s56e75Yiw5paw5aCG5Lit44CCXG5cbiAxICAg5o6S5bqP5oCd5oOzXG4g4pGgICDliJ3lp4vml7bvvIzlsIbmr4/kuKrorrDlvZXnnIvmiJDkuIDkuKrljZXni6znmoTmnInluo/luo/liJfvvIzliJlu5Liq5b6F5o6S5bqP6K6w5b2V5bCx5pivbuS4qumVv+W6puS4ujHnmoTmnInluo/lrZDluo/liJfvvJtcbiDikaEgIOWvueaJgOacieacieW6j+WtkOW6j+WIl+i/m+ihjOS4pOS4pOW9kuW5tu+8jOW+l+WIsO+DqW4vMu+DueS4qumVv+W6puS4ujLmiJYx55qE5pyJ5bqP5a2Q5bqP5YiX4oCU4oCU5LiA6Laf5b2S5bm277ybXG4g4pGiICDph43lpI3ikaEg77yM55u05Yiw5b6X5Yiw6ZW/5bqm5Li6bueahOacieW6j+W6j+WIl+S4uuatouOAglxuXG4g5LiK6L+w5o6S5bqP6L+H56iL5Lit77yM5a2Q5bqP5YiX5oC75piv5Lik5Lik5b2S5bm277yM56ew5Li6Mi3ot6/lvZLlubbmjpLluo/jgILlhbbmoLjlv4PmmK/lpoLkvZXlsIbnm7jpgrvnmoTkuKTkuKrlrZDluo/liJflvZLlubbmiJDkuIDkuKrlrZDluo/liJfjgILorr7nm7jpgrvnmoTkuKTkuKrlrZDluo/liJfliIbliKvkuLrvvJpcbiB7UltrXSwgUltrKzFdLCDigKYsIFJbbV195ZKMe1JbbSsxXSwgUlttKzJdLOKApiwgUltoXX3vvIzlsIblroPku6zlvZLlubbkuLrkuIDkuKrmnInluo/nmoTlrZDluo/liJfvvJpcbiB7RFJbbF0sIERSW2wrMV0sIOKApiwgRFJbbV0sIERSW20rMV0sIOKApiwgRFJbaF0gfVxuXG4g5L6L77ya6K6+5pyJOeS4quW+heaOkuW6j+eahOiusOW9le+8jOWFs+mUruWtl+WIhuWIq+S4ujIzLCAzOCwgMjIsIDQ1LCAyMywgNjcsIDMxLCAxNSwgNDHvvIzlvZLlubbmjpLluo/nmoTov4fnqIvjgIJcbiDliJ3lp4vlhbPplK7lrZc6IFsyM10gICBbMzhdICAgWzIyXSAgIFs0NV0gICBbMjNdICAgWzY3XSAgIFszMV0gICBbMTVdICAgWzQxXVxuICAgICAgICAgICAgICB8ICAgICAgfCAgICAgIHwgICAgICB8ICAgICAgfCAgICAgIHwgICAgICB8ICAgICAgfFxuICAgICAgICAgICAgICAtLS0tLS0tLSAgICAgIC0tLS0tLS0tICAgICAgLS0tLS0tLS0gICAgICAtLS0tLS0tLVxuIOS4gOi2n+W9kuW5tuWQjjogWzIzICAgIDM4XSAgICBbMjIgICAgIDQ1XSAgICBbMjMgICAgIDY3XSAgICBbMTUgICAgIDMxXSAgIFs0MV1cbiAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLSAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLVxuIOS6jOi2n+W9kuW5tuWQjjogWzIyICAgICAyMyAgICAgIDM4ICAgICA0NV0gICAgWzE1ICAgICAyMyAgICAgMzEgICAgIDY3XSAgICBbNDFdXG4gICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiDkuInotp/lvZLlubblkI46IFsxNSAgICAgMjIgICAgICAyMyAgICAgMjMgICAgIDMxICAgICAzOCAgICAgNDUgICAgIDY3XSAgICBbNDFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4g5Zub6Laf5b2S5bm25ZCOOiBbMTUgICAgIDIyICAgICAgMjMgICAgIDIzICAgICAzMSAgICAgMzggICAgIDQxICAgICA0NSAgICAgNjdcblxuXG4gMiAg5LiA6Laf5b2S5bm25o6S5bqPXG4g5LiA6Laf5b2S5bm25o6S5bqP6YO95piv5LuO5YmN5Yiw5ZCO77yM5L6d5qyh5bCG55u46YK755qE5Lik5Liq5pyJ5bqP5a2Q5bqP5YiX5b2S5bm25Li65LiA5Liq77yM5LiU6Zmk5pyA5ZCO5LiA5Liq5a2Q5bqP5YiX5aSW77yM5YW25L2Z5q+P5Liq5a2Q5bqP5YiX55qE6ZW/5bqm6YO955u45ZCM44CC6K6+6L+Z5Lqb5a2Q5bqP5YiX55qE6ZW/5bqm5Li6ZO+8jOWImeS4gOi2n+W9kuW5tuaOkuW6j+eahOi/h+eoi+aYr++8mlxuIOS7jmo9MOW8gOWni++8jOS+neasoeWwhuebuOmCu+eahOS4pOS4quacieW6j+WtkOW6j+WIl1xuIFJbauKApmorZC0xXeWSjFJbaitk4oCmaisyZC0xXei/m+ihjOW9kuW5tu+8m+avj+asoeW9kuW5tuS4pOS4quWtkOW6j+WIl+WQju+8jGrlkI7np7vliqgyZOS4quS9jee9ru+8jOWNs1xuIGo9aisyZO+8m+iLpeWJqeS4i+eahOWFg+e0oOS4jei2s+S4pOS4quWtkOW6j+WIl+aXtu+8jOWIhuS7peS4i+S4pOenjeaDheWGteWkhOeQhu+8mlxuIOKRoCAg5Ymp5LiL55qE5YWD57Sg5Liq5pWwPmTvvJrlho3osIPnlKjkuIDmrKHkuIrov7Dov4fnqIvvvIzlsIbkuIDkuKrplb/luqbkuLpk55qE5a2Q5bqP5YiX5ZKM5LiN6LazZOeahOWtkOW6j+WIl+i/m+ihjOW9kuW5tu+8m1xuIOKRoSAg5Ymp5LiL55qE5YWD57Sg5Liq5pWw4omkZO+8muWwhuWJqeS4i+eahOWFg+e0oOS+neasoeWkjeWItuWIsOW9kuW5tuWQjueahOW6j+WIl+S4reOAglxuXG5cbiAzLueul+azleWIhuaekFxu5YW35pyJbuS4quW+heaOkuW6j+iusOW9leeahOW9kuW5tuasoeaVsOaYr+OPkjJu77yM6ICM5LiA6Laf5b2S5bm255qE5pe26Ze05aSN5p2C5bqm5Li6TyhuKe+8jOWImeaVtOS4quW9kuW5tuaOkuW6j+eahOaXtumXtOWkjeadguW6puaXoOiuuuaYr+acgOWlvei/mOaYr+acgOWdj+aDheWGteWdh+S4uk8obuOPkjJuKeOAguWcqOaOkuW6j+i/h+eoi+S4re+8jOS9v+eUqOS6hui+heWKqeWQkemHj0RS77yM5aSn5bCP5LiO5b6F5o6S5bqP6K6w5b2V56m66Ze055u45ZCM77yM5YiZ56m66Ze05aSN5p2C5bqm5Li6TyhuKeOAguW9kuW5tuaOkuW6j+aYr+eos+WumueahOOAglxuXG4gKi9cblxubGV0IG5Db3VudCA9IDA7XG5sZXQgbm9uUmVjdXJzaXZlQ291bnQgPSAwO1xubGV0IHJlY3Vyc2l2ZUNvdW50ID0gMDtcblxuLyoqXG4gKiDlsIbmnInluo/nmoRzcltzMS4uZTFd5ZKMc3JbczIuLmUyXeW9kuW5tuS4uuacieW6j+eahHRyW3MxLi5lMl1cbiAqIEBwYXJhbSBzclxuICogQHBhcmFtIHMxXG4gKiBAcGFyYW0gZTFcbiAqIEBwYXJhbSBlMlxuICovXG5mdW5jdGlvbiBtZXJnZShzciwgczEsIGUxLCBlMiwgY29tcCA9IGRlZmF1bHRDb21wYXJlKXtcbiAgICBsZXQgdGVtcCA9IFtdO1xuICAgIGxldCBpID0gczE7XG4gICAgbGV0IGogPSBlMSArIDE7XG4gICAgbGV0IGsgPSAwO1xuXG4gICAgd2hpbGUoaSA8PSBlMSAmJiBqIDw9IGUyKXtcbiAgICAgICAgaWYoY29tcChzcltpXSwgc3Jbal0pIDwgMCkgdGVtcFtrKytdID0gc3JbaSsrXTtcbiAgICAgICAgZWxzZSB0ZW1wW2srK10gPSBzcltqKytdO1xuICAgIH1cbiAgICB3aGlsZShpIDw9IGUxKSB0ZW1wW2srK10gPSBzcltpKytdO1xuICAgIHdoaWxlKGogPD0gZTIpIHRlbXBbaysrXSA9IHNyW2orK107XG5cbiAgICAvLyDlpI3liLblm57ljrtcbiAgICBmb3IoaSA9IHMxLCBrID0gMDsgaSA8PSBlMjsgKytpLCArK2spIHNyW2ldID0gdGVtcFtrXTtcbn1cblxuLyoqXG4gKiAyLei3r+W9kuW5tuaOkuW6j+mAkuW9kueul+azlVxuICogQHBhcmFtIHtBcnJheX0gc3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBzXG4gKiBAcGFyYW0ge051bWJlcn0gdFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTb3J0UmVjdXJzaXZlKHNyLCBzID0gMCwgdCA9IHNyLmxlbmd0aCAtIDEsIGNvbXAgPSBkZWZhdWx0Q29tcGFyZSl7XG4gICAgaWYocyA+PSB0KSByZXR1cm47XG5cbiAgICAvLyDlsIZzcltzLi50XeW5s+WIhuS4unNyW3MuLm1d5ZKMc3JbbSsxLi50XVxuICAgIGxldCBtID0gKHMgKyB0KSA+PiAxO1xuICAgIC8vIOmAkuW9kuWcsOWwhnNyW3MuLm1d5b2S5bm25Li65pyJ5bqP55qEc3Jbcy4ubV1cbiAgICBtZXJnZVNvcnRSZWN1cnNpdmUoc3IsIHMsIG0sIGNvbXApO1xuICAgIC8vIOmAkuW9kuWcsOWwhnNyW20rMS4udF3lvZLlubbkuLrmnInluo/nmoRzclttKzEuLnRdXG4gICAgbWVyZ2VTb3J0UmVjdXJzaXZlKHNyLCBtICsgMSwgdCwgY29tcCk7XG4gICAgLy8g5bCGc3Jbcy4ubV3lkoxzclttKzEuLnRd5b2S5bm25Yiwc3Jbcy4udF07XG4gICAgbWVyZ2Uoc3IsIHMsIG0sIHQsIGNvbXApO1xufVxuXG5cbmNvbnNvbGUubG9nKCdcXG5cXG5tZXJnZVNvcnRSZWN1cnNpdmU6Jyk7XG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA0OSwgNTUsIDRdO1xubWVyZ2VTb3J0UmVjdXJzaXZlKGFycik7XG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XG5cblxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTb3J0Tm9uUmVjdXJzaXZlKHNyLCBjb21wID0gZGVmYXVsdENvbXBhcmUpe1xuICAgIGxldCBqLCBrO1xuICAgIGZvcihsZXQgZCA9IDEsIG4gPSBzci5sZW5ndGggLSAxOyBkIDwgbjsgZCAqPSAyKSB7XG4gICAgICAgIC8vIOS4gOi2n+W9kuW5tuaOkuW6j+eul+azlVxuICAgICAgICBqID0gMDtcblxuICAgICAgICAvLyDlrZDluo/liJfkuKTkuKTlvZLlubZcbiAgICAgICAgd2hpbGUoKGsgPSAoaiArIDIgKiBkIC0gMSkpIDwgbil7XG4gICAgICAgICAgICBtZXJnZShzciwgaiwgIGogKyBkIC0gMSwgaywgY29tcCk7XG4gICAgICAgICAgICBqID0gayArIDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDliankvZnlhYPntKDkuKrmlbDotoXov4fkuIDkuKrlrZDluo/liJfplb/luqZcbiAgICAgICAgaWYoaiArIGQgLSAxIDwgbikgbWVyZ2Uoc3IsIGosIGogKyBkIC0gMSwgbiwgY29tcCk7XG4gICAgICAgIC8vIOWJqeS9meWtkOW6j+WIl+WkjeWItlxuICAgICAgICBlbHNlIG1lcmdlKHNyLCBqLCBuLCBuLCBjb21wKTtcbiAgICB9XG59XG5cbmNvbnNvbGUubG9nKCdcXG5tZXJnZVNvcnROb25SZWN1cnNpdmU6Jyk7XG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA0OSwgNTUsIDRdO1xubWVyZ2VTb3J0Tm9uUmVjdXJzaXZlKGFycik7XG5jb25zb2xlLmxvZyhhcnIgKyAnJyk7XG5cblxuLy8g6Ieq54S25ZCI5bm25o6S5bqPXG4vLyBodHRwOi8vd3d3LmNuYmxvZ3MuY29tL2xpdXNoYW5nMDQxOS9hcmNoaXZlLzIwMTEvMDkvMTkvMjE4MTQ3Ni5odG1sXG4vLyBodHRwOi8vd3d3LmNuYmxvZ3MuY29tL2xhbmtlL2FyY2hpdmUvMjAxMy8wMS8xNS8yODYwNDg3Lmh0bWxcbi8qXG7oh6rnhLblvZLlubbmmK/lvZLlubbmjpLluo/nmoTkuIDkuKrlj5jlvaLvvIzmlYjnjofmm7Tpq5jkuIDkupvvvIzlj6/ku6XlnKjlvZLlubbmjpLluo/pnZ7pgJLlvZLlrp7njrDnmoTln7rnoYDkuIrov5vooYzkv67mlLku5a+55LqO5bey57uP5LiA5Liq5bey57uP57uZ5a6a5pWw57uEYSzpgJrluLjlrZjlnKjlpJrkuKrplb/luqblpKfkuo4x55qE5bey57uP6Ieq54S25o6S5aW955qE5a2Q5pWw57uE5q61LOWboOatpOeUqOS4gOasoeWvueaVsOe7hGHnmoTnur/mgKfmiavmj4/lsLHlj6/ku6Xmib7lh7rmiYDmnInov5nkupvmjpLlpb3luo/nmoTlrZDmlbDnu4TmrrUs54S25ZCO5YaN5a+56L+Z5Lqb5a2Q5pWw57uE5q615L+p5L+p5ZCI5bm2LlxuICovXG5cblxuLy8g5omr5o+P5b6X5Yiw5a2Q5Liy55qE5Ye95pWwXG5mdW5jdGlvbiBwYXNzKHNxTGlzdCwgcmVjLCBjb21wKXtcbiAgICBsZXQgbnVtID0gMDtcbiAgICByZWNbbnVtKytdID0gMDtcbiAgICBsZXQgbGVuID0gc3FMaXN0Lmxlbmd0aDtcblxuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBsZW47ICsraSl7XG4gICAgICAgIGlmKGNvbXAoc3FMaXN0W2ldLCBzcUxpc3RbaSArIDFdKSA+IDApIHJlY1tudW0rK10gPSBpICsgMTtcbiAgICB9XG4gICAgcmVjW251bSsrXSA9IGxlbjtcblxuICAgIHJldHVybiBudW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYXR1cmVNZXJnZVNvcnQoc3FMaXN0LCBjb21wID0gZGVmYXVsdENvbXBhcmUpe1xuICAgIGxldCByZWMgPSBbXTtcblxuICAgIC8vbnVtPTLor7TmmI7lt7Lnu4/mjpLlpb3luo/kuoZcbiAgICAvL+avj+W+queOr+S4gOasoe+8jOi/m+ihjOS4gOasoXBhc3MoKeaTjeS9nFxuICAgIGZvcihsZXQgbnVtID0gcGFzcyhzcUxpc3QsIHJlYywgY29tcCk7IG51bSAhPT0gMjsgbnVtID0gcGFzcyhzcUxpc3QsIHJlYywgY29tcCkpe1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpICsgMiA8IG51bTsgaSArPSAyKSB7XG4gICAgICAgICAgICBtZXJnZShzcUxpc3QsIHJlY1tpXSwgcmVjW2kgKyAxXSAtIDEsIHJlY1tpICsgMl0gLSAxLCBjb21wKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc29sZS5sb2coJ1xcbm5hdHVyZU1lcmdlU29ydDonKTtcbnZhciBhcnIgPSBbNDksIDM4LCA2NSwgOTcsIDc2LCAxMywgMjcsIDQ5LCA1NSwgNF07XG5uYXR1cmVNZXJnZVNvcnQoYXJyKTtcbmNvbnNvbGUubG9nKGFyciArICcnKTtcblxuXG5jb25zb2xlLmxvZyhyZWN1cnNpdmVDb3VudCk7XG5jb25zb2xlLmxvZyhub25SZWN1cnNpdmVDb3VudCk7XG5jb25zb2xlLmxvZyhuQ291bnQpO1xuXG4vLyDlj4zlkJHoh6rnhLblkIjlubbmjpLluo/nrpfms5Vcbi8qXG7lj4zlkJHoh6rnhLblkIjlubbmjpLluo/mmK/moLnmja7mrLLmjpLluo/mlbDmja7lsYDpg6jkuI3mmK/ljYfluo/lsLHmmK/pmY3luo/nmoToh6rnhLbmnInluo/nibnngrks5YWI57q/5oCn5omr5o+P5Ye66Ieq54S25pyJ5bqP55qE5a2Q5pWw57uE5q61LOWGjei/m+ihjOWQiOW5tuaOkuW6jy7miavmj4/ml7bnmoTmnInluo/mlbDmrrXplb/luqbotorplb8s5q615pWw6LaK5bCRLOWvueW6lOWQiOW5tuagkeeahOWxguaVsOWwseS8mui2iuWwkSznrpfms5XnmoTmlYjnjofotorpq5guXG4gKi9cbmV4cG9ydCBsZXQgbmF0dXJhbE1lcmdlU29ydCA9IChmdW5jdGlvbigpe1xuICAgIHJldHVybiBuYXR1cmFsTWVyZ2VTb3J0O1xuXG4gICAgZnVuY3Rpb24gbmF0dXJhbE1lcmdlU29ydChhLCBjb21wID0gZGVmYXVsdENvbXBhcmUpe1xuICAgICAgICBsZXQgYiA9IFtdO1xuICAgICAgICBsZXQgbiA9IGEubGVuZ3RoO1xuICAgICAgICB3aGlsZSghbWVyZ2VSdW5zKGEsIGIsIG4sIGNvbXApKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZVJ1bnMoYSwgYiwgbiwgY29tcCl7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGsgPSAwO1xuICAgICAgICBsZXQgYXNjID0gdHJ1ZTtcbiAgICAgICAgbGV0IHg7XG5cbiAgICAgICAgd2hpbGUoaSA8IG4pe1xuICAgICAgICAgICAgayA9IGk7XG4gICAgICAgICAgICAvLyDmib7liLDmnIDlkI7kuIDkuKrpgJLlop7luo/liJflhYPntKBcbiAgICAgICAgICAgIGRvIHggPSBhW2krK107IHdoaWxlKGkgPCBuICYmIGNvbXAoeCwgYVtpXSkgPD0gMCk7XG4gICAgICAgICAgICAvLyDmib7liLDmnIDlkI7kuIDkuKrpgJLlh4/luo/liJflhYPntKBcbiAgICAgICAgICAgIHdoaWxlKGkgPCBuICYmIGNvbXAoeCwgYVtpXSkgPj0gMCkgeCA9IGFbaSsrXTtcbiAgICAgICAgICAgIC8vIOW9kuW5tumAkuWinuW6j+WIl+WSjOmAkuWHj+W6j+WIl++8jOe7k+aenOWPr+iDvemAkuWinuaIlumAkuWHj1xuICAgICAgICAgICAgbWVyZ2UoYSwgYiwgaywgaSAtIDEsIGFzYywgY29tcCk7XG4gICAgICAgICAgICBhc2MgPSAhYXNjO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5b2Ta+etieS6jjDml7bku6Pooahh5bey57uP5o6S5aW95bqP5LqGXG4gICAgICAgIHJldHVybiBrID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlKGEsIGIsIGxvdywgaGlnaCwgYXNjLCBjb21wKXtcbiAgICAgICAgbGV0IGsgPSBhc2MgPyBsb3cgOiBoaWdoO1xuICAgICAgICBsZXQgYyA9IGFzYyA/IDEgOiAtMTtcbiAgICAgICAgbGV0IGkgPSBsb3c7XG4gICAgICAgIGxldCBqID0gaGlnaDtcblxuICAgICAgICB3aGlsZShpIDw9IGope1xuICAgICAgICAgICAgaWYoY29tcChhW2ldLCBhW2pdKSA8PSAwKSBiW2tdID0gYVtpKytdO1xuICAgICAgICAgICAgZWxzZSBiW2tdID0gYVtqLS1dO1xuICAgICAgICAgICAgayArPSBjO1xuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gayA9IGxvdywgaiA9IGhpZ2g7IGkgPD0gajsgKytpLCArK2spIGFbaV0gPSBiW2tdO1xuICAgIH1cbn0pKCk7XG5cbmNvbnNvbGUubG9nKCdcXG5uYXR1cmFsTWVyZ2VTb3J0OicpO1xudmFyIGFyciA9IFs0OSwgMzgsIDY1LCA5NywgNzYsIDEzLCAyNywgNDksIDU1LCA0XTtcbm5hdHVyYWxNZXJnZVNvcnQoYXJyKTtcbmNvbnNvbGUubG9nKGFyciArICcnKTtcblxuXG4vLyDpk77ooajlrZjlgqjnu5PmnoTnmoToh6rnhLblkIjlubbmjpLluo9cbmV4cG9ydCBsZXQgbGlua2VkTGlzdE5hdHVyYWxNZXJnZVNvcnQgPSAoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbWVyZ2VTb3J0O1xuXG4gICAgZnVuY3Rpb24gbWVyZ2VTb3J0KGxpbmtlZGxpc3QsIG5lZWRSZXBsYWNlID0gdHJ1ZSwgY29tcCA9IGRlZmF1bHRDb21wYXJlKXtcbiAgICAgICAgaWYoIWxpbmtlZGxpc3QpIHJldHVybiBsaW5rZWRsaXN0O1xuXG4gICAgICAgIGxldCBxdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuICAgICAgICBsZXQgbGlzdCA9IGxpbmtlZGxpc3QuaGVhZDtcblxuICAgICAgICBpZighbGlzdCB8fCAhbGlzdC5uZXh0KSByZXR1cm4gbGlua2VkbGlzdDtcblxuICAgICAgICBsZXQgdSA9IGxpc3Q7XG4gICAgICAgIGxldCB0ID0gbGlzdDtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIC8vIOWwhumAkuWinueahOe7k+eCueaUvuWFpeWIsOmYn+WIl+S4re+8iOS8muiiq+WIh+aWre+8iVxuICAgICAgICBmb3IoOyB0OyB0ID0gdSl7XG4gICAgICAgICAgICB3aGlsZSh1ICYmIHUubmV4dCAmJiBjb21wKHUuZGF0YSwgdS5uZXh0LmRhdGEpIDw9IDApXG4gICAgICAgICAgICAgICAgdSA9IHUubmV4dDtcbiAgICAgICAgICAgIHYgPSB1O1xuICAgICAgICAgICAgdSA9IHUubmV4dDtcbiAgICAgICAgICAgIHYubmV4dCA9IG51bGw7XG4gICAgICAgICAgICBxdWV1ZS5lblF1ZXVlKHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdCA9IHF1ZXVlLmRlUXVldWUoKTtcbiAgICAgICAgLy8g5ZCI5bm257uT54K5XG4gICAgICAgIHdoaWxlKHF1ZXVlLnNpemUpe1xuICAgICAgICAgICAgcXVldWUuZW5RdWV1ZSh0KTtcbiAgICAgICAgICAgIGxldCBhID0gcXVldWUuZGVRdWV1ZSgpO1xuICAgICAgICAgICAgbGV0IGIgPSBxdWV1ZS5kZVF1ZXVlKCk7XG4gICAgICAgICAgICB0ID0gbWVyZ2UoYSwgYiwgY29tcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihuZWVkUmVwbGFjZSkgbGlua2VkbGlzdC5oZWFkID0gdDtcblxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZShhLCBiLCBjb21wKXtcbiAgICAgICAgbGV0IGMgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgICAgICBsZXQgaGVhZCA9IHtkYXRhOiBudWxsLCBuZXh0OiBudWxsfTtcbiAgICAgICAgYy5oZWFkID0gaGVhZDtcbiAgICAgICAgYyA9IGMuaGVhZDtcblxuICAgICAgICB3aGlsZShhICYmIGIpe1xuICAgICAgICAgICAgaWYoY29tcChhLmRhdGEsIGIuZGF0YSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgYy5uZXh0ID0gYTtcbiAgICAgICAgICAgICAgICBjID0gYTtcbiAgICAgICAgICAgICAgICBhID0gYS5uZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjLm5leHQgPSBiO1xuICAgICAgICAgICAgICAgIGMgPSBiO1xuICAgICAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjLm5leHQgPSBhID8gYSA6IGI7XG5cbiAgICAgICAgcmV0dXJuIGhlYWQubmV4dDtcbiAgICB9XG59KSgpO1xuXG52YXIgYXJyID0gWzQ5LCAzOCwgNjUsIDk3LCA3NiwgMTMsIDI3LCA0OSwgNTUsIDRdO1xudmFyIGxpbmtlZExpc3QgPSBuZXcgTGlua2VkTGlzdChhcnIpO1xubGlua2VkTGlzdE5hdHVyYWxNZXJnZVNvcnQobGlua2VkTGlzdCk7XG5jb25zb2xlLmxvZyhsaW5rZWRMaXN0ICsgJycpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Tb3J0L21lcmdpbmcvaW5kZXguanMiLCIvKipcbiAqIENyZWF0ZWQgYnkgbHVrZSBvbiAyMDE1LzIvMi5cbiAqL1xuXG5pbXBvcnQgZGVmYXVsdENvbXBhcmUgZnJvbSAnLi4vZGVmYXVsdENvbXBhcmlzaW9uJztcblxuLypcbumAieaLqeaOkuW6j1xuXG7pgInmi6nmjpLluo8oU2VsZWN0aW9uIFNvcnQp55qE5Z+65pys5oCd5oOz5piv77ya5q+P5qyh5LuO5b2T5YmN5b6F5o6S5bqP55qE6K6w5b2V5Lit6YCJ5Y+W5YWz6ZSu5a2X5pyA5bCP55qE6K6w5b2V6KGo77yM54S25ZCO5LiO5b6F5o6S5bqP55qE6K6w5b2V5bqP5YiX5Lit55qE56ys5LiA5Liq6K6w5b2V6L+b6KGM5Lqk5o2i77yM55u05Yiw5pW05Liq6K6w5b2V5bqP5YiX5pyJ5bqP5Li65q2i44CCXG5cblxu566A5Y2V6YCJ5oup5o6S5bqPXG5cbueugOWNlemAieaLqeaOkuW6jyhTaW1wbGUgU2VsZWN0aW9uIFNvcnQg77yM5Y+I56ew5Li655u05o6l6YCJ5oup5o6S5bqPKeeahOWfuuacrOaTjeS9nOaYr++8mumAmui/h24taeasoeWFs+mUruWtl+mXtOeahOavlOi+g++8jOS7jm4taSsx5Liq6K6w5b2V5Lit6YCJ5Y+W5YWz6ZSu5a2X5pyA5bCP55qE6K6w5b2V77yM54S25ZCO5ZKM56ysaeS4quiusOW9lei/m+ihjOS6pOaNou+8jGk9MSwgMiwg4oCmIG4tMSDjgIJcbjEgIOaOkuW6j+ekuuS+i1xu5L6L77ya6K6+5pyJ5YWz6ZSu5a2X5bqP5YiX5Li677yaNywgNCwgLTIsIDE5LCAxMywgNu+8jOebtOaOpemAieaLqeaOkuW6j+eahOi/h+eoi++8mlxu5Yid5aeL6K6w5b2V55qE5YWz6ZSu5a2X77yaICA3ICAgICA0ICAgIC0yICAgICAxOSAgICAxMyAgICA2XG4gICAg56ys5LiA6Laf5o6S5bqP77yaICAtMiAgICAgNCAgICAgNyAgICAgMTkgICAgMTMgICAgNlxuICAgIOesrOS6jOi2n+aOkuW6j++8miAgLTIgICAgIDQgICAgIDcgICAgIDE5ICAgIDEzICAgIDZcbiAgICDnrKzkuInotp/mjpLluo/vvJogIC0yICAgICA0ICAgICA2ICAgICAxOSAgICAxMyAgICA3XG4gICAg56ys5Zub6Laf5o6S5bqP77yaICAtMiAgICAgNCAgICAgNiAgICAgNyAgICAgMTMgICAgMTlcbiAgICDnrKzkupTotp/mjpLluo/vvJogIC0yICAgICA0ICAgICA2ICAgICA3ICAgICAxMyAgICAxOVxuICAgIOesrOWFrei2n+aOkuW6j++8miAgLTIgICAgIDQgICAgIDYgICAgIDcgICAgIDEzICAgIDE5XG5cbjIu566X5rOV5YiG5p6QXG7mlbTkuKrnrpfms5XmmK/kuozph43lvqrnjq/vvJrlpJblvqrnjq/mjqfliLbmjpLluo/nmoTotp/mlbDvvIzlr7lu5Liq6K6w5b2V6L+b6KGM5o6S5bqP55qE6Laf5pWw5Li6bi0x6Laf77yb5YaF5b6q546v5o6n5Yi25q+P5LiA6Laf55qE5o6S5bqP44CCXG7ov5vooYznrKxp6Laf5o6S5bqP5pe277yM5YWz6ZSu5a2X55qE5q+U6L6D5qyh5pWw5Li6bi1p77yM5YiZ77yaXG7mr5TovoPmrKHmlbDvvJogbioobiAtIDEpIC8gMlxu5pe26Ze05aSN5p2C5bqm5piv77yaVChuKT1PKG4yKVxu56m66Ze05aSN5p2C5bqm5piv77yaUyhuKT1PKDEpXG7ku47mjpLluo/nmoTnqLPlrprmgKfmnaXnnIvvvIznm7TmjqXpgInmi6nmjpLluo/mmK/kuI3nqLPlrprnmoTjgIJcblxuICovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsZVNlbGVjdGlvblNvcnQoc3FMaXN0LCBjb21wID0gZGVmYXVsdENvbXBhcmUpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc3FMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGxldCBrID0gaTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGsgKyAxOyBqIDwgbGVuOyArK2opXG4gICAgICAgICAgICBpZiAoY29tcChzcUxpc3Rbal0sIHNxTGlzdFtrXSkgPCAwKSBrID0gajtcblxuICAgICAgICBpZiAoayAhPT0gaSkge1xuICAgICAgICAgICAgbGV0IHRlbXAgPSBzcUxpc3Rba107XG4gICAgICAgICAgICBzcUxpc3Rba10gPSBzcUxpc3RbaV07XG4gICAgICAgICAgICBzcUxpc3RbaV0gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgYXJyID0gWzcsIDQsIC0yLCAxOSwgMTMsIDZdO1xuc2ltcGxlU2VsZWN0aW9uU29ydChhcnIpO1xuY29uc29sZS5sb2coYXJyICsgJycpO1xuXG5cbi8qXG7moJHlvaLpgInmi6nmjpLluo9cblxu6aaW5YWI5a+5buS4quiusOW9leeahOWFs+mUruWtl+S4pOS4pOi/m+ihjOavlOi+g++8jOmAieWPlu+DqW4vMu+DueS4qui+g+Wwj+iAhe+8m+eEtuWQjui/me+DqW4vMu+DueS4qui+g+Wwj+iAheS4pOS4pOi/m+ihjOavlOi+g++8jOmAieWPlu+DqW4vNO+DueS4qui+g+Wwj+iAheKApiDlpoLmraTph43lpI3vvIznm7TliLDlj6rliakx5Liq5YWz6ZSu5a2X5Li65q2i44CCXG7or6Xov4fnqIvlj6/nlKjkuIDmo7XmnIlu5Liq5Y+25a2Q57uT54K555qE5a6M5YWo5LqM5Y+J5qCR6KGo56S677yM5q+P5Liq5p6d57uT54K555qE5YWz6ZSu5a2X6YO9562J5LqO5YW25bem44CB5Y+z5a2p5a2Q57uT54K55Lit6L6D5bCP55qE5YWz6ZSu5a2X77yM5qC557uT54K555qE5YWz6ZSu5a2X5bCx5piv5pyA5bCP55qE5YWz6ZSu5a2X44CCXG7ovpPlh7rmnIDlsI/lhbPplK7lrZflkI7vvIzmoLnmja7lhbPns7vnmoTlj6/kvKDpgJLmgKfvvIzmrLLpgInlj5bmrKHlsI/lhbPplK7lrZfvvIzlj6rpnIDlsIblj7blrZDnu5PngrnkuK3nmoTmnIDlsI/lhbPplK7lrZfmlLnkuLrigJzmnIDlpKflgLzigJ0g77yM54S25ZCO6YeN5aSN5LiK6L+w5q2l6aqk5Y2z5Y+v44CCXG7lkKvmnIlu5Liq5Y+25a2Q57uT54K555qE5a6M5YWo5LqM5Y+J5qCR55qE5rex5bqm5Li674Op44+SMm7vg7krMe+8jOWImeaAu+eahOaXtumXtOWkjeadguW6puS4uk8obuOPkjJuKSDjgIJcblxu5L2G6L+Z56eN5o6S5bqP5pa55rOV5bCa5pyJ6L6F5Yqp5a2Y5YKo56m66Ze06L6D5aSaLOWSjOacgOWkp+WAvOi/m+ihjOWkmuS9meavlOi+g+etiee8uueCueOAguS4uuS6huW8peihpei/meS6m+e8uumZt++8jOWHuueOsOS6huWPpuS4gOenjemAieaLqeaOkuW6jy0tLeWghuaOkuW6j1xuICovXG5cblxuXG4vKlxu5aCG5o6S5bqPXG5cbjEgIOWghueahOWumuS5iVxu5pivbuS4quWFg+e0oOeahOW6j+WIl0g9e2sxLCBrMiAsIOKApiBrbn0g77yM5ruh6Laz77yaXG4gICAga2niiaRrMmkgICAgICAg5b2TMmniiaRu5pe2XG4gICAga2niiaRrMmkrMSAgIOW9kzJpKzHiiaRu5pe2XG5cbueUseWghueahOWumuS5ieefpe+8jOWghuaYr+S4gOajteS7pWsx5Li65qC555qE5a6M5YWo5LqM5Y+J5qCR44CC6Iul5a+56K+l5LqM5Y+J5qCR55qE57uT54K56L+b6KGM57yW5Y+3KOS7juS4iuWIsOS4i++8jOS7juW3puWIsOWPsynvvIzlvpfliLDnmoTluo/liJflsLHmmK/lsIbkuozlj4nmoJHnmoTnu5Pngrnku6Xpobrluo/nu5PmnoTlrZjmlL7vvIzloIbnmoTnu5PmnoTmraPlpb3lkozor6Xluo/liJfnu5PmnoTlrozlhajkuIDoh7TjgIJcblxuMiAg5aCG55qE5oCn6LSoXG4gICAgMSkgIOWghuaYr+S4gOajtemHh+eUqOmhuuW6j+WtmOWCqOe7k+aehOeahOWujOWFqOS6jOWPieagke+8jCBrMeaYr+aguee7k+eCue+8m1xuICAgIDIpICDloIbnmoTmoLnnu5PngrnmmK/lhbPplK7lrZfluo/liJfkuK3nmoTmnIDlsI8o5oiW5pyA5aSnKeWAvO+8jOWIhuWIq+ensOS4uuWwjyjmiJblpKcp5qC55aCG77ybXG4gICAgMykgIOS7juaguee7k+eCueWIsOavj+S4gOWPtuWtkOe7k+eCuei3r+W+hOS4iueahOWFg+e0oOe7hOaIkOeahOW6j+WIl+mDveaYr+aMieWFg+e0oOWAvCjmiJblhbPplK7lrZflgLwp6Z2e6YCS5YePKOaIlumdnumAkuWininnmoTvvJtcbiAgICA0KSAg5aCG5Lit55qE5Lu75LiA5a2Q5qCR5Lmf5piv5aCG44CCXG5cbuWIqeeUqOWghumhtuiusOW9leeahOWFs+mUruWtl+WAvOacgOWwjyjmiJbmnIDlpKcp55qE5oCn6LSo77yM5LuO5b2T5YmN5b6F5o6S5bqP55qE6K6w5b2V5Lit5L6d5qyh6YCJ5Y+W5YWz6ZSu5a2X5pyA5bCPKOaIluacgOWkpynnmoTorrDlvZXvvIzlsLHlj6/ku6Xlrp7njrDlr7nmlbDmja7orrDlvZXnmoTmjpLluo/vvIzov5nnp43mjpLluo/mlrnms5Xnp7DkuLrloIbmjpLluo/jgIJcblxuMyAg5aCG5o6S5bqP5oCd5oOzXG5cbuKRoCAg5a+55LiA57uE5b6F5o6S5bqP55qE6K6w5b2V77yM5oyJ5aCG55qE5a6a5LmJ5bu656uL5aCG77ybXG7ikaEgIOWwhuWghumhtuiusOW9leWSjOacgOWQjuS4gOS4quiusOW9leS6pOaNouS9jee9ru+8jOWImeWJjW4tMeS4quiusOW9leaYr+aXoOW6j+eahO+8jOiAjOacgOWQjuS4gOS4quiusOW9leaYr+acieW6j+eahO+8m1xu4pGiICDloIbpobborrDlvZXooqvkuqTmjaLlkI7vvIzliY1uLTHkuKrorrDlvZXkuI3lho3mmK/loIbvvIzpnIDlsIbliY1uLTHkuKrlvoXmjpLluo/orrDlvZXph43mlrDnu4Tnu4fmiJDkuLrkuIDkuKrloIbvvIznhLblkI7lsIbloIbpobborrDlvZXlkozlgJLmlbDnrKzkuozkuKrorrDlvZXkuqTmjaLkvY3nva7vvIzljbPlsIbmlbTkuKrluo/liJfkuK3mrKHlsI/lhbPplK7lrZflgLznmoTorrDlvZXosIPmlbQo5o6S6ZmkKeWHuuaXoOW6j+WMuu+8m1xu4pGjICDph43lpI3kuIrov7DmraXpqqTvvIznm7TliLDlhajpg6jorrDlvZXmjpLlpb3luo/kuLrmraLjgIJcblxu57uT6K6677ya5o6S5bqP6L+H56iL5Lit77yM6Iul6YeH55So5bCP5qC55aCG77yM5o6S5bqP5ZCO5b6X5Yiw55qE5piv6Z2e6YCS5YeP5bqP5YiX77yb6Iul6YeH55So5aSn5qC55aCG77yM5o6S5bqP5ZCO5b6X5Yiw55qE5piv6Z2e6YCS5aKe5bqP5YiX44CCXG5cbuWghuaOkuW6j+eahOWFs+mUrlxu4pGgICDlpoLkvZXnlLHkuIDkuKrml6Dluo/luo/liJflu7rmiJDkuIDkuKrloIbvvJ9cbuKRoSAg5aaC5L2V5Zyo6L6T5Ye65aCG6aG25YWD57Sg5LmL5ZCO77yM6LCD5pW05Ymp5L2Z5YWD57Sg77yM5L2/5LmL5oiQ5Li65LiA5Liq5paw55qE5aCG77yfXG5cbjQgIOWghueahOiwg+aVtOKAlOKAlOetm+mAiVxu4pG0IOWghueahOiwg+aVtOaAneaDs1xu6L6T5Ye65aCG6aG25YWD57Sg5LmL5ZCO77yM5Lul5aCG5Lit5pyA5ZCO5LiA5Liq5YWD57Sg5pu/5Luj5LmL77yb54S25ZCO5bCG5qC557uT54K55YC85LiO5bem44CB5Y+z5a2Q5qCR55qE5qC557uT54K55YC86L+b6KGM5q+U6L6D77yM5bm25LiO5YW25Lit5bCP6ICF6L+b6KGM5Lqk5o2i77yb6YeN5aSN5LiK6L+w5pON5L2c77yM55u05Yiw5piv5Y+25a2Q57uT54K55oiW5YW25YWz6ZSu5a2X5YC85bCP5LqO562J5LqO5bem44CB5Y+z5a2Q5qCR55qE5YWz6ZSu5a2X55qE5YC877yM5bCG5b6X5Yiw5paw55qE5aCG44CC56ew6L+Z5Liq5LuO5aCG6aG26Iez5Y+25a2Q55qE6LCD5pW06L+H56iL5Li64oCc562b6YCJ4oCd44CCXG5cbuazqOaEj++8muetm+mAiei/h+eoi+S4re+8jOaguee7k+eCueeahOW3puOAgeWPs+WtkOagkemDveaYr+Wghu+8jOWboOatpO+8jOetm+mAieaYr+S7juaguee7k+eCueWIsOafkOS4quWPtuWtkOe7k+eCueeahOS4gOasoeiwg+aVtOi/h+eoi+OAglxuXG41ICDloIbnmoTlu7rnq4tcbuWIqeeUqOetm+mAieeul+azle+8jOWPr+S7peWwhuS7u+aEj+aXoOW6j+eahOiusOW9leW6j+WIl+W7uuaIkOS4gOS4quWghu+8jOiuvlJbMV0sUlsyXSwg4oCmLFJbbl3mmK/lvoXmjpLluo/nmoTorrDlvZXluo/liJfjgIJcbuWwhuS6jOWPieagkeeahOavj+ajteWtkOagkemDveetm+mAieaIkOS4uuWghuOAguWPquacieaguee7k+eCueeahOagkeaYr+WghuOAguesrOKMim4vMuKMi+S4que7k+eCueS5i+WQjueahOaJgOaciee7k+eCuemDveayoeacieWtkOagke+8jOWNs+S7peesrOKMim4vMuKMi+S4que7k+eCueS5i+WQjueahOe7k+eCueS4uuagueeahOWtkOagkemDveaYr+WghuOAguWboOatpO+8jOS7pei/meS6m+e7k+eCueS4uuW3puOAgeWPs+WtqeWtkOeahOe7k+eCue+8jOWFtuW3puOAgeWPs+WtkOagkemDveaYr+Wghu+8jOWImei/m+ihjOS4gOasoeetm+mAieWwseWPr+S7peaIkOS4uuWghuOAguWQjOeQhu+8jOWPquimgeWwhui/meS6m+e7k+eCueeahOebtOaOpeeItue7k+eCuei/m+ihjOS4gOasoeetm+mAieWwseWPr+S7peaIkOS4uuWghuKApuOAglxu5Y+q6ZyA5LuO56ys4oyKbi8y4oyL5Liq6K6w5b2V5Yiw56ysMeS4quiusOW9leS+neasoei/m+ihjOetm+mAieWwseWPr+S7peW7uueri+WghuOAglxuXG42ICAg5aCG5o6S5bqP566X5rOV5a6e546wXG7loIbnmoTmoLnnu5PngrnmmK/lhbPplK7lrZfmnIDlsI/nmoTorrDlvZXvvIzovpPlh7rmoLnnu5PngrnlkI7vvIzmmK/ku6Xluo/liJfnmoTmnIDlkI7kuIDkuKrorrDlvZXkvZzkuLrmoLnnu5PngrnvvIzogIzljp/mnaXloIbnmoTlt6bjgIHlj7PlrZDmoJHpg73mmK/loIbvvIzliJnov5vooYzkuIDmrKHnrZvpgInlsLHlj6/ku6XmiJDkuLrloIbjgIJcblxuNyAg566X5rOV5YiG5p6QXG7kuLvopoHov4fnqIvvvJrliJ3lp4vlu7rloIblkozph43mlrDosIPmlbTmiJDloIbjgILorr7orrDlvZXmlbDkuLpu77yM5omA5a+55bqU55qE5a6M5YWo5LqM5Y+J5qCR5rex5bqm5Li6aCDjgIJcbuKXhiAg5Yid5aeL5bu65aCG77ya5q+P5Liq6Z2e5Y+25a2Q57uT54K56YO96KaB5LuO5LiK5Yiw5LiL5YGa4oCc562b6YCJ4oCdIOOAguesrGnlsYLnu5PngrnmlbDiiaQyaS0x77yM57uT54K55LiL56e755qE5pyA5aSn5rex5bqm5pivaC1p77yM6ICM5q+P5LiL56e75LiA5bGC6KaB5q+U6L6DMuasoe+8jOWImeavlOi+g+asoeaVsEMxKG4p5Li677yaXG5DMShuKeKJpDQobi3jj5Iybi0xKVxu4peGICDnrZvpgInosIPmlbTvvJrmr4/mrKHnrZvpgInopoHlsIbmoLnnu5PngrnigJzkuIvmsonigJ3liLDkuIDkuKrlkIjpgILkvY3nva7jgILnrKxp5qyh562b6YCJ5pe277ya5aCG5Lit5YWD57Sg5Liq5pWw5Li6bi1pKzHvvJvloIbnmoTmt7HluqbmmK/vg6vjj5IyKG4taSsxKe+Duysx77yM5YiZ6L+b6KGMbi0x5qyh4oCc562b6YCJ4oCd55qE5q+U6L6D5qyh5pWwQzIobinkuLrvvJpcbkMyKG4pPDJu44+SMm5cbuWghuaOkuW6j+eahOavlOi+g+asoeaVsOeahOaVsOmHj+e6p+S4uu+8miBUKG4pPU8obuOPkjJuKe+8m+iAjOmZhOWKoOepuumXtOWwseaYr+S6pOaNouaXtuaJgOeUqOeahOS4tOaXtuepuumXtO+8jOaVheepuumXtOWkjeadguW6puS4uu+8miBTKG4pPU8oMSkg44CCXG5cbuWghuaOkuW6j+mAguWQiOiusOW9leaVsOi+g+Wkp+eahOaDheWGtVxuXG5cbmh0dHA6Ly9ibG9nLmNzZG4ubmV0L3p6MTk4ODA4L2FydGljbGUvZGV0YWlscy83Njc4MDU1XG4gKi9cblxuLyoqXG4gKiDlt7Lnn6VzcUxpc3Rbcy4ubV3kuK3orrDlvZXnmoTlhbPplK7lrZfpmaRzcUxpc3Rbc13kuYvlpJblnYfmu6HotrPloIbnmoTlrprkuYnvvIxcbiAqIOacrOWHveaVsOiwg+aVtHNxTGlzdFtzXeeahOWFs+mUruWtl++8jOS9v3NxTGlzdFtzLi5tXeaIkOS4uuS4gOS4quWkp+Wghumhtu+8iOWvueWFtuS4reWFs+mUruWtl+iAjOiogO+8iVxuICogQHBhcmFtIHtBcnJheX0gc3FMaXN0XG4gKiBAcGFyYW0ge051bWJlcn0gc1xuICogQHBhcmFtIHtOdW1iZXJ9IG1cbiAqL1xuZnVuY3Rpb24gaGVhcEFkanVzdChzcUxpc3QsIHMsIG0sIGNvbXApIHtcbiAgICBsZXQgcmMgPSBzcUxpc3Rbc107XG5cbiAgICAvLyDmsr/lhbPplK7lrZfovoPlpKfnmoTlranlrZDnu5PngrnlkJHkuIvnrZvpgIlcbiAgICBmb3IgKGxldCBqID0gMiAqIHMgKyAxOyBqIDw9IG07IGogPSBqICogMiArIDEpIHtcbiAgICAgICAgLy8gauS4uuWFs+mUruWtl+i+g+Wkp+eahOiusOW9leS4i+agh1xuICAgICAgICBpZiAoaiA8IG0gJiYgY29tcChzcUxpc3Rbal0sIHNxTGlzdFtqICsgMV0pIDwgMCkgKytqO1xuICAgICAgICAvLyByY+W6lOaPkuWFpeWcqOS9jee9rnPkuIpcbiAgICAgICAgaWYgKGNvbXAocmMsIHNxTGlzdFtqXSkgPj0gMCkgYnJlYWs7XG4gICAgICAgIHNxTGlzdFtzXSA9IHNxTGlzdFtqXTtcbiAgICAgICAgcyA9IGo7XG4gICAgfVxuXG4gICAgc3FMaXN0W3NdID0gcmM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoZWFwU29ydChzcUxpc3QsIGNvbXAgPSBkZWZhdWx0Q29tcGFyZSkge1xuICAgIGxldCBsZW4gPSBzcUxpc3QubGVuZ3RoO1xuICAgIC8vIOW7uueri+Wkp+WghumhtlxuICAgIGZvciAobGV0IGkgPSAobGVuID4+IDEpIC0gMTsgaSA+PSAwOyAtLWkpXG4gICAgICAgIGhlYXBBZGp1c3Qoc3FMaXN0LCBpLCBsZW4gLSAxLCBjb21wKTtcblxuICAgIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID4gMDsgLS1pKSB7XG4gICAgICAgIC8vIOWwhuWghumhtuiusOW9leWSjOW9k+WJjeacque7j+aOkuW6j+WtkOW6j+WIl3NxTGlzdFswLi5pXeS4rVxuICAgICAgICAvLyDmnIDlkI7kuIDkuKrorrDlvZXnm7jkupLkuqTmjaJcbiAgICAgICAgbGV0IHRlbXAgPSBzcUxpc3RbaV07XG4gICAgICAgIHNxTGlzdFtpXSA9IHNxTGlzdFswXTtcbiAgICAgICAgc3FMaXN0WzBdID0gdGVtcDtcblxuICAgICAgICAvLyDlsIZzcUxpc3RbMC4uaSAtIDFd6YeN5paw6LCD5pW05Li65aSn5aCG6aG2XG4gICAgICAgIGhlYXBBZGp1c3Qoc3FMaXN0LCAwLCBpIC0gMSwgY29tcCk7XG4gICAgfVxufVxuXG52YXIgYXJyID0gWzEsIDMsIDQsIDUsIDcsIDIsIDYsIDgsIDBdO1xuaGVhcFNvcnQoYXJyKTtcbmNvbnNvbGUubG9nKGFyciArICcnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Tb3J0L3NlbGVjdGlvbi9pbmRleC5qcyIsIi8qKlxuICog5aCG5YiG6YWN5a2Y5YKo6KGo56S6XG4gKlxuICog6L+Z56eN5a2Y5YKo6KGo56S655qE54m554K55piv77yM5LuN5Lul5LiA57uE5Zyw5Z2A6L+e57ut55qE5a2Y5YKo5Y2V5YWD5a2Y5pS+5Liy5YC85a2X56ym5bqP5YiX77yM5L2G5a6D5Lus55qE5a2Y5YKo56m66Ze05piv5Zyo56iL5bqP5omn6KGM6L+H56iL5Lit5Yqo5oCB5YiG6YWN6ICM5b6X44CC5ZyoY+ivreiogOS4re+8jOWtmOWcqOS4gOS4quensOS5i+S4uuKAnOWghuKAneeahOiHqueUseWtmOWCqOWMuu+8jOW5tueUsWPor63oqIDnmoTliqjmgIHliIbphY3lh73mlbBtYWxsb2MoKeWSjGZyZWUoKeadpeeuoeeQhuOAguWIqeeUqOWHveaVsG1hbGxvYygp5Li65q+P5Liq5paw5Lqn55Sf55qE5Liy5YiG6YWN5LiA5Z2X5a6e6ZmF5Liy6ZW/5omA6ZyA55qE5a2Y5YKo56m66Ze044CCXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSFN0cmluZyB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5jaCA9IHt9O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgLy8gMSA8PSBwb3NpdGlvbiA8PSB0aGlzLmxlbmd0aC7lnKjkuLLnmoTnrKxwb3NpdGlvbuS4quWtl+espuS5i+WJjeaPkuWFpeS4snRIU3RyaW5nXG4gICAgc3RySW5zZXJ0IChwb3NpdGlvbiwgdEhTdHJpbmcpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMSB8fCBwb3NpdGlvbiA+IHRoaXMubGVuZ3RoICsgMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBwb3NpdGlvbicpO1xuXG4gICAgICAgIGlmICh0SFN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIOS4uuaPkuWFpXTogIzohb7lh7rkvY3nva5cbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgbGVuID0gcG9zaXRpb24gLSAxOyBpID49IGxlbjsgLS1pKVxuICAgICAgICAgICAgICAgIHRoaXMuY2hbaSArIHRIU3RyaW5nLmxlbmd0aF0gPSB0aGlzLmNoW2ldO1xuXG4gICAgICAgICAgICBzdHJpbmdDb3B5KHRoaXMuY2gsIHRIU3RyaW5nLmNoLCBwb3NpdGlvbiAtIDEsIHRIU3RyaW5nLmxlbmd0aCAtIDEsIDApO1xuXG4gICAgICAgICAgICB0aGlzLmxlbmd0aCArPSB0SFN0cmluZy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyQXNzaWduIChjaGFycykge1xuICAgICAgICBzdHJpbmdDb3B5KHRoaXMuY2gsIGNoYXJzLCAwLCBjaGFycy5sZW5ndGggLSAxLCAwKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gICAgfVxuICAgIHN0ckxlbmd0aCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgc3RyQ29tcGFyZSAodEhTdHJpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoOyBpIDwgbGVuICYmIGkgPCB0SFN0cmluZy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLmNoW2ldICE9PSB0SFN0cmluZy5jaFtpXSkgcmV0dXJuIHRoaXMuY2hbaV0gLSB0SFN0cmluZy5jaFtpXTtcblxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggLSB0SFN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGNsZWFyU3RyaW5nICgpIHtcbiAgICAgICAgdGhpcy5jaCA9IHt9O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGNvbmNhdCAocykge1xuICAgICAgICBsZXQgdCA9IG5ldyBIU3RyaW5nKCk7XG5cbiAgICAgICAgLy8gdC5jaFswLi50aGlzLmxlbmd0aCAtIDFdID0gdGhpcy5jaFswLi50aGlzLmxlbmd0aCAtIDFdXG4gICAgICAgIHN0cmluZ0NvcHkodC5jaCwgdGhpcy5jaCwgMCwgdGhpcy5sZW5ndGggLSAxLCAwKTtcbiAgICAgICAgdC5sZW5ndGggPSB0aGlzLmxlbmd0aCArIHMubGVuZ3RoO1xuICAgICAgICAvLyB0LmNoW3RoaXMubGVuZ3RoLi50Lmxlbmd0aCAtIDFdID0gcy5jaFswLi5zLmxlbmd0aCAtIDFdXG4gICAgICAgIHN0cmluZ0NvcHkodC5jaCwgcy5jaCwgdGhpcy5sZW5ndGgsIHMubGVuZ3RoIC0gMSwgMCk7XG5cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIHN1YnN0cmluZyAocG9zaXRpb24sIGxlbikge1xuICAgICAgICBwb3NpdGlvbiA9IH5+cG9zaXRpb24gfHwgMDtcbiAgICAgICAgbGVuID0gfn5sZW4gfHwgdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPiB0aGlzLmxlbmd0aCAtIDEgfHwgbGVuIDwgMCB8fCBsZW4gPiB0aGlzLmxlbmd0aCAtIHBvc2l0aW9uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHBhcmFtZXRlcicpO1xuXG4gICAgICAgIGxldCBzdWIgPSBuZXcgSFN0cmluZygpO1xuICAgICAgICBzdHJpbmdDb3B5KHN1Yi5jaCwgdGhpcy5jaCwgMCwgbGVuIC0gMSwgcG9zaXRpb24pO1xuICAgICAgICBzdWIubGVuZ3RoID0gbGVuO1xuXG4gICAgICAgIHJldHVybiBzdWI7XG4gICAgfVxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgICAgbGV0IHMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHMgKz0gdGhpcy5jaFtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN0cmluZ0NvcHkoZGVzdGluYXRpb24sIHRhcmdldCwgZGVzdFN0YXJ0LCBsZW5ndGgsIHRhcmdldFN0YXJ0KSB7XG4gICAgZGVzdFN0YXJ0ID0gZGVzdFN0YXJ0IHx8IDA7XG4gICAgbGVuZ3RoID0gbGVuZ3RoIHx8IHRhcmdldC5sZW5ndGg7XG4gICAgdGFyZ2V0U3RhcnQgPSB0YXJnZXRTdGFydCB8fCAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVzdGluYXRpb25bZGVzdFN0YXJ0ICsgaV0gPSB0YXJnZXRbdGFyZ2V0U3RhcnQgKyBpXTtcbiAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1N0cmluZy9IU3RyaW5nLmpzIiwiLyoqXG4gKiDkuLLnmoTlnZfpk77lrZjlgqjooajnpLpcbiAqXG4gKiDlkoznur/mgKfooajnmoTpk77lvI/lrZjlgqjnu5PmnoTnm7jnsbvkvLzvvIzkuZ/lj6/ph4fnlKjpk77lvI/mlrnlvI/lrZjlgqjkuLLlgLzjgILnlLHkuo7kuLLnu5PmnoTnmoTnibnmrormgKctLee7k+aehOS4reeahOavj+S4quaVsOaNruWFg+e0oOaYr+S4gOS4quWtl+espu+8jOWImeeUqOmTvuihqOWtmOWCqOS4suWAvOaXtu+8jOWtmOWcqOS4gOS4quKAnOe7k+eCueWkp+Wwj+KAneeahOmXrumimO+8jOWNs+avj+S4que7k+eCueWPr+S7peWtmOaUvuS4gOS4quWtl+espu+8jOS5n+WPr+S7peWtmOaUvuWkmuS4quWtl+espuOAglxuICog5LiL6Z2i5piv57uT54K55aSn5bCP5Li6NO+8iOWNs+avj+S4que7k+eCueWtmOaUvjTkuKrlrZfnrKbvvInnmoTpk77ooahcbiAqIGhlYWQgLS0+IChhLGIsYyxkKSAtLT4gKGUsZixnLGgpIC0tPiAoaSMjIylcbiAqIOS4i+mdouaYr+e7k+eCueWkp+Wwj+S4ujHnmoTpk77ooahcbiAqIGhlYWQgLS0+IChhKSAtLT4gKGIpIC0tPiAoYykgLS0+IC4uLiAtLT4gKGkpXG4gKlxuICog5b2T57uT54K55aSn5bCP5aSn5LqOMeaXtu+8jOeUseS6juS4sumVv+S4jeS4gOWumuaYr+e7k+eCueWkp+Wwj+eahOaVtOWAjeaVsO+8jOWImemTvuihqOS4reeahOacgOWQjuS4gOS4que7k+eCueS4jeS4gOWumuWFqOiiq+S4suWAvOWNoOa7oe+8jOatpOaXtumAmuW4uOihpeS4iuKAnCPigJ3miJblhbblroPpnZ7kuLLlgLzlrZfnrKbjgIJcbiAqIOS4uuS6huS+v+S6jui/m+ihjOS4sueahOaTjeS9nO+8jOW9k+S7pemTvuihqOWtmOWCqOS4suWAvOaXtu+8jOmZpOWktOaMh+mSiOWklui/mOWPr+mZhOiuvuS4gOS4quWwvuaMh+mSiOaMh+ekuumTvuihqOS4reeahOacgOWQjuS4gOS4que7k+eCue+8jOW5tue7meWHuuW9k+WJjeS4sueahOmVv+W6pu+8jOensOWmguatpOWumuS5ieeahOS4suWtmOWCqOe7k+aehOS4uuWdl+mTvue7k+aehOOAglxuICpcbiAqIOeUseS6juS4gOiIrOaDheWGteS4i++8jOWvueS4sui/m+ihjOaTjeS9nOaXtu+8jOWPqumcgOimgeS7juWktOWQkeWwvumhuuW6j+aJq+aPj+WNs+WPr++8jOWImeWvueS4suWAvOS4jeW/heW7uueri+WPjOWQkemTvuihqOOAguiuvuWwvuaMh+mSiOeahOebrueahOaYr+S4uuS6huS+v+S6jui/m+ihjOi/nuaOpeaTjeS9nO+8jOS9huW6lOazqOaEj+i/nuaOpeaXtumcgOWkhOeQhuesrOS4gOS4quS4suWwvueahOaXoOaViOWtl+espuOAglxuICog5Zyo6ZO+5byP5a2Y5YKo5pa55byP5Lit77yM57uT54K55aSn5bCP55qE6YCJ5oup5ZKM6aG65bqP5a2Y5YKo5pa55byP55qE5qC85byP6YCJ5oup5LiA5qC36YO95b6I6YeN6KaB77yM5a6D55u05o6l5b2x5ZON5Yiw5Liy5aSE55CG55qE5pWI546H44CC5aaC5p6c5Liy5b6I6ZW/77yM6L+Z6KaB5rGC5oiR5Lus6ICD6JmR5Liy5YC855qE5a2Y5YKo5a+G5bqm77yaXG4gKiDlrZjlgqjlr4bluqYgPSDkuLLlgLzmiYDljaDnmoTlrZjlgqjkvY0gLyDlrp7pmYXliIbphY3nmoTlrZjlgqjkvY1cbiAqXG4gKiDkuLLlgLznmoTpk77lvI/lrZjlgqjnu5PmnoTlr7nmn5DkupvkuLLmk43kvZzvvIzlpoLov57mjqXmk43kvZznrYnmnInkuIDlrprmlrnkvr/kuYvlpITvvIzkvYbmgLvnmoTmnaXor7TkuI3lpoLlj6blpJbkuKTnp43lrZjlgqjnu5PmnoTngbXmtLvvvIzlroPljaDnlKjlrZjlgqjph4/lpKfkuJTmk43kvZzlpI3mnYLjgIJcbiAqL1xuaW1wb3J0IFN0YWNrIGZyb20gJy4uL1N0YWNrL2luZGV4JztcblxuY2xhc3MgQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGNodW5rU2l6ZSA9IDQpIHtcbiAgICAgICAgdGhpcy5jaHVua1NpemUgPSBjaHVua1NpemU7XG4gICAgICAgIHRoaXMuY2ggPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNoW2ldID0gJyMnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHR5cGU6IENodW5rXG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMU3RyaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihjaHVua1NpemUgPSA0KSB7XG4gICAgICAgIC8vIHR5cGUgQ2h1bmtcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICAgICAgLy8gdHlwZTogY2h1bmtcbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgLy8g5Liy55qE5b2T5YmN6ZW/5bqmXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jaHVua1NpemUgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgLy8g5bCG5a2X56ym5Liy6L2s5o2i5oiQTFN0cmluZ+exu+Wei1xuICAgIHN0ckFzc2lnbiAoY2hhcnMpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IENodW5rKHRoaXMuY2h1bmtTaXplKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjaGFycy5sZW5ndGg7XG5cbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjaGFycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY3VycmVudC5jaFtpICUgdGhpcy5jaHVua1NpemVdID0gY2hhcnNbaV07XG4gICAgICAgICAgICBpZiAoaSArIDEgPCBsZW4gJiYgKGkgKyAxKSAlIHRoaXMuY2h1bmtTaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5uZXh0ID0gbmV3IENodW5rKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGFpbCA9IGN1cnJlbnQ7XG4gICAgfVxuICAgIC8vIOWtl+espuS4suWvueavlFxuICAgIC8vIFRPRE8g5piv5ZCm5Y675o6JY2h1bmtTaXpl55qE5a+55q+UXG4gICAgc3RyQ29tcGFyZSAodExTdHJpbmcpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCBjdXJUID0gdExTdHJpbmcuaGVhZDtcblxuICAgICAgICBpZiAodGhpcy5sZW5ndGggIT09IHRMU3RyaW5nLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5jaFtpXSAhPT0gY3VyVC5jaFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgY3VyVCA9IGN1clQubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjbGVhclN0cmluZyAoKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgY29uY2F0ICh0TFN0aW5nKSB7XG4gICAgICAgIGlmICghdExTdGluZy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICBsZXQgcmV0ID0gbmV3IExTdHJpbmcodGhpcy5jaHVua1NpemUpO1xuXG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvcHlTdHJpbmcocmV0LCB0TFN0aW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldC5oZWFkID0gcmV0LnRhaWwgPSBuZXcgQ2h1bmsodGhpcy5jaHVua1NpemUpO1xuICAgICAgICAgICAgY29weVN0cmluZyhyZXQsIHRoaXMpO1xuXG4gICAgICAgICAgICBsZXQgaW5kZXggPSByZXQudGFpbC5jaC5pbmRleE9mKCcjJyk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29weVN0cmluZyhyZXQsIHRMU3RpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3B5U3RyaW5nKHJldCwgdExTdGluZywgcmV0LnRhaWwsIHRMU3RpbmcuaGVhZCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgc3Vic3RyaW5nIChwb3MsIGxlbikge1xuICAgICAgICBwb3MgPSB+fnBvcyB8fCAwO1xuICAgICAgICBsZW4gPSB+fmxlbiB8fCB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKHBvcyA8IDAgfHwgcG9zID4gdGhpcy5sZW5ndGggLSAxIHx8IGxlbiA8IDAgfHwgbGVuID4gdGhpcy5sZW5ndGggLSBwb3MpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgcGFyYW1ldGVyJyk7XG5cbiAgICAgICAgbGV0IHN1YiA9IG5ldyBMU3RyaW5nKHRoaXMuY2h1bmtTaXplKTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBmaW5kUG9zQ2h1bmsodGhpcywgcG9zKTtcbiAgICAgICAgbGV0IGN1clMgPSBzdWIuaGVhZCA9IG5ldyBDaHVuayh0aGlzLmNodW5rU2l6ZSk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgc3ViLmxlbmd0aCA9IGxlbjtcblxuICAgICAgICBvdXRlcmxvb3A6IHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgc2l6ZSA9IHRoaXMuY2h1bmtTaXplOyBqIDwgc2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGxlbikge1xuICAgICAgICAgICAgICAgICAgICBicmVhayBvdXRlcmxvb3A7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyUy5jaFtqXSA9IGN1cnJlbnQuY2hbKGkgKyBwb3MpICUgdGhpcy5jaHVua1NpemVdO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoaSArIHBvcykgJSB0aGlzLmNodW5rU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAlIHRoaXMuY2h1bmtTaXplID09PSAwICYmIChjdXJyZW50LmNoW2ldIHx8IGN1cnJlbnQubmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clMubmV4dCA9IG5ldyBDaHVuayh0aGlzLmNodW5rU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJTID0gY3VyUy5uZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9XG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuaGVhZDtcblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkgcmV0dXJuICcnO1xuXG4gICAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmNodW5rU2l6ZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gY3VycmVudC5jaFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcjJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBjdXJyZW50LmNoW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZmluZFBvc0NodW5rKGxTdHJpbmcsIHBvcykge1xuICAgIGxldCBjdXJyZW50ID0gbFN0cmluZy5oZWFkO1xuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsU3RyaW5nLmNodW5rU2l6ZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocG9zLS0gPT09IDApIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb3B5U3RyaW5nKGRlc3RpbmF0aW9uLCB0YXJnZXQsIGN1ckQsIGN1cnJULCBvZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICBjdXJyVCA9IGN1cnJUIHx8IHRhcmdldC5oZWFkO1xuICAgIGN1ckQgPSBjdXJEIHx8IGRlc3RpbmF0aW9uLmhlYWQ7XG4gICAgbGV0IGsgPSAwO1xuXG4gICAgd2hpbGUgKGN1cnJUKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0YXJnZXQuY2h1bmtTaXplOyBpIDwgbGVuOyBpKyssIGsrKykge1xuICAgICAgICAgICAgbGV0IGogPSBrICUgY3VyRC5jaHVua1NpemUgKyBvZmZzZXQ7XG4gICAgICAgICAgICBjdXJELmNoW2ogJSBjdXJELmNodW5rU2l6ZV0gPSBjdXJyVC5jaFtpXTtcblxuICAgICAgICAgICAgaWYgKChqICsgMSkgJSBjdXJELmNodW5rU2l6ZSA9PT0gMCAmJiAoY3VyclQuY2hbaSArIDFdIHx8IGN1cnJULm5leHQpKSB7XG4gICAgICAgICAgICAgICAgY3VyRC5uZXh0ID0gbmV3IENodW5rKGRlc3RpbmF0aW9uLmNodW5rU2l6ZSk7XG4gICAgICAgICAgICAgICAgY3VyRCA9IGN1ckQubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJUID0gY3VyclQubmV4dDtcbiAgICB9XG5cbiAgICBkZXN0aW5hdGlvbi50YWlsID0gY3VyRDtcbiAgICBkZXN0aW5hdGlvbi5sZW5ndGggKz0gdGFyZ2V0Lmxlbmd0aDtcbn1cblxubGV0IGEgPSBuZXcgTFN0cmluZygpO1xubGV0IGIgPSBuZXcgTFN0cmluZygpO1xubGV0IGMgPSBuZXcgTFN0cmluZygpO1xuXG5hLnN0ckFzc2lnbignYWJjZGVmZycpO1xuY29uc29sZS5sb2coYSArICcnKTtcbmIuc3RyQXNzaWduKCdoaWprbG1ubycpO1xuY29uc29sZS5sb2coYiArICcnKTtcbmMuc3RyQXNzaWduKCdhYmNkZWZnJyk7XG5jb25zb2xlLmxvZyhhLnN0ckNvbXBhcmUoYikpO1xuY29uc29sZS5sb2coYS5zdHJDb21wYXJlKGMpKTtcbmxldCB0ID0gYS5jb25jYXQoYik7XG5jb25zb2xlLmxvZyh0ICsgJycpO1xudCA9IHQuc3Vic3RyaW5nKDIsIDUpO1xuY29uc29sZS5sb2codCArICcnKTtcblxuXG4vLyDliKTmlq3mmK/lkKbkuLrlm57mloflrZfnrKbkuLJcbmZ1bmN0aW9uIHBhbGluZHJvbWUobFN0cikge1xuICAgIGxldCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgIGxldCBwID0gbFN0ci5oZWFkO1xuICAgIGxldCBpID0gMDtcblxuICAgIGZvciAobGV0IGsgPSAxOyBrIDw9IGxTdHIubGVuZ3RoOyArK2spIHtcbiAgICAgICAgaWYgKGsgPD0gbFN0ci5sZW5ndGggLyAyKSBzdGFjay5wdXNoKHAuY2hbaV0pO1xuICAgICAgICBlbHNlIGlmIChrID4gKGxTdHIubGVuZ3RoICsgMSkgLyAyKSB7XG4gICAgICAgICAgICBsZXQgYyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHAuY2hbaV0gIT09IGMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgrK2kgPT09IGxTdHIuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU3RyaW5nL0xTdHJpbmcuanMiLCIvKipcbiAqIOS4su+8iHN0cmluZ++8ie+8iOaIluWtl+espuS4su+8ieaYr+eUsembtuS4quaIluWkmuS4quWtl+espue7hOaIkOeahOaciemZkOW6j+WIl+OAguS4suS4reWtl+espueahOaVsOebruensOS4uuS4sueahOmVv+W6puOAgumbtuS4quWtl+espueahOS4suensOS4uuepuuS4su+8iG51bGwgc3RyaW5n77yJ77yM5a6D55qE6ZW/5bqm5Li66Zu244CCXG4gKiDkuLLkuK3ku7vmhI/kuKrov57nu63nmoTlrZfnrKbnu4TmiJDnmoTlrZDluo/liJfnp7DkuLror6XkuLLnmoTlrZDkuLLjgILljIXlkKvlrZDkuLLnmoTkuLLnm7jlupTlnLDnp7DkuLrkuLvkuLLjgILpgJrluLjnp7DlrZfnrKblnKjluo/liJfkuK3nmoTluo/lj7fkuLror6XlrZfnrKblnKjkuLLkuK3nmoTkvY3nva7jgILlrZDkuLLlnKjkuLvkuLLkuK3nmoTkvY3nva7liJnku6XlrZDkuLLnmoTnrKzkuIDkuKrlrZfnrKblnKjkuLvkuLLkuK3nmoTkvY3nva7mnaXooajnpLrjgIJcbiAqIOWPquacieW9k+S4pOS4quS4sueahOmVv+W6puebuOetie+8jOW5tuS4lOWQhOS4quWvueW6lOS9jee9rueahOWtl+espumDveebuOetieaXtuaJjeebuOetieOAglxuICpcbiAqIOS4suaciTPnp43mnLrlhoXooajnpLrmlrnms5XvvJpcbiAqIDEu5a6a6ZW/6aG65bqP5a2Y5YKo6KGo56S6XG4gKiAyLuWghuWIhumFjeWtmOWCqOihqOekulxuICogMy7kuLLnmoTlnZfpk77lrZjlgqjooajnpLpcbiAqL1xuXG4vKipcbiAqIOWumumVv+mhuuW6j+WtmOWCqOihqOekulxuICog57G75Ly85LqO57q/5oCn6KGo55qE6aG65bqP5a2Y5YKo57uT5p6E77yM55So5LiA57uE5Zyw5Z2A6L+e57ut55qE5a2Y5YKo5Y2V5YWD5a2Y5YKo5Liy5YC85b6X5a2X56ym5bqP5YiX44CC5Zyo5Liy55qE5a6a6ZW/6aG65bqP5a2Y5YKo57uT5p6E5Lit77yM5oyJ54Wn6aKE5a6a5LmJ55qE5aSn5bCP77yM5Li65q+P5Liq5a6a5LmJ55qE5Liy5Y+Y6YeP5YiG6YWN5LiA5Liq5Zu65a6a6ZW/5bqm55qE5a2Y5YKo5Yy677yM5YiZ5Y+v55So5a6a6ZW/5pWw57uE5p2l5o+P6L+w44CCXG4gKiDku6XkuIvmoIfkuLow55qE5pWw57uE5YiG6YeP5a2Y5pS+5Liy55qE5a6e6ZmF6ZW/5bqm44CCXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU1N0cmluZyB7XG4gICAgY29uc3RydWN0b3Ioc3RyKXtcbiAgICAgICAgdGhpcy5NQVhTVFJMRU4gPSAxMDtcbiAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgdGhpc1swXSA9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gc3RyW2kgLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIOi/lOWbnueUsXMx5ZKMczLov57mjqXogIzmiJDnmoTmlrDkuLJcbiAgICBjb25jYXQgKHMyKSB7XG4gICAgICAgIGxldCB0ID0gbmV3IFNTdHJpbmcoKTtcbiAgICAgICAgLy8g5pyq5oiq5patXG4gICAgICAgIGlmICh0aGlzWzBdICsgczJbMF0gPD0gdGhpcy5NQVhTVFJMRU4pIHtcbiAgICAgICAgICAgIGNvcHlTdHIyVCh0aGlzKTtcbiAgICAgICAgICAgIGNvcHlTdHIyVChzMiwgdGhpc1swXSk7XG4gICAgICAgICAgICB0WzBdID0gdGhpc1swXSArIHMyWzBdO1xuXG4gICAgICAgICAgICAvLyDmiKrmlq1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzWzBdIDwgdGhpcy5NQVhTVFJMRU4pIHtcbiAgICAgICAgICAgIGNvcHlTdHIyVCh0aGlzKTtcbiAgICAgICAgICAgIGNvcHlTdHIyVChzMiwgdGhpc1swXSwgdGhpcy5NQVhTVFJMRU4gLSB0aGlzWzBdKTtcbiAgICAgICAgICAgIHRbMF0gPSB0aGlzLk1BWFNUUkxFTjtcblxuICAgICAgICAgICAgLy8g5oiq5pat77yI5LuF5Y+WczHvvIlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvcHlTdHIyVCh0aGlzLCAwLCB0aGlzLk1BWFNUUkxFTik7XG4gICAgICAgICAgICB0WzBdID0gdGhpc1swXSA9IHRoaXMuTUFYU1RSTEVOO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHQ7XG5cbiAgICAgICAgZnVuY3Rpb24gY29weVN0cjJUKHN0ciwgc3RhcnQgPSAwLCBlbmQgPSBzdHJbMF0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxLCBsZW4gPSBlbmQgfHwgc3RyWzBdOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdFtzdGFydCArIGldID0gc3RyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnN0cmluZyAocG9zaXRpb24gPSAwLCBsZW4gPSB0aGlzWzBdKSB7XG4gICAgICAgIHBvc2l0aW9uID0gfn5wb3NpdGlvbjtcbiAgICAgICAgbGVuID0gfn5sZW47XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPiB0aGlzWzBdIC0gMSB8fCBsZW4gPCAwIHx8IGxlbiA+IHRoaXNbMF0gLSBwb3NpdGlvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBwYXJhbWV0ZXInKTtcblxuICAgICAgICBsZXQgc3ViID0gbmV3IFNTdHJpbmcoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHN1YltpXSA9IHRoaXNbcG9zaXRpb24gKyBpIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgc3ViWzBdID0gbGVuO1xuXG4gICAgICAgIHJldHVybiBzdWI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5bCG5Liyc+S4reeahOWtkOS4snTmm7/mjaLkuLp277yM6L+U5Zue5pu/5o2i5qyh5pWwXG4gICAgICogdG9kbyB0byBiZSB0ZXN0ZWRcbiAgICAgKiBAcGFyYW0ge1NTdHJpbmd9IHRcbiAgICAgKiBAcGFyYW0ge1NTdHJpbmd9IHZcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSDmm7/mjaLmrKHmlbBcbiAgICAgKi9cbiAgICByZXBsYWNlICh0LCB2KSB7XG4gICAgICAgIGZvciAobGV0IG4gPSAwLCBpID0gMTsgaSA8PSB0aGlzWzBdIC0gdFswXSArIDE7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGksIGsgPSAxOyB0W2tdICYmIHRoaXNbal0gPT09IHRba107ICsraiwgKytrKTtcblxuICAgICAgICAgICAgLy8g5om+5Yiw5LqG5LiOdOWMuemFjeeahOWtl+S4su+8muWIhuS4ieenjeaDheWGteWkhOeQhlxuICAgICAgICAgICAgaWYgKGsgPiB0WzBdKSB7XG4gICAgICAgICAgICAgICAgbGV0IGw7XG4gICAgICAgICAgICAgICAgLy8g5paw5a2X5Liy55qE6ZW/5bqm5LiO5Y6f5a2Q5Liy55u45ZCM5pe277yM55u05o6l5pu/5o2iXG4gICAgICAgICAgICAgICAgaWYgKHRbMF0gPT09IHZbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gMTsgbCA8PSB0WzBdOyArK2wpIHRoaXNbaSArIGwgLSAxXSA9IHZbbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIOaWsOWtkOS4sumVv+W6puWkp+S6juWOn+WtkOS4suaXtu+8jOWFiOWwhuWQjumDqOWPs+enu1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRbMF0gPCB2WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobCA9IHRoaXNbMF07IGwgPj0gaSArIHRbMF07IC0tbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbCArIHZbMF0gLSB0WzBdXSA9IHRoaXNbbF07XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gMTsgbCA8PSB2WzBdOyArK2wpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2kgKyBsIC0gMV0gPSB2W2xdO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIOaWsOWtkOS4sumVv+W6puWwj+S6juWOn+WtkOS4suaXtu+8jOWFiOWwhuWQjumDqOW3puenu1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGwgPSBpICsgdlswXTsgbCA8PSB0aGlzWzBdICsgdlswXSAtIHRbMF07ICsrbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbF0gPSB0aGlzW2wgLSB2WzBdICsgdFswXV07XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gMTsgbCA8PSB2WzBdOyArK2wpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2kgKyBsIC0gMV0gPSB2W2xdO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpc1swXSA9IHRoaXNbMF0gLSB0WzBdICsgdlswXTtcbiAgICAgICAgICAgICAgICBpICs9IHZbMF07XG4gICAgICAgICAgICAgICAgKytuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgICBsZXQgc3RyID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyB0aGlzW2ldOyBpKyspIHtcbiAgICAgICAgICAgIHN0ciArPSB0aGlzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIC8vIOi/lOWbnuWtkOS4snNzdHJpbmflnKjkuLvkuLLkuK3nmoTnrKxwb3NpdGlvbuS4quWtl+espuS5i+WQjueahOS9jee9rlxuICAgIGluZGV4IChzc3RyaW5nLCBwb3NpdGlvbikge1xuICAgICAgICBsZXQgaSA9IHBvc2l0aW9uIHx8IDE7XG4gICAgICAgIGxldCBqID0gMTtcblxuICAgICAgICB3aGlsZSAoaSA8PSB0aGlzWzBdICYmIGogPD0gc3N0cmluZ1swXSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IHNzdHJpbmdbal0pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gaSAtIGogKyAyO1xuICAgICAgICAgICAgICAgIGogPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGogPiBzc3RyaW5nWzBdID8gaSAtIHNzdHJpbmdbMF0gOiAtMTtcbiAgICB9XG4gICAga21wSW5kZXggKHNzdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgICAgIGxldCBpID0gcG9zaXRpb24gfHwgMTtcbiAgICAgICAgbGV0IGogPSAxO1xuICAgICAgICBsZXQgbmV4dCA9IGdldE5leHQoc3N0cmluZyk7XG5cbiAgICAgICAgd2hpbGUgKGkgPD0gdGhpc1swXSAmJiBqIDw9IHNzdHJpbmdbMF0pIHtcbiAgICAgICAgICAgIGlmIChqID09PSAwIHx8IHRoaXNbaV0gPT09IHNzdHJpbmdbal0pIHtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBqID0gbmV4dFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqID4gc3N0cmluZ1swXSA/IGkgLSBzc3RyaW5nWzBdIDogLTE7XG4gICAgfVxuXG4gICAgLy8g5rGC5YyF5ZCr5Zyo5a2X56ym5Liy5Lit6ICMc3Ry5rKh5pyJ55qE5a2X56ym5LiyXG4gICAgc3VidHJhY3QgKHN0cikge1xuICAgICAgICBsZXQgciA9IG5ldyBTU3RyaW5nKCk7XG4gICAgICAgIHJbMF0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXNbMF07ICsraSkge1xuICAgICAgICAgICAgbGV0IGMgPSB0aGlzW2ldO1xuICAgICAgICAgICAgLy8g5Yik5pat5b2T5YmN5a2X56ymY+aYr+WQpuesrOS4gOasoeWHuueOsFxuICAgICAgICAgICAgbGV0IGogPSAxO1xuICAgICAgICAgICAgZm9yICg7IGogPCBpICYmIHRoaXNbal0gIT09IGM7ICsraik7XG4gICAgICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgICAgIC8vIOWIpOaWreW9k+WJjeWtl+espuaYr+WQpuWMheWQq+WcqHN0cuS4rVxuICAgICAgICAgICAgICAgIGxldCBrID0gMVxuICAgICAgICAgICAgICAgIGZvciAoOyBrIDw9IHN0clswXSAmJiBzdHJba10gIT09IGM7ICsrayk7XG4gICAgICAgICAgICAgICAgaWYgKGsgPiBzdHJbMF0pIHJbKytyWzBdXSA9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyB0b2RvIGJ1ZyBleGlzdHNcbiAgICBkZWxldGVfc3Vic3RyaW5nIChzdHIpIHtcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzWzBdIC0gc3RyWzBdICsgMTsgKytpKSB7XG4gICAgICAgICAgICBsZXQgaiA9IDE7XG4gICAgICAgICAgICBmb3IgKDsgaiA8PSBzdHJbMF0gJiYgdGhpc1tpICsgaiAtIDFdID09PSBzdHJbal07ICsraik7XG4gICAgICAgICAgICBpZiAoaiA+IHN0clswXSAtIDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gaTsgayA8PSB0aGlzWzBdIC0gc3RyWzBdOyArK2spIHRoaXNba10gPSB0aGlzW2sgKyBzdHJbMF1dO1xuICAgICAgICAgICAgICAgIHRoaXNbMF0gLT0gc3RyWzBdO1xuICAgICAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0TmV4dChzc3RyaW5nKSB7XG4gICAgbGV0IGkgPSAxO1xuICAgIGxldCBuZXh0ID0gezE6IDB9O1xuICAgIGxldCBqID0gMDtcblxuICAgIHdoaWxlIChpIDwgc3N0cmluZ1swXSkge1xuICAgICAgICBpZiAoaiA9PT0gMCB8fCBzc3RyaW5nW2ldID09PSBzc3RyaW5nW2pdKSB7XG4gICAgICAgICAgICBpZiAoc3N0cmluZ1srK2ldICE9PSBzc3RyaW5nWysral0pIHtcbiAgICAgICAgICAgICAgICBuZXh0W2ldID0gajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dFtpXSA9IG5leHRbal07XG4gICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICBuZXh0WysraV0gPSArK2o7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqID0gbmV4dFtqXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXh0O1xufVxuXG5sZXQgYSA9IG5ldyBTU3RyaW5nKCk7XG5sZXQgYiA9IG5ldyBTU3RyaW5nKCk7XG5mb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGFbaSArIDFdID0gaSArICcnO1xuICAgIGJbaSArIDFdID0gaSArICcnO1xufVxuYVswXSA9IGJbMF0gPSA0O1xubGV0IHQgPSBhLmNvbmNhdChiKTtcbmNvbnNvbGUubG9nKHQgKyAnJyk7ICAgICAgIC8vIDAxMjMwMTIzXG5cbmxldCBkID0gbmV3IFNTdHJpbmcoJ2FjYWJhYWJhYWJjYWNhYWJjJyk7XG5sZXQgYyA9IG5ldyBTU3RyaW5nKCdhYmFhYmMnKTtcblxuY29uc29sZS5sb2coJ2luZGV4OiAnICsgZC5pbmRleChjKSk7XG5jb25zb2xlLmxvZygna21wSW5kZXg6ICcgKyBkLmttcEluZGV4KGMpKTtcblxuYSA9IG5ldyBTU3RyaW5nKCdhYmNkZWZnJyk7XG5iID0gbmV3IFNTdHJpbmcoJ2FzZGZnJyk7XG5jb25zb2xlLmxvZyhhLnN1YnRyYWN0KGIpICsgJycpO1xuXG5hID0gbmV3IFNTdHJpbmcoJ2FiY2RlZmdoJyk7XG5iID0gbmV3IFNTdHJpbmcoJ2NkZWYnKTtcbmNvbnNvbGUubG9nKGEuZGVsZXRlX3N1YnN0cmluZyhiKSArICcnKTtcbmNvbnNvbGUubG9nKGEgKyAnJyk7XG5cbi8qXG4g5Zyo6aG65bqP5a2Y5YKo57uT5p6E5Lit77yM5a6e546w5Liy5pON5L2c55qE5Y6f5pON5L2c5Li64oCc5a2X56ym5Liy5bqP5YiX55qE5aSN5Yi24oCd77yM5pON5L2c5pe26Ze05aSN5p2C5bqm5Z+65LqO5aSN5Yi255qE5a2X56ym5Liy5bqP5YiX55qE6ZW/5bqm44CCXG4g5Y+m5LiA5pON5L2c54m554K55piv77yM5aaC5p6c5Zyo5pON5L2c5Lit5Ye6546w5Liy5YC85bqP5YiX55qE6ZW/5bqm6LaF6L+HTUFYU1RSTEVO5pe277yM57qm5a6a55So5oiq5bC+5rOV5aSE55CG77yM6L+Z56eN5oOF5Ya15LiN5LuF5Zyo5rGC6L+e5o6l5Liy5pe25Y+v6IO95Y+R55Sf77yM5Zyo5Liy55qE5YW25LuW5pON5L2c5Lit77yM5aaC5o+S5YWl77yM572u5o2i562J5Lmf5Y+v6IO95Y+R55Sf77yM5YWL5pyN6L+Z5Liq5byK55eF5ZSv5pyJ5LiN6ZmQ5a6a5Liy6ZW/55qE5pyA5aSn6ZW/5bqm77yM5Y2z5Yqo5oCB5YiG6YWN5Liy5YC855qE5a2Y5YKo56m66Ze044CCXG4gKi9cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU3RyaW5nL1NTdHJpbmcuanMiLCJ2YXIgYXNuMSA9IHJlcXVpcmUoJy4uL2FzbjEnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBhcGkgPSBleHBvcnRzO1xuXG5hcGkuZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG5hbWUsIGJvZHkpIHtcbiAgcmV0dXJuIG5ldyBFbnRpdHkobmFtZSwgYm9keSk7XG59O1xuXG5mdW5jdGlvbiBFbnRpdHkobmFtZSwgYm9keSkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gIHRoaXMuZGVjb2RlcnMgPSB7fTtcbiAgdGhpcy5lbmNvZGVycyA9IHt9O1xufTtcblxuRW50aXR5LnByb3RvdHlwZS5fY3JlYXRlTmFtZWQgPSBmdW5jdGlvbiBjcmVhdGVOYW1lZChiYXNlKSB7XG4gIHZhciBuYW1lZDtcbiAgdHJ5IHtcbiAgICBuYW1lZCA9IHJlcXVpcmUoJ3ZtJykucnVuSW5UaGlzQ29udGV4dChcbiAgICAgICcoZnVuY3Rpb24gJyArIHRoaXMubmFtZSArICcoZW50aXR5KSB7XFxuJyArXG4gICAgICAnICB0aGlzLl9pbml0TmFtZWQoZW50aXR5KTtcXG4nICtcbiAgICAgICd9KSdcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbmFtZWQgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICB0aGlzLl9pbml0TmFtZWQoZW50aXR5KTtcbiAgICB9O1xuICB9XG4gIGluaGVyaXRzKG5hbWVkLCBiYXNlKTtcbiAgbmFtZWQucHJvdG90eXBlLl9pbml0TmFtZWQgPSBmdW5jdGlvbiBpbml0bmFtZWQoZW50aXR5KSB7XG4gICAgYmFzZS5jYWxsKHRoaXMsIGVudGl0eSk7XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBuYW1lZCh0aGlzKTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuX2dldERlY29kZXIgPSBmdW5jdGlvbiBfZ2V0RGVjb2RlcihlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICdkZXInO1xuICAvLyBMYXppbHkgY3JlYXRlIGRlY29kZXJcbiAgaWYgKCF0aGlzLmRlY29kZXJzLmhhc093blByb3BlcnR5KGVuYykpXG4gICAgdGhpcy5kZWNvZGVyc1tlbmNdID0gdGhpcy5fY3JlYXRlTmFtZWQoYXNuMS5kZWNvZGVyc1tlbmNdKTtcbiAgcmV0dXJuIHRoaXMuZGVjb2RlcnNbZW5jXTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIGVuYywgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5fZ2V0RGVjb2RlcihlbmMpLmRlY29kZShkYXRhLCBvcHRpb25zKTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuX2dldEVuY29kZXIgPSBmdW5jdGlvbiBfZ2V0RW5jb2RlcihlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICdkZXInO1xuICAvLyBMYXppbHkgY3JlYXRlIGVuY29kZXJcbiAgaWYgKCF0aGlzLmVuY29kZXJzLmhhc093blByb3BlcnR5KGVuYykpXG4gICAgdGhpcy5lbmNvZGVyc1tlbmNdID0gdGhpcy5fY3JlYXRlTmFtZWQoYXNuMS5lbmNvZGVyc1tlbmNdKTtcbiAgcmV0dXJuIHRoaXMuZW5jb2RlcnNbZW5jXTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIGVuYywgLyogaW50ZXJuYWwgKi8gcmVwb3J0ZXIpIHtcbiAgcmV0dXJuIHRoaXMuX2dldEVuY29kZXIoZW5jKS5lbmNvZGUoZGF0YSwgcmVwb3J0ZXIpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hc24xLmpzL2xpYi9hc24xL2FwaS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZXBvcnRlciA9IHJlcXVpcmUoJy4uL2Jhc2UnKS5SZXBvcnRlcjtcbnZhciBFbmNvZGVyQnVmZmVyID0gcmVxdWlyZSgnLi4vYmFzZScpLkVuY29kZXJCdWZmZXI7XG52YXIgRGVjb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4uL2Jhc2UnKS5EZWNvZGVyQnVmZmVyO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuLy8gU3VwcG9ydGVkIHRhZ3NcbnZhciB0YWdzID0gW1xuICAnc2VxJywgJ3NlcW9mJywgJ3NldCcsICdzZXRvZicsICdvYmppZCcsICdib29sJyxcbiAgJ2dlbnRpbWUnLCAndXRjdGltZScsICdudWxsXycsICdlbnVtJywgJ2ludCcsICdvYmpEZXNjJyxcbiAgJ2JpdHN0cicsICdibXBzdHInLCAnY2hhcnN0cicsICdnZW5zdHInLCAnZ3JhcGhzdHInLCAnaWE1c3RyJywgJ2lzbzY0NnN0cicsXG4gICdudW1zdHInLCAnb2N0c3RyJywgJ3ByaW50c3RyJywgJ3Q2MXN0cicsICd1bmlzdHInLCAndXRmOHN0cicsICd2aWRlb3N0cidcbl07XG5cbi8vIFB1YmxpYyBtZXRob2RzIGxpc3RcbnZhciBtZXRob2RzID0gW1xuICAna2V5JywgJ29iaicsICd1c2UnLCAnb3B0aW9uYWwnLCAnZXhwbGljaXQnLCAnaW1wbGljaXQnLCAnZGVmJywgJ2Nob2ljZScsXG4gICdhbnknLCAnY29udGFpbnMnXG5dLmNvbmNhdCh0YWdzKTtcblxuLy8gT3ZlcnJpZGVkIG1ldGhvZHMgbGlzdFxudmFyIG92ZXJyaWRlZCA9IFtcbiAgJ19wZWVrVGFnJywgJ19kZWNvZGVUYWcnLCAnX3VzZScsXG4gICdfZGVjb2RlU3RyJywgJ19kZWNvZGVPYmppZCcsICdfZGVjb2RlVGltZScsXG4gICdfZGVjb2RlTnVsbCcsICdfZGVjb2RlSW50JywgJ19kZWNvZGVCb29sJywgJ19kZWNvZGVMaXN0JyxcblxuICAnX2VuY29kZUNvbXBvc2l0ZScsICdfZW5jb2RlU3RyJywgJ19lbmNvZGVPYmppZCcsICdfZW5jb2RlVGltZScsXG4gICdfZW5jb2RlTnVsbCcsICdfZW5jb2RlSW50JywgJ19lbmNvZGVCb29sJ1xuXTtcblxuZnVuY3Rpb24gTm9kZShlbmMsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB7fTtcbiAgdGhpcy5fYmFzZVN0YXRlID0gc3RhdGU7XG5cbiAgc3RhdGUuZW5jID0gZW5jO1xuXG4gIHN0YXRlLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICBzdGF0ZS5jaGlsZHJlbiA9IG51bGw7XG5cbiAgLy8gU3RhdGVcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuYXJncyA9IG51bGw7XG4gIHN0YXRlLnJldmVyc2VBcmdzID0gbnVsbDtcbiAgc3RhdGUuY2hvaWNlID0gbnVsbDtcbiAgc3RhdGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgc3RhdGUuYW55ID0gZmFsc2U7XG4gIHN0YXRlLm9iaiA9IGZhbHNlO1xuICBzdGF0ZS51c2UgPSBudWxsO1xuICBzdGF0ZS51c2VEZWNvZGVyID0gbnVsbDtcbiAgc3RhdGUua2V5ID0gbnVsbDtcbiAgc3RhdGVbJ2RlZmF1bHQnXSA9IG51bGw7XG4gIHN0YXRlLmV4cGxpY2l0ID0gbnVsbDtcbiAgc3RhdGUuaW1wbGljaXQgPSBudWxsO1xuICBzdGF0ZS5jb250YWlucyA9IG51bGw7XG5cbiAgLy8gU2hvdWxkIGNyZWF0ZSBuZXcgaW5zdGFuY2Ugb24gZWFjaCBtZXRob2RcbiAgaWYgKCFzdGF0ZS5wYXJlbnQpIHtcbiAgICBzdGF0ZS5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuX3dyYXAoKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xuXG52YXIgc3RhdGVQcm9wcyA9IFtcbiAgJ2VuYycsICdwYXJlbnQnLCAnY2hpbGRyZW4nLCAndGFnJywgJ2FyZ3MnLCAncmV2ZXJzZUFyZ3MnLCAnY2hvaWNlJyxcbiAgJ29wdGlvbmFsJywgJ2FueScsICdvYmonLCAndXNlJywgJ2FsdGVyZWRVc2UnLCAna2V5JywgJ2RlZmF1bHQnLCAnZXhwbGljaXQnLFxuICAnaW1wbGljaXQnLCAnY29udGFpbnMnXG5dO1xuXG5Ob2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBjc3RhdGUgPSB7fTtcbiAgc3RhdGVQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICBjc3RhdGVbcHJvcF0gPSBzdGF0ZVtwcm9wXTtcbiAgfSk7XG4gIHZhciByZXMgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihjc3RhdGUucGFyZW50KTtcbiAgcmVzLl9iYXNlU3RhdGUgPSBjc3RhdGU7XG4gIHJldHVybiByZXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fd3JhcCA9IGZ1bmN0aW9uIHdyYXAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIHRoaXNbbWV0aG9kXSA9IGZ1bmN0aW9uIF93cmFwcGVkTWV0aG9kKCkge1xuICAgICAgdmFyIGNsb25lID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG4gICAgICBzdGF0ZS5jaGlsZHJlbi5wdXNoKGNsb25lKTtcbiAgICAgIHJldHVybiBjbG9uZVttZXRob2RdLmFwcGx5KGNsb25lLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0sIHRoaXMpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGJvZHkpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5wYXJlbnQgPT09IG51bGwpO1xuICBib2R5LmNhbGwodGhpcyk7XG5cbiAgLy8gRmlsdGVyIGNoaWxkcmVuXG4gIHN0YXRlLmNoaWxkcmVuID0gc3RhdGUuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkLl9iYXNlU3RhdGUucGFyZW50ID09PSB0aGlzO1xuICB9LCB0aGlzKTtcbiAgYXNzZXJ0LmVxdWFsKHN0YXRlLmNoaWxkcmVuLmxlbmd0aCwgMSwgJ1Jvb3Qgbm9kZSBjYW4gaGF2ZSBvbmx5IG9uZSBjaGlsZCcpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX3VzZUFyZ3MgPSBmdW5jdGlvbiB1c2VBcmdzKGFyZ3MpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vIEZpbHRlciBjaGlsZHJlbiBhbmQgYXJnc1xuICB2YXIgY2hpbGRyZW4gPSBhcmdzLmZpbHRlcihmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvcjtcbiAgfSwgdGhpcyk7XG4gIGFyZ3MgPSBhcmdzLmZpbHRlcihmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gIShhcmcgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSwgdGhpcyk7XG5cbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzc2VydChzdGF0ZS5jaGlsZHJlbiA9PT0gbnVsbCk7XG4gICAgc3RhdGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgIC8vIFJlcGxhY2UgcGFyZW50IHRvIG1haW50YWluIGJhY2t3YXJkIGxpbmtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBjaGlsZC5fYmFzZVN0YXRlLnBhcmVudCA9IHRoaXM7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgaWYgKGFyZ3MubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNzZXJ0KHN0YXRlLmFyZ3MgPT09IG51bGwpO1xuICAgIHN0YXRlLmFyZ3MgPSBhcmdzO1xuICAgIHN0YXRlLnJldmVyc2VBcmdzID0gYXJncy5tYXAoZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ29iamVjdCcgfHwgYXJnLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpXG4gICAgICAgIHJldHVybiBhcmc7XG5cbiAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGFyZykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PSAoa2V5IHwgMCkpXG4gICAgICAgICAga2V5IHw9IDA7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ1trZXldO1xuICAgICAgICByZXNbdmFsdWVdID0ga2V5O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICB9XG59O1xuXG4vL1xuLy8gT3ZlcnJpZGVkIG1ldGhvZHNcbi8vXG5cbm92ZXJyaWRlZC5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBOb2RlLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gX292ZXJyaWRlZCgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICcgbm90IGltcGxlbWVudGVkIGZvciBlbmNvZGluZzogJyArIHN0YXRlLmVuYyk7XG4gIH07XG59KTtcblxuLy9cbi8vIFB1YmxpYyBtZXRob2RzXG4vL1xuXG50YWdzLmZvckVhY2goZnVuY3Rpb24odGFnKSB7XG4gIE5vZGUucHJvdG90eXBlW3RhZ10gPSBmdW5jdGlvbiBfdGFnTWV0aG9kKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhc3NlcnQoc3RhdGUudGFnID09PSBudWxsKTtcbiAgICBzdGF0ZS50YWcgPSB0YWc7XG5cbiAgICB0aGlzLl91c2VBcmdzKGFyZ3MpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KTtcblxuTm9kZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGl0ZW0pIHtcbiAgYXNzZXJ0KGl0ZW0pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLnVzZSA9PT0gbnVsbCk7XG4gIHN0YXRlLnVzZSA9IGl0ZW07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5vcHRpb25hbCA9IGZ1bmN0aW9uIG9wdGlvbmFsKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgc3RhdGUub3B0aW9uYWwgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZGVmID0gZnVuY3Rpb24gZGVmKHZhbCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlWydkZWZhdWx0J10gPT09IG51bGwpO1xuICBzdGF0ZVsnZGVmYXVsdCddID0gdmFsO1xuICBzdGF0ZS5vcHRpb25hbCA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5leHBsaWNpdCA9IGZ1bmN0aW9uIGV4cGxpY2l0KG51bSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLmV4cGxpY2l0ID09PSBudWxsICYmIHN0YXRlLmltcGxpY2l0ID09PSBudWxsKTtcbiAgc3RhdGUuZXhwbGljaXQgPSBudW07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5pbXBsaWNpdCA9IGZ1bmN0aW9uIGltcGxpY2l0KG51bSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLmV4cGxpY2l0ID09PSBudWxsICYmIHN0YXRlLmltcGxpY2l0ID09PSBudWxsKTtcbiAgc3RhdGUuaW1wbGljaXQgPSBudW07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5vYmogPSBmdW5jdGlvbiBvYmooKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIHN0YXRlLm9iaiA9IHRydWU7XG5cbiAgaWYgKGFyZ3MubGVuZ3RoICE9PSAwKVxuICAgIHRoaXMuX3VzZUFyZ3MoYXJncyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbiBrZXkobmV3S2V5KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUua2V5ID09PSBudWxsKTtcbiAgc3RhdGUua2V5ID0gbmV3S2V5O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuYW55ID0gZnVuY3Rpb24gYW55KCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgc3RhdGUuYW55ID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmNob2ljZSA9IGZ1bmN0aW9uIGNob2ljZShvYmopIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5jaG9pY2UgPT09IG51bGwpO1xuICBzdGF0ZS5jaG9pY2UgPSBvYmo7XG4gIHRoaXMuX3VzZUFyZ3MoT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9KSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKGl0ZW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS51c2UgPT09IG51bGwpO1xuICBzdGF0ZS5jb250YWlucyA9IGl0ZW07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gRGVjb2Rpbmdcbi8vXG5cbk5vZGUucHJvdG90eXBlLl9kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vIERlY29kZSByb290IG5vZGVcbiAgaWYgKHN0YXRlLnBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gaW5wdXQud3JhcFJlc3VsdChzdGF0ZS5jaGlsZHJlblswXS5fZGVjb2RlKGlucHV0LCBvcHRpb25zKSk7XG5cbiAgdmFyIHJlc3VsdCA9IHN0YXRlWydkZWZhdWx0J107XG4gIHZhciBwcmVzZW50ID0gdHJ1ZTtcblxuICB2YXIgcHJldktleSA9IG51bGw7XG4gIGlmIChzdGF0ZS5rZXkgIT09IG51bGwpXG4gICAgcHJldktleSA9IGlucHV0LmVudGVyS2V5KHN0YXRlLmtleSk7XG5cbiAgLy8gQ2hlY2sgaWYgdGFnIGlzIHRoZXJlXG4gIGlmIChzdGF0ZS5vcHRpb25hbCkge1xuICAgIHZhciB0YWcgPSBudWxsO1xuICAgIGlmIChzdGF0ZS5leHBsaWNpdCAhPT0gbnVsbClcbiAgICAgIHRhZyA9IHN0YXRlLmV4cGxpY2l0O1xuICAgIGVsc2UgaWYgKHN0YXRlLmltcGxpY2l0ICE9PSBudWxsKVxuICAgICAgdGFnID0gc3RhdGUuaW1wbGljaXQ7XG4gICAgZWxzZSBpZiAoc3RhdGUudGFnICE9PSBudWxsKVxuICAgICAgdGFnID0gc3RhdGUudGFnO1xuXG4gICAgaWYgKHRhZyA9PT0gbnVsbCAmJiAhc3RhdGUuYW55KSB7XG4gICAgICAvLyBUcmlhbCBhbmQgRXJyb3JcbiAgICAgIHZhciBzYXZlID0gaW5wdXQuc2F2ZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHN0YXRlLmNob2ljZSA9PT0gbnVsbClcbiAgICAgICAgICB0aGlzLl9kZWNvZGVHZW5lcmljKHN0YXRlLnRhZywgaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5fZGVjb2RlQ2hvaWNlKGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgcHJlc2VudCA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHByZXNlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlucHV0LnJlc3RvcmUoc2F2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXNlbnQgPSB0aGlzLl9wZWVrVGFnKGlucHV0LCB0YWcsIHN0YXRlLmFueSk7XG5cbiAgICAgIGlmIChpbnB1dC5pc0Vycm9yKHByZXNlbnQpKVxuICAgICAgICByZXR1cm4gcHJlc2VudDtcbiAgICB9XG4gIH1cblxuICAvLyBQdXNoIG9iamVjdCBvbiBzdGFja1xuICB2YXIgcHJldk9iajtcbiAgaWYgKHN0YXRlLm9iaiAmJiBwcmVzZW50KVxuICAgIHByZXZPYmogPSBpbnB1dC5lbnRlck9iamVjdCgpO1xuXG4gIGlmIChwcmVzZW50KSB7XG4gICAgLy8gVW53cmFwIGV4cGxpY2l0IHZhbHVlc1xuICAgIGlmIChzdGF0ZS5leHBsaWNpdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGV4cGxpY2l0ID0gdGhpcy5fZGVjb2RlVGFnKGlucHV0LCBzdGF0ZS5leHBsaWNpdCk7XG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcihleHBsaWNpdCkpXG4gICAgICAgIHJldHVybiBleHBsaWNpdDtcbiAgICAgIGlucHV0ID0gZXhwbGljaXQ7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gaW5wdXQub2Zmc2V0O1xuXG4gICAgLy8gVW53cmFwIGltcGxpY2l0IGFuZCBub3JtYWwgdmFsdWVzXG4gICAgaWYgKHN0YXRlLnVzZSA9PT0gbnVsbCAmJiBzdGF0ZS5jaG9pY2UgPT09IG51bGwpIHtcbiAgICAgIGlmIChzdGF0ZS5hbnkpXG4gICAgICAgIHZhciBzYXZlID0gaW5wdXQuc2F2ZSgpO1xuICAgICAgdmFyIGJvZHkgPSB0aGlzLl9kZWNvZGVUYWcoXG4gICAgICAgIGlucHV0LFxuICAgICAgICBzdGF0ZS5pbXBsaWNpdCAhPT0gbnVsbCA/IHN0YXRlLmltcGxpY2l0IDogc3RhdGUudGFnLFxuICAgICAgICBzdGF0ZS5hbnlcbiAgICAgICk7XG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcihib2R5KSlcbiAgICAgICAgcmV0dXJuIGJvZHk7XG5cbiAgICAgIGlmIChzdGF0ZS5hbnkpXG4gICAgICAgIHJlc3VsdCA9IGlucHV0LnJhdyhzYXZlKTtcbiAgICAgIGVsc2VcbiAgICAgICAgaW5wdXQgPSBib2R5O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHJhY2sgJiYgc3RhdGUudGFnICE9PSBudWxsKVxuICAgICAgb3B0aW9ucy50cmFjayhpbnB1dC5wYXRoKCksIHN0YXJ0LCBpbnB1dC5sZW5ndGgsICd0YWdnZWQnKTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHJhY2sgJiYgc3RhdGUudGFnICE9PSBudWxsKVxuICAgICAgb3B0aW9ucy50cmFjayhpbnB1dC5wYXRoKCksIGlucHV0Lm9mZnNldCwgaW5wdXQubGVuZ3RoLCAnY29udGVudCcpO1xuXG4gICAgLy8gU2VsZWN0IHByb3BlciBtZXRob2QgZm9yIHRhZ1xuICAgIGlmIChzdGF0ZS5hbnkpXG4gICAgICByZXN1bHQgPSByZXN1bHQ7XG4gICAgZWxzZSBpZiAoc3RhdGUuY2hvaWNlID09PSBudWxsKVxuICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb2RlR2VuZXJpYyhzdGF0ZS50YWcsIGlucHV0LCBvcHRpb25zKTtcbiAgICBlbHNlXG4gICAgICByZXN1bHQgPSB0aGlzLl9kZWNvZGVDaG9pY2UoaW5wdXQsIG9wdGlvbnMpO1xuXG4gICAgaWYgKGlucHV0LmlzRXJyb3IocmVzdWx0KSlcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAvLyBEZWNvZGUgY2hpbGRyZW5cbiAgICBpZiAoIXN0YXRlLmFueSAmJiBzdGF0ZS5jaG9pY2UgPT09IG51bGwgJiYgc3RhdGUuY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIHN0YXRlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gZGVjb2RlQ2hpbGRyZW4oY2hpbGQpIHtcbiAgICAgICAgLy8gTk9URTogV2UgYXJlIGlnbm9yaW5nIGVycm9ycyBoZXJlLCB0byBsZXQgcGFyc2VyIGNvbnRpbnVlIHdpdGggb3RoZXJcbiAgICAgICAgLy8gcGFydHMgb2YgZW5jb2RlZCBkYXRhXG4gICAgICAgIGNoaWxkLl9kZWNvZGUoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGVjb2RlIGNvbnRhaW5lZC9lbmNvZGVkIGJ5IHNjaGVtYSwgb25seSBpbiBiaXQgb3Igb2N0ZXQgc3RyaW5nc1xuICAgIGlmIChzdGF0ZS5jb250YWlucyAmJiAoc3RhdGUudGFnID09PSAnb2N0c3RyJyB8fCBzdGF0ZS50YWcgPT09ICdiaXRzdHInKSkge1xuICAgICAgdmFyIGRhdGEgPSBuZXcgRGVjb2RlckJ1ZmZlcihyZXN1bHQpO1xuICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0VXNlKHN0YXRlLmNvbnRhaW5zLCBpbnB1dC5fcmVwb3J0ZXJTdGF0ZS5vYmopXG4gICAgICAgICAgLl9kZWNvZGUoZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLy8gUG9wIG9iamVjdFxuICBpZiAoc3RhdGUub2JqICYmIHByZXNlbnQpXG4gICAgcmVzdWx0ID0gaW5wdXQubGVhdmVPYmplY3QocHJldk9iaik7XG5cbiAgLy8gU2V0IGtleVxuICBpZiAoc3RhdGUua2V5ICE9PSBudWxsICYmIChyZXN1bHQgIT09IG51bGwgfHwgcHJlc2VudCA9PT0gdHJ1ZSkpXG4gICAgaW5wdXQubGVhdmVLZXkocHJldktleSwgc3RhdGUua2V5LCByZXN1bHQpO1xuICBlbHNlIGlmIChwcmV2S2V5ICE9PSBudWxsKVxuICAgIGlucHV0LmV4aXRLZXkocHJldktleSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9kZWNvZGVHZW5lcmljID0gZnVuY3Rpb24gZGVjb2RlR2VuZXJpYyh0YWcsIGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBpZiAodGFnID09PSAnc2VxJyB8fCB0YWcgPT09ICdzZXQnKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAodGFnID09PSAnc2Vxb2YnIHx8IHRhZyA9PT0gJ3NldG9mJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlTGlzdChpbnB1dCwgdGFnLCBzdGF0ZS5hcmdzWzBdLCBvcHRpb25zKTtcbiAgZWxzZSBpZiAoL3N0ciQvLnRlc3QodGFnKSlcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlU3RyKGlucHV0LCB0YWcsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmppZCcgJiYgc3RhdGUuYXJncylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlT2JqaWQoaW5wdXQsIHN0YXRlLmFyZ3NbMF0sIHN0YXRlLmFyZ3NbMV0sIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmppZCcpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZU9iamlkKGlucHV0LCBudWxsLCBudWxsLCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnZ2VudGltZScgfHwgdGFnID09PSAndXRjdGltZScpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZVRpbWUoaW5wdXQsIHRhZywgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ251bGxfJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlTnVsbChpbnB1dCwgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2Jvb2wnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVCb29sKGlucHV0LCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqRGVzYycpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZVN0cihpbnB1dCwgdGFnLCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnaW50JyB8fCB0YWcgPT09ICdlbnVtJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlSW50KGlucHV0LCBzdGF0ZS5hcmdzICYmIHN0YXRlLmFyZ3NbMF0sIG9wdGlvbnMpO1xuXG4gIGlmIChzdGF0ZS51c2UgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXNlKHN0YXRlLnVzZSwgaW5wdXQuX3JlcG9ydGVyU3RhdGUub2JqKVxuICAgICAgICAuX2RlY29kZShpbnB1dCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlucHV0LmVycm9yKCd1bmtub3duIHRhZzogJyArIHRhZyk7XG4gIH1cbn07XG5cbk5vZGUucHJvdG90eXBlLl9nZXRVc2UgPSBmdW5jdGlvbiBfZ2V0VXNlKGVudGl0eSwgb2JqKSB7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICAvLyBDcmVhdGUgYWx0ZXJlZCB1c2UgZGVjb2RlciBpZiBpbXBsaWNpdCBpcyBzZXRcbiAgc3RhdGUudXNlRGVjb2RlciA9IHRoaXMuX3VzZShlbnRpdHksIG9iaik7XG4gIGFzc2VydChzdGF0ZS51c2VEZWNvZGVyLl9iYXNlU3RhdGUucGFyZW50ID09PSBudWxsKTtcbiAgc3RhdGUudXNlRGVjb2RlciA9IHN0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5jaGlsZHJlblswXTtcbiAgaWYgKHN0YXRlLmltcGxpY2l0ICE9PSBzdGF0ZS51c2VEZWNvZGVyLl9iYXNlU3RhdGUuaW1wbGljaXQpIHtcbiAgICBzdGF0ZS51c2VEZWNvZGVyID0gc3RhdGUudXNlRGVjb2Rlci5jbG9uZSgpO1xuICAgIHN0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5pbXBsaWNpdCA9IHN0YXRlLmltcGxpY2l0O1xuICB9XG4gIHJldHVybiBzdGF0ZS51c2VEZWNvZGVyO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2RlY29kZUNob2ljZSA9IGZ1bmN0aW9uIGRlY29kZUNob2ljZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuICB2YXIgbWF0Y2ggPSBmYWxzZTtcblxuICBPYmplY3Qua2V5cyhzdGF0ZS5jaG9pY2UpLnNvbWUoZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIHNhdmUgPSBpbnB1dC5zYXZlKCk7XG4gICAgdmFyIG5vZGUgPSBzdGF0ZS5jaG9pY2Vba2V5XTtcbiAgICB0cnkge1xuICAgICAgdmFyIHZhbHVlID0gbm9kZS5fZGVjb2RlKGlucHV0LCBvcHRpb25zKTtcbiAgICAgIGlmIChpbnB1dC5pc0Vycm9yKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXN1bHQgPSB7IHR5cGU6IGtleSwgdmFsdWU6IHZhbHVlIH07XG4gICAgICBtYXRjaCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaW5wdXQucmVzdG9yZShzYXZlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIHRoaXMpO1xuXG4gIGlmICghbWF0Y2gpXG4gICAgcmV0dXJuIGlucHV0LmVycm9yKCdDaG9pY2Ugbm90IG1hdGNoZWQnKTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy9cbi8vIEVuY29kaW5nXG4vL1xuXG5Ob2RlLnByb3RvdHlwZS5fY3JlYXRlRW5jb2RlckJ1ZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YSkge1xuICByZXR1cm4gbmV3IEVuY29kZXJCdWZmZXIoZGF0YSwgdGhpcy5yZXBvcnRlcik7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIHJlcG9ydGVyLCBwYXJlbnQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSAhPT0gbnVsbCAmJiBzdGF0ZVsnZGVmYXVsdCddID09PSBkYXRhKVxuICAgIHJldHVybjtcblxuICB2YXIgcmVzdWx0ID0gdGhpcy5fZW5jb2RlVmFsdWUoZGF0YSwgcmVwb3J0ZXIsIHBhcmVudCk7XG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm47XG5cbiAgaWYgKHRoaXMuX3NraXBEZWZhdWx0KHJlc3VsdCwgcmVwb3J0ZXIsIHBhcmVudCkpXG4gICAgcmV0dXJuO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZW5jb2RlVmFsdWUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgcmVwb3J0ZXIsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgLy8gRGVjb2RlIHJvb3Qgbm9kZVxuICBpZiAoc3RhdGUucGFyZW50ID09PSBudWxsKVxuICAgIHJldHVybiBzdGF0ZS5jaGlsZHJlblswXS5fZW5jb2RlKGRhdGEsIHJlcG9ydGVyIHx8IG5ldyBSZXBvcnRlcigpKTtcblxuICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAvLyBTZXQgcmVwb3J0ZXIgdG8gc2hhcmUgaXQgd2l0aCBhIGNoaWxkIGNsYXNzXG4gIHRoaXMucmVwb3J0ZXIgPSByZXBvcnRlcjtcblxuICAvLyBDaGVjayBpZiBkYXRhIGlzIHRoZXJlXG4gIGlmIChzdGF0ZS5vcHRpb25hbCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSAhPT0gbnVsbClcbiAgICAgIGRhdGEgPSBzdGF0ZVsnZGVmYXVsdCddXG4gICAgZWxzZVxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5jb2RlIGNoaWxkcmVuIGZpcnN0XG4gIHZhciBjb250ZW50ID0gbnVsbDtcbiAgdmFyIHByaW1pdGl2ZSA9IGZhbHNlO1xuICBpZiAoc3RhdGUuYW55KSB7XG4gICAgLy8gQW55dGhpbmcgdGhhdCB3YXMgZ2l2ZW4gaXMgdHJhbnNsYXRlZCB0byBidWZmZXJcbiAgICByZXN1bHQgPSB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKGRhdGEpO1xuICB9IGVsc2UgaWYgKHN0YXRlLmNob2ljZSkge1xuICAgIHJlc3VsdCA9IHRoaXMuX2VuY29kZUNob2ljZShkYXRhLCByZXBvcnRlcik7XG4gIH0gZWxzZSBpZiAoc3RhdGUuY29udGFpbnMpIHtcbiAgICBjb250ZW50ID0gdGhpcy5fZ2V0VXNlKHN0YXRlLmNvbnRhaW5zLCBwYXJlbnQpLl9lbmNvZGUoZGF0YSwgcmVwb3J0ZXIpO1xuICAgIHByaW1pdGl2ZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAoc3RhdGUuY2hpbGRyZW4pIHtcbiAgICBjb250ZW50ID0gc3RhdGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuX2Jhc2VTdGF0ZS50YWcgPT09ICdudWxsXycpXG4gICAgICAgIHJldHVybiBjaGlsZC5fZW5jb2RlKG51bGwsIHJlcG9ydGVyLCBkYXRhKTtcblxuICAgICAgaWYgKGNoaWxkLl9iYXNlU3RhdGUua2V5ID09PSBudWxsKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ0NoaWxkIHNob3VsZCBoYXZlIGEga2V5Jyk7XG4gICAgICB2YXIgcHJldktleSA9IHJlcG9ydGVyLmVudGVyS2V5KGNoaWxkLl9iYXNlU3RhdGUua2V5KTtcblxuICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdDaGlsZCBleHBlY3RlZCwgYnV0IGlucHV0IGlzIG5vdCBvYmplY3QnKTtcblxuICAgICAgdmFyIHJlcyA9IGNoaWxkLl9lbmNvZGUoZGF0YVtjaGlsZC5fYmFzZVN0YXRlLmtleV0sIHJlcG9ydGVyLCBkYXRhKTtcbiAgICAgIHJlcG9ydGVyLmxlYXZlS2V5KHByZXZLZXkpO1xuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sIHRoaXMpLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0pO1xuICAgIGNvbnRlbnQgPSB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKGNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGlmIChzdGF0ZS50YWcgPT09ICdzZXFvZicgfHwgc3RhdGUudGFnID09PSAnc2V0b2YnKSB7XG4gICAgICAvLyBUT0RPKGluZHV0bnkpOiB0aGlzIHNob3VsZCBiZSB0aHJvd24gb24gRFNMIGxldmVsXG4gICAgICBpZiAoIShzdGF0ZS5hcmdzICYmIHN0YXRlLmFyZ3MubGVuZ3RoID09PSAxKSlcbiAgICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdUb28gbWFueSBhcmdzIGZvciA6ICcgKyBzdGF0ZS50YWcpO1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignc2Vxb2Yvc2V0b2YsIGJ1dCBkYXRhIGlzIG5vdCBBcnJheScpO1xuXG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjaGlsZC5fYmFzZVN0YXRlLmltcGxpY2l0ID0gbnVsbDtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKGRhdGEubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRVc2Uoc3RhdGUuYXJnc1swXSwgZGF0YSkuX2VuY29kZShpdGVtLCByZXBvcnRlcik7XG4gICAgICB9LCBjaGlsZCkpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUudXNlICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLl9nZXRVc2Uoc3RhdGUudXNlLCBwYXJlbnQpLl9lbmNvZGUoZGF0YSwgcmVwb3J0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5fZW5jb2RlUHJpbWl0aXZlKHN0YXRlLnRhZywgZGF0YSk7XG4gICAgICBwcmltaXRpdmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVuY29kZSBkYXRhIGl0c2VsZlxuICB2YXIgcmVzdWx0O1xuICBpZiAoIXN0YXRlLmFueSAmJiBzdGF0ZS5jaG9pY2UgPT09IG51bGwpIHtcbiAgICB2YXIgdGFnID0gc3RhdGUuaW1wbGljaXQgIT09IG51bGwgPyBzdGF0ZS5pbXBsaWNpdCA6IHN0YXRlLnRhZztcbiAgICB2YXIgY2xzID0gc3RhdGUuaW1wbGljaXQgPT09IG51bGwgPyAndW5pdmVyc2FsJyA6ICdjb250ZXh0JztcblxuICAgIGlmICh0YWcgPT09IG51bGwpIHtcbiAgICAgIGlmIChzdGF0ZS51c2UgPT09IG51bGwpXG4gICAgICAgIHJlcG9ydGVyLmVycm9yKCdUYWcgY291bGQgYmUgb21taXRlZCBvbmx5IGZvciAudXNlKCknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLnVzZSA9PT0gbnVsbClcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fZW5jb2RlQ29tcG9zaXRlKHRhZywgcHJpbWl0aXZlLCBjbHMsIGNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdyYXAgaW4gZXhwbGljaXRcbiAgaWYgKHN0YXRlLmV4cGxpY2l0ICE9PSBudWxsKVxuICAgIHJlc3VsdCA9IHRoaXMuX2VuY29kZUNvbXBvc2l0ZShzdGF0ZS5leHBsaWNpdCwgZmFsc2UsICdjb250ZXh0JywgcmVzdWx0KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZUNob2ljZSA9IGZ1bmN0aW9uIGVuY29kZUNob2ljZShkYXRhLCByZXBvcnRlcikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgdmFyIG5vZGUgPSBzdGF0ZS5jaG9pY2VbZGF0YS50eXBlXTtcbiAgaWYgKCFub2RlKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZGF0YS50eXBlICsgJyBub3QgZm91bmQgaW4gJyArXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzdGF0ZS5jaG9pY2UpKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGUuX2VuY29kZShkYXRhLnZhbHVlLCByZXBvcnRlcik7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZW5jb2RlUHJpbWl0aXZlID0gZnVuY3Rpb24gZW5jb2RlUHJpbWl0aXZlKHRhZywgZGF0YSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgaWYgKC9zdHIkLy50ZXN0KHRhZykpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZVN0cihkYXRhLCB0YWcpO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmppZCcgJiYgc3RhdGUuYXJncylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlT2JqaWQoZGF0YSwgc3RhdGUucmV2ZXJzZUFyZ3NbMF0sIHN0YXRlLmFyZ3NbMV0pO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmppZCcpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZU9iamlkKGRhdGEsIG51bGwsIG51bGwpO1xuICBlbHNlIGlmICh0YWcgPT09ICdnZW50aW1lJyB8fCB0YWcgPT09ICd1dGN0aW1lJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlVGltZShkYXRhLCB0YWcpO1xuICBlbHNlIGlmICh0YWcgPT09ICdudWxsXycpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZU51bGwoKTtcbiAgZWxzZSBpZiAodGFnID09PSAnaW50JyB8fCB0YWcgPT09ICdlbnVtJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlSW50KGRhdGEsIHN0YXRlLmFyZ3MgJiYgc3RhdGUucmV2ZXJzZUFyZ3NbMF0pO1xuICBlbHNlIGlmICh0YWcgPT09ICdib29sJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlQm9vbChkYXRhKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqRGVzYycpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZVN0cihkYXRhLCB0YWcpO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB0YWc6ICcgKyB0YWcpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2lzTnVtc3RyID0gZnVuY3Rpb24gaXNOdW1zdHIoc3RyKSB7XG4gIHJldHVybiAvXlswLTkgXSokLy50ZXN0KHN0cik7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5faXNQcmludHN0ciA9IGZ1bmN0aW9uIGlzUHJpbnRzdHIoc3RyKSB7XG4gIHJldHVybiAvXltBLVphLXowLTkgJ1xcKFxcKVxcKyxcXC1cXC5cXC86PVxcP10qJC8udGVzdChzdHIpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hc24xLmpzL2xpYi9hc24xL2Jhc2Uvbm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmZ1bmN0aW9uIFJlcG9ydGVyKG9wdGlvbnMpIHtcbiAgdGhpcy5fcmVwb3J0ZXJTdGF0ZSA9IHtcbiAgICBvYmo6IG51bGwsXG4gICAgcGF0aDogW10sXG4gICAgb3B0aW9uczogb3B0aW9ucyB8fCB7fSxcbiAgICBlcnJvcnM6IFtdXG4gIH07XG59XG5leHBvcnRzLlJlcG9ydGVyID0gUmVwb3J0ZXI7XG5cblJlcG9ydGVyLnByb3RvdHlwZS5pc0Vycm9yID0gZnVuY3Rpb24gaXNFcnJvcihvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIFJlcG9ydGVyRXJyb3I7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgcmV0dXJuIHsgb2JqOiBzdGF0ZS5vYmosIHBhdGhMZW46IHN0YXRlLnBhdGgubGVuZ3RoIH07XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIHJlc3RvcmUoZGF0YSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHN0YXRlLm9iaiA9IGRhdGEub2JqO1xuICBzdGF0ZS5wYXRoID0gc3RhdGUucGF0aC5zbGljZSgwLCBkYXRhLnBhdGhMZW4pO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmVudGVyS2V5ID0gZnVuY3Rpb24gZW50ZXJLZXkoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9yZXBvcnRlclN0YXRlLnBhdGgucHVzaChrZXkpO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmV4aXRLZXkgPSBmdW5jdGlvbiBleGl0S2V5KGluZGV4KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgc3RhdGUucGF0aCA9IHN0YXRlLnBhdGguc2xpY2UoMCwgaW5kZXggLSAxKTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5sZWF2ZUtleSA9IGZ1bmN0aW9uIGxlYXZlS2V5KGluZGV4LCBrZXksIHZhbHVlKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdGhpcy5leGl0S2V5KGluZGV4KTtcbiAgaWYgKHN0YXRlLm9iaiAhPT0gbnVsbClcbiAgICBzdGF0ZS5vYmpba2V5XSA9IHZhbHVlO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiBwYXRoKCkge1xuICByZXR1cm4gdGhpcy5fcmVwb3J0ZXJTdGF0ZS5wYXRoLmpvaW4oJy8nKTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5lbnRlck9iamVjdCA9IGZ1bmN0aW9uIGVudGVyT2JqZWN0KCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHZhciBwcmV2ID0gc3RhdGUub2JqO1xuICBzdGF0ZS5vYmogPSB7fTtcbiAgcmV0dXJuIHByZXY7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUubGVhdmVPYmplY3QgPSBmdW5jdGlvbiBsZWF2ZU9iamVjdChwcmV2KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdmFyIG5vdyA9IHN0YXRlLm9iajtcbiAgc3RhdGUub2JqID0gcHJldjtcbiAgcmV0dXJuIG5vdztcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1zZykge1xuICB2YXIgZXJyO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHZhciBpbmhlcml0ZWQgPSBtc2cgaW5zdGFuY2VvZiBSZXBvcnRlckVycm9yO1xuICBpZiAoaW5oZXJpdGVkKSB7XG4gICAgZXJyID0gbXNnO1xuICB9IGVsc2Uge1xuICAgIGVyciA9IG5ldyBSZXBvcnRlckVycm9yKHN0YXRlLnBhdGgubWFwKGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHJldHVybiAnWycgKyBKU09OLnN0cmluZ2lmeShlbGVtKSArICddJztcbiAgICB9KS5qb2luKCcnKSwgbXNnLm1lc3NhZ2UgfHwgbXNnLCBtc2cuc3RhY2spO1xuICB9XG5cbiAgaWYgKCFzdGF0ZS5vcHRpb25zLnBhcnRpYWwpXG4gICAgdGhyb3cgZXJyO1xuXG4gIGlmICghaW5oZXJpdGVkKVxuICAgIHN0YXRlLmVycm9ycy5wdXNoKGVycik7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS53cmFwUmVzdWx0ID0gZnVuY3Rpb24gd3JhcFJlc3VsdChyZXN1bHQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5vcHRpb25zLnBhcnRpYWwpXG4gICAgcmV0dXJuIHJlc3VsdDtcblxuICByZXR1cm4ge1xuICAgIHJlc3VsdDogdGhpcy5pc0Vycm9yKHJlc3VsdCkgPyBudWxsIDogcmVzdWx0LFxuICAgIGVycm9yczogc3RhdGUuZXJyb3JzXG4gIH07XG59O1xuXG5mdW5jdGlvbiBSZXBvcnRlckVycm9yKHBhdGgsIG1zZykge1xuICB0aGlzLnBhdGggPSBwYXRoO1xuICB0aGlzLnJldGhyb3cobXNnKTtcbn07XG5pbmhlcml0cyhSZXBvcnRlckVycm9yLCBFcnJvcik7XG5cblJlcG9ydGVyRXJyb3IucHJvdG90eXBlLnJldGhyb3cgPSBmdW5jdGlvbiByZXRocm93KG1zZykge1xuICB0aGlzLm1lc3NhZ2UgPSBtc2cgKyAnIGF0OiAnICsgKHRoaXMucGF0aCB8fCAnKHNoYWxsb3cpJyk7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXBvcnRlckVycm9yKTtcblxuICBpZiAoIXRoaXMuc3RhY2spIHtcbiAgICB0cnkge1xuICAgICAgLy8gSUUgb25seSBhZGRzIHN0YWNrIHdoZW4gdGhyb3duXG4gICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5tZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLnN0YWNrID0gZS5zdGFjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FzbjEuanMvbGliL2FzbjEvYmFzZS9yZXBvcnRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcblxuZXhwb3J0cy50YWdDbGFzcyA9IHtcbiAgMDogJ3VuaXZlcnNhbCcsXG4gIDE6ICdhcHBsaWNhdGlvbicsXG4gIDI6ICdjb250ZXh0JyxcbiAgMzogJ3ByaXZhdGUnXG59O1xuZXhwb3J0cy50YWdDbGFzc0J5TmFtZSA9IGNvbnN0YW50cy5fcmV2ZXJzZShleHBvcnRzLnRhZ0NsYXNzKTtcblxuZXhwb3J0cy50YWcgPSB7XG4gIDB4MDA6ICdlbmQnLFxuICAweDAxOiAnYm9vbCcsXG4gIDB4MDI6ICdpbnQnLFxuICAweDAzOiAnYml0c3RyJyxcbiAgMHgwNDogJ29jdHN0cicsXG4gIDB4MDU6ICdudWxsXycsXG4gIDB4MDY6ICdvYmppZCcsXG4gIDB4MDc6ICdvYmpEZXNjJyxcbiAgMHgwODogJ2V4dGVybmFsJyxcbiAgMHgwOTogJ3JlYWwnLFxuICAweDBhOiAnZW51bScsXG4gIDB4MGI6ICdlbWJlZCcsXG4gIDB4MGM6ICd1dGY4c3RyJyxcbiAgMHgwZDogJ3JlbGF0aXZlT2lkJyxcbiAgMHgxMDogJ3NlcScsXG4gIDB4MTE6ICdzZXQnLFxuICAweDEyOiAnbnVtc3RyJyxcbiAgMHgxMzogJ3ByaW50c3RyJyxcbiAgMHgxNDogJ3Q2MXN0cicsXG4gIDB4MTU6ICd2aWRlb3N0cicsXG4gIDB4MTY6ICdpYTVzdHInLFxuICAweDE3OiAndXRjdGltZScsXG4gIDB4MTg6ICdnZW50aW1lJyxcbiAgMHgxOTogJ2dyYXBoc3RyJyxcbiAgMHgxYTogJ2lzbzY0NnN0cicsXG4gIDB4MWI6ICdnZW5zdHInLFxuICAweDFjOiAndW5pc3RyJyxcbiAgMHgxZDogJ2NoYXJzdHInLFxuICAweDFlOiAnYm1wc3RyJ1xufTtcbmV4cG9ydHMudGFnQnlOYW1lID0gY29uc3RhbnRzLl9yZXZlcnNlKGV4cG9ydHMudGFnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hc24xLmpzL2xpYi9hc24xL2NvbnN0YW50cy9kZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGVjb2RlcnMgPSBleHBvcnRzO1xuXG5kZWNvZGVycy5kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuZGVjb2RlcnMucGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hc24xLmpzL2xpYi9hc24xL2RlY29kZXJzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBERVJEZWNvZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcblxuZnVuY3Rpb24gUEVNRGVjb2RlcihlbnRpdHkpIHtcbiAgREVSRGVjb2Rlci5jYWxsKHRoaXMsIGVudGl0eSk7XG4gIHRoaXMuZW5jID0gJ3BlbSc7XG59O1xuaW5oZXJpdHMoUEVNRGVjb2RlciwgREVSRGVjb2Rlcik7XG5tb2R1bGUuZXhwb3J0cyA9IFBFTURlY29kZXI7XG5cblBFTURlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBsaW5lcyA9IGRhdGEudG9TdHJpbmcoKS5zcGxpdCgvW1xcclxcbl0rL2cpO1xuXG4gIHZhciBsYWJlbCA9IG9wdGlvbnMubGFiZWwudG9VcHBlckNhc2UoKTtcblxuICB2YXIgcmUgPSAvXi0tLS0tKEJFR0lOfEVORCkgKFteLV0rKS0tLS0tJC87XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWF0Y2ggPSBsaW5lc1tpXS5tYXRjaChyZSk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsKVxuICAgICAgY29udGludWU7XG5cbiAgICBpZiAobWF0Y2hbMl0gIT09IGxhYmVsKVxuICAgICAgY29udGludWU7XG5cbiAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICBpZiAobWF0Y2hbMV0gIT09ICdCRUdJTicpXG4gICAgICAgIGJyZWFrO1xuICAgICAgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobWF0Y2hbMV0gIT09ICdFTkQnKVxuICAgICAgICBicmVhaztcbiAgICAgIGVuZCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKVxuICAgIHRocm93IG5ldyBFcnJvcignUEVNIHNlY3Rpb24gbm90IGZvdW5kIGZvcjogJyArIGxhYmVsKTtcblxuICB2YXIgYmFzZTY0ID0gbGluZXMuc2xpY2Uoc3RhcnQgKyAxLCBlbmQpLmpvaW4oJycpO1xuICAvLyBSZW1vdmUgZXhjZXNzaXZlIHN5bWJvbHNcbiAgYmFzZTY0LnJlcGxhY2UoL1teYS16MC05XFwrXFwvPV0rL2dpLCAnJyk7XG5cbiAgdmFyIGlucHV0ID0gbmV3IEJ1ZmZlcihiYXNlNjQsICdiYXNlNjQnKTtcbiAgcmV0dXJuIERFUkRlY29kZXIucHJvdG90eXBlLmRlY29kZS5jYWxsKHRoaXMsIGlucHV0LCBvcHRpb25zKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9wZW0uanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZW5jb2RlcnMgPSBleHBvcnRzO1xuXG5lbmNvZGVycy5kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuZW5jb2RlcnMucGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIERFUkVuY29kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuXG5mdW5jdGlvbiBQRU1FbmNvZGVyKGVudGl0eSkge1xuICBERVJFbmNvZGVyLmNhbGwodGhpcywgZW50aXR5KTtcbiAgdGhpcy5lbmMgPSAncGVtJztcbn07XG5pbmhlcml0cyhQRU1FbmNvZGVyLCBERVJFbmNvZGVyKTtcbm1vZHVsZS5leHBvcnRzID0gUEVNRW5jb2RlcjtcblxuUEVNRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJ1ZiA9IERFUkVuY29kZXIucHJvdG90eXBlLmVuY29kZS5jYWxsKHRoaXMsIGRhdGEpO1xuXG4gIHZhciBwID0gYnVmLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgdmFyIG91dCA9IFsgJy0tLS0tQkVHSU4gJyArIG9wdGlvbnMubGFiZWwgKyAnLS0tLS0nIF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkgKz0gNjQpXG4gICAgb3V0LnB1c2gocC5zbGljZShpLCBpICsgNjQpKTtcbiAgb3V0LnB1c2goJy0tLS0tRU5EICcgKyBvcHRpb25zLmxhYmVsICsgJy0tLS0tJyk7XG4gIHJldHVybiBvdXQuam9pbignXFxuJyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FzbjEuanMvbGliL2FzbjEvZW5jb2RlcnMvcGVtLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBcnJheToge1xuICAgICAgICAvLyBDcm9zc0xpc3Q6IHJlcXVpcmUoJy4vQXJyYXkvQ3Jvc3NMaXN0JykuZGVmYXVsdCxcbiAgICAgICAgLy8gVFNNYXRyaXg6IHJlcXVpcmUoJy4vQXJyYXkvVFNNYXRyaXgnKS5kZWZhdWx0XG4gICAgICAgIC8vIHRvZG8gYXJyYXkgYWxnb3JpdGhtc1xuICAgIH0sXG4gICAgXG4gICAgQmluYXJ5VHJlZToge1xuICAgICAgICAvLyBCaW5hcnlUaHJlYWRUcmVlOiByZXF1aXJlKCcuL0JpbmFyeVRyZWUvQmluYXJ5VGhyZWFkVHJlZScpLFxuICAgICAgICBCaW5hcnlUcmVlOiByZXF1aXJlKCcuL0JpbmFyeVRyZWUvQmluYXJ5VHJlZScpLFxuICAgICAgICBodWZmTWFuQ29kaW5nOiByZXF1aXJlKCcuL0JpbmFyeVRyZWUvaHVmZk1hbkNvZGluZycpLmRlZmF1bHQsXG4gICAgICAgIEJpbmFyeVRyZWVBcnJheTogcmVxdWlyZSgnLi9CaW5hcnlUcmVlL0JpbmFyeVRyZWVBcnJheS5qcycpXG4gICAgICAgIC8vIE1GU2V0OiByZXF1aXJlKCcuL0JpbmFyeVRyZWUvTUZTZXQnKSxcbiAgICB9LFxuICAgIFxuICAgIEdlbmVyYWxpemVkTGlzdDogcmVxdWlyZSgnLi9HZW5lcmFsaXplZExpc3QvR0xpc3QnKS5kZWZhdWx0LFxuICAgIFxuICAgIEdyYXBoOiB7XG4gICAgICAgIEFkamFjZW5jeUxpc3RHcmFwaDogcmVxdWlyZSgnLi9HcmFwaC9BZGphY2VuY3lMaXN0R3JhcGgnKS5kZWZhdWx0LFxuICAgICAgICBBZGphY2VuY3lNYXRyaXhHcmFwaDogcmVxdWlyZSgnLi9HcmFwaC9BZGphY2VuY3lNYXRyaXhHcmFwaCcpLmRlZmF1bHQsXG4gICAgICAgIEFNTEdyYXBoOiByZXF1aXJlKCcuL0dyYXBoL0FNTEdyYXBoJykuZGVmYXVsdCxcbiAgICAgICAgT0xHcmFwaDogcmVxdWlyZSgnLi9HcmFwaC9PTEdyYXBoJykuZGVmYXVsdFxuICAgIH0sXG4gICAgXG4gICAgTGlzdDoge1xuICAgICAgICBEb3VibGVMaW5rZWRMaXN0OiByZXF1aXJlKCcuL0xpc3QvRG91YmxlTGlua2VkTGlzdCcpLmRlZmF1bHQsXG4gICAgICAgIExpbmVhckxpc3Q6IHJlcXVpcmUoJy4vTGlzdC9MaW5lYXJMaXN0JyksXG4gICAgICAgIFN0YXRpY0xpbmtlZExpc3Q6IHJlcXVpcmUoJy4vTGlzdC9TdGF0aWNMaW5rZWRMaXN0JykuZGVmYXVsdCxcbiAgICAgICAgTFJVQ2FjaGU6IHJlcXVpcmUoJy4vTGlzdC9MUlUnKS5kZWZhdWx0XG4gICAgfSxcbiAgICBcbiAgICBRdWV1ZToge1xuICAgICAgICBDeWNsZVF1ZXVlOiByZXF1aXJlKCcuL1F1ZXVlL0N5Y2xlUXVldWUnKS5kZWZhdWx0LFxuICAgICAgICBQcmlvcml0eVF1ZXVlOiByZXF1aXJlKCcuL1F1ZXVlL1ByaW9yaXR5UXVldWUnKS5kZWZhdWx0LFxuICAgICAgICBRdWV1ZTogcmVxdWlyZSgnLi9RdWV1ZS9RdWV1ZScpLmRlZmF1bHRcbiAgICB9LFxuICAgIFxuICAgIFNlYXJjaDoge1xuICAgICAgICBBVkxUcmVlOiByZXF1aXJlKCcuL1NlYXJjaC9BVkxUcmVlJyksXG4gICAgICAgIGJpbmFyeVNlYXJjaDogcmVxdWlyZSgnLi9TZWFyY2gvQmluYXJ5U2VhcmNoJyksXG4gICAgICAgIEJpbmFyeVNvcnRlZFRyZWU6IHJlcXVpcmUoJy4vU2VhcmNoL0JpbmFyeVNvcnRlZFRyZWUnKS5kZWZhdWx0LFxuICAgICAgICBCUGx1c1RyZWU6IHJlcXVpcmUoJy4vU2VhcmNoL0JQbHVzVHJlZScpLFxuICAgICAgICBCVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvQlRyZWUnKSxcbiAgICAgICAgRGlnaXRhbFNlYXJjaFRyZWU6IHJlcXVpcmUoJy4vU2VhcmNoL0RpZ2l0YWxTZWFyY2hUcmVlJyksXG4gICAgICAgIFN1ZmZpeFRyZWU6IHJlcXVpcmUoJy4vU2VhcmNoL1N1ZmZpeFRyZWUuanMnKS5kZWZhdWx0LFxuICAgICAgICBmaWJvbmFjY2lTZWFyY2g6IHJlcXVpcmUoJy4vU2VhcmNoL2ZpYm9uYWNjaVNlYXJjaCcpLmRlZmF1bHQsXG4gICAgICAgIEhhc2hUYWJsZTogcmVxdWlyZSgnLi9TZWFyY2gvSGFzaFRhYmxlJyksXG4gICAgICAgIFJlZEJsYWNrVHJlZTogcmVxdWlyZSgnLi9TZWFyY2gvUmVkQmxhY2tUcmVlJykuZGVmYXVsdCxcbiAgICAgICAgc2VxdWVudGlhbFNlYXJjaDogcmVxdWlyZSgnLi9TZWFyY2gvc2VxdWVudGlhbFNlYXJjaCcpLmRlZmF1bHQsXG4gICAgICAgIFNPU1RyZWU6IHJlcXVpcmUoJy4vU2VhcmNoL1NPU1RyZWUnKSxcbiAgICAgICAgQmxvb21GaWx0ZXI6IHJlcXVpcmUoJy4vU2VhcmNoL0Jsb29tRmlsdGVyJylcbiAgICB9LFxuXG4gICAgU29ydDoge1xuICAgICAgICBkaXN0cmlidXRpb246IHJlcXVpcmUoJy4vU29ydC9kaXN0cmlidXRpb24vaW5kZXgnKSxcbiAgICAgICAgZXhjaGFuZ2U6IHJlcXVpcmUoJy4vU29ydC9leGNoYW5nZS9pbmRleCcpLFxuICAgICAgICBpbnNlcnRpb246IHJlcXVpcmUoJy4vU29ydC9pbnNlcnRpb24vaW5kZXgnKSxcbiAgICAgICAgbWVyZ2luZzogcmVxdWlyZSgnLi9Tb3J0L21lcmdpbmcvaW5kZXgnKSxcbiAgICAgICAgc2VsZWN0aW9uOiByZXF1aXJlKCcuL1NvcnQvc2VsZWN0aW9uL2luZGV4JylcbiAgICB9LFxuXG4gICAgU3RhY2s6IHJlcXVpcmUoJy4vU3RhY2svaW5kZXgnKS5kZWZhdWx0LFxuXG4gICAgU3RyaW5nOiB7XG4gICAgICAgIEhTdHJpbmc6IHJlcXVpcmUoJy4vU3RyaW5nL0hTdHJpbmcnKS5kZWZhdWx0LFxuICAgICAgICBMU3RyaW5nOiByZXF1aXJlKCcuL1N0cmluZy9MU3RyaW5nJykuZGVmYXVsdCxcbiAgICAgICAgU1N0cmluZzogcmVxdWlyZSgnLi9TdHJpbmcvU1N0cmluZycpLmRlZmF1bHRcbiAgICAgICAgLy8gdG9kbyBzdHJpbmcgYWxnb3JpdGhtc1xuICAgIH0sXG5cbiAgICBIZWFwOiByZXF1aXJlKCcuL0hlYXAnKS5kZWZhdWx0XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jhc2U2NC1qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIG1vZGVzID0gcmVxdWlyZSgnLi9tb2RlcycpXG52YXIgU3RyZWFtQ2lwaGVyID0gcmVxdWlyZSgnLi9zdHJlYW1DaXBoZXInKVxudmFyIEF1dGhDaXBoZXIgPSByZXF1aXJlKCcuL2F1dGhDaXBoZXInKVxudmFyIGVidGsgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG5cbmluaGVyaXRzKERlY2lwaGVyLCBUcmFuc2Zvcm0pXG5mdW5jdGlvbiBEZWNpcGhlciAobW9kZSwga2V5LCBpdikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVjaXBoZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBEZWNpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2NhY2hlID0gbmV3IFNwbGl0dGVyKClcbiAgdGhpcy5fbGFzdCA9IHZvaWQgMFxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBuZXcgQnVmZmVyKGl2Lmxlbmd0aClcbiAgaXYuY29weSh0aGlzLl9wcmV2KVxuICB0aGlzLl9tb2RlID0gbW9kZVxuICB0aGlzLl9hdXRvcGFkZGluZyA9IHRydWVcbn1cbkRlY2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5fY2FjaGUuYWRkKGRhdGEpXG4gIHZhciBjaHVua1xuICB2YXIgdGhpbmdcbiAgdmFyIG91dCA9IFtdXG4gIHdoaWxlICgoY2h1bmsgPSB0aGlzLl9jYWNoZS5nZXQodGhpcy5fYXV0b3BhZGRpbmcpKSkge1xuICAgIHRoaW5nID0gdGhpcy5fbW9kZS5kZWNyeXB0KHRoaXMsIGNodW5rKVxuICAgIG91dC5wdXNoKHRoaW5nKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cbkRlY2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaHVuayA9IHRoaXMuX2NhY2hlLmZsdXNoKClcbiAgaWYgKHRoaXMuX2F1dG9wYWRkaW5nKSB7XG4gICAgcmV0dXJuIHVucGFkKHRoaXMuX21vZGUuZGVjcnlwdCh0aGlzLCBjaHVuaykpXG4gIH0gZWxzZSBpZiAoY2h1bmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgbm90IG11bHRpcGxlIG9mIGJsb2NrIGxlbmd0aCcpXG4gIH1cbn1cbkRlY2lwaGVyLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uIChzZXRUbykge1xuICB0aGlzLl9hdXRvcGFkZGluZyA9ICEhc2V0VG9cbiAgcmV0dXJuIHRoaXNcbn1cbmZ1bmN0aW9uIFNwbGl0dGVyICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNwbGl0dGVyKSkge1xuICAgIHJldHVybiBuZXcgU3BsaXR0ZXIoKVxuICB9XG4gIHRoaXMuY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxufVxuU3BsaXR0ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBkYXRhXSlcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChhdXRvUGFkZGluZykge1xuICB2YXIgb3V0XG4gIGlmIChhdXRvUGFkZGluZykge1xuICAgIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+IDE2KSB7XG4gICAgICBvdXQgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgICByZXR1cm4gb3V0XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+PSAxNikge1xuICAgICAgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuU3BsaXR0ZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZVxuICB9XG59XG5mdW5jdGlvbiB1bnBhZCAobGFzdCkge1xuICB2YXIgcGFkZGVkID0gbGFzdFsxNV1cbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgcGFkZGVkKSB7XG4gICAgaWYgKGxhc3RbKGkgKyAoMTYgLSBwYWRkZWQpKV0gIT09IHBhZGRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gZGVjcnlwdCBkYXRhJylcbiAgICB9XG4gIH1cbiAgaWYgKHBhZGRlZCA9PT0gMTYpIHtcbiAgICByZXR1cm5cbiAgfVxuICByZXR1cm4gbGFzdC5zbGljZSgwLCAxNiAtIHBhZGRlZClcbn1cblxudmFyIG1vZGVsaXN0ID0ge1xuICBFQ0I6IHJlcXVpcmUoJy4vbW9kZXMvZWNiJyksXG4gIENCQzogcmVxdWlyZSgnLi9tb2Rlcy9jYmMnKSxcbiAgQ0ZCOiByZXF1aXJlKCcuL21vZGVzL2NmYicpLFxuICBDRkI4OiByZXF1aXJlKCcuL21vZGVzL2NmYjgnKSxcbiAgQ0ZCMTogcmVxdWlyZSgnLi9tb2Rlcy9jZmIxJyksXG4gIE9GQjogcmVxdWlyZSgnLi9tb2Rlcy9vZmInKSxcbiAgQ1RSOiByZXF1aXJlKCcuL21vZGVzL2N0cicpLFxuICBHQ006IHJlcXVpcmUoJy4vbW9kZXMvY3RyJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXJpdiAoc3VpdGUsIHBhc3N3b3JkLCBpdikge1xuICB2YXIgY29uZmlnID0gbW9kZXNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIGlmICh0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgaXYgPSBuZXcgQnVmZmVyKGl2KVxuICB9XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFzc3dvcmQgPSBuZXcgQnVmZmVyKHBhc3N3b3JkKVxuICB9XG4gIGlmIChwYXNzd29yZC5sZW5ndGggIT09IGNvbmZpZy5rZXkgLyA4KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgbGVuZ3RoICcgKyBwYXNzd29yZC5sZW5ndGgpXG4gIH1cbiAgaWYgKGl2Lmxlbmd0aCAhPT0gY29uZmlnLml2KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBpdiBsZW5ndGggJyArIGl2Lmxlbmd0aClcbiAgfVxuICBpZiAoY29uZmlnLnR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYsIHRydWUpXG4gIH0gZWxzZSBpZiAoY29uZmlnLnR5cGUgPT09ICdhdXRoJykge1xuICAgIHJldHVybiBuZXcgQXV0aENpcGhlcihtb2RlbGlzdFtjb25maWcubW9kZV0sIHBhc3N3b3JkLCBpdiwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gbmV3IERlY2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHZhciBjb25maWcgPSBtb2Rlc1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cbiAgdmFyIGtleXMgPSBlYnRrKHBhc3N3b3JkLCBmYWxzZSwgY29uZmlnLmtleSwgY29uZmlnLml2KVxuICByZXR1cm4gY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwga2V5cy5rZXksIGtleXMuaXYpXG59XG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyID0gY3JlYXRlRGVjaXBoZXJcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXJpdiA9IGNyZWF0ZURlY2lwaGVyaXZcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm93c2VyaWZ5LWFlcy9kZWNyeXB0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBtb2RlcyA9IHJlcXVpcmUoJy4vbW9kZXMnKVxudmFyIGVidGsgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG52YXIgU3RyZWFtQ2lwaGVyID0gcmVxdWlyZSgnLi9zdHJlYW1DaXBoZXInKVxudmFyIEF1dGhDaXBoZXIgPSByZXF1aXJlKCcuL2F1dGhDaXBoZXInKVxuaW5oZXJpdHMoQ2lwaGVyLCBUcmFuc2Zvcm0pXG5mdW5jdGlvbiBDaXBoZXIgKG1vZGUsIGtleSwgaXYpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENpcGhlcikpIHtcbiAgICByZXR1cm4gbmV3IENpcGhlcihtb2RlLCBrZXksIGl2KVxuICB9XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuX2NhY2hlID0gbmV3IFNwbGl0dGVyKClcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gbmV3IEJ1ZmZlcihpdi5sZW5ndGgpXG4gIGl2LmNvcHkodGhpcy5fcHJldilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSB0cnVlXG59XG5DaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9jYWNoZS5hZGQoZGF0YSlcbiAgdmFyIGNodW5rXG4gIHZhciB0aGluZ1xuICB2YXIgb3V0ID0gW11cbiAgd2hpbGUgKChjaHVuayA9IHRoaXMuX2NhY2hlLmdldCgpKSkge1xuICAgIHRoaW5nID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICAgIG91dC5wdXNoKHRoaW5nKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dClcbn1cbkNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2h1bmsgPSB0aGlzLl9jYWNoZS5mbHVzaCgpXG4gIGlmICh0aGlzLl9hdXRvcGFkZGluZykge1xuICAgIGNodW5rID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICAgIHRoaXMuX2NpcGhlci5zY3J1YigpXG4gICAgcmV0dXJuIGNodW5rXG4gIH0gZWxzZSBpZiAoY2h1bmsudG9TdHJpbmcoJ2hleCcpICE9PSAnMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAnKSB7XG4gICAgdGhpcy5fY2lwaGVyLnNjcnViKClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgbm90IG11bHRpcGxlIG9mIGJsb2NrIGxlbmd0aCcpXG4gIH1cbn1cbkNpcGhlci5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoc2V0VG8pIHtcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSAhIXNldFRvXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIFNwbGl0dGVyICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNwbGl0dGVyKSkge1xuICAgIHJldHVybiBuZXcgU3BsaXR0ZXIoKVxuICB9XG4gIHRoaXMuY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxufVxuU3BsaXR0ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBkYXRhXSlcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID4gMTUpIHtcbiAgICB2YXIgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICByZXR1cm4gb3V0XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblNwbGl0dGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbiA9IDE2IC0gdGhpcy5jYWNoZS5sZW5ndGhcbiAgdmFyIHBhZEJ1ZmYgPSBuZXcgQnVmZmVyKGxlbilcblxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBwYWRCdWZmLndyaXRlVUludDgobGVuLCBpKVxuICB9XG4gIHZhciBvdXQgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBwYWRCdWZmXSlcbiAgcmV0dXJuIG91dFxufVxudmFyIG1vZGVsaXN0ID0ge1xuICBFQ0I6IHJlcXVpcmUoJy4vbW9kZXMvZWNiJyksXG4gIENCQzogcmVxdWlyZSgnLi9tb2Rlcy9jYmMnKSxcbiAgQ0ZCOiByZXF1aXJlKCcuL21vZGVzL2NmYicpLFxuICBDRkI4OiByZXF1aXJlKCcuL21vZGVzL2NmYjgnKSxcbiAgQ0ZCMTogcmVxdWlyZSgnLi9tb2Rlcy9jZmIxJyksXG4gIE9GQjogcmVxdWlyZSgnLi9tb2Rlcy9vZmInKSxcbiAgQ1RSOiByZXF1aXJlKCcuL21vZGVzL2N0cicpLFxuICBHQ006IHJlcXVpcmUoJy4vbW9kZXMvY3RyJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyaXYgKHN1aXRlLCBwYXNzd29yZCwgaXYpIHtcbiAgdmFyIGNvbmZpZyA9IG1vZGVzW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuICBpZiAodHlwZW9mIGl2ID09PSAnc3RyaW5nJykge1xuICAgIGl2ID0gbmV3IEJ1ZmZlcihpdilcbiAgfVxuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJykge1xuICAgIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZClcbiAgfVxuICBpZiAocGFzc3dvcmQubGVuZ3RoICE9PSBjb25maWcua2V5IC8gOCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQga2V5IGxlbmd0aCAnICsgcGFzc3dvcmQubGVuZ3RoKVxuICB9XG4gIGlmIChpdi5sZW5ndGggIT09IGNvbmZpZy5pdikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaXYgbGVuZ3RoICcgKyBpdi5sZW5ndGgpXG4gIH1cbiAgaWYgKGNvbmZpZy50eXBlID09PSAnc3RyZWFtJykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKG1vZGVsaXN0W2NvbmZpZy5tb2RlXSwgcGFzc3dvcmQsIGl2KVxuICB9IGVsc2UgaWYgKGNvbmZpZy50eXBlID09PSAnYXV0aCcpIHtcbiAgICByZXR1cm4gbmV3IEF1dGhDaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYpXG4gIH1cbiAgcmV0dXJuIG5ldyBDaXBoZXIobW9kZWxpc3RbY29uZmlnLm1vZGVdLCBwYXNzd29yZCwgaXYpXG59XG5mdW5jdGlvbiBjcmVhdGVDaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIgY29uZmlnID0gbW9kZXNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGNvbmZpZy5rZXksIGNvbmZpZy5pdilcbiAgcmV0dXJuIGNyZWF0ZUNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cblxuZXhwb3J0cy5jcmVhdGVDaXBoZXJpdiA9IGNyZWF0ZUNpcGhlcml2XG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGNyZWF0ZUNpcGhlclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jyb3dzZXJpZnktYWVzL2VuY3J5cHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB6ZXJvcyA9IG5ldyBCdWZmZXIoMTYpXG56ZXJvcy5maWxsKDApXG5tb2R1bGUuZXhwb3J0cyA9IEdIQVNIXG5mdW5jdGlvbiBHSEFTSCAoa2V5KSB7XG4gIHRoaXMuaCA9IGtleVxuICB0aGlzLnN0YXRlID0gbmV3IEJ1ZmZlcigxNilcbiAgdGhpcy5zdGF0ZS5maWxsKDApXG4gIHRoaXMuY2FjaGUgPSBuZXcgQnVmZmVyKCcnKVxufVxuLy8gZnJvbSBodHRwOi8vYml0d2lzZXNoaWZ0bGVmdC5naXRodWIuaW8vc2pjbC9kb2Mvc3ltYm9scy9zcmMvY29yZV9nY20uanMuaHRtbFxuLy8gYnkgSnVobyBWw6Row6QtSGVydHR1YVxuR0hBU0gucHJvdG90eXBlLmdoYXNoID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGJsb2NrLmxlbmd0aCkge1xuICAgIHRoaXMuc3RhdGVbaV0gXj0gYmxvY2tbaV1cbiAgfVxuICB0aGlzLl9tdWx0aXBseSgpXG59XG5cbkdIQVNILnByb3RvdHlwZS5fbXVsdGlwbHkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBWaSA9IHRvQXJyYXkodGhpcy5oKVxuICB2YXIgWmkgPSBbMCwgMCwgMCwgMF1cbiAgdmFyIGosIHhpLCBsc2JfVmlcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgMTI4KSB7XG4gICAgeGkgPSAodGhpcy5zdGF0ZVt+fihpIC8gOCldICYgKDEgPDwgKDcgLSBpICUgOCkpKSAhPT0gMFxuICAgIGlmICh4aSkge1xuICAgICAgLy8gWl9pKzEgPSBaX2kgXiBWX2lcbiAgICAgIFppID0geG9yKFppLCBWaSlcbiAgICB9XG5cbiAgICAvLyBTdG9yZSB0aGUgdmFsdWUgb2YgTFNCKFZfaSlcbiAgICBsc2JfVmkgPSAoVmlbM10gJiAxKSAhPT0gMFxuXG4gICAgLy8gVl9pKzEgPSBWX2kgPj4gMVxuICAgIGZvciAoaiA9IDM7IGogPiAwOyBqLS0pIHtcbiAgICAgIFZpW2pdID0gKFZpW2pdID4+PiAxKSB8ICgoVmlbaiAtIDFdICYgMSkgPDwgMzEpXG4gICAgfVxuICAgIFZpWzBdID0gVmlbMF0gPj4+IDFcblxuICAgIC8vIElmIExTQihWX2kpIGlzIDEsIFZfaSsxID0gKFZfaSA+PiAxKSBeIFJcbiAgICBpZiAobHNiX1ZpKSB7XG4gICAgICBWaVswXSA9IFZpWzBdIF4gKDB4ZTEgPDwgMjQpXG4gICAgfVxuICB9XG4gIHRoaXMuc3RhdGUgPSBmcm9tQXJyYXkoWmkpXG59XG5HSEFTSC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgYnVmXSlcbiAgdmFyIGNodW5rXG4gIHdoaWxlICh0aGlzLmNhY2hlLmxlbmd0aCA+PSAxNikge1xuICAgIGNodW5rID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICB0aGlzLmdoYXNoKGNodW5rKVxuICB9XG59XG5HSEFTSC5wcm90b3R5cGUuZmluYWwgPSBmdW5jdGlvbiAoYWJsLCBibCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGgpIHtcbiAgICB0aGlzLmdoYXNoKEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIHplcm9zXSwgMTYpKVxuICB9XG4gIHRoaXMuZ2hhc2goZnJvbUFycmF5KFtcbiAgICAwLCBhYmwsXG4gICAgMCwgYmxcbiAgXSkpXG4gIHJldHVybiB0aGlzLnN0YXRlXG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkgKGJ1Zikge1xuICByZXR1cm4gW1xuICAgIGJ1Zi5yZWFkVUludDMyQkUoMCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSg0KSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDgpLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoMTIpXG4gIF1cbn1cbmZ1bmN0aW9uIGZyb21BcnJheSAob3V0KSB7XG4gIG91dCA9IG91dC5tYXAoZml4dXBfdWludDMyKVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcigxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMV0sIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzNdLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxudmFyIHVpbnRfbWF4ID0gTWF0aC5wb3coMiwgMzIpXG5mdW5jdGlvbiBmaXh1cF91aW50MzIgKHgpIHtcbiAgdmFyIHJldCwgeF9wb3NcbiAgcmV0ID0geCA+IHVpbnRfbWF4IHx8IHggPCAwID8gKHhfcG9zID0gTWF0aC5hYnMoeCkgJSB1aW50X21heCwgeCA8IDAgPyB1aW50X21heCAtIHhfcG9zIDogeF9wb3MpIDogeFxuICByZXR1cm4gcmV0XG59XG5mdW5jdGlvbiB4b3IgKGEsIGIpIHtcbiAgcmV0dXJuIFtcbiAgICBhWzBdIF4gYlswXSxcbiAgICBhWzFdIF4gYlsxXSxcbiAgICBhWzJdIF4gYlsyXSxcbiAgICBhWzNdIF4gYlszXVxuICBdXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1hZXMvZ2hhc2guanNcbi8vIG1vZHVsZSBpZCA9IDE2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZWJ0ayA9IHJlcXVpcmUoJ2V2cF9ieXRlc3Rva2V5JylcbnZhciBhZXMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcy9icm93c2VyJylcbnZhciBERVMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWRlcycpXG52YXIgZGVzTW9kZXMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWRlcy9tb2RlcycpXG52YXIgYWVzTW9kZXMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcy9tb2RlcycpXG5mdW5jdGlvbiBjcmVhdGVDaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICB2YXIga2V5TGVuLCBpdkxlblxuICBzdWl0ZSA9IHN1aXRlLnRvTG93ZXJDYXNlKClcbiAgaWYgKGFlc01vZGVzW3N1aXRlXSkge1xuICAgIGtleUxlbiA9IGFlc01vZGVzW3N1aXRlXS5rZXlcbiAgICBpdkxlbiA9IGFlc01vZGVzW3N1aXRlXS5pdlxuICB9IGVsc2UgaWYgKGRlc01vZGVzW3N1aXRlXSkge1xuICAgIGtleUxlbiA9IGRlc01vZGVzW3N1aXRlXS5rZXkgKiA4XG4gICAgaXZMZW4gPSBkZXNNb2Rlc1tzdWl0ZV0uaXZcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGtleUxlbiwgaXZMZW4pXG4gIHJldHVybiBjcmVhdGVDaXBoZXJpdihzdWl0ZSwga2V5cy5rZXksIGtleXMuaXYpXG59XG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHZhciBrZXlMZW4sIGl2TGVuXG4gIHN1aXRlID0gc3VpdGUudG9Mb3dlckNhc2UoKVxuICBpZiAoYWVzTW9kZXNbc3VpdGVdKSB7XG4gICAga2V5TGVuID0gYWVzTW9kZXNbc3VpdGVdLmtleVxuICAgIGl2TGVuID0gYWVzTW9kZXNbc3VpdGVdLml2XG4gIH0gZWxzZSBpZiAoZGVzTW9kZXNbc3VpdGVdKSB7XG4gICAga2V5TGVuID0gZGVzTW9kZXNbc3VpdGVdLmtleSAqIDhcbiAgICBpdkxlbiA9IGRlc01vZGVzW3N1aXRlXS5pdlxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cbiAgdmFyIGtleXMgPSBlYnRrKHBhc3N3b3JkLCBmYWxzZSwga2V5TGVuLCBpdkxlbilcbiAgcmV0dXJuIGNyZWF0ZURlY2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDaXBoZXJpdiAoc3VpdGUsIGtleSwgaXYpIHtcbiAgc3VpdGUgPSBzdWl0ZS50b0xvd2VyQ2FzZSgpXG4gIGlmIChhZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICByZXR1cm4gYWVzLmNyZWF0ZUNpcGhlcml2KHN1aXRlLCBrZXksIGl2KVxuICB9IGVsc2UgaWYgKGRlc01vZGVzW3N1aXRlXSkge1xuICAgIHJldHVybiBuZXcgREVTKHtcbiAgICAgIGtleToga2V5LFxuICAgICAgaXY6IGl2LFxuICAgICAgbW9kZTogc3VpdGVcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZURlY2lwaGVyaXYgKHN1aXRlLCBrZXksIGl2KSB7XG4gIHN1aXRlID0gc3VpdGUudG9Mb3dlckNhc2UoKVxuICBpZiAoYWVzTW9kZXNbc3VpdGVdKSB7XG4gICAgcmV0dXJuIGFlcy5jcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBrZXksIGl2KVxuICB9IGVsc2UgaWYgKGRlc01vZGVzW3N1aXRlXSkge1xuICAgIHJldHVybiBuZXcgREVTKHtcbiAgICAgIGtleToga2V5LFxuICAgICAgaXY6IGl2LFxuICAgICAgbW9kZTogc3VpdGUsXG4gICAgICBkZWNyeXB0OiB0cnVlXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG59XG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGV4cG9ydHMuQ2lwaGVyID0gY3JlYXRlQ2lwaGVyXG5leHBvcnRzLmNyZWF0ZUNpcGhlcml2ID0gZXhwb3J0cy5DaXBoZXJpdiA9IGNyZWF0ZUNpcGhlcml2XG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyID0gZXhwb3J0cy5EZWNpcGhlciA9IGNyZWF0ZURlY2lwaGVyXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBleHBvcnRzLkRlY2lwaGVyaXYgPSBjcmVhdGVEZWNpcGhlcml2XG5mdW5jdGlvbiBnZXRDaXBoZXJzICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGRlc01vZGVzKS5jb25jYXQoYWVzLmdldENpcGhlcnMoKSlcbn1cbmV4cG9ydHMubGlzdENpcGhlcnMgPSBleHBvcnRzLmdldENpcGhlcnMgPSBnZXRDaXBoZXJzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1jaXBoZXIvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBDaXBoZXJCYXNlID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGRlcyA9IHJlcXVpcmUoJ2Rlcy5qcycpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbnZhciBtb2RlcyA9IHtcbiAgJ2Rlcy1lZGUzLWNiYyc6IGRlcy5DQkMuaW5zdGFudGlhdGUoZGVzLkVERSksXG4gICdkZXMtZWRlMyc6IGRlcy5FREUsXG4gICdkZXMtZWRlLWNiYyc6IGRlcy5DQkMuaW5zdGFudGlhdGUoZGVzLkVERSksXG4gICdkZXMtZWRlJzogZGVzLkVERSxcbiAgJ2Rlcy1jYmMnOiBkZXMuQ0JDLmluc3RhbnRpYXRlKGRlcy5ERVMpLFxuICAnZGVzLWVjYic6IGRlcy5ERVNcbn1cbm1vZGVzLmRlcyA9IG1vZGVzWydkZXMtY2JjJ11cbm1vZGVzLmRlczMgPSBtb2Rlc1snZGVzLWVkZTMtY2JjJ11cbm1vZHVsZS5leHBvcnRzID0gREVTXG5pbmhlcml0cyhERVMsIENpcGhlckJhc2UpXG5mdW5jdGlvbiBERVMgKG9wdHMpIHtcbiAgQ2lwaGVyQmFzZS5jYWxsKHRoaXMpXG4gIHZhciBtb2RlTmFtZSA9IG9wdHMubW9kZS50b0xvd2VyQ2FzZSgpXG4gIHZhciBtb2RlID0gbW9kZXNbbW9kZU5hbWVdXG4gIHZhciB0eXBlXG4gIGlmIChvcHRzLmRlY3J5cHQpIHtcbiAgICB0eXBlID0gJ2RlY3J5cHQnXG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9ICdlbmNyeXB0J1xuICB9XG4gIHZhciBrZXkgPSBvcHRzLmtleVxuICBpZiAobW9kZU5hbWUgPT09ICdkZXMtZWRlJyB8fCBtb2RlTmFtZSA9PT0gJ2Rlcy1lZGUtY2JjJykge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwga2V5LnNsaWNlKDAsIDgpXSlcbiAgfVxuICB2YXIgaXYgPSBvcHRzLml2XG4gIHRoaXMuX2RlcyA9IG1vZGUuY3JlYXRlKHtcbiAgICBrZXk6IGtleSxcbiAgICBpdjogaXYsXG4gICAgdHlwZTogdHlwZVxuICB9KVxufVxuREVTLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy5fZGVzLnVwZGF0ZShkYXRhKSlcbn1cbkRFUy5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IEJ1ZmZlcih0aGlzLl9kZXMuZmluYWwoKSlcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm93c2VyaWZ5LWRlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHNbJ2Rlcy1lY2InXSA9IHtcbiAga2V5OiA4LFxuICBpdjogMFxufVxuZXhwb3J0c1snZGVzLWNiYyddID0gZXhwb3J0cy5kZXMgPSB7XG4gIGtleTogOCxcbiAgaXY6IDhcbn1cbmV4cG9ydHNbJ2Rlcy1lZGUzLWNiYyddID0gZXhwb3J0cy5kZXMzID0ge1xuICBrZXk6IDI0LFxuICBpdjogOFxufVxuZXhwb3J0c1snZGVzLWVkZTMnXSA9IHtcbiAga2V5OiAyNCxcbiAgaXY6IDBcbn1cbmV4cG9ydHNbJ2Rlcy1lZGUtY2JjJ10gPSB7XG4gIGtleTogMTYsXG4gIGl2OiA4XG59XG5leHBvcnRzWydkZXMtZWRlJ10gPSB7XG4gIGtleTogMTYsXG4gIGl2OiAwXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1kZXMvbW9kZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci9hbGdvcml0aG1zLmpzb24nKVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jyb3dzZXJpZnktc2lnbi9hbGdvcy5qc1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vc2lnbicpXG52YXIgdmVyaWZ5ID0gcmVxdWlyZSgnLi92ZXJpZnknKVxuXG52YXIgYWxnb3JpdGhtcyA9IHJlcXVpcmUoJy4vYWxnb3JpdGhtcy5qc29uJylcbk9iamVjdC5rZXlzKGFsZ29yaXRobXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBhbGdvcml0aG1zW2tleV0uaWQgPSBuZXcgQnVmZmVyKGFsZ29yaXRobXNba2V5XS5pZCwgJ2hleCcpXG4gIGFsZ29yaXRobXNba2V5LnRvTG93ZXJDYXNlKCldID0gYWxnb3JpdGhtc1trZXldXG59KVxuXG5mdW5jdGlvbiBTaWduIChhbGdvcml0aG0pIHtcbiAgc3RyZWFtLldyaXRhYmxlLmNhbGwodGhpcylcblxuICB2YXIgZGF0YSA9IGFsZ29yaXRobXNbYWxnb3JpdGhtXVxuICBpZiAoIWRhdGEpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIGRpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaFR5cGUgPSBkYXRhLmhhc2hcbiAgdGhpcy5faGFzaCA9IGNyZWF0ZUhhc2goZGF0YS5oYXNoKVxuICB0aGlzLl90YWcgPSBkYXRhLmlkXG4gIHRoaXMuX3NpZ25UeXBlID0gZGF0YS5zaWduXG59XG5pbmhlcml0cyhTaWduLCBzdHJlYW0uV3JpdGFibGUpXG5cblNpZ24ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIF93cml0ZSAoZGF0YSwgXywgZG9uZSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuICBkb25lKClcbn1cblxuU2lnbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuXG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG4gIHJldHVybiB0aGlzXG59XG5cblNpZ24ucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduTWV0aG9kIChrZXksIGVuYykge1xuICB0aGlzLmVuZCgpXG4gIHZhciBoYXNoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuICB2YXIgc2lnID0gc2lnbihoYXNoLCBrZXksIHRoaXMuX2hhc2hUeXBlLCB0aGlzLl9zaWduVHlwZSwgdGhpcy5fdGFnKVxuXG4gIHJldHVybiBlbmMgPyBzaWcudG9TdHJpbmcoZW5jKSA6IHNpZ1xufVxuXG5mdW5jdGlvbiBWZXJpZnkgKGFsZ29yaXRobSkge1xuICBzdHJlYW0uV3JpdGFibGUuY2FsbCh0aGlzKVxuXG4gIHZhciBkYXRhID0gYWxnb3JpdGhtc1thbGdvcml0aG1dXG4gIGlmICghZGF0YSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1lc3NhZ2UgZGlnZXN0JylcblxuICB0aGlzLl9oYXNoID0gY3JlYXRlSGFzaChkYXRhLmhhc2gpXG4gIHRoaXMuX3RhZyA9IGRhdGEuaWRcbiAgdGhpcy5fc2lnblR5cGUgPSBkYXRhLnNpZ25cbn1cbmluaGVyaXRzKFZlcmlmeSwgc3RyZWFtLldyaXRhYmxlKVxuXG5WZXJpZnkucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIF93cml0ZSAoZGF0YSwgXywgZG9uZSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuICBkb25lKClcbn1cblxuVmVyaWZ5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG5cbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuVmVyaWZ5LnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnlNZXRob2QgKGtleSwgc2lnLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBzaWcgPT09ICdzdHJpbmcnKSBzaWcgPSBuZXcgQnVmZmVyKHNpZywgZW5jKVxuXG4gIHRoaXMuZW5kKClcbiAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoLmRpZ2VzdCgpXG4gIHJldHVybiB2ZXJpZnkoc2lnLCBoYXNoLCBrZXksIHRoaXMuX3NpZ25UeXBlLCB0aGlzLl90YWcpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNpZ24gKGFsZ29yaXRobSkge1xuICByZXR1cm4gbmV3IFNpZ24oYWxnb3JpdGhtKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVWZXJpZnkgKGFsZ29yaXRobSkge1xuICByZXR1cm4gbmV3IFZlcmlmeShhbGdvcml0aG0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTaWduOiBjcmVhdGVTaWduLFxuICBWZXJpZnk6IGNyZWF0ZVZlcmlmeSxcbiAgY3JlYXRlU2lnbjogY3JlYXRlU2lnbixcbiAgY3JlYXRlVmVyaWZ5OiBjcmVhdGVWZXJpZnlcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIG11Y2ggb2YgdGhpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9zZWxmLXNpZ25lZC9ibG9iL2doLXBhZ2VzL2xpYi9yc2EuanNcbnZhciBjcmVhdGVIbWFjID0gcmVxdWlyZSgnY3JlYXRlLWhtYWMnKVxudmFyIGNydCA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktcnNhJylcbnZhciBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWNcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcbnZhciBwYXJzZUtleXMgPSByZXF1aXJlKCdwYXJzZS1hc24xJylcbnZhciBjdXJ2ZXMgPSByZXF1aXJlKCcuL2N1cnZlcy5qc29uJylcblxuZnVuY3Rpb24gc2lnbiAoaGFzaCwga2V5LCBoYXNoVHlwZSwgc2lnblR5cGUsIHRhZykge1xuICB2YXIgcHJpdiA9IHBhcnNlS2V5cyhrZXkpXG4gIGlmIChwcml2LmN1cnZlKSB7XG4gICAgLy8gcnNhIGtleXMgY2FuIGJlIGludGVycHJldGVkIGFzIGVjZHNhIG9uZXMgaW4gb3BlbnNzbFxuICAgIGlmIChzaWduVHlwZSAhPT0gJ2VjZHNhJyAmJiBzaWduVHlwZSAhPT0gJ2VjZHNhL3JzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHJpdmF0ZSBrZXkgdHlwZScpXG4gICAgcmV0dXJuIGVjU2lnbihoYXNoLCBwcml2KVxuICB9IGVsc2UgaWYgKHByaXYudHlwZSA9PT0gJ2RzYScpIHtcbiAgICBpZiAoc2lnblR5cGUgIT09ICdkc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHByaXZhdGUga2V5IHR5cGUnKVxuICAgIHJldHVybiBkc2FTaWduKGhhc2gsIHByaXYsIGhhc2hUeXBlKVxuICB9IGVsc2Uge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ3JzYScgJiYgc2lnblR5cGUgIT09ICdlY2RzYS9yc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHByaXZhdGUga2V5IHR5cGUnKVxuICB9XG4gIGhhc2ggPSBCdWZmZXIuY29uY2F0KFt0YWcsIGhhc2hdKVxuICB2YXIgbGVuID0gcHJpdi5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICB2YXIgcGFkID0gWyAwLCAxIF1cbiAgd2hpbGUgKGhhc2gubGVuZ3RoICsgcGFkLmxlbmd0aCArIDEgPCBsZW4pIHBhZC5wdXNoKDB4ZmYpXG4gIHBhZC5wdXNoKDB4MDApXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGhhc2gubGVuZ3RoKSBwYWQucHVzaChoYXNoW2ldKVxuXG4gIHZhciBvdXQgPSBjcnQocGFkLCBwcml2KVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGVjU2lnbiAoaGFzaCwgcHJpdikge1xuICB2YXIgY3VydmVJZCA9IGN1cnZlc1twcml2LmN1cnZlLmpvaW4oJy4nKV1cbiAgaWYgKCFjdXJ2ZUlkKSB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY3VydmUgJyArIHByaXYuY3VydmUuam9pbignLicpKVxuXG4gIHZhciBjdXJ2ZSA9IG5ldyBFQyhjdXJ2ZUlkKVxuICB2YXIga2V5ID0gY3VydmUua2V5RnJvbVByaXZhdGUocHJpdi5wcml2YXRlS2V5KVxuICB2YXIgb3V0ID0ga2V5LnNpZ24oaGFzaClcblxuICByZXR1cm4gbmV3IEJ1ZmZlcihvdXQudG9ERVIoKSlcbn1cblxuZnVuY3Rpb24gZHNhU2lnbiAoaGFzaCwgcHJpdiwgYWxnbykge1xuICB2YXIgeCA9IHByaXYucGFyYW1zLnByaXZfa2V5XG4gIHZhciBwID0gcHJpdi5wYXJhbXMucFxuICB2YXIgcSA9IHByaXYucGFyYW1zLnFcbiAgdmFyIGcgPSBwcml2LnBhcmFtcy5nXG4gIHZhciByID0gbmV3IEJOKDApXG4gIHZhciBrXG4gIHZhciBIID0gYml0czJpbnQoaGFzaCwgcSkubW9kKHEpXG4gIHZhciBzID0gZmFsc2VcbiAgdmFyIGt2ID0gZ2V0S2V5KHgsIHEsIGhhc2gsIGFsZ28pXG4gIHdoaWxlIChzID09PSBmYWxzZSkge1xuICAgIGsgPSBtYWtlS2V5KHEsIGt2LCBhbGdvKVxuICAgIHIgPSBtYWtlUihnLCBrLCBwLCBxKVxuICAgIHMgPSBrLmludm0ocSkuaW11bChILmFkZCh4Lm11bChyKSkpLm1vZChxKVxuICAgIGlmIChzLmNtcG4oMCkgPT09IDApIHtcbiAgICAgIHMgPSBmYWxzZVxuICAgICAgciA9IG5ldyBCTigwKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG9ERVIociwgcylcbn1cblxuZnVuY3Rpb24gdG9ERVIgKHIsIHMpIHtcbiAgciA9IHIudG9BcnJheSgpXG4gIHMgPSBzLnRvQXJyYXkoKVxuXG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHJbMF0gJiAweDgwKSByID0gWyAwIF0uY29uY2F0KHIpXG4gIGlmIChzWzBdICYgMHg4MCkgcyA9IFsgMCBdLmNvbmNhdChzKVxuXG4gIHZhciB0b3RhbCA9IHIubGVuZ3RoICsgcy5sZW5ndGggKyA0XG4gIHZhciByZXMgPSBbIDB4MzAsIHRvdGFsLCAweDAyLCByLmxlbmd0aCBdXG4gIHJlcyA9IHJlcy5jb25jYXQociwgWyAweDAyLCBzLmxlbmd0aCBdLCBzKVxuICByZXR1cm4gbmV3IEJ1ZmZlcihyZXMpXG59XG5cbmZ1bmN0aW9uIGdldEtleSAoeCwgcSwgaGFzaCwgYWxnbykge1xuICB4ID0gbmV3IEJ1ZmZlcih4LnRvQXJyYXkoKSlcbiAgaWYgKHgubGVuZ3RoIDwgcS5ieXRlTGVuZ3RoKCkpIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQnVmZmVyKHEuYnl0ZUxlbmd0aCgpIC0geC5sZW5ndGgpXG4gICAgemVyb3MuZmlsbCgwKVxuICAgIHggPSBCdWZmZXIuY29uY2F0KFsgemVyb3MsIHggXSlcbiAgfVxuICB2YXIgaGxlbiA9IGhhc2gubGVuZ3RoXG4gIHZhciBoYml0cyA9IGJpdHMyb2N0ZXRzKGhhc2gsIHEpXG4gIHZhciB2ID0gbmV3IEJ1ZmZlcihobGVuKVxuICB2LmZpbGwoMSlcbiAgdmFyIGsgPSBuZXcgQnVmZmVyKGhsZW4pXG4gIGsuZmlsbCgwKVxuICBrID0gY3JlYXRlSG1hYyhhbGdvLCBrKS51cGRhdGUodikudXBkYXRlKG5ldyBCdWZmZXIoWyAwIF0pKS51cGRhdGUoeCkudXBkYXRlKGhiaXRzKS5kaWdlc3QoKVxuICB2ID0gY3JlYXRlSG1hYyhhbGdvLCBrKS51cGRhdGUodikuZGlnZXN0KClcbiAgayA9IGNyZWF0ZUhtYWMoYWxnbywgaykudXBkYXRlKHYpLnVwZGF0ZShuZXcgQnVmZmVyKFsgMSBdKSkudXBkYXRlKHgpLnVwZGF0ZShoYml0cykuZGlnZXN0KClcbiAgdiA9IGNyZWF0ZUhtYWMoYWxnbywgaykudXBkYXRlKHYpLmRpZ2VzdCgpXG4gIHJldHVybiB7IGs6IGssIHY6IHYgfVxufVxuXG5mdW5jdGlvbiBiaXRzMmludCAob2JpdHMsIHEpIHtcbiAgdmFyIGJpdHMgPSBuZXcgQk4ob2JpdHMpXG4gIHZhciBzaGlmdCA9IChvYml0cy5sZW5ndGggPDwgMykgLSBxLmJpdExlbmd0aCgpXG4gIGlmIChzaGlmdCA+IDApIGJpdHMuaXNocm4oc2hpZnQpXG4gIHJldHVybiBiaXRzXG59XG5cbmZ1bmN0aW9uIGJpdHMyb2N0ZXRzIChiaXRzLCBxKSB7XG4gIGJpdHMgPSBiaXRzMmludChiaXRzLCBxKVxuICBiaXRzID0gYml0cy5tb2QocSlcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoYml0cy50b0FycmF5KCkpXG4gIGlmIChvdXQubGVuZ3RoIDwgcS5ieXRlTGVuZ3RoKCkpIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQnVmZmVyKHEuYnl0ZUxlbmd0aCgpIC0gb3V0Lmxlbmd0aClcbiAgICB6ZXJvcy5maWxsKDApXG4gICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbIHplcm9zLCBvdXQgXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIG1ha2VLZXkgKHEsIGt2LCBhbGdvKSB7XG4gIHZhciB0XG4gIHZhciBrXG5cbiAgZG8ge1xuICAgIHQgPSBuZXcgQnVmZmVyKDApXG5cbiAgICB3aGlsZSAodC5sZW5ndGggKiA4IDwgcS5iaXRMZW5ndGgoKSkge1xuICAgICAga3YudiA9IGNyZWF0ZUhtYWMoYWxnbywga3YuaykudXBkYXRlKGt2LnYpLmRpZ2VzdCgpXG4gICAgICB0ID0gQnVmZmVyLmNvbmNhdChbIHQsIGt2LnYgXSlcbiAgICB9XG5cbiAgICBrID0gYml0czJpbnQodCwgcSlcbiAgICBrdi5rID0gY3JlYXRlSG1hYyhhbGdvLCBrdi5rKS51cGRhdGUoa3YudikudXBkYXRlKG5ldyBCdWZmZXIoWyAwIF0pKS5kaWdlc3QoKVxuICAgIGt2LnYgPSBjcmVhdGVIbWFjKGFsZ28sIGt2LmspLnVwZGF0ZShrdi52KS5kaWdlc3QoKVxuICB9IHdoaWxlIChrLmNtcChxKSAhPT0gLTEpXG5cbiAgcmV0dXJuIGtcbn1cblxuZnVuY3Rpb24gbWFrZVIgKGcsIGssIHAsIHEpIHtcbiAgcmV0dXJuIGcudG9SZWQoQk4ubW9udChwKSkucmVkUG93KGspLmZyb21SZWQoKS5tb2QocSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaWduXG5tb2R1bGUuZXhwb3J0cy5nZXRLZXkgPSBnZXRLZXlcbm1vZHVsZS5leHBvcnRzLm1ha2VLZXkgPSBtYWtlS2V5XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1zaWduL2Jyb3dzZXIvc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIG11Y2ggb2YgdGhpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9zZWxmLXNpZ25lZC9ibG9iL2doLXBhZ2VzL2xpYi9yc2EuanNcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcbnZhciBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWNcbnZhciBwYXJzZUtleXMgPSByZXF1aXJlKCdwYXJzZS1hc24xJylcbnZhciBjdXJ2ZXMgPSByZXF1aXJlKCcuL2N1cnZlcy5qc29uJylcblxuZnVuY3Rpb24gdmVyaWZ5IChzaWcsIGhhc2gsIGtleSwgc2lnblR5cGUsIHRhZykge1xuICB2YXIgcHViID0gcGFyc2VLZXlzKGtleSlcbiAgaWYgKHB1Yi50eXBlID09PSAnZWMnKSB7XG4gICAgLy8gcnNhIGtleXMgY2FuIGJlIGludGVycHJldGVkIGFzIGVjZHNhIG9uZXMgaW4gb3BlbnNzbFxuICAgIGlmIChzaWduVHlwZSAhPT0gJ2VjZHNhJyAmJiBzaWduVHlwZSAhPT0gJ2VjZHNhL3JzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHVibGljIGtleSB0eXBlJylcbiAgICByZXR1cm4gZWNWZXJpZnkoc2lnLCBoYXNoLCBwdWIpXG4gIH0gZWxzZSBpZiAocHViLnR5cGUgPT09ICdkc2EnKSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAnZHNhJykgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwdWJsaWMga2V5IHR5cGUnKVxuICAgIHJldHVybiBkc2FWZXJpZnkoc2lnLCBoYXNoLCBwdWIpXG4gIH0gZWxzZSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAncnNhJyAmJiBzaWduVHlwZSAhPT0gJ2VjZHNhL3JzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHVibGljIGtleSB0eXBlJylcbiAgfVxuICBoYXNoID0gQnVmZmVyLmNvbmNhdChbdGFnLCBoYXNoXSlcbiAgdmFyIGxlbiA9IHB1Yi5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICB2YXIgcGFkID0gWyAxIF1cbiAgdmFyIHBhZE51bSA9IDBcbiAgd2hpbGUgKGhhc2gubGVuZ3RoICsgcGFkLmxlbmd0aCArIDIgPCBsZW4pIHtcbiAgICBwYWQucHVzaCgweGZmKVxuICAgIHBhZE51bSsrXG4gIH1cbiAgcGFkLnB1c2goMHgwMClcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgaGFzaC5sZW5ndGgpIHtcbiAgICBwYWQucHVzaChoYXNoW2ldKVxuICB9XG4gIHBhZCA9IG5ldyBCdWZmZXIocGFkKVxuICB2YXIgcmVkID0gQk4ubW9udChwdWIubW9kdWx1cylcbiAgc2lnID0gbmV3IEJOKHNpZykudG9SZWQocmVkKVxuXG4gIHNpZyA9IHNpZy5yZWRQb3cobmV3IEJOKHB1Yi5wdWJsaWNFeHBvbmVudCkpXG4gIHNpZyA9IG5ldyBCdWZmZXIoc2lnLmZyb21SZWQoKS50b0FycmF5KCkpXG4gIHZhciBvdXQgPSBwYWROdW0gPCA4ID8gMSA6IDBcbiAgbGVuID0gTWF0aC5taW4oc2lnLmxlbmd0aCwgcGFkLmxlbmd0aClcbiAgaWYgKHNpZy5sZW5ndGggIT09IHBhZC5sZW5ndGgpIG91dCA9IDFcblxuICBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikgb3V0IHw9IHNpZ1tpXSBeIHBhZFtpXVxuICByZXR1cm4gb3V0ID09PSAwXG59XG5cbmZ1bmN0aW9uIGVjVmVyaWZ5IChzaWcsIGhhc2gsIHB1Yikge1xuICB2YXIgY3VydmVJZCA9IGN1cnZlc1twdWIuZGF0YS5hbGdvcml0aG0uY3VydmUuam9pbignLicpXVxuICBpZiAoIWN1cnZlSWQpIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjdXJ2ZSAnICsgcHViLmRhdGEuYWxnb3JpdGhtLmN1cnZlLmpvaW4oJy4nKSlcblxuICB2YXIgY3VydmUgPSBuZXcgRUMoY3VydmVJZClcbiAgdmFyIHB1YmtleSA9IHB1Yi5kYXRhLnN1YmplY3RQcml2YXRlS2V5LmRhdGFcblxuICByZXR1cm4gY3VydmUudmVyaWZ5KGhhc2gsIHNpZywgcHVia2V5KVxufVxuXG5mdW5jdGlvbiBkc2FWZXJpZnkgKHNpZywgaGFzaCwgcHViKSB7XG4gIHZhciBwID0gcHViLmRhdGEucFxuICB2YXIgcSA9IHB1Yi5kYXRhLnFcbiAgdmFyIGcgPSBwdWIuZGF0YS5nXG4gIHZhciB5ID0gcHViLmRhdGEucHViX2tleVxuICB2YXIgdW5wYWNrZWQgPSBwYXJzZUtleXMuc2lnbmF0dXJlLmRlY29kZShzaWcsICdkZXInKVxuICB2YXIgcyA9IHVucGFja2VkLnNcbiAgdmFyIHIgPSB1bnBhY2tlZC5yXG4gIGNoZWNrVmFsdWUocywgcSlcbiAgY2hlY2tWYWx1ZShyLCBxKVxuICB2YXIgbW9udHAgPSBCTi5tb250KHApXG4gIHZhciB3ID0gcy5pbnZtKHEpXG4gIHZhciB2ID0gZy50b1JlZChtb250cClcbiAgICAucmVkUG93KG5ldyBCTihoYXNoKS5tdWwodykubW9kKHEpKVxuICAgIC5mcm9tUmVkKClcbiAgICAubXVsKHkudG9SZWQobW9udHApLnJlZFBvdyhyLm11bCh3KS5tb2QocSkpLmZyb21SZWQoKSlcbiAgICAubW9kKHApXG4gICAgLm1vZChxKVxuICByZXR1cm4gdi5jbXAocikgPT09IDBcbn1cblxuZnVuY3Rpb24gY2hlY2tWYWx1ZSAoYiwgcSkge1xuICBpZiAoYi5jbXBuKDApIDw9IDApIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWcnKVxuICBpZiAoYi5jbXAocSkgPj0gcSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmVyaWZ5XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3NlcmlmeS1zaWduL2Jyb3dzZXIvdmVyaWZ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCl7XG4gIHJldHVybiAkT2JqZWN0LmNyZWF0ZShQLCBEKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKXtcbiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3ltYm9sO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fd2tzLWV4dCcpLmYoJ2l0ZXJhdG9yJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgdG9JbmRleCAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoJHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuICAgICAgLCB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHJlc3VsdCAgICAgPSBnZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gcElFLmZcbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzXG4vLyBtb2R1bGUgaWQgPSAxODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanNcbi8vIG1vZHVsZSBpZCA9IDE4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qc1xuLy8gbW9kdWxlIGlkID0gMTg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNRVRBICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHNldERlc2MgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGlkICAgICAgID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogICAgICBNRVRBLFxuICBORUVEOiAgICAgZmFsc2UsXG4gIGZhc3RLZXk6ICBmYXN0S2V5LFxuICBnZXRXZWFrOiAgZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qc1xuLy8gbW9kdWxlIGlkID0gMTg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkUCAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpe1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgICA9IGdldEtleXMoUHJvcGVydGllcylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpID0gMFxuICAgICwgUDtcbiAgd2hpbGUobGVuZ3RoID4gaSlkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4vLyBtb2R1bGUgaWQgPSAxODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUE4gICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXG4gICwgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihPKXtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanNcbi8vIG1vZHVsZSBpZCA9IDE5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanNcbi8vIG1vZHVsZSBpZCA9IDE5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qc1xuLy8gbW9kdWxlIGlkID0gMTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtYXggICAgICAgPSBNYXRoLm1heFxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKVxuICAsIHN0ZXAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIEl0ZXJhdG9ycyAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGtpbmQgID0gdGhpcy5fa1xuICAgICwgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldH0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDIwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIE1FVEEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgd2tzRGVmaW5lICAgICAgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2tleW9mJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgX2NyZWF0ZSAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBnT1BORXh0ICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpXG4gICwgJEdPUEQgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJERQICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRrZXlzICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxuICAsIGRQICAgICAgICAgICAgID0gJERQLmZcbiAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcbiAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIVVTRV9OQVRJVkUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKXNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDIwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMjA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDIwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdsb2JhbCAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBJdGVyYXRvcnMgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbmZvcih2YXIgY29sbGVjdGlvbnMgPSBbJ05vZGVMaXN0JywgJ0RPTVRva2VuTGlzdCcsICdNZWRpYUxpc3QnLCAnU3R5bGVTaGVldExpc3QnLCAnQ1NTUnVsZUxpc3QnXSwgaSA9IDA7IGkgPCA1OyBpKyspe1xuICB2YXIgTkFNRSAgICAgICA9IGNvbGxlY3Rpb25zW2ldXG4gICAgLCBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdXG4gICAgLCBwcm90byAgICAgID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKWhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDIwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZWxsaXB0aWMgPSByZXF1aXJlKCdlbGxpcHRpYycpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFQ0RIKGN1cnZlKSB7XG5cdHJldHVybiBuZXcgRUNESChjdXJ2ZSk7XG59O1xuXG52YXIgYWxpYXNlcyA9IHtcblx0c2VjcDI1NmsxOiB7XG5cdFx0bmFtZTogJ3NlY3AyNTZrMScsXG5cdFx0Ynl0ZUxlbmd0aDogMzJcblx0fSxcblx0c2VjcDIyNHIxOiB7XG5cdFx0bmFtZTogJ3AyMjQnLFxuXHRcdGJ5dGVMZW5ndGg6IDI4XG5cdH0sXG5cdHByaW1lMjU2djE6IHtcblx0XHRuYW1lOiAncDI1NicsXG5cdFx0Ynl0ZUxlbmd0aDogMzJcblx0fSxcblx0cHJpbWUxOTJ2MToge1xuXHRcdG5hbWU6ICdwMTkyJyxcblx0XHRieXRlTGVuZ3RoOiAyNFxuXHR9LFxuXHRlZDI1NTE5OiB7XG5cdFx0bmFtZTogJ2VkMjU1MTknLFxuXHRcdGJ5dGVMZW5ndGg6IDMyXG5cdH0sXG5cdHNlY3AzODRyMToge1xuXHRcdG5hbWU6ICdwMzg0Jyxcblx0XHRieXRlTGVuZ3RoOiA0OFxuXHR9LFxuXHRzZWNwNTIxcjE6IHtcblx0XHRuYW1lOiAncDUyMScsXG5cdFx0Ynl0ZUxlbmd0aDogNjZcblx0fVxufTtcblxuYWxpYXNlcy5wMjI0ID0gYWxpYXNlcy5zZWNwMjI0cjE7XG5hbGlhc2VzLnAyNTYgPSBhbGlhc2VzLnNlY3AyNTZyMSA9IGFsaWFzZXMucHJpbWUyNTZ2MTtcbmFsaWFzZXMucDE5MiA9IGFsaWFzZXMuc2VjcDE5MnIxID0gYWxpYXNlcy5wcmltZTE5MnYxO1xuYWxpYXNlcy5wMzg0ID0gYWxpYXNlcy5zZWNwMzg0cjE7XG5hbGlhc2VzLnA1MjEgPSBhbGlhc2VzLnNlY3A1MjFyMTtcblxuZnVuY3Rpb24gRUNESChjdXJ2ZSkge1xuXHR0aGlzLmN1cnZlVHlwZSA9IGFsaWFzZXNbY3VydmVdO1xuXHRpZiAoIXRoaXMuY3VydmVUeXBlICkge1xuXHRcdHRoaXMuY3VydmVUeXBlID0ge1xuXHRcdFx0bmFtZTogY3VydmVcblx0XHR9O1xuXHR9XG5cdHRoaXMuY3VydmUgPSBuZXcgZWxsaXB0aWMuZWModGhpcy5jdXJ2ZVR5cGUubmFtZSk7XG5cdHRoaXMua2V5cyA9IHZvaWQgMDtcbn1cblxuRUNESC5wcm90b3R5cGUuZ2VuZXJhdGVLZXlzID0gZnVuY3Rpb24gKGVuYywgZm9ybWF0KSB7XG5cdHRoaXMua2V5cyA9IHRoaXMuY3VydmUuZ2VuS2V5UGFpcigpO1xuXHRyZXR1cm4gdGhpcy5nZXRQdWJsaWNLZXkoZW5jLCBmb3JtYXQpO1xufTtcblxuRUNESC5wcm90b3R5cGUuY29tcHV0ZVNlY3JldCA9IGZ1bmN0aW9uIChvdGhlciwgaW5lbmMsIGVuYykge1xuXHRpbmVuYyA9IGluZW5jIHx8ICd1dGY4Jztcblx0aWYgKCFCdWZmZXIuaXNCdWZmZXIob3RoZXIpKSB7XG5cdFx0b3RoZXIgPSBuZXcgQnVmZmVyKG90aGVyLCBpbmVuYyk7XG5cdH1cblx0dmFyIG90aGVyUHViID0gdGhpcy5jdXJ2ZS5rZXlGcm9tUHVibGljKG90aGVyKS5nZXRQdWJsaWMoKTtcblx0dmFyIG91dCA9IG90aGVyUHViLm11bCh0aGlzLmtleXMuZ2V0UHJpdmF0ZSgpKS5nZXRYKCk7XG5cdHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZShvdXQsIGVuYywgdGhpcy5jdXJ2ZVR5cGUuYnl0ZUxlbmd0aCk7XG59O1xuXG5FQ0RILnByb3RvdHlwZS5nZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAoZW5jLCBmb3JtYXQpIHtcblx0dmFyIGtleSA9IHRoaXMua2V5cy5nZXRQdWJsaWMoZm9ybWF0ID09PSAnY29tcHJlc3NlZCcsIHRydWUpO1xuXHRpZiAoZm9ybWF0ID09PSAnaHlicmlkJykge1xuXHRcdGlmIChrZXlba2V5Lmxlbmd0aCAtIDFdICUgMikge1xuXHRcdFx0a2V5WzBdID0gNztcblx0XHR9IGVsc2Uge1xuXHRcdFx0a2V5IFswXSA9IDY7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZShrZXksIGVuYyk7XG59O1xuXG5FQ0RILnByb3RvdHlwZS5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKGVuYykge1xuXHRyZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5rZXlzLmdldFByaXZhdGUoKSwgZW5jKTtcbn07XG5cbkVDREgucHJvdG90eXBlLnNldFB1YmxpY0tleSA9IGZ1bmN0aW9uIChwdWIsIGVuYykge1xuXHRlbmMgPSBlbmMgfHwgJ3V0ZjgnO1xuXHRpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwdWIpKSB7XG5cdFx0cHViID0gbmV3IEJ1ZmZlcihwdWIsIGVuYyk7XG5cdH1cblx0dGhpcy5rZXlzLl9pbXBvcnRQdWJsaWMocHViKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5FQ0RILnByb3RvdHlwZS5zZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKHByaXYsIGVuYykge1xuXHRlbmMgPSBlbmMgfHwgJ3V0ZjgnO1xuXHRpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwcml2KSkge1xuXHRcdHByaXYgPSBuZXcgQnVmZmVyKHByaXYsIGVuYyk7XG5cdH1cblx0dmFyIF9wcml2ID0gbmV3IEJOKHByaXYpO1xuXHRfcHJpdiA9IF9wcml2LnRvU3RyaW5nKDE2KTtcblx0dGhpcy5rZXlzLl9pbXBvcnRQcml2YXRlKF9wcml2KTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRSZXR1cm5WYWx1ZShibiwgZW5jLCBsZW4pIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGJuKSkge1xuXHRcdGJuID0gYm4udG9BcnJheSgpO1xuXHR9XG5cdHZhciBidWYgPSBuZXcgQnVmZmVyKGJuKTtcblx0aWYgKGxlbiAmJiBidWYubGVuZ3RoIDwgbGVuKSB7XG5cdFx0dmFyIHplcm9zID0gbmV3IEJ1ZmZlcihsZW4gLSBidWYubGVuZ3RoKTtcblx0XHR6ZXJvcy5maWxsKDApO1xuXHRcdGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3plcm9zLCBidWZdKTtcblx0fVxuXHRpZiAoIWVuYykge1xuXHRcdHJldHVybiBidWY7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGJ1Zi50b1N0cmluZyhlbmMpO1xuXHR9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3JlYXRlLWVjZGgvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMjA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBpbnRTaXplID0gNDtcbnZhciB6ZXJvQnVmZmVyID0gbmV3IEJ1ZmZlcihpbnRTaXplKTsgemVyb0J1ZmZlci5maWxsKDApO1xudmFyIGNocnN6ID0gODtcblxuZnVuY3Rpb24gdG9BcnJheShidWYsIGJpZ0VuZGlhbikge1xuICBpZiAoKGJ1Zi5sZW5ndGggJSBpbnRTaXplKSAhPT0gMCkge1xuICAgIHZhciBsZW4gPSBidWYubGVuZ3RoICsgKGludFNpemUgLSAoYnVmLmxlbmd0aCAlIGludFNpemUpKTtcbiAgICBidWYgPSBCdWZmZXIuY29uY2F0KFtidWYsIHplcm9CdWZmZXJdLCBsZW4pO1xuICB9XG5cbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgZm4gPSBiaWdFbmRpYW4gPyBidWYucmVhZEludDMyQkUgOiBidWYucmVhZEludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSBpbnRTaXplKSB7XG4gICAgYXJyLnB1c2goZm4uY2FsbChidWYsIGkpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiB0b0J1ZmZlcihhcnIsIHNpemUsIGJpZ0VuZGlhbikge1xuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgdmFyIGZuID0gYmlnRW5kaWFuID8gYnVmLndyaXRlSW50MzJCRSA6IGJ1Zi53cml0ZUludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4uY2FsbChidWYsIGFycltpXSwgaSAqIDQsIHRydWUpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5cbmZ1bmN0aW9uIGhhc2goYnVmLCBmbiwgaGFzaFNpemUsIGJpZ0VuZGlhbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBuZXcgQnVmZmVyKGJ1Zik7XG4gIHZhciBhcnIgPSBmbih0b0FycmF5KGJ1ZiwgYmlnRW5kaWFuKSwgYnVmLmxlbmd0aCAqIGNocnN6KTtcbiAgcmV0dXJuIHRvQnVmZmVyKGFyciwgaGFzaFNpemUsIGJpZ0VuZGlhbik7XG59XG5leHBvcnRzLmhhc2ggPSBoYXNoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jcmVhdGUtaGFzaC9oZWxwZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLnJuZyA9IGV4cG9ydHMucHNldWRvUmFuZG9tQnl0ZXMgPSBleHBvcnRzLnBybmcgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpXG5leHBvcnRzLmNyZWF0ZUhhc2ggPSBleHBvcnRzLkhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG5leHBvcnRzLmNyZWF0ZUhtYWMgPSBleHBvcnRzLkhtYWMgPSByZXF1aXJlKCdjcmVhdGUtaG1hYycpXG5cbnZhciBoYXNoZXMgPSBbJ3NoYTEnLCAnc2hhMjI0JywgJ3NoYTI1NicsICdzaGEzODQnLCAnc2hhNTEyJywgJ21kNScsICdybWQxNjAnXS5jb25jYXQoT2JqZWN0LmtleXMocmVxdWlyZSgnYnJvd3NlcmlmeS1zaWduL2FsZ29zJykpKVxuZXhwb3J0cy5nZXRIYXNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBoYXNoZXNcbn1cblxudmFyIHAgPSByZXF1aXJlKCdwYmtkZjInKVxuZXhwb3J0cy5wYmtkZjIgPSBwLnBia2RmMlxuZXhwb3J0cy5wYmtkZjJTeW5jID0gcC5wYmtkZjJTeW5jXG5cbnZhciBhZXMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWNpcGhlcicpXG47W1xuICAnQ2lwaGVyJyxcbiAgJ2NyZWF0ZUNpcGhlcicsXG4gICdDaXBoZXJpdicsXG4gICdjcmVhdGVDaXBoZXJpdicsXG4gICdEZWNpcGhlcicsXG4gICdjcmVhdGVEZWNpcGhlcicsXG4gICdEZWNpcGhlcml2JyxcbiAgJ2NyZWF0ZURlY2lwaGVyaXYnLFxuICAnZ2V0Q2lwaGVycycsXG4gICdsaXN0Q2lwaGVycydcbl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGV4cG9ydHNba2V5XSA9IGFlc1trZXldXG59KVxuXG52YXIgZGggPSByZXF1aXJlKCdkaWZmaWUtaGVsbG1hbicpXG47W1xuICAnRGlmZmllSGVsbG1hbkdyb3VwJyxcbiAgJ2NyZWF0ZURpZmZpZUhlbGxtYW5Hcm91cCcsXG4gICdnZXREaWZmaWVIZWxsbWFuJyxcbiAgJ2NyZWF0ZURpZmZpZUhlbGxtYW4nLFxuICAnRGlmZmllSGVsbG1hbidcbl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGV4cG9ydHNba2V5XSA9IGRoW2tleV1cbn0pXG5cbnZhciBzaWduID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1zaWduJylcbjtbXG4gICdjcmVhdGVTaWduJyxcbiAgJ1NpZ24nLFxuICAnY3JlYXRlVmVyaWZ5JyxcbiAgJ1ZlcmlmeSdcbl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGV4cG9ydHNba2V5XSA9IHNpZ25ba2V5XVxufSlcblxuZXhwb3J0cy5jcmVhdGVFQ0RIID0gcmVxdWlyZSgnY3JlYXRlLWVjZGgnKVxuXG52YXIgcHVibGljRW5jcnlwdCA9IHJlcXVpcmUoJ3B1YmxpYy1lbmNyeXB0JylcblxuO1tcbiAgJ3B1YmxpY0VuY3J5cHQnLFxuICAncHJpdmF0ZUVuY3J5cHQnLFxuICAncHVibGljRGVjcnlwdCcsXG4gICdwcml2YXRlRGVjcnlwdCdcbl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGV4cG9ydHNba2V5XSA9IHB1YmxpY0VuY3J5cHRba2V5XVxufSlcblxuLy8gdGhlIGxlYXN0IEkgY2FuIGRvIGlzIG1ha2UgZXJyb3IgbWVzc2FnZXMgZm9yIHRoZSByZXN0IG9mIHRoZSBub2RlLmpzL2NyeXB0byBhcGkuXG47W1xuICAnY3JlYXRlQ3JlZGVudGlhbHMnXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgZXhwb3J0c1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgICAgJ3NvcnJ5LCAnICsgbmFtZSArICcgaXMgbm90IGltcGxlbWVudGVkIHlldCcsXG4gICAgICAnd2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMnLFxuICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG8tYnJvd3NlcmlmeS9jcnlwdG8tYnJvd3NlcmlmeSdcbiAgICBdLmpvaW4oJ1xcbicpKVxuICB9XG59KVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NyeXB0by1icm93c2VyaWZ5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5cdEMtbGlrZSB1bnNpZ25lZCAzMiBiaXRzIGludGVnZXJzIGluIEphdmFzY3JpcHRcblx0Q29weXJpZ2h0IChDKSAyMDEzLCBQaWVycmUgQ3VydG9cblx0TUlUIGxpY2Vuc2VcbiAqL1xuOyhmdW5jdGlvbiAocm9vdCkge1xuXG5cdC8vIExvY2FsIGNhY2hlIGZvciB0eXBpY2FsIHJhZGljZXNcblx0dmFyIHJhZGl4UG93ZXJDYWNoZSA9IHtcblx0XHQzNjogVUlOVDMyKCBNYXRoLnBvdygzNiwgNSkgKVxuXHQsXHQxNjogVUlOVDMyKCBNYXRoLnBvdygxNiwgNykgKVxuXHQsXHQxMDogVUlOVDMyKCBNYXRoLnBvdygxMCwgOSkgKVxuXHQsXHQyOiAgVUlOVDMyKCBNYXRoLnBvdygyLCAzMCkgKVxuXHR9XG5cdHZhciByYWRpeENhY2hlID0ge1xuXHRcdDM2OiBVSU5UMzIoMzYpXG5cdCxcdDE2OiBVSU5UMzIoMTYpXG5cdCxcdDEwOiBVSU5UMzIoMTApXG5cdCxcdDI6ICBVSU5UMzIoMilcblx0fVxuXG5cdC8qKlxuXHQgKlx0UmVwcmVzZW50cyBhbiB1bnNpZ25lZCAzMiBiaXRzIGludGVnZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xOdW1iZXJ9IGxvdyBiaXRzICAgICB8IGludGVnZXIgYXMgYSBzdHJpbmcgXHRcdCB8IGludGVnZXIgYXMgYSBudW1iZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ8TnVtYmVyfFVuZGVmaW5lZH0gaGlnaCBiaXRzIHwgcmFkaXggKG9wdGlvbmFsLCBkZWZhdWx0PTEwKVxuXHQgKiBAcmV0dXJuIFxuXHQgKi9cblx0ZnVuY3Rpb24gVUlOVDMyIChsLCBoKSB7XG5cdFx0aWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBVSU5UMzIpIClcblx0XHRcdHJldHVybiBuZXcgVUlOVDMyKGwsIGgpXG5cblx0XHR0aGlzLl9sb3cgPSAwXG5cdFx0dGhpcy5faGlnaCA9IDBcblx0XHR0aGlzLnJlbWFpbmRlciA9IG51bGxcblx0XHRpZiAodHlwZW9mIGggPT0gJ3VuZGVmaW5lZCcpXG5cdFx0XHRyZXR1cm4gZnJvbU51bWJlci5jYWxsKHRoaXMsIGwpXG5cblx0XHRpZiAodHlwZW9mIGwgPT0gJ3N0cmluZycpXG5cdFx0XHRyZXR1cm4gZnJvbVN0cmluZy5jYWxsKHRoaXMsIGwsIGgpXG5cblx0XHRmcm9tQml0cy5jYWxsKHRoaXMsIGwsIGgpXG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSBjdXJyZW50IF9VSU5UMzJfIG9iamVjdCB3aXRoIGl0cyBsb3cgYW5kIGhpZ2ggYml0c1xuXHQgKiBAbWV0aG9kIGZyb21CaXRzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsb3cgYml0c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaGlnaCBiaXRzXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGZyb21CaXRzIChsLCBoKSB7XG5cdFx0dGhpcy5fbG93ID0gbCB8IDBcblx0XHR0aGlzLl9oaWdoID0gaCB8IDBcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDMyLnByb3RvdHlwZS5mcm9tQml0cyA9IGZyb21CaXRzXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDMyXyBvYmplY3QgZnJvbSBhIG51bWJlclxuXHQgKiBAbWV0aG9kIGZyb21OdW1iZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlclxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBmcm9tTnVtYmVyICh2YWx1ZSkge1xuXHRcdHRoaXMuX2xvdyA9IHZhbHVlICYgMHhGRkZGXG5cdFx0dGhpcy5faGlnaCA9IHZhbHVlID4+PiAxNlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRVSU5UMzIucHJvdG90eXBlLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDMyXyBvYmplY3QgZnJvbSBhIHN0cmluZ1xuXHQgKiBAbWV0aG9kIGZyb21TdHJpbmdcblx0ICogQHBhcmFtIHtTdHJpbmd9IGludGVnZXIgYXMgYSBzdHJpbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gZnJvbVN0cmluZyAocywgcmFkaXgpIHtcblx0XHR2YXIgdmFsdWUgPSBwYXJzZUludChzLCByYWRpeCB8fCAxMClcblxuXHRcdHRoaXMuX2xvdyA9IHZhbHVlICYgMHhGRkZGXG5cdFx0dGhpcy5faGlnaCA9IHZhbHVlID4+PiAxNlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRVSU5UMzIucHJvdG90eXBlLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nXG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhpcyBfVUlOVDMyXyB0byBhIG51bWJlclxuXHQgKiBAbWV0aG9kIHRvTnVtYmVyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gdGhlIGNvbnZlcnRlZCBVSU5UMzJcblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9oaWdoICogNjU1MzYpICsgdGhpcy5fbG93XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydCB0aGlzIF9VSU5UMzJfIHRvIGEgc3RyaW5nXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiB7U3RyaW5nfSB0aGUgY29udmVydGVkIFVJTlQzMlxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChyYWRpeCkge1xuXHRcdHJldHVybiB0aGlzLnRvTnVtYmVyKCkudG9TdHJpbmcocmFkaXggfHwgMTApXG5cdH1cblxuXHQvKipcblx0ICogQWRkIHR3byBfVUlOVDMyXy4gVGhlIGN1cnJlbnQgX1VJTlQzMl8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBhZGRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHZhciBhMDAgPSB0aGlzLl9sb3cgKyBvdGhlci5fbG93XG5cdFx0dmFyIGExNiA9IGEwMCA+Pj4gMTZcblxuXHRcdGExNiArPSB0aGlzLl9oaWdoICsgb3RoZXIuX2hpZ2hcblxuXHRcdHRoaXMuX2xvdyA9IGEwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSBhMTYgJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogU3VidHJhY3QgdHdvIF9VSU5UMzJfLiBUaGUgY3VycmVudCBfVUlOVDMyXyBzdG9yZXMgdGhlIHJlc3VsdFxuXHQgKiBAbWV0aG9kIHN1YnRyYWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdC8vVE9ETyBpbmxpbmVcblx0XHRyZXR1cm4gdGhpcy5hZGQoIG90aGVyLmNsb25lKCkubmVnYXRlKCkgKVxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGx5IHR3byBfVUlOVDMyXy4gVGhlIGN1cnJlbnQgX1VJTlQzMl8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBtdWx0aXBseVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHQvKlxuXHRcdFx0YSA9IGEwMCArIGExNlxuXHRcdFx0YiA9IGIwMCArIGIxNlxuXHRcdFx0YSpiID0gKGEwMCArIGExNikoYjAwICsgYjE2KVxuXHRcdFx0XHQ9IGEwMGIwMCArIGEwMGIxNiArIGExNmIwMCArIGExNmIxNlxuXG5cdFx0XHRhMTZiMTYgb3ZlcmZsb3dzIHRoZSAzMmJpdHNcblx0XHQgKi9cblx0XHR2YXIgYTE2ID0gdGhpcy5faGlnaFxuXHRcdHZhciBhMDAgPSB0aGlzLl9sb3dcblx0XHR2YXIgYjE2ID0gb3RoZXIuX2hpZ2hcblx0XHR2YXIgYjAwID0gb3RoZXIuX2xvd1xuXG4vKiBSZW1vdmVkIHRvIGluY3JlYXNlIHNwZWVkIHVuZGVyIG5vcm1hbCBjaXJjdW1zdGFuY2VzIChpLmUuIG5vdCBtdWx0aXBseWluZyBieSAwIG9yIDEpXG5cdFx0Ly8gdGhpcyA9PSAwIG9yIG90aGVyID09IDE6IG5vdGhpbmcgdG8gZG9cblx0XHRpZiAoKGEwMCA9PSAwICYmIGExNiA9PSAwKSB8fCAoYjAwID09IDEgJiYgYjE2ID09IDApKSByZXR1cm4gdGhpc1xuXG5cdFx0Ly8gb3RoZXIgPT0gMCBvciB0aGlzID09IDE6IHRoaXMgPSBvdGhlclxuXHRcdGlmICgoYjAwID09IDAgJiYgYjE2ID09IDApIHx8IChhMDAgPT0gMSAmJiBhMTYgPT0gMCkpIHtcblx0XHRcdHRoaXMuX2xvdyA9IG90aGVyLl9sb3dcblx0XHRcdHRoaXMuX2hpZ2ggPSBvdGhlci5faGlnaFxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG4qL1xuXG5cdFx0dmFyIGMxNiwgYzAwXG5cdFx0YzAwID0gYTAwICogYjAwXG5cdFx0YzE2ID0gYzAwID4+PiAxNlxuXG5cdFx0YzE2ICs9IGExNiAqIGIwMFxuXHRcdGMxNiAmPSAweEZGRkZcdFx0Ly8gTm90IHJlcXVpcmVkIGJ1dCBpbXByb3ZlcyBwZXJmb3JtYW5jZVxuXHRcdGMxNiArPSBhMDAgKiBiMTZcblxuXHRcdHRoaXMuX2xvdyA9IGMwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSBjMTYgJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogRGl2aWRlIHR3byBfVUlOVDMyXy4gVGhlIGN1cnJlbnQgX1VJTlQzMl8gc3RvcmVzIHRoZSByZXN1bHQuXG5cdCAqIFRoZSByZW1haW5kZXIgaXMgbWFkZSBhdmFpbGFibGUgYXMgdGhlIF9yZW1haW5kZXJfIHByb3BlcnR5IG9uXG5cdCAqIHRoZSBfVUlOVDMyXyBvYmplY3QuIEl0IGNhbiBiZSBudWxsLCBtZWFuaW5nIHRoZXJlIGFyZSBubyByZW1haW5kZXIuXG5cdCAqIEBtZXRob2QgZGl2XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAoIChvdGhlci5fbG93ID09IDApICYmIChvdGhlci5faGlnaCA9PSAwKSApIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJylcblxuXHRcdC8vIG90aGVyID09IDFcblx0XHRpZiAob3RoZXIuX2hpZ2ggPT0gMCAmJiBvdGhlci5fbG93ID09IDEpIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gbmV3IFVJTlQzMigwKVxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cblx0XHQvLyBvdGhlciA+IHRoaXM6IDBcblx0XHRpZiAoIG90aGVyLmd0KHRoaXMpICkge1xuXHRcdFx0dGhpcy5yZW1haW5kZXIgPSB0aGlzLmNsb25lKClcblx0XHRcdHRoaXMuX2xvdyA9IDBcblx0XHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblx0XHQvLyBvdGhlciA9PSB0aGlzOiAxXG5cdFx0aWYgKCB0aGlzLmVxKG90aGVyKSApIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gbmV3IFVJTlQzMigwKVxuXHRcdFx0dGhpcy5fbG93ID0gMVxuXHRcdFx0dGhpcy5faGlnaCA9IDBcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0Ly8gU2hpZnQgdGhlIGRpdmlzb3IgbGVmdCB1bnRpbCBpdCBpcyBoaWdoZXIgdGhhbiB0aGUgZGl2aWRlbmRcblx0XHR2YXIgX290aGVyID0gb3RoZXIuY2xvbmUoKVxuXHRcdHZhciBpID0gLTFcblx0XHR3aGlsZSAoICF0aGlzLmx0KF9vdGhlcikgKSB7XG5cdFx0XHQvLyBIaWdoIGJpdCBjYW4gb3ZlcmZsb3cgdGhlIGRlZmF1bHQgMTZiaXRzXG5cdFx0XHQvLyBJdHMgb2sgc2luY2Ugd2UgcmlnaHQgc2hpZnQgYWZ0ZXIgdGhpcyBsb29wXG5cdFx0XHQvLyBUaGUgb3ZlcmZsb3duIGJpdCBtdXN0IGJlIGtlcHQgdGhvdWdoXG5cdFx0XHRfb3RoZXIuc2hpZnRMZWZ0KDEsIHRydWUpXG5cdFx0XHRpKytcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIHJlbWFpbmRlclxuXHRcdHRoaXMucmVtYWluZGVyID0gdGhpcy5jbG9uZSgpXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgY3VycmVudCByZXN1bHQgdG8gMFxuXHRcdHRoaXMuX2xvdyA9IDBcblx0XHR0aGlzLl9oaWdoID0gMFxuXHRcdGZvciAoOyBpID49IDA7IGktLSkge1xuXHRcdFx0X290aGVyLnNoaWZ0UmlnaHQoMSlcblx0XHRcdC8vIElmIHNoaWZ0ZWQgZGl2aXNvciBpcyBzbWFsbGVyIHRoYW4gdGhlIGRpdmlkZW5kXG5cdFx0XHQvLyB0aGVuIHN1YnRyYWN0IGl0IGZyb20gdGhlIGRpdmlkZW5kXG5cdFx0XHRpZiAoICF0aGlzLnJlbWFpbmRlci5sdChfb3RoZXIpICkge1xuXHRcdFx0XHR0aGlzLnJlbWFpbmRlci5zdWJ0cmFjdChfb3RoZXIpXG5cdFx0XHRcdC8vIFVwZGF0ZSB0aGUgY3VycmVudCByZXN1bHRcblx0XHRcdFx0aWYgKGkgPj0gMTYpIHtcblx0XHRcdFx0XHR0aGlzLl9oaWdoIHw9IDEgPDwgKGkgLSAxNilcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9sb3cgfD0gMSA8PCBpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIE5lZ2F0ZSB0aGUgY3VycmVudCBfVUlOVDMyX1xuXHQgKiBAbWV0aG9kIG5lZ2F0ZVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdiA9ICggfnRoaXMuX2xvdyAmIDB4RkZGRiApICsgMVxuXHRcdHRoaXMuX2xvdyA9IHYgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gKH50aGlzLl9oaWdoICsgKHYgPj4+IDE2KSkgJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogRXF1YWxzXG5cdCAqIEBtZXRob2QgZXFcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5lcXVhbHMgPSBVSU5UMzIucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9sb3cgPT0gb3RoZXIuX2xvdykgJiYgKHRoaXMuX2hpZ2ggPT0gb3RoZXIuX2hpZ2gpXG5cdH1cblxuXHQvKipcblx0ICogR3JlYXRlciB0aGFuIChzdHJpY3QpXG5cdCAqIEBtZXRob2QgZ3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5ncmVhdGVyVGhhbiA9IFVJTlQzMi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAodGhpcy5faGlnaCA+IG90aGVyLl9oaWdoKSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9oaWdoIDwgb3RoZXIuX2hpZ2gpIHJldHVybiBmYWxzZVxuXHRcdHJldHVybiB0aGlzLl9sb3cgPiBvdGhlci5fbG93XG5cdH1cblxuXHQvKipcblx0ICogTGVzcyB0aGFuIChzdHJpY3QpXG5cdCAqIEBtZXRob2QgbHRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5sZXNzVGhhbiA9IFVJTlQzMi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAodGhpcy5faGlnaCA8IG90aGVyLl9oaWdoKSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9oaWdoID4gb3RoZXIuX2hpZ2gpIHJldHVybiBmYWxzZVxuXHRcdHJldHVybiB0aGlzLl9sb3cgPCBvdGhlci5fbG93XG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBPUlxuXHQgKiBAbWV0aG9kIG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2xvdyB8PSBvdGhlci5fbG93XG5cdFx0dGhpcy5faGlnaCB8PSBvdGhlci5faGlnaFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIEFORFxuXHQgKiBAbWV0aG9kIGFuZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dGhpcy5fbG93ICY9IG90aGVyLl9sb3dcblx0XHR0aGlzLl9oaWdoICY9IG90aGVyLl9oaWdoXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgTk9UXG5cdCAqIEBtZXRob2Qgbm90XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fbG93ID0gfnRoaXMuX2xvdyAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSB+dGhpcy5faGlnaCAmIDB4RkZGRlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIFhPUlxuXHQgKiBAbWV0aG9kIHhvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dGhpcy5fbG93IF49IG90aGVyLl9sb3dcblx0XHR0aGlzLl9oaWdoIF49IG90aGVyLl9oaWdoXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugc2hpZnQgcmlnaHRcblx0ICogQG1ldGhvZCBzaGlmdFJpZ2h0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byBzaGlmdFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBVSU5UMzIucHJvdG90eXBlLnNoaWZ0ciA9IGZ1bmN0aW9uIChuKSB7XG5cdFx0aWYgKG4gPiAxNikge1xuXHRcdFx0dGhpcy5fbG93ID0gdGhpcy5faGlnaCA+PiAobiAtIDE2KVxuXHRcdFx0dGhpcy5faGlnaCA9IDBcblx0XHR9IGVsc2UgaWYgKG4gPT0gMTYpIHtcblx0XHRcdHRoaXMuX2xvdyA9IHRoaXMuX2hpZ2hcblx0XHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2xvdyA9ICh0aGlzLl9sb3cgPj4gbikgfCAoICh0aGlzLl9oaWdoIDw8ICgxNi1uKSkgJiAweEZGRkYgKVxuXHRcdFx0dGhpcy5faGlnaCA+Pj0gblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBzaGlmdCBsZWZ0XG5cdCAqIEBtZXRob2Qgc2hpZnRMZWZ0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byBzaGlmdFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93IG92ZXJmbG93XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gVUlOVDMyLnByb3RvdHlwZS5zaGlmdGwgPSBmdW5jdGlvbiAobiwgYWxsb3dPdmVyZmxvdykge1xuXHRcdGlmIChuID4gMTYpIHtcblx0XHRcdHRoaXMuX2hpZ2ggPSB0aGlzLl9sb3cgPDwgKG4gLSAxNilcblx0XHRcdHRoaXMuX2xvdyA9IDBcblx0XHRcdGlmICghYWxsb3dPdmVyZmxvdykge1xuXHRcdFx0XHR0aGlzLl9oaWdoICY9IDB4RkZGRlxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobiA9PSAxNikge1xuXHRcdFx0dGhpcy5faGlnaCA9IHRoaXMuX2xvd1xuXHRcdFx0dGhpcy5fbG93ID0gMFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9oaWdoID0gKHRoaXMuX2hpZ2ggPDwgbikgfCAodGhpcy5fbG93ID4+ICgxNi1uKSlcblx0XHRcdHRoaXMuX2xvdyA9ICh0aGlzLl9sb3cgPDwgbikgJiAweEZGRkZcblx0XHRcdGlmICghYWxsb3dPdmVyZmxvdykge1xuXHRcdFx0XHQvLyBPdmVyZmxvdyBvbmx5IGFsbG93ZWQgb24gdGhlIGhpZ2ggYml0cy4uLlxuXHRcdFx0XHR0aGlzLl9oaWdoICY9IDB4RkZGRlxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSByb3RhdGUgbGVmdFxuXHQgKiBAbWV0aG9kIHJvdGxcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBvZiBiaXRzIHRvIHJvdGF0ZVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBVSU5UMzIucHJvdG90eXBlLnJvdGwgPSBmdW5jdGlvbiAobikge1xuXHRcdHZhciB2ID0gKHRoaXMuX2hpZ2ggPDwgMTYpIHwgdGhpcy5fbG93XG5cdFx0diA9ICh2IDw8IG4pIHwgKHYgPj4+ICgzMiAtIG4pKVxuXHRcdHRoaXMuX2xvdyA9IHYgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gdiA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSByb3RhdGUgcmlnaHRcblx0ICogQG1ldGhvZCByb3RyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byByb3RhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5yb3RhdGVSaWdodCA9IFVJTlQzMi5wcm90b3R5cGUucm90ciA9IGZ1bmN0aW9uIChuKSB7XG5cdFx0dmFyIHYgPSAodGhpcy5faGlnaCA8PCAxNikgfCB0aGlzLl9sb3dcblx0XHR2ID0gKHYgPj4+IG4pIHwgKHYgPDwgKDMyIC0gbikpXG5cdFx0dGhpcy5fbG93ID0gdiAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSB2ID4+PiAxNlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSB0aGUgY3VycmVudCBfVUlOVDMyX1xuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge09iamVjdH0gY2xvbmVkIFVJTlQzMlxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IFVJTlQzMih0aGlzLl9sb3csIHRoaXMuX2hpZ2gpXG5cdH1cblxuXHRpZiAodHlwZW9mIGRlZmluZSAhPSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EIC8gUmVxdWlyZUpTXG5cdFx0ZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gVUlOVDMyXG5cdFx0fSlcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Ly8gTm9kZS5qc1xuXHRcdG1vZHVsZS5leHBvcnRzID0gVUlOVDMyXG5cdH0gZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdHJvb3RbJ1VJTlQzMiddID0gVUlOVDMyXG5cdH1cblxufSkodGhpcylcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jdWludC9saWIvdWludDMyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5cdEMtbGlrZSB1bnNpZ25lZCA2NCBiaXRzIGludGVnZXJzIGluIEphdmFzY3JpcHRcblx0Q29weXJpZ2h0IChDKSAyMDEzLCBQaWVycmUgQ3VydG9cblx0TUlUIGxpY2Vuc2VcbiAqL1xuOyhmdW5jdGlvbiAocm9vdCkge1xuXG5cdC8vIExvY2FsIGNhY2hlIGZvciB0eXBpY2FsIHJhZGljZXNcblx0dmFyIHJhZGl4UG93ZXJDYWNoZSA9IHtcblx0XHQxNjogVUlOVDY0KCBNYXRoLnBvdygxNiwgNSkgKVxuXHQsXHQxMDogVUlOVDY0KCBNYXRoLnBvdygxMCwgNSkgKVxuXHQsXHQyOiAgVUlOVDY0KCBNYXRoLnBvdygyLCA1KSApXG5cdH1cblx0dmFyIHJhZGl4Q2FjaGUgPSB7XG5cdFx0MTY6IFVJTlQ2NCgxNilcblx0LFx0MTA6IFVJTlQ2NCgxMClcblx0LFx0MjogIFVJTlQ2NCgyKVxuXHR9XG5cblx0LyoqXG5cdCAqXHRSZXByZXNlbnRzIGFuIHVuc2lnbmVkIDY0IGJpdHMgaW50ZWdlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZpcnN0IGxvdyBiaXRzICg4KVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kIGxvdyBiaXRzICg4KVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZmlyc3QgaGlnaCBiaXRzICg4KVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kIGhpZ2ggYml0cyAoOClcblx0ICogb3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxvdyBiaXRzICgzMilcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2ggYml0cyAoMzIpXG5cdCAqIG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaW50ZWdlciBhcyBhIHN0cmluZyBcdFx0IHwgaW50ZWdlciBhcyBhIG51bWJlclxuXHQgKiBAcGFyYW0ge051bWJlcnxVbmRlZmluZWR9IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiBcblx0ICovXG5cdGZ1bmN0aW9uIFVJTlQ2NCAoYTAwLCBhMTYsIGEzMiwgYTQ4KSB7XG5cdFx0aWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBVSU5UNjQpIClcblx0XHRcdHJldHVybiBuZXcgVUlOVDY0KGEwMCwgYTE2LCBhMzIsIGE0OClcblxuXHRcdHRoaXMucmVtYWluZGVyID0gbnVsbFxuXHRcdGlmICh0eXBlb2YgYTAwID09ICdzdHJpbmcnKVxuXHRcdFx0cmV0dXJuIGZyb21TdHJpbmcuY2FsbCh0aGlzLCBhMDAsIGExNilcblxuXHRcdGlmICh0eXBlb2YgYTE2ID09ICd1bmRlZmluZWQnKVxuXHRcdFx0cmV0dXJuIGZyb21OdW1iZXIuY2FsbCh0aGlzLCBhMDApXG5cblx0XHRmcm9tQml0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSBjdXJyZW50IF9VSU5UNjRfIG9iamVjdCB3aXRoIGl0cyBsb3cgYW5kIGhpZ2ggYml0c1xuXHQgKiBAbWV0aG9kIGZyb21CaXRzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBmaXJzdCBsb3cgYml0cyAoOClcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZCBsb3cgYml0cyAoOClcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZpcnN0IGhpZ2ggYml0cyAoOClcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZCBoaWdoIGJpdHMgKDgpXG5cdCAqIG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsb3cgYml0cyAoMzIpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoIGJpdHMgKDMyKVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBmcm9tQml0cyAoYTAwLCBhMTYsIGEzMiwgYTQ4KSB7XG5cdFx0aWYgKHR5cGVvZiBhMzIgPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRoaXMuX2EwMCA9IGEwMCAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTE2ID0gYTAwID4+PiAxNlxuXHRcdFx0dGhpcy5fYTMyID0gYTE2ICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hNDggPSBhMTYgPj4+IDE2XG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblxuXHRcdHRoaXMuX2EwMCA9IGEwMCB8IDBcblx0XHR0aGlzLl9hMTYgPSBhMTYgfCAwXG5cdFx0dGhpcy5fYTMyID0gYTMyIHwgMFxuXHRcdHRoaXMuX2E0OCA9IGE0OCB8IDBcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDY0LnByb3RvdHlwZS5mcm9tQml0cyA9IGZyb21CaXRzXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDY0XyBvYmplY3QgZnJvbSBhIG51bWJlclxuXHQgKiBAbWV0aG9kIGZyb21OdW1iZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlclxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBmcm9tTnVtYmVyICh2YWx1ZSkge1xuXHRcdHRoaXMuX2EwMCA9IHZhbHVlICYgMHhGRkZGXG5cdFx0dGhpcy5fYTE2ID0gdmFsdWUgPj4+IDE2XG5cdFx0dGhpcy5fYTMyID0gMFxuXHRcdHRoaXMuX2E0OCA9IDBcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDY0LnByb3RvdHlwZS5mcm9tTnVtYmVyID0gZnJvbU51bWJlclxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgX1VJTlQ2NF8gb2JqZWN0IGZyb20gYSBzdHJpbmdcblx0ICogQG1ldGhvZCBmcm9tU3RyaW5nXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnRlZ2VyIGFzIGEgc3RyaW5nXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpeCAob3B0aW9uYWwsIGRlZmF1bHQ9MTApXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGZyb21TdHJpbmcgKHMsIHJhZGl4KSB7XG5cdFx0cmFkaXggPSByYWRpeCB8fCAxMFxuXG5cdFx0dGhpcy5fYTAwID0gMFxuXHRcdHRoaXMuX2ExNiA9IDBcblx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0dGhpcy5fYTQ4ID0gMFxuXG5cdFx0Lypcblx0XHRcdEluIEphdmFzY3JpcHQsIGJpdHdpc2Ugb3BlcmF0b3JzIG9ubHkgb3BlcmF0ZSBvbiB0aGUgZmlyc3QgMzIgYml0cyBcblx0XHRcdG9mIGEgbnVtYmVyLCBldmVuIHRob3VnaCBwYXJzZUludCgpIGVuY29kZXMgbnVtYmVycyB3aXRoIGEgNTMgYml0cyBcblx0XHRcdG1hbnRpc3NhLlxuXHRcdFx0VGhlcmVmb3JlIFVJTlQ2NCg8TnVtYmVyPikgY2FuIG9ubHkgd29yayBvbiAzMiBiaXRzLlxuXHRcdFx0VGhlIHJhZGl4IG1heGltdW0gdmFsdWUgaXMgMzYgKGFzIHBlciBFQ01BIHNwZWNzKSAoMjYgbGV0dGVycyArIDEwIGRpZ2l0cylcblx0XHRcdG1heGltdW0gaW5wdXQgdmFsdWUgaXMgbSA9IDMyYml0cyBhcyAxID0gMl4zMiAtIDFcblx0XHRcdFNvIHRoZSBtYXhpbXVtIHN1YnN0cmluZyBsZW5ndGggbiBpczpcblx0XHRcdDM2XihuKzEpIC0gMSA9IDJeMzIgLSAxXG5cdFx0XHQzNl4obisxKSA9IDJeMzJcblx0XHRcdChuKzEpbG4oMzYpID0gMzJsbigyKVxuXHRcdFx0biA9IDMybG4oMikvbG4oMzYpIC0gMVxuXHRcdFx0biA9IDUuMTg5NjQ0OTE1Njg3NjkyXG5cdFx0XHRuID0gNVxuXHRcdCAqL1xuXHRcdHZhciByYWRpeFVpbnQgPSByYWRpeFBvd2VyQ2FjaGVbcmFkaXhdIHx8IG5ldyBVSU5UNjQoIE1hdGgucG93KHJhZGl4LCA1KSApXG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gNSkge1xuXHRcdFx0dmFyIHNpemUgPSBNYXRoLm1pbig1LCBsZW4gLSBpKVxuXHRcdFx0dmFyIHZhbHVlID0gcGFyc2VJbnQoIHMuc2xpY2UoaSwgaSArIHNpemUpLCByYWRpeCApXG5cdFx0XHR0aGlzLm11bHRpcGx5KFxuXHRcdFx0XHRcdHNpemUgPCA1XG5cdFx0XHRcdFx0XHQ/IG5ldyBVSU5UNjQoIE1hdGgucG93KHJhZGl4LCBzaXplKSApXG5cdFx0XHRcdFx0XHQ6IHJhZGl4VWludFxuXHRcdFx0XHQpXG5cdFx0XHRcdC5hZGQoIG5ldyBVSU5UNjQodmFsdWUpIClcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cdFVJTlQ2NC5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGZyb21TdHJpbmdcblxuXHQvKipcblx0ICogQ29udmVydCB0aGlzIF9VSU5UNjRfIHRvIGEgbnVtYmVyIChsYXN0IDMyIGJpdHMgYXJlIGRyb3BwZWQpXG5cdCAqIEBtZXRob2QgdG9OdW1iZXJcblx0ICogQHJldHVybiB7TnVtYmVyfSB0aGUgY29udmVydGVkIFVJTlQ2NFxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gKHRoaXMuX2ExNiAqIDY1NTM2KSArIHRoaXMuX2EwMFxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhpcyBfVUlOVDY0XyB0byBhIHN0cmluZ1xuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpeCAob3B0aW9uYWwsIGRlZmF1bHQ9MTApXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGNvbnZlcnRlZCBVSU5UNjRcblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgpIHtcblx0XHRyYWRpeCA9IHJhZGl4IHx8IDEwXG5cdFx0dmFyIHJhZGl4VWludCA9IHJhZGl4Q2FjaGVbcmFkaXhdIHx8IG5ldyBVSU5UNjQocmFkaXgpXG5cblx0XHRpZiAoICF0aGlzLmd0KHJhZGl4VWludCkgKSByZXR1cm4gdGhpcy50b051bWJlcigpLnRvU3RyaW5nKHJhZGl4KVxuXG5cdFx0dmFyIHNlbGYgPSB0aGlzLmNsb25lKClcblx0XHR2YXIgcmVzID0gbmV3IEFycmF5KDY0KVxuXHRcdGZvciAodmFyIGkgPSA2MzsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHNlbGYuZGl2KHJhZGl4VWludClcblx0XHRcdHJlc1tpXSA9IHNlbGYucmVtYWluZGVyLnRvTnVtYmVyKCkudG9TdHJpbmcocmFkaXgpXG5cdFx0XHRpZiAoICFzZWxmLmd0KHJhZGl4VWludCkgKSBicmVha1xuXHRcdH1cblx0XHRyZXNbaS0xXSA9IHNlbGYudG9OdW1iZXIoKS50b1N0cmluZyhyYWRpeClcblxuXHRcdHJldHVybiByZXMuam9pbignJylcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgdHdvIF9VSU5UNjRfLiBUaGUgY3VycmVudCBfVUlOVDY0XyBzdG9yZXMgdGhlIHJlc3VsdFxuXHQgKiBAbWV0aG9kIGFkZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dmFyIGEwMCA9IHRoaXMuX2EwMCArIG90aGVyLl9hMDBcblxuXHRcdHZhciBhMTYgPSBhMDAgPj4+IDE2XG5cdFx0YTE2ICs9IHRoaXMuX2ExNiArIG90aGVyLl9hMTZcblxuXHRcdHZhciBhMzIgPSBhMTYgPj4+IDE2XG5cdFx0YTMyICs9IHRoaXMuX2EzMiArIG90aGVyLl9hMzJcblxuXHRcdHZhciBhNDggPSBhMzIgPj4+IDE2XG5cdFx0YTQ4ICs9IHRoaXMuX2E0OCArIG90aGVyLl9hNDhcblxuXHRcdHRoaXMuX2EwMCA9IGEwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IGExNiAmIDB4RkZGRlxuXHRcdHRoaXMuX2EzMiA9IGEzMiAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9IGE0OCAmIDB4RkZGRlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBTdWJ0cmFjdCB0d28gX1VJTlQ2NF8uIFRoZSBjdXJyZW50IF9VSU5UNjRfIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIEBtZXRob2Qgc3VidHJhY3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBvdGhlci5jbG9uZSgpLm5lZ2F0ZSgpIClcblx0fVxuXG5cdC8qKlxuXHQgKiBNdWx0aXBseSB0d28gX1VJTlQ2NF8uIFRoZSBjdXJyZW50IF9VSU5UNjRfIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIEBtZXRob2QgbXVsdGlwbHlcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0Lypcblx0XHRcdGEgPSBhMDAgKyBhMTYgKyBhMzIgKyBhNDhcblx0XHRcdGIgPSBiMDAgKyBiMTYgKyBiMzIgKyBiNDhcblx0XHRcdGEqYiA9IChhMDAgKyBhMTYgKyBhMzIgKyBhNDgpKGIwMCArIGIxNiArIGIzMiArIGI0OClcblx0XHRcdFx0PSBhMDBiMDAgKyBhMDBiMTYgKyBhMDBiMzIgKyBhMDBiNDhcblx0XHRcdFx0KyBhMTZiMDAgKyBhMTZiMTYgKyBhMTZiMzIgKyBhMTZiNDhcblx0XHRcdFx0KyBhMzJiMDAgKyBhMzJiMTYgKyBhMzJiMzIgKyBhMzJiNDhcblx0XHRcdFx0KyBhNDhiMDAgKyBhNDhiMTYgKyBhNDhiMzIgKyBhNDhiNDhcblxuXHRcdFx0YTE2YjQ4LCBhMzJiMzIsIGE0OGIxNiwgYTQ4YjMyIGFuZCBhNDhiNDggb3ZlcmZsb3cgdGhlIDY0IGJpdHNcblx0XHRcdHNvIGl0IGNvbWVzIGRvd24gdG86XG5cdFx0XHRhKmJcdD0gYTAwYjAwICsgYTAwYjE2ICsgYTAwYjMyICsgYTAwYjQ4XG5cdFx0XHRcdCsgYTE2YjAwICsgYTE2YjE2ICsgYTE2YjMyXG5cdFx0XHRcdCsgYTMyYjAwICsgYTMyYjE2XG5cdFx0XHRcdCsgYTQ4YjAwXG5cdFx0XHRcdD0gYTAwYjAwXG5cdFx0XHRcdCsgYTAwYjE2ICsgYTE2YjAwXG5cdFx0XHRcdCsgYTAwYjMyICsgYTE2YjE2ICsgYTMyYjAwXG5cdFx0XHRcdCsgYTAwYjQ4ICsgYTE2YjMyICsgYTMyYjE2ICsgYTQ4YjAwXG5cdFx0ICovXG5cdFx0dmFyIGEwMCA9IHRoaXMuX2EwMFxuXHRcdHZhciBhMTYgPSB0aGlzLl9hMTZcblx0XHR2YXIgYTMyID0gdGhpcy5fYTMyXG5cdFx0dmFyIGE0OCA9IHRoaXMuX2E0OFxuXHRcdHZhciBiMDAgPSBvdGhlci5fYTAwXG5cdFx0dmFyIGIxNiA9IG90aGVyLl9hMTZcblx0XHR2YXIgYjMyID0gb3RoZXIuX2EzMlxuXHRcdHZhciBiNDggPSBvdGhlci5fYTQ4XG5cblx0XHR2YXIgYzAwID0gYTAwICogYjAwXG5cblx0XHR2YXIgYzE2ID0gYzAwID4+PiAxNlxuXHRcdGMxNiArPSBhMDAgKiBiMTZcblx0XHR2YXIgYzMyID0gYzE2ID4+PiAxNlxuXHRcdGMxNiAmPSAweEZGRkZcblx0XHRjMTYgKz0gYTE2ICogYjAwXG5cblx0XHRjMzIgKz0gYzE2ID4+PiAxNlxuXHRcdGMzMiArPSBhMDAgKiBiMzJcblx0XHR2YXIgYzQ4ID0gYzMyID4+PiAxNlxuXHRcdGMzMiAmPSAweEZGRkZcblx0XHRjMzIgKz0gYTE2ICogYjE2XG5cdFx0YzQ4ICs9IGMzMiA+Pj4gMTZcblx0XHRjMzIgJj0gMHhGRkZGXG5cdFx0YzMyICs9IGEzMiAqIGIwMFxuXG5cdFx0YzQ4ICs9IGMzMiA+Pj4gMTZcblx0XHRjNDggKz0gYTAwICogYjQ4XG5cdFx0YzQ4ICY9IDB4RkZGRlxuXHRcdGM0OCArPSBhMTYgKiBiMzJcblx0XHRjNDggJj0gMHhGRkZGXG5cdFx0YzQ4ICs9IGEzMiAqIGIxNlxuXHRcdGM0OCAmPSAweEZGRkZcblx0XHRjNDggKz0gYTQ4ICogYjAwXG5cblx0XHR0aGlzLl9hMDAgPSBjMDAgJiAweEZGRkZcblx0XHR0aGlzLl9hMTYgPSBjMTYgJiAweEZGRkZcblx0XHR0aGlzLl9hMzIgPSBjMzIgJiAweEZGRkZcblx0XHR0aGlzLl9hNDggPSBjNDggJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogRGl2aWRlIHR3byBfVUlOVDY0Xy4gVGhlIGN1cnJlbnQgX1VJTlQ2NF8gc3RvcmVzIHRoZSByZXN1bHQuXG5cdCAqIFRoZSByZW1haW5kZXIgaXMgbWFkZSBhdmFpbGFibGUgYXMgdGhlIF9yZW1haW5kZXJfIHByb3BlcnR5IG9uXG5cdCAqIHRoZSBfVUlOVDY0XyBvYmplY3QuIEl0IGNhbiBiZSBudWxsLCBtZWFuaW5nIHRoZXJlIGFyZSBubyByZW1haW5kZXIuXG5cdCAqIEBtZXRob2QgZGl2XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAoIChvdGhlci5fYTE2ID09IDApICYmIChvdGhlci5fYTMyID09IDApICYmIChvdGhlci5fYTQ4ID09IDApICkge1xuXHRcdFx0aWYgKG90aGVyLl9hMDAgPT0gMCkgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKVxuXG5cdFx0XHQvLyBvdGhlciA9PSAxOiB0aGlzXG5cdFx0XHRpZiAob3RoZXIuX2EwMCA9PSAxKSB7XG5cdFx0XHRcdHRoaXMucmVtYWluZGVyID0gbmV3IFVJTlQ2NCgwKVxuXHRcdFx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIG90aGVyID4gdGhpczogMFxuXHRcdGlmICggb3RoZXIuZ3QodGhpcykgKSB7XG5cdFx0XHR0aGlzLnJlbWFpbmRlciA9IHRoaXMuY2xvbmUoKVxuXHRcdFx0dGhpcy5fYTAwID0gMFxuXHRcdFx0dGhpcy5fYTE2ID0gMFxuXHRcdFx0dGhpcy5fYTMyID0gMFxuXHRcdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cdFx0Ly8gb3RoZXIgPT0gdGhpczogMVxuXHRcdGlmICggdGhpcy5lcShvdGhlcikgKSB7XG5cdFx0XHR0aGlzLnJlbWFpbmRlciA9IG5ldyBVSU5UNjQoMClcblx0XHRcdHRoaXMuX2EwMCA9IDFcblx0XHRcdHRoaXMuX2ExNiA9IDBcblx0XHRcdHRoaXMuX2EzMiA9IDBcblx0XHRcdHRoaXMuX2E0OCA9IDBcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0Ly8gU2hpZnQgdGhlIGRpdmlzb3IgbGVmdCB1bnRpbCBpdCBpcyBoaWdoZXIgdGhhbiB0aGUgZGl2aWRlbmRcblx0XHR2YXIgX290aGVyID0gb3RoZXIuY2xvbmUoKVxuXHRcdHZhciBpID0gLTFcblx0XHR3aGlsZSAoICF0aGlzLmx0KF9vdGhlcikgKSB7XG5cdFx0XHQvLyBIaWdoIGJpdCBjYW4gb3ZlcmZsb3cgdGhlIGRlZmF1bHQgMTZiaXRzXG5cdFx0XHQvLyBJdHMgb2sgc2luY2Ugd2UgcmlnaHQgc2hpZnQgYWZ0ZXIgdGhpcyBsb29wXG5cdFx0XHQvLyBUaGUgb3ZlcmZsb3duIGJpdCBtdXN0IGJlIGtlcHQgdGhvdWdoXG5cdFx0XHRfb3RoZXIuc2hpZnRMZWZ0KDEsIHRydWUpXG5cdFx0XHRpKytcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIHJlbWFpbmRlclxuXHRcdHRoaXMucmVtYWluZGVyID0gdGhpcy5jbG9uZSgpXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgY3VycmVudCByZXN1bHQgdG8gMFxuXHRcdHRoaXMuX2EwMCA9IDBcblx0XHR0aGlzLl9hMTYgPSAwXG5cdFx0dGhpcy5fYTMyID0gMFxuXHRcdHRoaXMuX2E0OCA9IDBcblx0XHRmb3IgKDsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdF9vdGhlci5zaGlmdFJpZ2h0KDEpXG5cdFx0XHQvLyBJZiBzaGlmdGVkIGRpdmlzb3IgaXMgc21hbGxlciB0aGFuIHRoZSBkaXZpZGVuZFxuXHRcdFx0Ly8gdGhlbiBzdWJ0cmFjdCBpdCBmcm9tIHRoZSBkaXZpZGVuZFxuXHRcdFx0aWYgKCAhdGhpcy5yZW1haW5kZXIubHQoX290aGVyKSApIHtcblx0XHRcdFx0dGhpcy5yZW1haW5kZXIuc3VidHJhY3QoX290aGVyKVxuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIGN1cnJlbnQgcmVzdWx0XG5cdFx0XHRcdGlmIChpID49IDQ4KSB7XG5cdFx0XHRcdFx0dGhpcy5fYTQ4IHw9IDEgPDwgKGkgLSA0OClcblx0XHRcdFx0fSBlbHNlIGlmIChpID49IDMyKSB7XG5cdFx0XHRcdFx0dGhpcy5fYTMyIHw9IDEgPDwgKGkgLSAzMilcblx0XHRcdFx0fSBlbHNlIGlmIChpID49IDE2KSB7XG5cdFx0XHRcdFx0dGhpcy5fYTE2IHw9IDEgPDwgKGkgLSAxNilcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9hMDAgfD0gMSA8PCBpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIE5lZ2F0ZSB0aGUgY3VycmVudCBfVUlOVDY0X1xuXHQgKiBAbWV0aG9kIG5lZ2F0ZVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdiA9ICggfnRoaXMuX2EwMCAmIDB4RkZGRiApICsgMVxuXHRcdHRoaXMuX2EwMCA9IHYgJiAweEZGRkZcblx0XHR2ID0gKH50aGlzLl9hMTYgJiAweEZGRkYpICsgKHYgPj4+IDE2KVxuXHRcdHRoaXMuX2ExNiA9IHYgJiAweEZGRkZcblx0XHR2ID0gKH50aGlzLl9hMzIgJiAweEZGRkYpICsgKHYgPj4+IDE2KVxuXHRcdHRoaXMuX2EzMiA9IHYgJiAweEZGRkZcblx0XHR0aGlzLl9hNDggPSAofnRoaXMuX2E0OCArICh2ID4+PiAxNikpICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cblx0ICogQG1ldGhvZCBlcVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLmVxdWFscyA9IFVJTlQ2NC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRyZXR1cm4gKHRoaXMuX2E0OCA9PSBvdGhlci5fYTQ4KSAmJiAodGhpcy5fYTAwID09IG90aGVyLl9hMDApXG5cdFx0XHQgJiYgKHRoaXMuX2EzMiA9PSBvdGhlci5fYTMyKSAmJiAodGhpcy5fYTE2ID09IG90aGVyLl9hMTYpXG5cdH1cblxuXHQvKipcblx0ICogR3JlYXRlciB0aGFuIChzdHJpY3QpXG5cdCAqIEBtZXRob2QgZ3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5ncmVhdGVyVGhhbiA9IFVJTlQ2NC5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAodGhpcy5fYTQ4ID4gb3RoZXIuX2E0OCkgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5fYTQ4IDwgb3RoZXIuX2E0OCkgcmV0dXJuIGZhbHNlXG5cdFx0aWYgKHRoaXMuX2EzMiA+IG90aGVyLl9hMzIpIHJldHVybiB0cnVlXG5cdFx0aWYgKHRoaXMuX2EzMiA8IG90aGVyLl9hMzIpIHJldHVybiBmYWxzZVxuXHRcdGlmICh0aGlzLl9hMTYgPiBvdGhlci5fYTE2KSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9hMTYgPCBvdGhlci5fYTE2KSByZXR1cm4gZmFsc2Vcblx0XHRyZXR1cm4gdGhpcy5fYTAwID4gb3RoZXIuX2EwMFxuXHR9XG5cblx0LyoqXG5cdCAqIExlc3MgdGhhbiAoc3RyaWN0KVxuXHQgKiBAbWV0aG9kIGx0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUubGVzc1RoYW4gPSBVSU5UNjQucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0aWYgKHRoaXMuX2E0OCA8IG90aGVyLl9hNDgpIHJldHVybiB0cnVlXG5cdFx0aWYgKHRoaXMuX2E0OCA+IG90aGVyLl9hNDgpIHJldHVybiBmYWxzZVxuXHRcdGlmICh0aGlzLl9hMzIgPCBvdGhlci5fYTMyKSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9hMzIgPiBvdGhlci5fYTMyKSByZXR1cm4gZmFsc2Vcblx0XHRpZiAodGhpcy5fYTE2IDwgb3RoZXIuX2ExNikgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5fYTE2ID4gb3RoZXIuX2ExNikgcmV0dXJuIGZhbHNlXG5cdFx0cmV0dXJuIHRoaXMuX2EwMCA8IG90aGVyLl9hMDBcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIE9SXG5cdCAqIEBtZXRob2Qgb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dGhpcy5fYTAwIHw9IG90aGVyLl9hMDBcblx0XHR0aGlzLl9hMTYgfD0gb3RoZXIuX2ExNlxuXHRcdHRoaXMuX2EzMiB8PSBvdGhlci5fYTMyXG5cdFx0dGhpcy5fYTQ4IHw9IG90aGVyLl9hNDhcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBBTkRcblx0ICogQG1ldGhvZCBhbmRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2EwMCAmPSBvdGhlci5fYTAwXG5cdFx0dGhpcy5fYTE2ICY9IG90aGVyLl9hMTZcblx0XHR0aGlzLl9hMzIgJj0gb3RoZXIuX2EzMlxuXHRcdHRoaXMuX2E0OCAmPSBvdGhlci5fYTQ4XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgWE9SXG5cdCAqIEBtZXRob2QgeG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR0aGlzLl9hMDAgXj0gb3RoZXIuX2EwMFxuXHRcdHRoaXMuX2ExNiBePSBvdGhlci5fYTE2XG5cdFx0dGhpcy5fYTMyIF49IG90aGVyLl9hMzJcblx0XHR0aGlzLl9hNDggXj0gb3RoZXIuX2E0OFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIE5PVFxuXHQgKiBAbWV0aG9kIG5vdFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2EwMCA9IH50aGlzLl9hMDAgJiAweEZGRkZcblx0XHR0aGlzLl9hMTYgPSB+dGhpcy5fYTE2ICYgMHhGRkZGXG5cdFx0dGhpcy5fYTMyID0gfnRoaXMuX2EzMiAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9IH50aGlzLl9hNDggJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBzaGlmdCByaWdodFxuXHQgKiBAbWV0aG9kIHNoaWZ0UmlnaHRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuc2hpZnRSaWdodCA9IFVJTlQ2NC5wcm90b3R5cGUuc2hpZnRyID0gZnVuY3Rpb24gKG4pIHtcblx0XHRuICU9IDY0XG5cdFx0aWYgKG4gPj0gNDgpIHtcblx0XHRcdHRoaXMuX2EwMCA9IHRoaXMuX2E0OCA+PiAobiAtIDQ4KVxuXHRcdFx0dGhpcy5fYTE2ID0gMFxuXHRcdFx0dGhpcy5fYTMyID0gMFxuXHRcdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdH0gZWxzZSBpZiAobiA+PSAzMikge1xuXHRcdFx0biAtPSAzMlxuXHRcdFx0dGhpcy5fYTAwID0gKCAodGhpcy5fYTMyID4+IG4pIHwgKHRoaXMuX2E0OCA8PCAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9ICh0aGlzLl9hNDggPj4gbikgJiAweEZGRkZcblx0XHRcdHRoaXMuX2EzMiA9IDBcblx0XHRcdHRoaXMuX2E0OCA9IDBcblx0XHR9IGVsc2UgaWYgKG4gPj0gMTYpIHtcblx0XHRcdG4gLT0gMTZcblx0XHRcdHRoaXMuX2EwMCA9ICggKHRoaXMuX2ExNiA+PiBuKSB8ICh0aGlzLl9hMzIgPDwgKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSAoICh0aGlzLl9hMzIgPj4gbikgfCAodGhpcy5fYTQ4IDw8ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTMyID0gKHRoaXMuX2E0OCA+PiBuKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9hMDAgPSAoICh0aGlzLl9hMDAgPj4gbikgfCAodGhpcy5fYTE2IDw8ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTE2ID0gKCAodGhpcy5fYTE2ID4+IG4pIHwgKHRoaXMuX2EzMiA8PCAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2EzMiA9ICggKHRoaXMuX2EzMiA+PiBuKSB8ICh0aGlzLl9hNDggPDwgKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hNDggPSAodGhpcy5fYTQ4ID4+IG4pICYgMHhGRkZGXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIHNoaWZ0IGxlZnRcblx0ICogQG1ldGhvZCBzaGlmdExlZnRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3cgb3ZlcmZsb3dcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5zaGlmdExlZnQgPSBVSU5UNjQucHJvdG90eXBlLnNoaWZ0bCA9IGZ1bmN0aW9uIChuLCBhbGxvd092ZXJmbG93KSB7XG5cdFx0biAlPSA2NFxuXHRcdGlmIChuID49IDQ4KSB7XG5cdFx0XHR0aGlzLl9hNDggPSB0aGlzLl9hMDAgPDwgKG4gLSA0OClcblx0XHRcdHRoaXMuX2EzMiA9IDBcblx0XHRcdHRoaXMuX2ExNiA9IDBcblx0XHRcdHRoaXMuX2EwMCA9IDBcblx0XHR9IGVsc2UgaWYgKG4gPj0gMzIpIHtcblx0XHRcdG4gLT0gMzJcblx0XHRcdHRoaXMuX2E0OCA9ICh0aGlzLl9hMTYgPDwgbikgfCAodGhpcy5fYTAwID4+ICgxNi1uKSlcblx0XHRcdHRoaXMuX2EzMiA9ICh0aGlzLl9hMDAgPDwgbikgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9IDBcblx0XHRcdHRoaXMuX2EwMCA9IDBcblx0XHR9IGVsc2UgaWYgKG4gPj0gMTYpIHtcblx0XHRcdG4gLT0gMTZcblx0XHRcdHRoaXMuX2E0OCA9ICh0aGlzLl9hMzIgPDwgbikgfCAodGhpcy5fYTE2ID4+ICgxNi1uKSlcblx0XHRcdHRoaXMuX2EzMiA9ICggKHRoaXMuX2ExNiA8PCBuKSB8ICh0aGlzLl9hMDAgPj4gKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSAodGhpcy5fYTAwIDw8IG4pICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMDAgPSAwXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2E0OCA9ICh0aGlzLl9hNDggPDwgbikgfCAodGhpcy5fYTMyID4+ICgxNi1uKSlcblx0XHRcdHRoaXMuX2EzMiA9ICggKHRoaXMuX2EzMiA8PCBuKSB8ICh0aGlzLl9hMTYgPj4gKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSAoICh0aGlzLl9hMTYgPDwgbikgfCAodGhpcy5fYTAwID4+ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTAwID0gKHRoaXMuX2EwMCA8PCBuKSAmIDB4RkZGRlxuXHRcdH1cblx0XHRpZiAoIWFsbG93T3ZlcmZsb3cpIHtcblx0XHRcdHRoaXMuX2E0OCAmPSAweEZGRkZcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugcm90YXRlIGxlZnRcblx0ICogQG1ldGhvZCByb3RsXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byByb3RhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5yb3RhdGVMZWZ0ID0gVUlOVDY0LnByb3RvdHlwZS5yb3RsID0gZnVuY3Rpb24gKG4pIHtcblx0XHRuICU9IDY0XG5cdFx0aWYgKG4gPT0gMCkgcmV0dXJuIHRoaXNcblx0XHRpZiAobiA+PSAzMikge1xuXHRcdFx0Ly8gQS5CLkMuRFxuXHRcdFx0Ly8gQi5DLkQuQSByb3RsKDE2KVxuXHRcdFx0Ly8gQy5ELkEuQiByb3RsKDMyKVxuXHRcdFx0dmFyIHYgPSB0aGlzLl9hMDBcblx0XHRcdHRoaXMuX2EwMCA9IHRoaXMuX2EzMlxuXHRcdFx0dGhpcy5fYTMyID0gdlxuXHRcdFx0diA9IHRoaXMuX2E0OFxuXHRcdFx0dGhpcy5fYTQ4ID0gdGhpcy5fYTE2XG5cdFx0XHR0aGlzLl9hMTYgPSB2XG5cdFx0XHRpZiAobiA9PSAzMikgcmV0dXJuIHRoaXNcblx0XHRcdG4gLT0gMzJcblx0XHR9XG5cblx0XHR2YXIgaGlnaCA9ICh0aGlzLl9hNDggPDwgMTYpIHwgdGhpcy5fYTMyXG5cdFx0dmFyIGxvdyA9ICh0aGlzLl9hMTYgPDwgMTYpIHwgdGhpcy5fYTAwXG5cblx0XHR2YXIgX2hpZ2ggPSAoaGlnaCA8PCBuKSB8IChsb3cgPj4+ICgzMiAtIG4pKVxuXHRcdHZhciBfbG93ID0gKGxvdyA8PCBuKSB8IChoaWdoID4+PiAoMzIgLSBuKSlcblxuXHRcdHRoaXMuX2EwMCA9IF9sb3cgJiAweEZGRkZcblx0XHR0aGlzLl9hMTYgPSBfbG93ID4+PiAxNlxuXHRcdHRoaXMuX2EzMiA9IF9oaWdoICYgMHhGRkZGXG5cdFx0dGhpcy5fYTQ4ID0gX2hpZ2ggPj4+IDE2XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugcm90YXRlIHJpZ2h0XG5cdCAqIEBtZXRob2Qgcm90clxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gcm90YXRlXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUucm90YXRlUmlnaHQgPSBVSU5UNjQucHJvdG90eXBlLnJvdHIgPSBmdW5jdGlvbiAobikge1xuXHRcdG4gJT0gNjRcblx0XHRpZiAobiA9PSAwKSByZXR1cm4gdGhpc1xuXHRcdGlmIChuID49IDMyKSB7XG5cdFx0XHQvLyBBLkIuQy5EXG5cdFx0XHQvLyBELkEuQi5DIHJvdHIoMTYpXG5cdFx0XHQvLyBDLkQuQS5CIHJvdHIoMzIpXG5cdFx0XHR2YXIgdiA9IHRoaXMuX2EwMFxuXHRcdFx0dGhpcy5fYTAwID0gdGhpcy5fYTMyXG5cdFx0XHR0aGlzLl9hMzIgPSB2XG5cdFx0XHR2ID0gdGhpcy5fYTQ4XG5cdFx0XHR0aGlzLl9hNDggPSB0aGlzLl9hMTZcblx0XHRcdHRoaXMuX2ExNiA9IHZcblx0XHRcdGlmIChuID09IDMyKSByZXR1cm4gdGhpc1xuXHRcdFx0biAtPSAzMlxuXHRcdH1cblxuXHRcdHZhciBoaWdoID0gKHRoaXMuX2E0OCA8PCAxNikgfCB0aGlzLl9hMzJcblx0XHR2YXIgbG93ID0gKHRoaXMuX2ExNiA8PCAxNikgfCB0aGlzLl9hMDBcblxuXHRcdHZhciBfaGlnaCA9IChoaWdoID4+PiBuKSB8IChsb3cgPDwgKDMyIC0gbikpXG5cdFx0dmFyIF9sb3cgPSAobG93ID4+PiBuKSB8IChoaWdoIDw8ICgzMiAtIG4pKVxuXG5cdFx0dGhpcy5fYTAwID0gX2xvdyAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IF9sb3cgPj4+IDE2XG5cdFx0dGhpcy5fYTMyID0gX2hpZ2ggJiAweEZGRkZcblx0XHR0aGlzLl9hNDggPSBfaGlnaCA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQ2xvbmUgdGhlIGN1cnJlbnQgX1VJTlQ2NF9cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IGNsb25lZCBVSU5UNjRcblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBVSU5UNjQodGhpcy5fYTAwLCB0aGlzLl9hMTYsIHRoaXMuX2EzMiwgdGhpcy5fYTQ4KVxuXHR9XG5cblx0aWYgKHR5cGVvZiBkZWZpbmUgIT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRCAvIFJlcXVpcmVKU1xuXHRcdGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIFVJTlQ2NFxuXHRcdH0pXG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdC8vIE5vZGUuanNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IFVJTlQ2NFxuXHR9IGVsc2Uge1xuXHRcdC8vIEJyb3dzZXJcblx0XHRyb290WydVSU5UNjQnXSA9IFVJTlQ2NFxuXHR9XG5cbn0pKHRoaXMpXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3VpbnQvbGliL3VpbnQ2NC5qc1xuLy8gbW9kdWxlIGlkID0gMjExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBwcm90byA9IHt9O1xuXG5mdW5jdGlvbiBDQkNTdGF0ZShpdikge1xuICBhc3NlcnQuZXF1YWwoaXYubGVuZ3RoLCA4LCAnSW52YWxpZCBJViBsZW5ndGgnKTtcblxuICB0aGlzLml2ID0gbmV3IEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXYubGVuZ3RoOyBpKyspXG4gICAgdGhpcy5pdltpXSA9IGl2W2ldO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZShCYXNlKSB7XG4gIGZ1bmN0aW9uIENCQyhvcHRpb25zKSB7XG4gICAgQmFzZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2NiY0luaXQoKTtcbiAgfVxuICBpbmhlcml0cyhDQkMsIEJhc2UpO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvdG8pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBDQkMucHJvdG90eXBlW2tleV0gPSBwcm90b1trZXldO1xuICB9XG5cbiAgQ0JDLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDQkMob3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIENCQztcbn1cblxuZXhwb3J0cy5pbnN0YW50aWF0ZSA9IGluc3RhbnRpYXRlO1xuXG5wcm90by5fY2JjSW5pdCA9IGZ1bmN0aW9uIF9jYmNJbml0KCkge1xuICB2YXIgc3RhdGUgPSBuZXcgQ0JDU3RhdGUodGhpcy5vcHRpb25zLml2KTtcbiAgdGhpcy5fY2JjU3RhdGUgPSBzdGF0ZTtcbn07XG5cbnByb3RvLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKGlucCwgaW5PZmYsIG91dCwgb3V0T2ZmKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2NiY1N0YXRlO1xuICB2YXIgc3VwZXJQcm90byA9IHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLnByb3RvdHlwZTtcblxuICB2YXIgaXYgPSBzdGF0ZS5pdjtcbiAgaWYgKHRoaXMudHlwZSA9PT0gJ2VuY3J5cHQnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgaXZbaV0gXj0gaW5wW2luT2ZmICsgaV07XG5cbiAgICBzdXBlclByb3RvLl91cGRhdGUuY2FsbCh0aGlzLCBpdiwgMCwgb3V0LCBvdXRPZmYpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgaXZbaV0gPSBvdXRbb3V0T2ZmICsgaV07XG4gIH0gZWxzZSB7XG4gICAgc3VwZXJQcm90by5fdXBkYXRlLmNhbGwodGhpcywgaW5wLCBpbk9mZiwgb3V0LCBvdXRPZmYpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgb3V0W291dE9mZiArIGldIF49IGl2W2ldO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgaXZbaV0gPSBpbnBbaW5PZmYgKyBpXTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kZXMuanMvbGliL2Rlcy9jYmMuanNcbi8vIG1vZHVsZSBpZCA9IDIxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbmZ1bmN0aW9uIENpcGhlcihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgdGhpcy50eXBlID0gdGhpcy5vcHRpb25zLnR5cGU7XG4gIHRoaXMuYmxvY2tTaXplID0gODtcbiAgdGhpcy5faW5pdCgpO1xuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5KHRoaXMuYmxvY2tTaXplKTtcbiAgdGhpcy5idWZmZXJPZmYgPSAwO1xufVxubW9kdWxlLmV4cG9ydHMgPSBDaXBoZXI7XG5cbkNpcGhlci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgLy8gTWlnaHQgYmUgb3ZlcnJpZGVkXG59O1xuXG5DaXBoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShkYXRhKSB7XG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHRoaXMudHlwZSA9PT0gJ2RlY3J5cHQnKVxuICAgIHJldHVybiB0aGlzLl91cGRhdGVEZWNyeXB0KGRhdGEpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUVuY3J5cHQoZGF0YSk7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl9idWZmZXIgPSBmdW5jdGlvbiBfYnVmZmVyKGRhdGEsIG9mZikge1xuICAvLyBBcHBlbmQgZGF0YSB0byBidWZmZXJcbiAgdmFyIG1pbiA9IE1hdGgubWluKHRoaXMuYnVmZmVyLmxlbmd0aCAtIHRoaXMuYnVmZmVyT2ZmLCBkYXRhLmxlbmd0aCAtIG9mZik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluOyBpKyspXG4gICAgdGhpcy5idWZmZXJbdGhpcy5idWZmZXJPZmYgKyBpXSA9IGRhdGFbb2ZmICsgaV07XG4gIHRoaXMuYnVmZmVyT2ZmICs9IG1pbjtcblxuICAvLyBTaGlmdCBuZXh0XG4gIHJldHVybiBtaW47XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl9mbHVzaEJ1ZmZlciA9IGZ1bmN0aW9uIF9mbHVzaEJ1ZmZlcihvdXQsIG9mZikge1xuICB0aGlzLl91cGRhdGUodGhpcy5idWZmZXIsIDAsIG91dCwgb2ZmKTtcbiAgdGhpcy5idWZmZXJPZmYgPSAwO1xuICByZXR1cm4gdGhpcy5ibG9ja1NpemU7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl91cGRhdGVFbmNyeXB0ID0gZnVuY3Rpb24gX3VwZGF0ZUVuY3J5cHQoZGF0YSkge1xuICB2YXIgaW5wdXRPZmYgPSAwO1xuICB2YXIgb3V0cHV0T2ZmID0gMDtcblxuICB2YXIgY291bnQgPSAoKHRoaXMuYnVmZmVyT2ZmICsgZGF0YS5sZW5ndGgpIC8gdGhpcy5ibG9ja1NpemUpIHwgMDtcbiAgdmFyIG91dCA9IG5ldyBBcnJheShjb3VudCAqIHRoaXMuYmxvY2tTaXplKTtcblxuICBpZiAodGhpcy5idWZmZXJPZmYgIT09IDApIHtcbiAgICBpbnB1dE9mZiArPSB0aGlzLl9idWZmZXIoZGF0YSwgaW5wdXRPZmYpO1xuXG4gICAgaWYgKHRoaXMuYnVmZmVyT2ZmID09PSB0aGlzLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBvdXRwdXRPZmYgKz0gdGhpcy5fZmx1c2hCdWZmZXIob3V0LCBvdXRwdXRPZmYpO1xuICB9XG5cbiAgLy8gV3JpdGUgYmxvY2tzXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aCAtICgoZGF0YS5sZW5ndGggLSBpbnB1dE9mZikgJSB0aGlzLmJsb2NrU2l6ZSk7XG4gIGZvciAoOyBpbnB1dE9mZiA8IG1heDsgaW5wdXRPZmYgKz0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICB0aGlzLl91cGRhdGUoZGF0YSwgaW5wdXRPZmYsIG91dCwgb3V0cHV0T2ZmKTtcbiAgICBvdXRwdXRPZmYgKz0gdGhpcy5ibG9ja1NpemU7XG4gIH1cblxuICAvLyBRdWV1ZSByZXN0XG4gIGZvciAoOyBpbnB1dE9mZiA8IGRhdGEubGVuZ3RoOyBpbnB1dE9mZisrLCB0aGlzLmJ1ZmZlck9mZisrKVxuICAgIHRoaXMuYnVmZmVyW3RoaXMuYnVmZmVyT2ZmXSA9IGRhdGFbaW5wdXRPZmZdO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl91cGRhdGVEZWNyeXB0ID0gZnVuY3Rpb24gX3VwZGF0ZURlY3J5cHQoZGF0YSkge1xuICB2YXIgaW5wdXRPZmYgPSAwO1xuICB2YXIgb3V0cHV0T2ZmID0gMDtcblxuICB2YXIgY291bnQgPSBNYXRoLmNlaWwoKHRoaXMuYnVmZmVyT2ZmICsgZGF0YS5sZW5ndGgpIC8gdGhpcy5ibG9ja1NpemUpIC0gMTtcbiAgdmFyIG91dCA9IG5ldyBBcnJheShjb3VudCAqIHRoaXMuYmxvY2tTaXplKTtcblxuICAvLyBUT0RPKGluZHV0bnkpOiBvcHRpbWl6ZSBpdCwgdGhpcyBpcyBmYXIgZnJvbSBvcHRpbWFsXG4gIGZvciAoOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICBpbnB1dE9mZiArPSB0aGlzLl9idWZmZXIoZGF0YSwgaW5wdXRPZmYpO1xuICAgIG91dHB1dE9mZiArPSB0aGlzLl9mbHVzaEJ1ZmZlcihvdXQsIG91dHB1dE9mZik7XG4gIH1cblxuICAvLyBCdWZmZXIgcmVzdCBvZiB0aGUgaW5wdXRcbiAgaW5wdXRPZmYgKz0gdGhpcy5fYnVmZmVyKGRhdGEsIGlucHV0T2ZmKTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5maW5hbCA9IGZ1bmN0aW9uIGZpbmFsKGJ1ZmZlcikge1xuICB2YXIgZmlyc3Q7XG4gIGlmIChidWZmZXIpXG4gICAgZmlyc3QgPSB0aGlzLnVwZGF0ZShidWZmZXIpO1xuXG4gIHZhciBsYXN0O1xuICBpZiAodGhpcy50eXBlID09PSAnZW5jcnlwdCcpXG4gICAgbGFzdCA9IHRoaXMuX2ZpbmFsRW5jcnlwdCgpO1xuICBlbHNlXG4gICAgbGFzdCA9IHRoaXMuX2ZpbmFsRGVjcnlwdCgpO1xuXG4gIGlmIChmaXJzdClcbiAgICByZXR1cm4gZmlyc3QuY29uY2F0KGxhc3QpO1xuICBlbHNlXG4gICAgcmV0dXJuIGxhc3Q7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl9wYWQgPSBmdW5jdGlvbiBfcGFkKGJ1ZmZlciwgb2ZmKSB7XG4gIGlmIChvZmYgPT09IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHdoaWxlIChvZmYgPCBidWZmZXIubGVuZ3RoKVxuICAgIGJ1ZmZlcltvZmYrK10gPSAwO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fZmluYWxFbmNyeXB0ID0gZnVuY3Rpb24gX2ZpbmFsRW5jcnlwdCgpIHtcbiAgaWYgKCF0aGlzLl9wYWQodGhpcy5idWZmZXIsIHRoaXMuYnVmZmVyT2ZmKSlcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIG91dCA9IG5ldyBBcnJheSh0aGlzLmJsb2NrU2l6ZSk7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLmJ1ZmZlciwgMCwgb3V0LCAwKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX3VucGFkID0gZnVuY3Rpb24gX3VucGFkKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyO1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fZmluYWxEZWNyeXB0ID0gZnVuY3Rpb24gX2ZpbmFsRGVjcnlwdCgpIHtcbiAgYXNzZXJ0LmVxdWFsKHRoaXMuYnVmZmVyT2ZmLCB0aGlzLmJsb2NrU2l6ZSwgJ05vdCBlbm91Z2ggZGF0YSB0byBkZWNyeXB0Jyk7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXkodGhpcy5ibG9ja1NpemUpO1xuICB0aGlzLl9mbHVzaEJ1ZmZlcihvdXQsIDApO1xuXG4gIHJldHVybiB0aGlzLl91bnBhZChvdXQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kZXMuanMvbGliL2Rlcy9jaXBoZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgZGVzID0gcmVxdWlyZSgnLi4vZGVzJyk7XG52YXIgdXRpbHMgPSBkZXMudXRpbHM7XG52YXIgQ2lwaGVyID0gZGVzLkNpcGhlcjtcblxuZnVuY3Rpb24gREVTU3RhdGUoKSB7XG4gIHRoaXMudG1wID0gbmV3IEFycmF5KDIpO1xuICB0aGlzLmtleXMgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBERVMob3B0aW9ucykge1xuICBDaXBoZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB2YXIgc3RhdGUgPSBuZXcgREVTU3RhdGUoKTtcbiAgdGhpcy5fZGVzU3RhdGUgPSBzdGF0ZTtcblxuICB0aGlzLmRlcml2ZUtleXMoc3RhdGUsIG9wdGlvbnMua2V5KTtcbn1cbmluaGVyaXRzKERFUywgQ2lwaGVyKTtcbm1vZHVsZS5leHBvcnRzID0gREVTO1xuXG5ERVMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBERVMob3B0aW9ucyk7XG59O1xuXG52YXIgc2hpZnRUYWJsZSA9IFtcbiAgMSwgMSwgMiwgMiwgMiwgMiwgMiwgMixcbiAgMSwgMiwgMiwgMiwgMiwgMiwgMiwgMVxuXTtcblxuREVTLnByb3RvdHlwZS5kZXJpdmVLZXlzID0gZnVuY3Rpb24gZGVyaXZlS2V5cyhzdGF0ZSwga2V5KSB7XG4gIHN0YXRlLmtleXMgPSBuZXcgQXJyYXkoMTYgKiAyKTtcblxuICBhc3NlcnQuZXF1YWwoa2V5Lmxlbmd0aCwgdGhpcy5ibG9ja1NpemUsICdJbnZhbGlkIGtleSBsZW5ndGgnKTtcblxuICB2YXIga0wgPSB1dGlscy5yZWFkVUludDMyQkUoa2V5LCAwKTtcbiAgdmFyIGtSID0gdXRpbHMucmVhZFVJbnQzMkJFKGtleSwgNCk7XG5cbiAgdXRpbHMucGMxKGtMLCBrUiwgc3RhdGUudG1wLCAwKTtcbiAga0wgPSBzdGF0ZS50bXBbMF07XG4gIGtSID0gc3RhdGUudG1wWzFdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmtleXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgc2hpZnQgPSBzaGlmdFRhYmxlW2kgPj4+IDFdO1xuICAgIGtMID0gdXRpbHMucjI4c2hsKGtMLCBzaGlmdCk7XG4gICAga1IgPSB1dGlscy5yMjhzaGwoa1IsIHNoaWZ0KTtcbiAgICB1dGlscy5wYzIoa0wsIGtSLCBzdGF0ZS5rZXlzLCBpKTtcbiAgfVxufTtcblxuREVTLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShpbnAsIGluT2ZmLCBvdXQsIG91dE9mZikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9kZXNTdGF0ZTtcblxuICB2YXIgbCA9IHV0aWxzLnJlYWRVSW50MzJCRShpbnAsIGluT2ZmKTtcbiAgdmFyIHIgPSB1dGlscy5yZWFkVUludDMyQkUoaW5wLCBpbk9mZiArIDQpO1xuXG4gIC8vIEluaXRpYWwgUGVybXV0YXRpb25cbiAgdXRpbHMuaXAobCwgciwgc3RhdGUudG1wLCAwKTtcbiAgbCA9IHN0YXRlLnRtcFswXTtcbiAgciA9IHN0YXRlLnRtcFsxXTtcblxuICBpZiAodGhpcy50eXBlID09PSAnZW5jcnlwdCcpXG4gICAgdGhpcy5fZW5jcnlwdChzdGF0ZSwgbCwgciwgc3RhdGUudG1wLCAwKTtcbiAgZWxzZVxuICAgIHRoaXMuX2RlY3J5cHQoc3RhdGUsIGwsIHIsIHN0YXRlLnRtcCwgMCk7XG5cbiAgbCA9IHN0YXRlLnRtcFswXTtcbiAgciA9IHN0YXRlLnRtcFsxXTtcblxuICB1dGlscy53cml0ZVVJbnQzMkJFKG91dCwgbCwgb3V0T2ZmKTtcbiAgdXRpbHMud3JpdGVVSW50MzJCRShvdXQsIHIsIG91dE9mZiArIDQpO1xufTtcblxuREVTLnByb3RvdHlwZS5fcGFkID0gZnVuY3Rpb24gX3BhZChidWZmZXIsIG9mZikge1xuICB2YXIgdmFsdWUgPSBidWZmZXIubGVuZ3RoIC0gb2ZmO1xuICBmb3IgKHZhciBpID0gb2ZmOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKVxuICAgIGJ1ZmZlcltpXSA9IHZhbHVlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuREVTLnByb3RvdHlwZS5fdW5wYWQgPSBmdW5jdGlvbiBfdW5wYWQoYnVmZmVyKSB7XG4gIHZhciBwYWQgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIDFdO1xuICBmb3IgKHZhciBpID0gYnVmZmVyLmxlbmd0aCAtIHBhZDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKylcbiAgICBhc3NlcnQuZXF1YWwoYnVmZmVyW2ldLCBwYWQpO1xuXG4gIHJldHVybiBidWZmZXIuc2xpY2UoMCwgYnVmZmVyLmxlbmd0aCAtIHBhZCk7XG59O1xuXG5ERVMucHJvdG90eXBlLl9lbmNyeXB0ID0gZnVuY3Rpb24gX2VuY3J5cHQoc3RhdGUsIGxTdGFydCwgclN0YXJ0LCBvdXQsIG9mZikge1xuICB2YXIgbCA9IGxTdGFydDtcbiAgdmFyIHIgPSByU3RhcnQ7XG5cbiAgLy8gQXBwbHkgZigpIHgxNiB0aW1lc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmtleXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIga2V5TCA9IHN0YXRlLmtleXNbaV07XG4gICAgdmFyIGtleVIgPSBzdGF0ZS5rZXlzW2kgKyAxXTtcblxuICAgIC8vIGYociwgaylcbiAgICB1dGlscy5leHBhbmQociwgc3RhdGUudG1wLCAwKTtcblxuICAgIGtleUwgXj0gc3RhdGUudG1wWzBdO1xuICAgIGtleVIgXj0gc3RhdGUudG1wWzFdO1xuICAgIHZhciBzID0gdXRpbHMuc3Vic3RpdHV0ZShrZXlMLCBrZXlSKTtcbiAgICB2YXIgZiA9IHV0aWxzLnBlcm11dGUocyk7XG5cbiAgICB2YXIgdCA9IHI7XG4gICAgciA9IChsIF4gZikgPj4+IDA7XG4gICAgbCA9IHQ7XG4gIH1cblxuICAvLyBSZXZlcnNlIEluaXRpYWwgUGVybXV0YXRpb25cbiAgdXRpbHMucmlwKHIsIGwsIG91dCwgb2ZmKTtcbn07XG5cbkRFUy5wcm90b3R5cGUuX2RlY3J5cHQgPSBmdW5jdGlvbiBfZGVjcnlwdChzdGF0ZSwgbFN0YXJ0LCByU3RhcnQsIG91dCwgb2ZmKSB7XG4gIHZhciBsID0gclN0YXJ0O1xuICB2YXIgciA9IGxTdGFydDtcblxuICAvLyBBcHBseSBmKCkgeDE2IHRpbWVzXG4gIGZvciAodmFyIGkgPSBzdGF0ZS5rZXlzLmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgdmFyIGtleUwgPSBzdGF0ZS5rZXlzW2ldO1xuICAgIHZhciBrZXlSID0gc3RhdGUua2V5c1tpICsgMV07XG5cbiAgICAvLyBmKHIsIGspXG4gICAgdXRpbHMuZXhwYW5kKGwsIHN0YXRlLnRtcCwgMCk7XG5cbiAgICBrZXlMIF49IHN0YXRlLnRtcFswXTtcbiAgICBrZXlSIF49IHN0YXRlLnRtcFsxXTtcbiAgICB2YXIgcyA9IHV0aWxzLnN1YnN0aXR1dGUoa2V5TCwga2V5Uik7XG4gICAgdmFyIGYgPSB1dGlscy5wZXJtdXRlKHMpO1xuXG4gICAgdmFyIHQgPSBsO1xuICAgIGwgPSAociBeIGYpID4+PiAwO1xuICAgIHIgPSB0O1xuICB9XG5cbiAgLy8gUmV2ZXJzZSBJbml0aWFsIFBlcm11dGF0aW9uXG4gIHV0aWxzLnJpcChsLCByLCBvdXQsIG9mZik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Rlcy5qcy9saWIvZGVzL2Rlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBkZXMgPSByZXF1aXJlKCcuLi9kZXMnKTtcbnZhciBDaXBoZXIgPSBkZXMuQ2lwaGVyO1xudmFyIERFUyA9IGRlcy5ERVM7XG5cbmZ1bmN0aW9uIEVERVN0YXRlKHR5cGUsIGtleSkge1xuICBhc3NlcnQuZXF1YWwoa2V5Lmxlbmd0aCwgMjQsICdJbnZhbGlkIGtleSBsZW5ndGgnKTtcblxuICB2YXIgazEgPSBrZXkuc2xpY2UoMCwgOCk7XG4gIHZhciBrMiA9IGtleS5zbGljZSg4LCAxNik7XG4gIHZhciBrMyA9IGtleS5zbGljZSgxNiwgMjQpO1xuXG4gIGlmICh0eXBlID09PSAnZW5jcnlwdCcpIHtcbiAgICB0aGlzLmNpcGhlcnMgPSBbXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2VuY3J5cHQnLCBrZXk6IGsxIH0pLFxuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdkZWNyeXB0Jywga2V5OiBrMiB9KSxcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZW5jcnlwdCcsIGtleTogazMgfSlcbiAgICBdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY2lwaGVycyA9IFtcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZGVjcnlwdCcsIGtleTogazMgfSksXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2VuY3J5cHQnLCBrZXk6IGsyIH0pLFxuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdkZWNyeXB0Jywga2V5OiBrMSB9KVxuICAgIF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRURFKG9wdGlvbnMpIHtcbiAgQ2lwaGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHN0YXRlID0gbmV3IEVERVN0YXRlKHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLmtleSk7XG4gIHRoaXMuX2VkZVN0YXRlID0gc3RhdGU7XG59XG5pbmhlcml0cyhFREUsIENpcGhlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gRURFO1xuXG5FREUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBFREUob3B0aW9ucyk7XG59O1xuXG5FREUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKGlucCwgaW5PZmYsIG91dCwgb3V0T2ZmKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2VkZVN0YXRlO1xuXG4gIHN0YXRlLmNpcGhlcnNbMF0uX3VwZGF0ZShpbnAsIGluT2ZmLCBvdXQsIG91dE9mZik7XG4gIHN0YXRlLmNpcGhlcnNbMV0uX3VwZGF0ZShvdXQsIG91dE9mZiwgb3V0LCBvdXRPZmYpO1xuICBzdGF0ZS5jaXBoZXJzWzJdLl91cGRhdGUob3V0LCBvdXRPZmYsIG91dCwgb3V0T2ZmKTtcbn07XG5cbkVERS5wcm90b3R5cGUuX3BhZCA9IERFUy5wcm90b3R5cGUuX3BhZDtcbkVERS5wcm90b3R5cGUuX3VucGFkID0gREVTLnByb3RvdHlwZS5fdW5wYWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZGVzLmpzL2xpYi9kZXMvZWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRShieXRlcywgb2ZmKSB7XG4gIHZhciByZXMgPSAgKGJ5dGVzWzAgKyBvZmZdIDw8IDI0KSB8XG4gICAgICAgICAgICAgKGJ5dGVzWzEgKyBvZmZdIDw8IDE2KSB8XG4gICAgICAgICAgICAgKGJ5dGVzWzIgKyBvZmZdIDw8IDgpIHxcbiAgICAgICAgICAgICBieXRlc1szICsgb2ZmXTtcbiAgcmV0dXJuIHJlcyA+Pj4gMDtcbn07XG5cbmV4cG9ydHMud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUoYnl0ZXMsIHZhbHVlLCBvZmYpIHtcbiAgYnl0ZXNbMCArIG9mZl0gPSB2YWx1ZSA+Pj4gMjQ7XG4gIGJ5dGVzWzEgKyBvZmZdID0gKHZhbHVlID4+PiAxNikgJiAweGZmO1xuICBieXRlc1syICsgb2ZmXSA9ICh2YWx1ZSA+Pj4gOCkgJiAweGZmO1xuICBieXRlc1szICsgb2ZmXSA9IHZhbHVlICYgMHhmZjtcbn07XG5cbmV4cG9ydHMuaXAgPSBmdW5jdGlvbiBpcChpbkwsIGluUiwgb3V0LCBvZmYpIHtcbiAgdmFyIG91dEwgPSAwO1xuICB2YXIgb3V0UiA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDY7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluUiA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5MID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDY7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gMjU7IGogKz0gOCkge1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluUiA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSAyNTsgaiArPSA4KSB7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5MID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG5cbiAgb3V0W29mZiArIDBdID0gb3V0TCA+Pj4gMDtcbiAgb3V0W29mZiArIDFdID0gb3V0UiA+Pj4gMDtcbn07XG5cbmV4cG9ydHMucmlwID0gZnVuY3Rpb24gcmlwKGluTCwgaW5SLCBvdXQsIG9mZikge1xuICB2YXIgb3V0TCA9IDA7XG4gIHZhciBvdXRSID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAyNDsgaiA+PSAwOyBqIC09IDgpIHtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpblIgPj4+IChqICsgaSkpICYgMTtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpbkwgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IDQ7IGkgPCA4OyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMjQ7IGogPj0gMDsgaiAtPSA4KSB7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5SID4+PiAoaiArIGkpKSAmIDE7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5MID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG5cbiAgb3V0W29mZiArIDBdID0gb3V0TCA+Pj4gMDtcbiAgb3V0W29mZiArIDFdID0gb3V0UiA+Pj4gMDtcbn07XG5cbmV4cG9ydHMucGMxID0gZnVuY3Rpb24gcGMxKGluTCwgaW5SLCBvdXQsIG9mZikge1xuICB2YXIgb3V0TCA9IDA7XG4gIHZhciBvdXRSID0gMDtcblxuICAvLyA3LCAxNSwgMjMsIDMxLCAzOSwgNDcsIDU1LCA2M1xuICAvLyA2LCAxNCwgMjIsIDMwLCAzOSwgNDcsIDU1LCA2M1xuICAvLyA1LCAxMywgMjEsIDI5LCAzOSwgNDcsIDU1LCA2M1xuICAvLyA0LCAxMiwgMjAsIDI4XG4gIGZvciAodmFyIGkgPSA3OyBpID49IDU7IGktLSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpblIgPj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5MID4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgIG91dEwgPDw9IDE7XG4gICAgb3V0TCB8PSAoaW5SID4+IChqICsgaSkpICYgMTtcbiAgfVxuXG4gIC8vIDEsIDksIDE3LCAyNSwgMzMsIDQxLCA0OSwgNTdcbiAgLy8gMiwgMTAsIDE4LCAyNiwgMzQsIDQyLCA1MCwgNThcbiAgLy8gMywgMTEsIDE5LCAyNywgMzUsIDQzLCA1MSwgNTlcbiAgLy8gMzYsIDQ0LCA1MiwgNjBcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMzsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluUiA+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpbkwgPj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgb3V0UiA8PD0gMTtcbiAgICBvdXRSIHw9IChpbkwgPj4gKGogKyBpKSkgJiAxO1xuICB9XG5cbiAgb3V0W29mZiArIDBdID0gb3V0TCA+Pj4gMDtcbiAgb3V0W29mZiArIDFdID0gb3V0UiA+Pj4gMDtcbn07XG5cbmV4cG9ydHMucjI4c2hsID0gZnVuY3Rpb24gcjI4c2hsKG51bSwgc2hpZnQpIHtcbiAgcmV0dXJuICgobnVtIDw8IHNoaWZ0KSAmIDB4ZmZmZmZmZikgfCAobnVtID4+PiAoMjggLSBzaGlmdCkpO1xufTtcblxudmFyIHBjMnRhYmxlID0gW1xuICAvLyBpbkwgPT4gb3V0TFxuICAxNCwgMTEsIDE3LCA0LCAyNywgMjMsIDI1LCAwLFxuICAxMywgMjIsIDcsIDE4LCA1LCA5LCAxNiwgMjQsXG4gIDIsIDIwLCAxMiwgMjEsIDEsIDgsIDE1LCAyNixcblxuICAvLyBpblIgPT4gb3V0UlxuICAxNSwgNCwgMjUsIDE5LCA5LCAxLCAyNiwgMTYsXG4gIDUsIDExLCAyMywgOCwgMTIsIDcsIDE3LCAwLFxuICAyMiwgMywgMTAsIDE0LCA2LCAyMCwgMjcsIDI0XG5dO1xuXG5leHBvcnRzLnBjMiA9IGZ1bmN0aW9uIHBjMihpbkwsIGluUiwgb3V0LCBvZmYpIHtcbiAgdmFyIG91dEwgPSAwO1xuICB2YXIgb3V0UiA9IDA7XG5cbiAgdmFyIGxlbiA9IHBjMnRhYmxlLmxlbmd0aCA+Pj4gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dEwgPDw9IDE7XG4gICAgb3V0TCB8PSAoaW5MID4+PiBwYzJ0YWJsZVtpXSkgJiAweDE7XG4gIH1cbiAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IHBjMnRhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0UiA8PD0gMTtcbiAgICBvdXRSIHw9IChpblIgPj4+IHBjMnRhYmxlW2ldKSAmIDB4MTtcbiAgfVxuXG4gIG91dFtvZmYgKyAwXSA9IG91dEwgPj4+IDA7XG4gIG91dFtvZmYgKyAxXSA9IG91dFIgPj4+IDA7XG59O1xuXG5leHBvcnRzLmV4cGFuZCA9IGZ1bmN0aW9uIGV4cGFuZChyLCBvdXQsIG9mZikge1xuICB2YXIgb3V0TCA9IDA7XG4gIHZhciBvdXRSID0gMDtcblxuICBvdXRMID0gKChyICYgMSkgPDwgNSkgfCAociA+Pj4gMjcpO1xuICBmb3IgKHZhciBpID0gMjM7IGkgPj0gMTU7IGkgLT0gNCkge1xuICAgIG91dEwgPDw9IDY7XG4gICAgb3V0TCB8PSAociA+Pj4gaSkgJiAweDNmO1xuICB9XG4gIGZvciAodmFyIGkgPSAxMTsgaSA+PSAzOyBpIC09IDQpIHtcbiAgICBvdXRSIHw9IChyID4+PiBpKSAmIDB4M2Y7XG4gICAgb3V0UiA8PD0gNjtcbiAgfVxuICBvdXRSIHw9ICgociAmIDB4MWYpIDw8IDEpIHwgKHIgPj4+IDMxKTtcblxuICBvdXRbb2ZmICsgMF0gPSBvdXRMID4+PiAwO1xuICBvdXRbb2ZmICsgMV0gPSBvdXRSID4+PiAwO1xufTtcblxudmFyIHNUYWJsZSA9IFtcbiAgMTQsIDAsIDQsIDE1LCAxMywgNywgMSwgNCwgMiwgMTQsIDE1LCAyLCAxMSwgMTMsIDgsIDEsXG4gIDMsIDEwLCAxMCwgNiwgNiwgMTIsIDEyLCAxMSwgNSwgOSwgOSwgNSwgMCwgMywgNywgOCxcbiAgNCwgMTUsIDEsIDEyLCAxNCwgOCwgOCwgMiwgMTMsIDQsIDYsIDksIDIsIDEsIDExLCA3LFxuICAxNSwgNSwgMTIsIDExLCA5LCAzLCA3LCAxNCwgMywgMTAsIDEwLCAwLCA1LCA2LCAwLCAxMyxcblxuICAxNSwgMywgMSwgMTMsIDgsIDQsIDE0LCA3LCA2LCAxNSwgMTEsIDIsIDMsIDgsIDQsIDE0LFxuICA5LCAxMiwgNywgMCwgMiwgMSwgMTMsIDEwLCAxMiwgNiwgMCwgOSwgNSwgMTEsIDEwLCA1LFxuICAwLCAxMywgMTQsIDgsIDcsIDEwLCAxMSwgMSwgMTAsIDMsIDQsIDE1LCAxMywgNCwgMSwgMixcbiAgNSwgMTEsIDgsIDYsIDEyLCA3LCA2LCAxMiwgOSwgMCwgMywgNSwgMiwgMTQsIDE1LCA5LFxuXG4gIDEwLCAxMywgMCwgNywgOSwgMCwgMTQsIDksIDYsIDMsIDMsIDQsIDE1LCA2LCA1LCAxMCxcbiAgMSwgMiwgMTMsIDgsIDEyLCA1LCA3LCAxNCwgMTEsIDEyLCA0LCAxMSwgMiwgMTUsIDgsIDEsXG4gIDEzLCAxLCA2LCAxMCwgNCwgMTMsIDksIDAsIDgsIDYsIDE1LCA5LCAzLCA4LCAwLCA3LFxuICAxMSwgNCwgMSwgMTUsIDIsIDE0LCAxMiwgMywgNSwgMTEsIDEwLCA1LCAxNCwgMiwgNywgMTIsXG5cbiAgNywgMTMsIDEzLCA4LCAxNCwgMTEsIDMsIDUsIDAsIDYsIDYsIDE1LCA5LCAwLCAxMCwgMyxcbiAgMSwgNCwgMiwgNywgOCwgMiwgNSwgMTIsIDExLCAxLCAxMiwgMTAsIDQsIDE0LCAxNSwgOSxcbiAgMTAsIDMsIDYsIDE1LCA5LCAwLCAwLCA2LCAxMiwgMTAsIDExLCAxLCA3LCAxMywgMTMsIDgsXG4gIDE1LCA5LCAxLCA0LCAzLCA1LCAxNCwgMTEsIDUsIDEyLCAyLCA3LCA4LCAyLCA0LCAxNCxcblxuICAyLCAxNCwgMTIsIDExLCA0LCAyLCAxLCAxMiwgNywgNCwgMTAsIDcsIDExLCAxMywgNiwgMSxcbiAgOCwgNSwgNSwgMCwgMywgMTUsIDE1LCAxMCwgMTMsIDMsIDAsIDksIDE0LCA4LCA5LCA2LFxuICA0LCAxMSwgMiwgOCwgMSwgMTIsIDExLCA3LCAxMCwgMSwgMTMsIDE0LCA3LCAyLCA4LCAxMyxcbiAgMTUsIDYsIDksIDE1LCAxMiwgMCwgNSwgOSwgNiwgMTAsIDMsIDQsIDAsIDUsIDE0LCAzLFxuXG4gIDEyLCAxMCwgMSwgMTUsIDEwLCA0LCAxNSwgMiwgOSwgNywgMiwgMTIsIDYsIDksIDgsIDUsXG4gIDAsIDYsIDEzLCAxLCAzLCAxMywgNCwgMTQsIDE0LCAwLCA3LCAxMSwgNSwgMywgMTEsIDgsXG4gIDksIDQsIDE0LCAzLCAxNSwgMiwgNSwgMTIsIDIsIDksIDgsIDUsIDEyLCAxNSwgMywgMTAsXG4gIDcsIDExLCAwLCAxNCwgNCwgMSwgMTAsIDcsIDEsIDYsIDEzLCAwLCAxMSwgOCwgNiwgMTMsXG5cbiAgNCwgMTMsIDExLCAwLCAyLCAxMSwgMTQsIDcsIDE1LCA0LCAwLCA5LCA4LCAxLCAxMywgMTAsXG4gIDMsIDE0LCAxMiwgMywgOSwgNSwgNywgMTIsIDUsIDIsIDEwLCAxNSwgNiwgOCwgMSwgNixcbiAgMSwgNiwgNCwgMTEsIDExLCAxMywgMTMsIDgsIDEyLCAxLCAzLCA0LCA3LCAxMCwgMTQsIDcsXG4gIDEwLCA5LCAxNSwgNSwgNiwgMCwgOCwgMTUsIDAsIDE0LCA1LCAyLCA5LCAzLCAyLCAxMixcblxuICAxMywgMSwgMiwgMTUsIDgsIDEzLCA0LCA4LCA2LCAxMCwgMTUsIDMsIDExLCA3LCAxLCA0LFxuICAxMCwgMTIsIDksIDUsIDMsIDYsIDE0LCAxMSwgNSwgMCwgMCwgMTQsIDEyLCA5LCA3LCAyLFxuICA3LCAyLCAxMSwgMSwgNCwgMTQsIDEsIDcsIDksIDQsIDEyLCAxMCwgMTQsIDgsIDIsIDEzLFxuICAwLCAxNSwgNiwgMTIsIDEwLCA5LCAxMywgMCwgMTUsIDMsIDMsIDUsIDUsIDYsIDgsIDExXG5dO1xuXG5leHBvcnRzLnN1YnN0aXR1dGUgPSBmdW5jdGlvbiBzdWJzdGl0dXRlKGluTCwgaW5SKSB7XG4gIHZhciBvdXQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBiID0gKGluTCA+Pj4gKDE4IC0gaSAqIDYpKSAmIDB4M2Y7XG4gICAgdmFyIHNiID0gc1RhYmxlW2kgKiAweDQwICsgYl07XG5cbiAgICBvdXQgPDw9IDQ7XG4gICAgb3V0IHw9IHNiO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgdmFyIGIgPSAoaW5SID4+PiAoMTggLSBpICogNikpICYgMHgzZjtcbiAgICB2YXIgc2IgPSBzVGFibGVbNCAqIDB4NDAgKyBpICogMHg0MCArIGJdO1xuXG4gICAgb3V0IDw8PSA0O1xuICAgIG91dCB8PSBzYjtcbiAgfVxuICByZXR1cm4gb3V0ID4+PiAwO1xufTtcblxudmFyIHBlcm11dGVUYWJsZSA9IFtcbiAgMTYsIDI1LCAxMiwgMTEsIDMsIDIwLCA0LCAxNSwgMzEsIDE3LCA5LCA2LCAyNywgMTQsIDEsIDIyLFxuICAzMCwgMjQsIDgsIDE4LCAwLCA1LCAyOSwgMjMsIDEzLCAxOSwgMiwgMjYsIDEwLCAyMSwgMjgsIDdcbl07XG5cbmV4cG9ydHMucGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUobnVtKSB7XG4gIHZhciBvdXQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBlcm11dGVUYWJsZS5sZW5ndGg7IGkrKykge1xuICAgIG91dCA8PD0gMTtcbiAgICBvdXQgfD0gKG51bSA+Pj4gcGVybXV0ZVRhYmxlW2ldKSAmIDB4MTtcbiAgfVxuICByZXR1cm4gb3V0ID4+PiAwO1xufTtcblxuZXhwb3J0cy5wYWRTcGxpdCA9IGZ1bmN0aW9uIHBhZFNwbGl0KG51bSwgc2l6ZSwgZ3JvdXApIHtcbiAgdmFyIHN0ciA9IG51bS50b1N0cmluZygyKTtcbiAgd2hpbGUgKHN0ci5sZW5ndGggPCBzaXplKVxuICAgIHN0ciA9ICcwJyArIHN0cjtcblxuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArPSBncm91cClcbiAgICBvdXQucHVzaChzdHIuc2xpY2UoaSwgaSArIGdyb3VwKSk7XG4gIHJldHVybiBvdXQuam9pbignICcpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kZXMuanMvbGliL2Rlcy91dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMjE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZW5lcmF0ZVByaW1lID0gcmVxdWlyZSgnLi9saWIvZ2VuZXJhdGVQcmltZScpXG52YXIgcHJpbWVzID0gcmVxdWlyZSgnLi9saWIvcHJpbWVzLmpzb24nKVxuXG52YXIgREggPSByZXF1aXJlKCcuL2xpYi9kaCcpXG5cbmZ1bmN0aW9uIGdldERpZmZpZUhlbGxtYW4gKG1vZCkge1xuICB2YXIgcHJpbWUgPSBuZXcgQnVmZmVyKHByaW1lc1ttb2RdLnByaW1lLCAnaGV4JylcbiAgdmFyIGdlbiA9IG5ldyBCdWZmZXIocHJpbWVzW21vZF0uZ2VuLCAnaGV4JylcblxuICByZXR1cm4gbmV3IERIKHByaW1lLCBnZW4pXG59XG5cbnZhciBFTkNPRElOR1MgPSB7XG4gICdiaW5hcnknOiB0cnVlLCAnaGV4JzogdHJ1ZSwgJ2Jhc2U2NCc6IHRydWVcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGlmZmllSGVsbG1hbiAocHJpbWUsIGVuYywgZ2VuZXJhdG9yLCBnZW5jKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZW5jKSB8fCBFTkNPRElOR1NbZW5jXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURpZmZpZUhlbGxtYW4ocHJpbWUsICdiaW5hcnknLCBlbmMsIGdlbmVyYXRvcilcbiAgfVxuXG4gIGVuYyA9IGVuYyB8fCAnYmluYXJ5J1xuICBnZW5jID0gZ2VuYyB8fCAnYmluYXJ5J1xuICBnZW5lcmF0b3IgPSBnZW5lcmF0b3IgfHwgbmV3IEJ1ZmZlcihbMl0pXG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZ2VuZXJhdG9yKSkge1xuICAgIGdlbmVyYXRvciA9IG5ldyBCdWZmZXIoZ2VuZXJhdG9yLCBnZW5jKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwcmltZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV3IERIKGdlbmVyYXRlUHJpbWUocHJpbWUsIGdlbmVyYXRvciksIGdlbmVyYXRvciwgdHJ1ZSlcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHByaW1lKSkge1xuICAgIHByaW1lID0gbmV3IEJ1ZmZlcihwcmltZSwgZW5jKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBESChwcmltZSwgZ2VuZXJhdG9yLCB0cnVlKVxufVxuXG5leHBvcnRzLkRpZmZpZUhlbGxtYW5Hcm91cCA9IGV4cG9ydHMuY3JlYXRlRGlmZmllSGVsbG1hbkdyb3VwID0gZXhwb3J0cy5nZXREaWZmaWVIZWxsbWFuID0gZ2V0RGlmZmllSGVsbG1hblxuZXhwb3J0cy5jcmVhdGVEaWZmaWVIZWxsbWFuID0gZXhwb3J0cy5EaWZmaWVIZWxsbWFuID0gY3JlYXRlRGlmZmllSGVsbG1hblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2RpZmZpZS1oZWxsbWFuL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIE1pbGxlclJhYmluID0gcmVxdWlyZSgnbWlsbGVyLXJhYmluJyk7XG52YXIgbWlsbGVyUmFiaW4gPSBuZXcgTWlsbGVyUmFiaW4oKTtcbnZhciBUV0VOVFlGT1VSID0gbmV3IEJOKDI0KTtcbnZhciBFTEVWRU4gPSBuZXcgQk4oMTEpO1xudmFyIFRFTiA9IG5ldyBCTigxMCk7XG52YXIgVEhSRUUgPSBuZXcgQk4oMyk7XG52YXIgU0VWRU4gPSBuZXcgQk4oNyk7XG52YXIgcHJpbWVzID0gcmVxdWlyZSgnLi9nZW5lcmF0ZVByaW1lJyk7XG52YXIgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xubW9kdWxlLmV4cG9ydHMgPSBESDtcblxuZnVuY3Rpb24gc2V0UHVibGljS2V5KHB1YiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHB1YikpIHtcbiAgICBwdWIgPSBuZXcgQnVmZmVyKHB1YiwgZW5jKTtcbiAgfVxuICB0aGlzLl9wdWIgPSBuZXcgQk4ocHViKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHNldFByaXZhdGVLZXkocHJpdiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHByaXYpKSB7XG4gICAgcHJpdiA9IG5ldyBCdWZmZXIocHJpdiwgZW5jKTtcbiAgfVxuICB0aGlzLl9wcml2ID0gbmV3IEJOKHByaXYpO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByaW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGNoZWNrUHJpbWUocHJpbWUsIGdlbmVyYXRvcikge1xuICB2YXIgZ2VuID0gZ2VuZXJhdG9yLnRvU3RyaW5nKCdoZXgnKTtcbiAgdmFyIGhleCA9IFtnZW4sIHByaW1lLnRvU3RyaW5nKDE2KV0uam9pbignXycpO1xuICBpZiAoaGV4IGluIHByaW1lQ2FjaGUpIHtcbiAgICByZXR1cm4gcHJpbWVDYWNoZVtoZXhdO1xuICB9XG4gIHZhciBlcnJvciA9IDA7XG5cbiAgaWYgKHByaW1lLmlzRXZlbigpIHx8XG4gICAgIXByaW1lcy5zaW1wbGVTaWV2ZSB8fFxuICAgICFwcmltZXMuZmVybWF0VGVzdChwcmltZSkgfHxcbiAgICAhbWlsbGVyUmFiaW4udGVzdChwcmltZSkpIHtcbiAgICAvL25vdCBhIHByaW1lIHNvICsxXG4gICAgZXJyb3IgKz0gMTtcblxuICAgIGlmIChnZW4gPT09ICcwMicgfHwgZ2VuID09PSAnMDUnKSB7XG4gICAgICAvLyB3ZSdkIGJlIGFibGUgdG8gY2hlY2sgdGhlIGdlbmVyYXRvclxuICAgICAgLy8gaXQgd291bGQgZmFpbCBzbyArOFxuICAgICAgZXJyb3IgKz0gODtcbiAgICB9IGVsc2Uge1xuICAgICAgLy93ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIHRlc3QgdGhlIGdlbmVyYXRvclxuICAgICAgLy8gc28gKzRcbiAgICAgIGVycm9yICs9IDQ7XG4gICAgfVxuICAgIHByaW1lQ2FjaGVbaGV4XSA9IGVycm9yO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAoIW1pbGxlclJhYmluLnRlc3QocHJpbWUuc2hybigxKSkpIHtcbiAgICAvL25vdCBhIHNhZmUgcHJpbWVcbiAgICBlcnJvciArPSAyO1xuICB9XG4gIHZhciByZW07XG4gIHN3aXRjaCAoZ2VuKSB7XG4gICAgY2FzZSAnMDInOlxuICAgICAgaWYgKHByaW1lLm1vZChUV0VOVFlGT1VSKS5jbXAoRUxFVkVOKSkge1xuICAgICAgICAvLyB1bnN1aWRhYmxlIGdlbmVyYXRvclxuICAgICAgICBlcnJvciArPSA4O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnMDUnOlxuICAgICAgcmVtID0gcHJpbWUubW9kKFRFTik7XG4gICAgICBpZiAocmVtLmNtcChUSFJFRSkgJiYgcmVtLmNtcChTRVZFTikpIHtcbiAgICAgICAgLy8gcHJpbWUgbW9kIDEwIG5lZWRzIHRvIGVxdWFsIDMgb3IgN1xuICAgICAgICBlcnJvciArPSA4O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGVycm9yICs9IDQ7XG4gIH1cbiAgcHJpbWVDYWNoZVtoZXhdID0gZXJyb3I7XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gREgocHJpbWUsIGdlbmVyYXRvciwgbWFsbGVhYmxlKSB7XG4gIHRoaXMuc2V0R2VuZXJhdG9yKGdlbmVyYXRvcik7XG4gIHRoaXMuX19wcmltZSA9IG5ldyBCTihwcmltZSk7XG4gIHRoaXMuX3ByaW1lID0gQk4ubW9udCh0aGlzLl9fcHJpbWUpO1xuICB0aGlzLl9wcmltZUxlbiA9IHByaW1lLmxlbmd0aDtcbiAgdGhpcy5fcHViID0gdW5kZWZpbmVkO1xuICB0aGlzLl9wcml2ID0gdW5kZWZpbmVkO1xuICB0aGlzLl9wcmltZUNvZGUgPSB1bmRlZmluZWQ7XG4gIGlmIChtYWxsZWFibGUpIHtcbiAgICB0aGlzLnNldFB1YmxpY0tleSA9IHNldFB1YmxpY0tleTtcbiAgICB0aGlzLnNldFByaXZhdGVLZXkgPSBzZXRQcml2YXRlS2V5O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3ByaW1lQ29kZSA9IDg7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShESC5wcm90b3R5cGUsICd2ZXJpZnlFcnJvcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9wcmltZUNvZGUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLl9wcmltZUNvZGUgPSBjaGVja1ByaW1lKHRoaXMuX19wcmltZSwgdGhpcy5fX2dlbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcmltZUNvZGU7XG4gIH1cbn0pO1xuREgucHJvdG90eXBlLmdlbmVyYXRlS2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9wcml2KSB7XG4gICAgdGhpcy5fcHJpdiA9IG5ldyBCTihyYW5kb21CeXRlcyh0aGlzLl9wcmltZUxlbikpO1xuICB9XG4gIHRoaXMuX3B1YiA9IHRoaXMuX2dlbi50b1JlZCh0aGlzLl9wcmltZSkucmVkUG93KHRoaXMuX3ByaXYpLmZyb21SZWQoKTtcbiAgcmV0dXJuIHRoaXMuZ2V0UHVibGljS2V5KCk7XG59O1xuXG5ESC5wcm90b3R5cGUuY29tcHV0ZVNlY3JldCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBvdGhlciA9IG5ldyBCTihvdGhlcik7XG4gIG90aGVyID0gb3RoZXIudG9SZWQodGhpcy5fcHJpbWUpO1xuICB2YXIgc2VjcmV0ID0gb3RoZXIucmVkUG93KHRoaXMuX3ByaXYpLmZyb21SZWQoKTtcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoc2VjcmV0LnRvQXJyYXkoKSk7XG4gIHZhciBwcmltZSA9IHRoaXMuZ2V0UHJpbWUoKTtcbiAgaWYgKG91dC5sZW5ndGggPCBwcmltZS5sZW5ndGgpIHtcbiAgICB2YXIgZnJvbnQgPSBuZXcgQnVmZmVyKHByaW1lLmxlbmd0aCAtIG91dC5sZW5ndGgpO1xuICAgIGZyb250LmZpbGwoMCk7XG4gICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbZnJvbnQsIG91dF0pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5ESC5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gZ2V0UHVibGljS2V5KGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5fcHViLCBlbmMpO1xufTtcblxuREgucHJvdG90eXBlLmdldFByaXZhdGVLZXkgPSBmdW5jdGlvbiBnZXRQcml2YXRlS2V5KGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5fcHJpdiwgZW5jKTtcbn07XG5cbkRILnByb3RvdHlwZS5nZXRQcmltZSA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMuX19wcmltZSwgZW5jKTtcbn07XG5cbkRILnByb3RvdHlwZS5nZXRHZW5lcmF0b3IgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLl9nZW4sIGVuYyk7XG59O1xuXG5ESC5wcm90b3R5cGUuc2V0R2VuZXJhdG9yID0gZnVuY3Rpb24gKGdlbiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGdlbikpIHtcbiAgICBnZW4gPSBuZXcgQnVmZmVyKGdlbiwgZW5jKTtcbiAgfVxuICB0aGlzLl9fZ2VuID0gZ2VuO1xuICB0aGlzLl9nZW4gPSBuZXcgQk4oZ2VuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRSZXR1cm5WYWx1ZShibiwgZW5jKSB7XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGJuLnRvQXJyYXkoKSk7XG4gIGlmICghZW5jKSB7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmLnRvU3RyaW5nKGVuYyk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kaWZmaWUtaGVsbG1hbi9saWIvZGguanNcbi8vIG1vZHVsZSBpZCA9IDIxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJtb2RwMVwiOiB7XG5cdFx0XCJnZW5cIjogXCIwMlwiLFxuXHRcdFwicHJpbWVcIjogXCJmZmZmZmZmZmZmZmZmZmZmYzkwZmRhYTIyMTY4YzIzNGM0YzY2MjhiODBkYzFjZDEyOTAyNGUwODhhNjdjYzc0MDIwYmJlYTYzYjEzOWIyMjUxNGEwODc5OGUzNDA0ZGRlZjk1MTliM2NkM2E0MzFiMzAyYjBhNmRmMjVmMTQzNzRmZTEzNTZkNmQ1MWMyNDVlNDg1YjU3NjYyNWU3ZWM2ZjQ0YzQyZTlhNjNhMzYyMGZmZmZmZmZmZmZmZmZmZmZcIlxuXHR9LFxuXHRcIm1vZHAyXCI6IHtcblx0XHRcImdlblwiOiBcIjAyXCIsXG5cdFx0XCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U2NTM4MWZmZmZmZmZmZmZmZmZmZmZcIlxuXHR9LFxuXHRcIm1vZHA1XCI6IHtcblx0XHRcImdlblwiOiBcIjAyXCIsXG5cdFx0XCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMjM3MzI3ZmZmZmZmZmZmZmZmZmZmZlwiXG5cdH0sXG5cdFwibW9kcDE0XCI6IHtcblx0XHRcImdlblwiOiBcIjAyXCIsXG5cdFx0XCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMTgyMTdjMzI5MDVlNDYyZTM2Y2UzYmUzOWU3NzJjMTgwZTg2MDM5YjI3ODNhMmVjMDdhMjhmYjVjNTVkZjA2ZjRjNTJjOWRlMmJjYmY2OTU1ODE3MTgzOTk1NDk3Y2VhOTU2YWU1MTVkMjI2MTg5OGZhMDUxMDE1NzI4ZTVhOGFhY2FhNjhmZmZmZmZmZmZmZmZmZmZmXCJcblx0fSxcblx0XCJtb2RwMTVcIjoge1xuXHRcdFwiZ2VuXCI6IFwiMDJcIixcblx0XHRcInByaW1lXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmM5MGZkYWEyMjE2OGMyMzRjNGM2NjI4YjgwZGMxY2QxMjkwMjRlMDg4YTY3Y2M3NDAyMGJiZWE2M2IxMzliMjI1MTRhMDg3OThlMzQwNGRkZWY5NTE5YjNjZDNhNDMxYjMwMmIwYTZkZjI1ZjE0Mzc0ZmUxMzU2ZDZkNTFjMjQ1ZTQ4NWI1NzY2MjVlN2VjNmY0NGM0MmU5YTYzN2VkNmIwYmZmNWNiNmY0MDZiN2VkZWUzODZiZmI1YTg5OWZhNWFlOWYyNDExN2M0YjFmZTY0OTI4NjY1MWVjZTQ1YjNkYzIwMDdjYjhhMTYzYmYwNTk4ZGE0ODM2MWM1NWQzOWE2OTE2M2ZhOGZkMjRjZjVmODM2NTVkMjNkY2EzYWQ5NjFjNjJmMzU2MjA4NTUyYmI5ZWQ1MjkwNzcwOTY5NjZkNjcwYzM1NGU0YWJjOTgwNGYxNzQ2YzA4Y2ExODIxN2MzMjkwNWU0NjJlMzZjZTNiZTM5ZTc3MmMxODBlODYwMzliMjc4M2EyZWMwN2EyOGZiNWM1NWRmMDZmNGM1MmM5ZGUyYmNiZjY5NTU4MTcxODM5OTU0OTdjZWE5NTZhZTUxNWQyMjYxODk4ZmEwNTEwMTU3MjhlNWE4YWFhYzQyZGFkMzMxNzBkMDQ1MDdhMzNhODU1MjFhYmRmMWNiYTY0ZWNmYjg1MDQ1OGRiZWYwYThhZWE3MTU3NWQwNjBjN2RiMzk3MGY4NWE2ZTFlNGM3YWJmNWFlOGNkYjA5MzNkNzFlOGM5NGUwNGEyNTYxOWRjZWUzZDIyNjFhZDJlZTZiZjEyZmZhMDZkOThhMDg2NGQ4NzYwMjczM2VjODZhNjQ1MjFmMmIxODE3N2IyMDBjYmJlMTE3NTc3YTYxNWQ2Yzc3MDk4OGMwYmFkOTQ2ZTIwOGUyNGZhMDc0ZTVhYjMxNDNkYjViZmNlMGZkMTA4ZTRiODJkMTIwYTkzYWQyY2FmZmZmZmZmZmZmZmZmZmZmXCJcblx0fSxcblx0XCJtb2RwMTZcIjoge1xuXHRcdFwiZ2VuXCI6IFwiMDJcIixcblx0XHRcInByaW1lXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmM5MGZkYWEyMjE2OGMyMzRjNGM2NjI4YjgwZGMxY2QxMjkwMjRlMDg4YTY3Y2M3NDAyMGJiZWE2M2IxMzliMjI1MTRhMDg3OThlMzQwNGRkZWY5NTE5YjNjZDNhNDMxYjMwMmIwYTZkZjI1ZjE0Mzc0ZmUxMzU2ZDZkNTFjMjQ1ZTQ4NWI1NzY2MjVlN2VjNmY0NGM0MmU5YTYzN2VkNmIwYmZmNWNiNmY0MDZiN2VkZWUzODZiZmI1YTg5OWZhNWFlOWYyNDExN2M0YjFmZTY0OTI4NjY1MWVjZTQ1YjNkYzIwMDdjYjhhMTYzYmYwNTk4ZGE0ODM2MWM1NWQzOWE2OTE2M2ZhOGZkMjRjZjVmODM2NTVkMjNkY2EzYWQ5NjFjNjJmMzU2MjA4NTUyYmI5ZWQ1MjkwNzcwOTY5NjZkNjcwYzM1NGU0YWJjOTgwNGYxNzQ2YzA4Y2ExODIxN2MzMjkwNWU0NjJlMzZjZTNiZTM5ZTc3MmMxODBlODYwMzliMjc4M2EyZWMwN2EyOGZiNWM1NWRmMDZmNGM1MmM5ZGUyYmNiZjY5NTU4MTcxODM5OTU0OTdjZWE5NTZhZTUxNWQyMjYxODk4ZmEwNTEwMTU3MjhlNWE4YWFhYzQyZGFkMzMxNzBkMDQ1MDdhMzNhODU1MjFhYmRmMWNiYTY0ZWNmYjg1MDQ1OGRiZWYwYThhZWE3MTU3NWQwNjBjN2RiMzk3MGY4NWE2ZTFlNGM3YWJmNWFlOGNkYjA5MzNkNzFlOGM5NGUwNGEyNTYxOWRjZWUzZDIyNjFhZDJlZTZiZjEyZmZhMDZkOThhMDg2NGQ4NzYwMjczM2VjODZhNjQ1MjFmMmIxODE3N2IyMDBjYmJlMTE3NTc3YTYxNWQ2Yzc3MDk4OGMwYmFkOTQ2ZTIwOGUyNGZhMDc0ZTVhYjMxNDNkYjViZmNlMGZkMTA4ZTRiODJkMTIwYTkyMTA4MDExYTcyM2MxMmE3ODdlNmQ3ODg3MTlhMTBiZGJhNWIyNjk5YzMyNzE4NmFmNGUyM2MxYTk0NjgzNGI2MTUwYmRhMjU4M2U5Y2EyYWQ0NGNlOGRiYmJjMmRiMDRkZThlZjkyZThlZmMxNDFmYmVjYWE2Mjg3YzU5NDc0ZTZiYzA1ZDk5YjI5NjRmYTA5MGMzYTIyMzNiYTE4NjUxNWJlN2VkMWY2MTI5NzBjZWUyZDdhZmI4MWJkZDc2MjE3MDQ4MWNkMDA2OTEyN2Q1YjA1YWE5OTNiNGVhOTg4ZDhmZGRjMTg2ZmZiN2RjOTBhNmMwOGY0ZGY0MzVjOTM0MDYzMTk5ZmZmZmZmZmZmZmZmZmZmZlwiXG5cdH0sXG5cdFwibW9kcDE3XCI6IHtcblx0XHRcImdlblwiOiBcIjAyXCIsXG5cdFx0XCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMTgyMTdjMzI5MDVlNDYyZTM2Y2UzYmUzOWU3NzJjMTgwZTg2MDM5YjI3ODNhMmVjMDdhMjhmYjVjNTVkZjA2ZjRjNTJjOWRlMmJjYmY2OTU1ODE3MTgzOTk1NDk3Y2VhOTU2YWU1MTVkMjI2MTg5OGZhMDUxMDE1NzI4ZTVhOGFhYWM0MmRhZDMzMTcwZDA0NTA3YTMzYTg1NTIxYWJkZjFjYmE2NGVjZmI4NTA0NThkYmVmMGE4YWVhNzE1NzVkMDYwYzdkYjM5NzBmODVhNmUxZTRjN2FiZjVhZThjZGIwOTMzZDcxZThjOTRlMDRhMjU2MTlkY2VlM2QyMjYxYWQyZWU2YmYxMmZmYTA2ZDk4YTA4NjRkODc2MDI3MzNlYzg2YTY0NTIxZjJiMTgxNzdiMjAwY2JiZTExNzU3N2E2MTVkNmM3NzA5ODhjMGJhZDk0NmUyMDhlMjRmYTA3NGU1YWIzMTQzZGI1YmZjZTBmZDEwOGU0YjgyZDEyMGE5MjEwODAxMWE3MjNjMTJhNzg3ZTZkNzg4NzE5YTEwYmRiYTViMjY5OWMzMjcxODZhZjRlMjNjMWE5NDY4MzRiNjE1MGJkYTI1ODNlOWNhMmFkNDRjZThkYmJiYzJkYjA0ZGU4ZWY5MmU4ZWZjMTQxZmJlY2FhNjI4N2M1OTQ3NGU2YmMwNWQ5OWIyOTY0ZmEwOTBjM2EyMjMzYmExODY1MTViZTdlZDFmNjEyOTcwY2VlMmQ3YWZiODFiZGQ3NjIxNzA0ODFjZDAwNjkxMjdkNWIwNWFhOTkzYjRlYTk4OGQ4ZmRkYzE4NmZmYjdkYzkwYTZjMDhmNGRmNDM1YzkzNDAyODQ5MjM2YzNmYWI0ZDI3YzcwMjZjMWQ0ZGNiMjYwMjY0NmRlYzk3NTFlNzYzZGJhMzdiZGY4ZmY5NDA2YWQ5ZTUzMGVlNWRiMzgyZjQxMzAwMWFlYjA2YTUzZWQ5MDI3ZDgzMTE3OTcyN2IwODY1YTg5MThkYTNlZGJlYmNmOWIxNGVkNDRjZTZjYmFjZWQ0YmIxYmRiN2YxNDQ3ZTZjYzI1NGIzMzIwNTE1MTJiZDdhZjQyNmZiOGY0MDEzNzhjZDJiZjU5ODNjYTAxYzY0YjkyZWNmMDMyZWExNWQxNzIxZDAzZjQ4MmQ3Y2U2ZTc0ZmVmNmQ1NWU3MDJmNDY5ODBjODJiNWE4NDAzMTkwMGIxYzllNTllN2M5N2ZiZWM3ZThmMzIzYTk3YTdlMzZjYzg4YmUwZjFkNDViN2ZmNTg1YWM1NGJkNDA3YjIyYjQxNTRhYWNjOGY2ZDdlYmY0OGUxZDgxNGNjNWVkMjBmODAzN2UwYTc5NzE1ZWVmMjliZTMyODA2YTFkNThiYjdjNWRhNzZmNTUwYWEzZDhhMWZiZmYwZWIxOWNjYjFhMzEzZDU1Y2RhNTZjOWVjMmVmMjk2MzIzODdmZThkNzZlM2MwNDY4MDQzZThmNjYzZjQ4NjBlZTEyYmYyZDViMGI3NDc0ZDZlNjk0ZjkxZTZkY2M0MDI0ZmZmZmZmZmZmZmZmZmZmZlwiXG5cdH0sXG5cdFwibW9kcDE4XCI6IHtcblx0XHRcImdlblwiOiBcIjAyXCIsXG5cdFx0XCJwcmltZVwiOiBcImZmZmZmZmZmZmZmZmZmZmZjOTBmZGFhMjIxNjhjMjM0YzRjNjYyOGI4MGRjMWNkMTI5MDI0ZTA4OGE2N2NjNzQwMjBiYmVhNjNiMTM5YjIyNTE0YTA4Nzk4ZTM0MDRkZGVmOTUxOWIzY2QzYTQzMWIzMDJiMGE2ZGYyNWYxNDM3NGZlMTM1NmQ2ZDUxYzI0NWU0ODViNTc2NjI1ZTdlYzZmNDRjNDJlOWE2MzdlZDZiMGJmZjVjYjZmNDA2YjdlZGVlMzg2YmZiNWE4OTlmYTVhZTlmMjQxMTdjNGIxZmU2NDkyODY2NTFlY2U0NWIzZGMyMDA3Y2I4YTE2M2JmMDU5OGRhNDgzNjFjNTVkMzlhNjkxNjNmYThmZDI0Y2Y1ZjgzNjU1ZDIzZGNhM2FkOTYxYzYyZjM1NjIwODU1MmJiOWVkNTI5MDc3MDk2OTY2ZDY3MGMzNTRlNGFiYzk4MDRmMTc0NmMwOGNhMTgyMTdjMzI5MDVlNDYyZTM2Y2UzYmUzOWU3NzJjMTgwZTg2MDM5YjI3ODNhMmVjMDdhMjhmYjVjNTVkZjA2ZjRjNTJjOWRlMmJjYmY2OTU1ODE3MTgzOTk1NDk3Y2VhOTU2YWU1MTVkMjI2MTg5OGZhMDUxMDE1NzI4ZTVhOGFhYWM0MmRhZDMzMTcwZDA0NTA3YTMzYTg1NTIxYWJkZjFjYmE2NGVjZmI4NTA0NThkYmVmMGE4YWVhNzE1NzVkMDYwYzdkYjM5NzBmODVhNmUxZTRjN2FiZjVhZThjZGIwOTMzZDcxZThjOTRlMDRhMjU2MTlkY2VlM2QyMjYxYWQyZWU2YmYxMmZmYTA2ZDk4YTA4NjRkODc2MDI3MzNlYzg2YTY0NTIxZjJiMTgxNzdiMjAwY2JiZTExNzU3N2E2MTVkNmM3NzA5ODhjMGJhZDk0NmUyMDhlMjRmYTA3NGU1YWIzMTQzZGI1YmZjZTBmZDEwOGU0YjgyZDEyMGE5MjEwODAxMWE3MjNjMTJhNzg3ZTZkNzg4NzE5YTEwYmRiYTViMjY5OWMzMjcxODZhZjRlMjNjMWE5NDY4MzRiNjE1MGJkYTI1ODNlOWNhMmFkNDRjZThkYmJiYzJkYjA0ZGU4ZWY5MmU4ZWZjMTQxZmJlY2FhNjI4N2M1OTQ3NGU2YmMwNWQ5OWIyOTY0ZmEwOTBjM2EyMjMzYmExODY1MTViZTdlZDFmNjEyOTcwY2VlMmQ3YWZiODFiZGQ3NjIxNzA0ODFjZDAwNjkxMjdkNWIwNWFhOTkzYjRlYTk4OGQ4ZmRkYzE4NmZmYjdkYzkwYTZjMDhmNGRmNDM1YzkzNDAyODQ5MjM2YzNmYWI0ZDI3YzcwMjZjMWQ0ZGNiMjYwMjY0NmRlYzk3NTFlNzYzZGJhMzdiZGY4ZmY5NDA2YWQ5ZTUzMGVlNWRiMzgyZjQxMzAwMWFlYjA2YTUzZWQ5MDI3ZDgzMTE3OTcyN2IwODY1YTg5MThkYTNlZGJlYmNmOWIxNGVkNDRjZTZjYmFjZWQ0YmIxYmRiN2YxNDQ3ZTZjYzI1NGIzMzIwNTE1MTJiZDdhZjQyNmZiOGY0MDEzNzhjZDJiZjU5ODNjYTAxYzY0YjkyZWNmMDMyZWExNWQxNzIxZDAzZjQ4MmQ3Y2U2ZTc0ZmVmNmQ1NWU3MDJmNDY5ODBjODJiNWE4NDAzMTkwMGIxYzllNTllN2M5N2ZiZWM3ZThmMzIzYTk3YTdlMzZjYzg4YmUwZjFkNDViN2ZmNTg1YWM1NGJkNDA3YjIyYjQxNTRhYWNjOGY2ZDdlYmY0OGUxZDgxNGNjNWVkMjBmODAzN2UwYTc5NzE1ZWVmMjliZTMyODA2YTFkNThiYjdjNWRhNzZmNTUwYWEzZDhhMWZiZmYwZWIxOWNjYjFhMzEzZDU1Y2RhNTZjOWVjMmVmMjk2MzIzODdmZThkNzZlM2MwNDY4MDQzZThmNjYzZjQ4NjBlZTEyYmYyZDViMGI3NDc0ZDZlNjk0ZjkxZTZkYmUxMTU5NzRhMzkyNmYxMmZlZTVlNDM4Nzc3Y2I2YTkzMmRmOGNkOGJlYzRkMDczYjkzMWJhM2JjODMyYjY4ZDlkZDMwMDc0MWZhN2JmOGFmYzQ3ZWQyNTc2ZjY5MzZiYTQyNDY2M2FhYjYzOWM1YWU0ZjU2ODM0MjNiNDc0MmJmMWM5NzgyMzhmMTZjYmUzOWQ2NTJkZTNmZGI4YmVmYzg0OGFkOTIyMjIyZTA0YTQwMzdjMDcxM2ViNTdhODFhMjNmMGM3MzQ3M2ZjNjQ2Y2VhMzA2YjRiY2JjODg2MmY4Mzg1ZGRmYTlkNGI3ZmEyYzA4N2U4Nzk2ODMzMDNlZDViZGQzYTA2MmIzY2Y1YjNhMjc4YTY2ZDJhMTNmODNmNDRmODJkZGYzMTBlZTA3NGFiNmEzNjQ1OTdlODk5YTAyNTVkYzE2NGYzMWNjNTA4NDY4NTFkZjlhYjQ4MTk1ZGVkN2VhMWIxZDUxMGJkN2VlNzRkNzNmYWYzNmJjMzFlY2ZhMjY4MzU5MDQ2ZjRlYjg3OWY5MjQwMDk0MzhiNDgxYzZjZDc4ODlhMDAyZWQ1ZWUzODJiYzkxOTBkYTZmYzAyNmU0Nzk1NThlNDQ3NTY3N2U5YWE5ZTMwNTBlMjc2NTY5NGRmYzgxZjU2ZTg4MGI5NmU3MTYwYzk4MGRkOThlZGQzZGZmZmZmZmZmZmZmZmZmZmZmXCJcblx0fVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZGlmZmllLWhlbGxtYW4vbGliL3ByaW1lcy5qc29uXG4vLyBtb2R1bGUgaWQgPSAyMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGdldE5BRiA9IHV0aWxzLmdldE5BRjtcbnZhciBnZXRKU0YgPSB1dGlscy5nZXRKU0Y7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBCYXNlQ3VydmUodHlwZSwgY29uZikge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnAgPSBuZXcgQk4oY29uZi5wLCAxNik7XG5cbiAgLy8gVXNlIE1vbnRnb21lcnksIHdoZW4gdGhlcmUgaXMgbm8gZmFzdCByZWR1Y3Rpb24gZm9yIHRoZSBwcmltZVxuICB0aGlzLnJlZCA9IGNvbmYucHJpbWUgPyBCTi5yZWQoY29uZi5wcmltZSkgOiBCTi5tb250KHRoaXMucCk7XG5cbiAgLy8gVXNlZnVsIGZvciBtYW55IGN1cnZlc1xuICB0aGlzLnplcm8gPSBuZXcgQk4oMCkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLm9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMudHdvID0gbmV3IEJOKDIpLnRvUmVkKHRoaXMucmVkKTtcblxuICAvLyBDdXJ2ZSBjb25maWd1cmF0aW9uLCBvcHRpb25hbFxuICB0aGlzLm4gPSBjb25mLm4gJiYgbmV3IEJOKGNvbmYubiwgMTYpO1xuICB0aGlzLmcgPSBjb25mLmcgJiYgdGhpcy5wb2ludEZyb21KU09OKGNvbmYuZywgY29uZi5nUmVkKTtcblxuICAvLyBUZW1wb3JhcnkgYXJyYXlzXG4gIHRoaXMuX3duYWZUMSA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQyID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDMgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUNCA9IG5ldyBBcnJheSg0KTtcblxuICAvLyBHZW5lcmFsaXplZCBHcmVnIE1heHdlbGwncyB0cmlja1xuICB2YXIgYWRqdXN0Q291bnQgPSB0aGlzLm4gJiYgdGhpcy5wLmRpdih0aGlzLm4pO1xuICBpZiAoIWFkanVzdENvdW50IHx8IGFkanVzdENvdW50LmNtcG4oMTAwKSA+IDApIHtcbiAgICB0aGlzLnJlZE4gPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX21heHdlbGxUcmljayA9IHRydWU7XG4gICAgdGhpcy5yZWROID0gdGhpcy5uLnRvUmVkKHRoaXMucmVkKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBCYXNlQ3VydmU7XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX2ZpeGVkTmFmTXVsID0gZnVuY3Rpb24gX2ZpeGVkTmFmTXVsKHAsIGspIHtcbiAgYXNzZXJ0KHAucHJlY29tcHV0ZWQpO1xuICB2YXIgZG91YmxlcyA9IHAuX2dldERvdWJsZXMoKTtcblxuICB2YXIgbmFmID0gZ2V0TkFGKGssIDEpO1xuICB2YXIgSSA9ICgxIDw8IChkb3VibGVzLnN0ZXAgKyAxKSkgLSAoZG91Ymxlcy5zdGVwICUgMiA9PT0gMCA/IDIgOiAxKTtcbiAgSSAvPSAzO1xuXG4gIC8vIFRyYW5zbGF0ZSBpbnRvIG1vcmUgd2luZG93ZWQgZm9ybVxuICB2YXIgcmVwciA9IFtdO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IG5hZi5sZW5ndGg7IGogKz0gZG91Ymxlcy5zdGVwKSB7XG4gICAgdmFyIG5hZlcgPSAwO1xuICAgIGZvciAodmFyIGsgPSBqICsgZG91Ymxlcy5zdGVwIC0gMTsgayA+PSBqOyBrLS0pXG4gICAgICBuYWZXID0gKG5hZlcgPDwgMSkgKyBuYWZba107XG4gICAgcmVwci5wdXNoKG5hZlcpO1xuICB9XG5cbiAgdmFyIGEgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgdmFyIGIgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgZm9yICh2YXIgaSA9IEk7IGkgPiAwOyBpLS0pIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcHIubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBuYWZXID0gcmVwcltqXTtcbiAgICAgIGlmIChuYWZXID09PSBpKVxuICAgICAgICBiID0gYi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXSk7XG4gICAgICBlbHNlIGlmIChuYWZXID09PSAtaSlcbiAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0ubmVnKCkpO1xuICAgIH1cbiAgICBhID0gYS5hZGQoYik7XG4gIH1cbiAgcmV0dXJuIGEudG9QKCk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsID0gZnVuY3Rpb24gX3duYWZNdWwocCwgaykge1xuICB2YXIgdyA9IDQ7XG5cbiAgLy8gUHJlY29tcHV0ZSB3aW5kb3dcbiAgdmFyIG5hZlBvaW50cyA9IHAuX2dldE5BRlBvaW50cyh3KTtcbiAgdyA9IG5hZlBvaW50cy53bmQ7XG4gIHZhciB3bmQgPSBuYWZQb2ludHMucG9pbnRzO1xuXG4gIC8vIEdldCBOQUYgZm9ybVxuICB2YXIgbmFmID0gZ2V0TkFGKGssIHcpO1xuXG4gIC8vIEFkZCBgdGhpc2AqKE4rMSkgZm9yIGV2ZXJ5IHctTkFGIGluZGV4XG4gIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgZm9yICh2YXIgaSA9IG5hZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIC8vIENvdW50IHplcm9lc1xuICAgIGZvciAodmFyIGsgPSAwOyBpID49IDAgJiYgbmFmW2ldID09PSAwOyBpLS0pXG4gICAgICBrKys7XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGsrKztcbiAgICBhY2MgPSBhY2MuZGJscChrKTtcblxuICAgIGlmIChpIDwgMClcbiAgICAgIGJyZWFrO1xuICAgIHZhciB6ID0gbmFmW2ldO1xuICAgIGFzc2VydCh6ICE9PSAwKTtcbiAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJykge1xuICAgICAgLy8gSiArLSBQXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBKICstIEpcbiAgICAgIGlmICh6ID4gMClcbiAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHAudHlwZSA9PT0gJ2FmZmluZScgPyBhY2MudG9QKCkgOiBhY2M7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsQWRkID0gZnVuY3Rpb24gX3duYWZNdWxBZGQoZGVmVyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqYWNvYmlhblJlc3VsdCkge1xuICB2YXIgd25kV2lkdGggPSB0aGlzLl93bmFmVDE7XG4gIHZhciB3bmQgPSB0aGlzLl93bmFmVDI7XG4gIHZhciBuYWYgPSB0aGlzLl93bmFmVDM7XG5cbiAgLy8gRmlsbCBhbGwgYXJyYXlzXG4gIHZhciBtYXggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgdmFyIG5hZlBvaW50cyA9IHAuX2dldE5BRlBvaW50cyhkZWZXKTtcbiAgICB3bmRXaWR0aFtpXSA9IG5hZlBvaW50cy53bmQ7XG4gICAgd25kW2ldID0gbmFmUG9pbnRzLnBvaW50cztcbiAgfVxuXG4gIC8vIENvbWIgc21hbGwgd2luZG93IE5BRnNcbiAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMTsgaSAtPSAyKSB7XG4gICAgdmFyIGEgPSBpIC0gMTtcbiAgICB2YXIgYiA9IGk7XG4gICAgaWYgKHduZFdpZHRoW2FdICE9PSAxIHx8IHduZFdpZHRoW2JdICE9PSAxKSB7XG4gICAgICBuYWZbYV0gPSBnZXROQUYoY29lZmZzW2FdLCB3bmRXaWR0aFthXSk7XG4gICAgICBuYWZbYl0gPSBnZXROQUYoY29lZmZzW2JdLCB3bmRXaWR0aFtiXSk7XG4gICAgICBtYXggPSBNYXRoLm1heChuYWZbYV0ubGVuZ3RoLCBtYXgpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2JdLmxlbmd0aCwgbWF4KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjb21iID0gW1xuICAgICAgcG9pbnRzW2FdLCAvKiAxICovXG4gICAgICBudWxsLCAvKiAzICovXG4gICAgICBudWxsLCAvKiA1ICovXG4gICAgICBwb2ludHNbYl0gLyogNyAqL1xuICAgIF07XG5cbiAgICAvLyBUcnkgdG8gYXZvaWQgUHJvamVjdGl2ZSBwb2ludHMsIGlmIHBvc3NpYmxlXG4gICAgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueSkgPT09IDApIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfSBlbHNlIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkucmVkTmVnKCkpID09PSAwKSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gW1xuICAgICAgLTMsIC8qIC0xIC0xICovXG4gICAgICAtMSwgLyogLTEgMCAqL1xuICAgICAgLTUsIC8qIC0xIDEgKi9cbiAgICAgIC03LCAvKiAwIC0xICovXG4gICAgICAwLCAvKiAwIDAgKi9cbiAgICAgIDcsIC8qIDAgMSAqL1xuICAgICAgNSwgLyogMSAtMSAqL1xuICAgICAgMSwgLyogMSAwICovXG4gICAgICAzICAvKiAxIDEgKi9cbiAgICBdO1xuXG4gICAgdmFyIGpzZiA9IGdldEpTRihjb2VmZnNbYV0sIGNvZWZmc1tiXSk7XG4gICAgbWF4ID0gTWF0aC5tYXgoanNmWzBdLmxlbmd0aCwgbWF4KTtcbiAgICBuYWZbYV0gPSBuZXcgQXJyYXkobWF4KTtcbiAgICBuYWZbYl0gPSBuZXcgQXJyYXkobWF4KTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1heDsgaisrKSB7XG4gICAgICB2YXIgamEgPSBqc2ZbMF1bal0gfCAwO1xuICAgICAgdmFyIGpiID0ganNmWzFdW2pdIHwgMDtcblxuICAgICAgbmFmW2FdW2pdID0gaW5kZXhbKGphICsgMSkgKiAzICsgKGpiICsgMSldO1xuICAgICAgbmFmW2JdW2pdID0gMDtcbiAgICAgIHduZFthXSA9IGNvbWI7XG4gICAgfVxuICB9XG5cbiAgdmFyIGFjYyA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICB2YXIgdG1wID0gdGhpcy5fd25hZlQ0O1xuICBmb3IgKHZhciBpID0gbWF4OyBpID49IDA7IGktLSkge1xuICAgIHZhciBrID0gMDtcblxuICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgIHZhciB6ZXJvID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgdG1wW2pdID0gbmFmW2pdW2ldIHwgMDtcbiAgICAgICAgaWYgKHRtcFtqXSAhPT0gMClcbiAgICAgICAgICB6ZXJvID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXplcm8pXG4gICAgICAgIGJyZWFrO1xuICAgICAgaysrO1xuICAgICAgaS0tO1xuICAgIH1cbiAgICBpZiAoaSA+PSAwKVxuICAgICAgaysrO1xuICAgIGFjYyA9IGFjYy5kYmxwKGspO1xuICAgIGlmIChpIDwgMClcbiAgICAgIGJyZWFrO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgdmFyIHogPSB0bXBbal07XG4gICAgICB2YXIgcDtcbiAgICAgIGlmICh6ID09PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGVsc2UgaWYgKHogPiAwKVxuICAgICAgICBwID0gd25kW2pdWyh6IC0gMSkgPj4gMV07XG4gICAgICBlbHNlIGlmICh6IDwgMClcbiAgICAgICAgcCA9IHduZFtqXVsoLXogLSAxKSA+PiAxXS5uZWcoKTtcblxuICAgICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZChwKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYWNjID0gYWNjLmFkZChwKTtcbiAgICB9XG4gIH1cbiAgLy8gWmVyb2lmeSByZWZlcmVuY2VzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgd25kW2ldID0gbnVsbDtcblxuICBpZiAoamFjb2JpYW5SZXN1bHQpXG4gICAgcmV0dXJuIGFjYztcbiAgZWxzZVxuICAgIHJldHVybiBhY2MudG9QKCk7XG59O1xuXG5mdW5jdGlvbiBCYXNlUG9pbnQoY3VydmUsIHR5cGUpIHtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnByZWNvbXB1dGVkID0gbnVsbDtcbn1cbkJhc2VDdXJ2ZS5CYXNlUG9pbnQgPSBCYXNlUG9pbnQ7XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSgvKm90aGVyKi8pIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUudmFsaWRhdGUodGhpcyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMsIGVuYykge1xuICBieXRlcyA9IHV0aWxzLnRvQXJyYXkoYnl0ZXMsIGVuYyk7XG5cbiAgdmFyIGxlbiA9IHRoaXMucC5ieXRlTGVuZ3RoKCk7XG5cbiAgLy8gdW5jb21wcmVzc2VkLCBoeWJyaWQtb2RkLCBoeWJyaWQtZXZlblxuICBpZiAoKGJ5dGVzWzBdID09PSAweDA0IHx8IGJ5dGVzWzBdID09PSAweDA2IHx8IGJ5dGVzWzBdID09PSAweDA3KSAmJlxuICAgICAgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gMiAqIGxlbikge1xuICAgIGlmIChieXRlc1swXSA9PT0gMHgwNilcbiAgICAgIGFzc2VydChieXRlc1tieXRlcy5sZW5ndGggLSAxXSAlIDIgPT09IDApO1xuICAgIGVsc2UgaWYgKGJ5dGVzWzBdID09PSAweDA3KVxuICAgICAgYXNzZXJ0KGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMSk7XG5cbiAgICB2YXIgcmVzID0gIHRoaXMucG9pbnQoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzLnNsaWNlKDEgKyBsZW4sIDEgKyAyICogbGVuKSk7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKChieXRlc1swXSA9PT0gMHgwMiB8fCBieXRlc1swXSA9PT0gMHgwMykgJiZcbiAgICAgICAgICAgICAgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRGcm9tWChieXRlcy5zbGljZSgxLCAxICsgbGVuKSwgYnl0ZXNbMF0gPT09IDB4MDMpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwb2ludCBmb3JtYXQnKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIGVuY29kZUNvbXByZXNzZWQoZW5jKSB7XG4gIHJldHVybiB0aGlzLmVuY29kZShlbmMsIHRydWUpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gX2VuY29kZShjb21wYWN0KSB7XG4gIHZhciBsZW4gPSB0aGlzLmN1cnZlLnAuYnl0ZUxlbmd0aCgpO1xuICB2YXIgeCA9IHRoaXMuZ2V0WCgpLnRvQXJyYXkoJ2JlJywgbGVuKTtcblxuICBpZiAoY29tcGFjdClcbiAgICByZXR1cm4gWyB0aGlzLmdldFkoKS5pc0V2ZW4oKSA/IDB4MDIgOiAweDAzIF0uY29uY2F0KHgpO1xuXG4gIHJldHVybiBbIDB4MDQgXS5jb25jYXQoeCwgdGhpcy5nZXRZKCkudG9BcnJheSgnYmUnLCBsZW4pKSA7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShlbmMsIGNvbXBhY3QpIHtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZSh0aGlzLl9lbmNvZGUoY29tcGFjdCksIGVuYyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLnByZWNvbXB1dGUgPSBmdW5jdGlvbiBwcmVjb21wdXRlKHBvd2VyKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHZhciBwcmVjb21wdXRlZCA9IHtcbiAgICBkb3VibGVzOiBudWxsLFxuICAgIG5hZjogbnVsbCxcbiAgICBiZXRhOiBudWxsXG4gIH07XG4gIHByZWNvbXB1dGVkLm5hZiA9IHRoaXMuX2dldE5BRlBvaW50cyg4KTtcbiAgcHJlY29tcHV0ZWQuZG91YmxlcyA9IHRoaXMuX2dldERvdWJsZXMoNCwgcG93ZXIpO1xuICBwcmVjb21wdXRlZC5iZXRhID0gdGhpcy5fZ2V0QmV0YSgpO1xuICB0aGlzLnByZWNvbXB1dGVkID0gcHJlY29tcHV0ZWQ7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9oYXNEb3VibGVzID0gZnVuY3Rpb24gX2hhc0RvdWJsZXMoaykge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBkb3VibGVzID0gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuICBpZiAoIWRvdWJsZXMpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiBkb3VibGVzLnBvaW50cy5sZW5ndGggPj0gTWF0aC5jZWlsKChrLmJpdExlbmd0aCgpICsgMSkgLyBkb3VibGVzLnN0ZXApO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0RG91YmxlcyA9IGZ1bmN0aW9uIF9nZXREb3VibGVzKHN0ZXAsIHBvd2VyKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkICYmIHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcylcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuXG4gIHZhciBkb3VibGVzID0gWyB0aGlzIF07XG4gIHZhciBhY2MgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvd2VyOyBpICs9IHN0ZXApIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0ZXA7IGorKylcbiAgICAgIGFjYyA9IGFjYy5kYmwoKTtcbiAgICBkb3VibGVzLnB1c2goYWNjKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0ZXA6IHN0ZXAsXG4gICAgcG9pbnRzOiBkb3VibGVzXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXROQUZQb2ludHMgPSBmdW5jdGlvbiBfZ2V0TkFGUG9pbnRzKHduZCkge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLm5hZilcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5uYWY7XG5cbiAgdmFyIHJlcyA9IFsgdGhpcyBdO1xuICB2YXIgbWF4ID0gKDEgPDwgd25kKSAtIDE7XG4gIHZhciBkYmwgPSBtYXggPT09IDEgPyBudWxsIDogdGhpcy5kYmwoKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXg7IGkrKylcbiAgICByZXNbaV0gPSByZXNbaSAtIDFdLmFkZChkYmwpO1xuICByZXR1cm4ge1xuICAgIHduZDogd25kLFxuICAgIHBvaW50czogcmVzXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG4gIHJldHVybiBudWxsO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChrKSB7XG4gIHZhciByID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspXG4gICAgciA9IHIuZGJsKCk7XG4gIHJldHVybiByO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gMjIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY3VydmUnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCYXNlID0gY3VydmUuYmFzZTtcblxudmFyIGFzc2VydCA9IGVsbGlwdGljLnV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gRWR3YXJkc0N1cnZlKGNvbmYpIHtcbiAgLy8gTk9URTogSW1wb3J0YW50IGFzIHdlIGFyZSBjcmVhdGluZyBwb2ludCBpbiBCYXNlLmNhbGwoKVxuICB0aGlzLnR3aXN0ZWQgPSAoY29uZi5hIHwgMCkgIT09IDE7XG4gIHRoaXMubU9uZUEgPSB0aGlzLnR3aXN0ZWQgJiYgKGNvbmYuYSB8IDApID09PSAtMTtcbiAgdGhpcy5leHRlbmRlZCA9IHRoaXMubU9uZUE7XG5cbiAgQmFzZS5jYWxsKHRoaXMsICdlZHdhcmRzJywgY29uZik7XG5cbiAgdGhpcy5hID0gbmV3IEJOKGNvbmYuYSwgMTYpLnVtb2QodGhpcy5yZWQubSk7XG4gIHRoaXMuYSA9IHRoaXMuYS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYyA9IG5ldyBCTihjb25mLmMsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYzIgPSB0aGlzLmMucmVkU3FyKCk7XG4gIHRoaXMuZCA9IG5ldyBCTihjb25mLmQsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuZGQgPSB0aGlzLmQucmVkQWRkKHRoaXMuZCk7XG5cbiAgYXNzZXJ0KCF0aGlzLnR3aXN0ZWQgfHwgdGhpcy5jLmZyb21SZWQoKS5jbXBuKDEpID09PSAwKTtcbiAgdGhpcy5vbmVDID0gKGNvbmYuYyB8IDApID09PSAxO1xufVxuaW5oZXJpdHMoRWR3YXJkc0N1cnZlLCBCYXNlKTtcbm1vZHVsZS5leHBvcnRzID0gRWR3YXJkc0N1cnZlO1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLl9tdWxBID0gZnVuY3Rpb24gX211bEEobnVtKSB7XG4gIGlmICh0aGlzLm1PbmVBKVxuICAgIHJldHVybiBudW0ucmVkTmVnKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5hLnJlZE11bChudW0pO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5fbXVsQyA9IGZ1bmN0aW9uIF9tdWxDKG51bSkge1xuICBpZiAodGhpcy5vbmVDKVxuICAgIHJldHVybiBudW07XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jLnJlZE11bChudW0pO1xufTtcblxuLy8gSnVzdCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIFNob3J0IGN1cnZlXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6LCB0KSB7XG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHksIHosIHQpO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gcG9pbnRGcm9tWCh4LCBvZGQpIHtcbiAgeCA9IG5ldyBCTih4LCAxNik7XG4gIGlmICgheC5yZWQpXG4gICAgeCA9IHgudG9SZWQodGhpcy5yZWQpO1xuXG4gIHZhciB4MiA9IHgucmVkU3FyKCk7XG4gIHZhciByaHMgPSB0aGlzLmMyLnJlZFN1Yih0aGlzLmEucmVkTXVsKHgyKSk7XG4gIHZhciBsaHMgPSB0aGlzLm9uZS5yZWRTdWIodGhpcy5jMi5yZWRNdWwodGhpcy5kKS5yZWRNdWwoeDIpKTtcblxuICB2YXIgeTIgPSByaHMucmVkTXVsKGxocy5yZWRJbnZtKCkpO1xuICB2YXIgeSA9IHkyLnJlZFNxcnQoKTtcbiAgaWYgKHkucmVkU3FyKCkucmVkU3ViKHkyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcblxuICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuICAgIHkgPSB5LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludEZyb21ZID0gZnVuY3Rpb24gcG9pbnRGcm9tWSh5LCBvZGQpIHtcbiAgeSA9IG5ldyBCTih5LCAxNik7XG4gIGlmICgheS5yZWQpXG4gICAgeSA9IHkudG9SZWQodGhpcy5yZWQpO1xuXG4gIC8vIHheMiA9ICh5XjIgLSAxKSAvIChkIHleMiArIDEpXG4gIHZhciB5MiA9IHkucmVkU3FyKCk7XG4gIHZhciBsaHMgPSB5Mi5yZWRTdWIodGhpcy5vbmUpO1xuICB2YXIgcmhzID0geTIucmVkTXVsKHRoaXMuZCkucmVkQWRkKHRoaXMub25lKTtcbiAgdmFyIHgyID0gbGhzLnJlZE11bChyaHMucmVkSW52bSgpKTtcblxuICBpZiAoeDIuY21wKHRoaXMuemVybykgPT09IDApIHtcbiAgICBpZiAob2RkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMucG9pbnQodGhpcy56ZXJvLCB5KTtcbiAgfVxuXG4gIHZhciB4ID0geDIucmVkU3FydCgpO1xuICBpZiAoeC5yZWRTcXIoKS5yZWRTdWIoeDIpLmNtcCh0aGlzLnplcm8pICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuXG4gIGlmICh4LmlzT2RkKCkgIT09IG9kZClcbiAgICB4ID0geC5yZWROZWcoKTtcblxuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICBpZiAocG9pbnQuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIEN1cnZlOiBBICogWF4yICsgWV4yID0gQ14yICogKDEgKyBEICogWF4yICogWV4yKVxuICBwb2ludC5ub3JtYWxpemUoKTtcblxuICB2YXIgeDIgPSBwb2ludC54LnJlZFNxcigpO1xuICB2YXIgeTIgPSBwb2ludC55LnJlZFNxcigpO1xuICB2YXIgbGhzID0geDIucmVkTXVsKHRoaXMuYSkucmVkQWRkKHkyKTtcbiAgdmFyIHJocyA9IHRoaXMuYzIucmVkTXVsKHRoaXMub25lLnJlZEFkZCh0aGlzLmQucmVkTXVsKHgyKS5yZWRNdWwoeTIpKSk7XG5cbiAgcmV0dXJuIGxocy5jbXAocmhzKSA9PT0gMDtcbn07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB5LCB6LCB0KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdwcm9qZWN0aXZlJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHRoaXMuY3VydmUuemVybztcbiAgICB0aGlzLnkgPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnQgPSB0aGlzLmN1cnZlLnplcm87XG4gICAgdGhpcy56T25lID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgdGhpcy56ID0geiA/IG5ldyBCTih6LCAxNikgOiB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnQgPSB0ICYmIG5ldyBCTih0LCAxNik7XG4gICAgaWYgKCF0aGlzLngucmVkKVxuICAgICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMueS5yZWQpXG4gICAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy56LnJlZClcbiAgICAgIHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKHRoaXMudCAmJiAhdGhpcy50LnJlZClcbiAgICAgIHRoaXMudCA9IHRoaXMudC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgdGhpcy56T25lID0gdGhpcy56ID09PSB0aGlzLmN1cnZlLm9uZTtcblxuICAgIC8vIFVzZSBleHRlbmRlZCBjb29yZGluYXRlc1xuICAgIGlmICh0aGlzLmN1cnZlLmV4dGVuZGVkICYmICF0aGlzLnQpIHtcbiAgICAgIHRoaXMudCA9IHRoaXMueC5yZWRNdWwodGhpcy55KTtcbiAgICAgIGlmICghdGhpcy56T25lKVxuICAgICAgICB0aGlzLnQgPSB0aGlzLnQucmVkTXVsKHRoaXMuei5yZWRJbnZtKCkpO1xuICAgIH1cbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmopIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaik7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeSwgeiwgdCkge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHksIHosIHQpO1xufTtcblxuUG9pbnQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihjdXJ2ZSwgb2JqKSB7XG4gIHJldHVybiBuZXcgUG9pbnQoY3VydmUsIG9ialswXSwgb2JqWzFdLCBvYmpbMl0pO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgUG9pbnQgeDogJyArIHRoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgeTogJyArIHRoaXMueS5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy54LmNtcG4oMCkgPT09IDAgJiZcbiAgICAgICAgIHRoaXMueS5jbXAodGhpcy56KSA9PT0gMDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZXh0RGJsID0gZnVuY3Rpb24gX2V4dERibCgpIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQtMS5odG1sXG4gIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDgtaHdjZFxuICAvLyA0TSArIDRTXG5cbiAgLy8gQSA9IFgxXjJcbiAgdmFyIGEgPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIEIgPSBZMV4yXG4gIHZhciBiID0gdGhpcy55LnJlZFNxcigpO1xuICAvLyBDID0gMiAqIFoxXjJcbiAgdmFyIGMgPSB0aGlzLnoucmVkU3FyKCk7XG4gIGMgPSBjLnJlZElBZGQoYyk7XG4gIC8vIEQgPSBhICogQVxuICB2YXIgZCA9IHRoaXMuY3VydmUuX211bEEoYSk7XG4gIC8vIEUgPSAoWDEgKyBZMSleMiAtIEEgLSBCXG4gIHZhciBlID0gdGhpcy54LnJlZEFkZCh0aGlzLnkpLnJlZFNxcigpLnJlZElTdWIoYSkucmVkSVN1YihiKTtcbiAgLy8gRyA9IEQgKyBCXG4gIHZhciBnID0gZC5yZWRBZGQoYik7XG4gIC8vIEYgPSBHIC0gQ1xuICB2YXIgZiA9IGcucmVkU3ViKGMpO1xuICAvLyBIID0gRCAtIEJcbiAgdmFyIGggPSBkLnJlZFN1YihiKTtcbiAgLy8gWDMgPSBFICogRlxuICB2YXIgbnggPSBlLnJlZE11bChmKTtcbiAgLy8gWTMgPSBHICogSFxuICB2YXIgbnkgPSBnLnJlZE11bChoKTtcbiAgLy8gVDMgPSBFICogSFxuICB2YXIgbnQgPSBlLnJlZE11bChoKTtcbiAgLy8gWjMgPSBGICogR1xuICB2YXIgbnogPSBmLnJlZE11bChnKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueiwgbnQpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9wcm9qRGJsID0gZnVuY3Rpb24gX3Byb2pEYmwoKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLXByb2plY3RpdmUuaHRtbFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA4LWJiamxwXG4gIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDctYmxcbiAgLy8gYW5kIG90aGVyc1xuICAvLyBHZW5lcmFsbHkgM00gKyA0UyBvciAyTSArIDRTXG5cbiAgLy8gQiA9IChYMSArIFkxKV4yXG4gIHZhciBiID0gdGhpcy54LnJlZEFkZCh0aGlzLnkpLnJlZFNxcigpO1xuICAvLyBDID0gWDFeMlxuICB2YXIgYyA9IHRoaXMueC5yZWRTcXIoKTtcbiAgLy8gRCA9IFkxXjJcbiAgdmFyIGQgPSB0aGlzLnkucmVkU3FyKCk7XG5cbiAgdmFyIG54O1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgaWYgKHRoaXMuY3VydmUudHdpc3RlZCkge1xuICAgIC8vIEUgPSBhICogQ1xuICAgIHZhciBlID0gdGhpcy5jdXJ2ZS5fbXVsQShjKTtcbiAgICAvLyBGID0gRSArIERcbiAgICB2YXIgZiA9IGUucmVkQWRkKGQpO1xuICAgIGlmICh0aGlzLnpPbmUpIHtcbiAgICAgIC8vIFgzID0gKEIgLSBDIC0gRCkgKiAoRiAtIDIpXG4gICAgICBueCA9IGIucmVkU3ViKGMpLnJlZFN1YihkKS5yZWRNdWwoZi5yZWRTdWIodGhpcy5jdXJ2ZS50d28pKTtcbiAgICAgIC8vIFkzID0gRiAqIChFIC0gRClcbiAgICAgIG55ID0gZi5yZWRNdWwoZS5yZWRTdWIoZCkpO1xuICAgICAgLy8gWjMgPSBGXjIgLSAyICogRlxuICAgICAgbnogPSBmLnJlZFNxcigpLnJlZFN1YihmKS5yZWRTdWIoZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEggPSBaMV4yXG4gICAgICB2YXIgaCA9IHRoaXMuei5yZWRTcXIoKTtcbiAgICAgIC8vIEogPSBGIC0gMiAqIEhcbiAgICAgIHZhciBqID0gZi5yZWRTdWIoaCkucmVkSVN1YihoKTtcbiAgICAgIC8vIFgzID0gKEItQy1EKSpKXG4gICAgICBueCA9IGIucmVkU3ViKGMpLnJlZElTdWIoZCkucmVkTXVsKGopO1xuICAgICAgLy8gWTMgPSBGICogKEUgLSBEKVxuICAgICAgbnkgPSBmLnJlZE11bChlLnJlZFN1YihkKSk7XG4gICAgICAvLyBaMyA9IEYgKiBKXG4gICAgICBueiA9IGYucmVkTXVsKGopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBFID0gQyArIERcbiAgICB2YXIgZSA9IGMucmVkQWRkKGQpO1xuICAgIC8vIEggPSAoYyAqIFoxKV4yXG4gICAgdmFyIGggPSB0aGlzLmN1cnZlLl9tdWxDKHRoaXMuYy5yZWRNdWwodGhpcy56KSkucmVkU3FyKCk7XG4gICAgLy8gSiA9IEUgLSAyICogSFxuICAgIHZhciBqID0gZS5yZWRTdWIoaCkucmVkU3ViKGgpO1xuICAgIC8vIFgzID0gYyAqIChCIC0gRSkgKiBKXG4gICAgbnggPSB0aGlzLmN1cnZlLl9tdWxDKGIucmVkSVN1YihlKSkucmVkTXVsKGopO1xuICAgIC8vIFkzID0gYyAqIEUgKiAoQyAtIEQpXG4gICAgbnkgPSB0aGlzLmN1cnZlLl9tdWxDKGUpLnJlZE11bChjLnJlZElTdWIoZCkpO1xuICAgIC8vIFozID0gRSAqIEpcbiAgICBueiA9IGUucmVkTXVsKGopO1xuICB9XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIERvdWJsZSBpbiBleHRlbmRlZCBjb29yZGluYXRlc1xuICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZClcbiAgICByZXR1cm4gdGhpcy5fZXh0RGJsKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fcHJvakRibCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9leHRBZGQgPSBmdW5jdGlvbiBfZXh0QWRkKHApIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQtMS5odG1sXG4gIC8vICAgICAjYWRkaXRpb24tYWRkLTIwMDgtaHdjZC0zXG4gIC8vIDhNXG5cbiAgLy8gQSA9IChZMSAtIFgxKSAqIChZMiAtIFgyKVxuICB2YXIgYSA9IHRoaXMueS5yZWRTdWIodGhpcy54KS5yZWRNdWwocC55LnJlZFN1YihwLngpKTtcbiAgLy8gQiA9IChZMSArIFgxKSAqIChZMiArIFgyKVxuICB2YXIgYiA9IHRoaXMueS5yZWRBZGQodGhpcy54KS5yZWRNdWwocC55LnJlZEFkZChwLngpKTtcbiAgLy8gQyA9IFQxICogayAqIFQyXG4gIHZhciBjID0gdGhpcy50LnJlZE11bCh0aGlzLmN1cnZlLmRkKS5yZWRNdWwocC50KTtcbiAgLy8gRCA9IFoxICogMiAqIFoyXG4gIHZhciBkID0gdGhpcy56LnJlZE11bChwLnoucmVkQWRkKHAueikpO1xuICAvLyBFID0gQiAtIEFcbiAgdmFyIGUgPSBiLnJlZFN1YihhKTtcbiAgLy8gRiA9IEQgLSBDXG4gIHZhciBmID0gZC5yZWRTdWIoYyk7XG4gIC8vIEcgPSBEICsgQ1xuICB2YXIgZyA9IGQucmVkQWRkKGMpO1xuICAvLyBIID0gQiArIEFcbiAgdmFyIGggPSBiLnJlZEFkZChhKTtcbiAgLy8gWDMgPSBFICogRlxuICB2YXIgbnggPSBlLnJlZE11bChmKTtcbiAgLy8gWTMgPSBHICogSFxuICB2YXIgbnkgPSBnLnJlZE11bChoKTtcbiAgLy8gVDMgPSBFICogSFxuICB2YXIgbnQgPSBlLnJlZE11bChoKTtcbiAgLy8gWjMgPSBGICogR1xuICB2YXIgbnogPSBmLnJlZE11bChnKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueiwgbnQpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9wcm9qQWRkID0gZnVuY3Rpb24gX3Byb2pBZGQocCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1wcm9qZWN0aXZlLmh0bWxcbiAgLy8gICAgICNhZGRpdGlvbi1hZGQtMjAwOC1iYmpscFxuICAvLyAgICAgI2FkZGl0aW9uLWFkZC0yMDA3LWJsXG4gIC8vIDEwTSArIDFTXG5cbiAgLy8gQSA9IFoxICogWjJcbiAgdmFyIGEgPSB0aGlzLnoucmVkTXVsKHAueik7XG4gIC8vIEIgPSBBXjJcbiAgdmFyIGIgPSBhLnJlZFNxcigpO1xuICAvLyBDID0gWDEgKiBYMlxuICB2YXIgYyA9IHRoaXMueC5yZWRNdWwocC54KTtcbiAgLy8gRCA9IFkxICogWTJcbiAgdmFyIGQgPSB0aGlzLnkucmVkTXVsKHAueSk7XG4gIC8vIEUgPSBkICogQyAqIERcbiAgdmFyIGUgPSB0aGlzLmN1cnZlLmQucmVkTXVsKGMpLnJlZE11bChkKTtcbiAgLy8gRiA9IEIgLSBFXG4gIHZhciBmID0gYi5yZWRTdWIoZSk7XG4gIC8vIEcgPSBCICsgRVxuICB2YXIgZyA9IGIucmVkQWRkKGUpO1xuICAvLyBYMyA9IEEgKiBGICogKChYMSArIFkxKSAqIChYMiArIFkyKSAtIEMgLSBEKVxuICB2YXIgdG1wID0gdGhpcy54LnJlZEFkZCh0aGlzLnkpLnJlZE11bChwLngucmVkQWRkKHAueSkpLnJlZElTdWIoYykucmVkSVN1YihkKTtcbiAgdmFyIG54ID0gYS5yZWRNdWwoZikucmVkTXVsKHRtcCk7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICBpZiAodGhpcy5jdXJ2ZS50d2lzdGVkKSB7XG4gICAgLy8gWTMgPSBBICogRyAqIChEIC0gYSAqIEMpXG4gICAgbnkgPSBhLnJlZE11bChnKS5yZWRNdWwoZC5yZWRTdWIodGhpcy5jdXJ2ZS5fbXVsQShjKSkpO1xuICAgIC8vIFozID0gRiAqIEdcbiAgICBueiA9IGYucmVkTXVsKGcpO1xuICB9IGVsc2Uge1xuICAgIC8vIFkzID0gQSAqIEcgKiAoRCAtIEMpXG4gICAgbnkgPSBhLnJlZE11bChnKS5yZWRNdWwoZC5yZWRTdWIoYykpO1xuICAgIC8vIFozID0gYyAqIEYgKiBHXG4gICAgbnogPSB0aGlzLmN1cnZlLl9tdWxDKGYpLnJlZE11bChnKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHA7XG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZClcbiAgICByZXR1cm4gdGhpcy5fZXh0QWRkKHApO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3Byb2pBZGQocCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcbiAgaWYgKHRoaXMuX2hhc0RvdWJsZXMoaykpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsIGspO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKGsxLCBwLCBrMikge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBbIHRoaXMsIHAgXSwgWyBrMSwgazIgXSwgMiwgZmFsc2UpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmptdWxBZGQgPSBmdW5jdGlvbiBqbXVsQWRkKGsxLCBwLCBrMikge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBbIHRoaXMsIHAgXSwgWyBrMSwgazIgXSwgMiwgdHJ1ZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICBpZiAodGhpcy56T25lKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIE5vcm1hbGl6ZSBjb29yZGluYXRlc1xuICB2YXIgemkgPSB0aGlzLnoucmVkSW52bSgpO1xuICB0aGlzLnggPSB0aGlzLngucmVkTXVsKHppKTtcbiAgdGhpcy55ID0gdGhpcy55LnJlZE11bCh6aSk7XG4gIGlmICh0aGlzLnQpXG4gICAgdGhpcy50ID0gdGhpcy50LnJlZE11bCh6aSk7XG4gIHRoaXMueiA9IHRoaXMuY3VydmUub25lO1xuICB0aGlzLnpPbmUgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cblBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KHRoaXMueC5yZWROZWcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnosXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudCAmJiB0aGlzLnQucmVkTmVnKCkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICB0aGlzLm5vcm1hbGl6ZSgpO1xuICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSgpIHtcbiAgdGhpcy5ub3JtYWxpemUoKTtcbiAgcmV0dXJuIHRoaXMueS5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShvdGhlcikge1xuICByZXR1cm4gdGhpcyA9PT0gb3RoZXIgfHxcbiAgICAgICAgIHRoaXMuZ2V0WCgpLmNtcChvdGhlci5nZXRYKCkpID09PSAwICYmXG4gICAgICAgICB0aGlzLmdldFkoKS5jbXAob3RoZXIuZ2V0WSgpKSA9PT0gMDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbiBlcVhUb1AoeCkge1xuICB2YXIgcnggPSB4LnRvUmVkKHRoaXMuY3VydmUucmVkKS5yZWRNdWwodGhpcy56KTtcbiAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4YyA9IHguY2xvbmUoKTtcbiAgdmFyIHQgPSB0aGlzLmN1cnZlLnJlZE4ucmVkTXVsKHRoaXMueik7XG4gIGZvciAoOzspIHtcbiAgICB4Yy5pYWRkKHRoaXMuY3VydmUubik7XG4gICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByeC5yZWRJQWRkKHQpO1xuICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIENvbXBhdGliaWxpdHkgd2l0aCBCYXNlQ3VydmVcblBvaW50LnByb3RvdHlwZS50b1AgPSBQb2ludC5wcm90b3R5cGUubm9ybWFsaXplO1xuUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gUG9pbnQucHJvdG90eXBlLmFkZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvZWR3YXJkcy5qc1xuLy8gbW9kdWxlIGlkID0gMjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY3VydmUnKTtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJhc2UgPSBjdXJ2ZS5iYXNlO1xuXG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG5cbmZ1bmN0aW9uIE1vbnRDdXJ2ZShjb25mKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnbW9udCcsIGNvbmYpO1xuXG4gIHRoaXMuYSA9IG5ldyBCTihjb25mLmEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYiA9IG5ldyBCTihjb25mLmIsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuaTQgPSBuZXcgQk4oNCkudG9SZWQodGhpcy5yZWQpLnJlZEludm0oKTtcbiAgdGhpcy50d28gPSBuZXcgQk4oMikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmEyNCA9IHRoaXMuaTQucmVkTXVsKHRoaXMuYS5yZWRBZGQodGhpcy50d28pKTtcbn1cbmluaGVyaXRzKE1vbnRDdXJ2ZSwgQmFzZSk7XG5tb2R1bGUuZXhwb3J0cyA9IE1vbnRDdXJ2ZTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG4gIHZhciB4ID0gcG9pbnQubm9ybWFsaXplKCkueDtcbiAgdmFyIHgyID0geC5yZWRTcXIoKTtcbiAgdmFyIHJocyA9IHgyLnJlZE11bCh4KS5yZWRBZGQoeDIucmVkTXVsKHRoaXMuYSkpLnJlZEFkZCh4KTtcbiAgdmFyIHkgPSByaHMucmVkU3FydCgpO1xuXG4gIHJldHVybiB5LnJlZFNxcigpLmNtcChyaHMpID09PSAwO1xufTtcblxuZnVuY3Rpb24gUG9pbnQoY3VydmUsIHgsIHopIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ3Byb2plY3RpdmUnKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueiA9IHRoaXMuY3VydmUuemVybztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueiA9IG5ldyBCTih6LCAxNik7XG4gICAgaWYgKCF0aGlzLngucmVkKVxuICAgICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMuei5yZWQpXG4gICAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICB9XG59XG5pbmhlcml0cyhQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuXG5Nb250Q3VydmUucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMsIGVuYykge1xuICByZXR1cm4gdGhpcy5wb2ludCh1dGlscy50b0FycmF5KGJ5dGVzLCBlbmMpLCAxKTtcbn07XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB6KSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeik7XG59O1xuXG5Nb250Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaikge1xuICByZXR1cm4gUG9pbnQuZnJvbUpTT04odGhpcywgb2JqKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5wcmVjb21wdXRlID0gZnVuY3Rpb24gcHJlY29tcHV0ZSgpIHtcbiAgLy8gTm8tb3Bcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gX2VuY29kZSgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WCgpLnRvQXJyYXkoJ2JlJywgdGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKSk7XG59O1xuXG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmopIHtcbiAgcmV0dXJuIG5ldyBQb2ludChjdXJ2ZSwgb2JqWzBdLCBvYmpbMV0gfHwgY3VydmUub25lKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHo6ICcgKyB0aGlzLnouZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcbiAgcmV0dXJuIHRoaXMuei5jbXBuKDApID09PSAwO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgLy8gaHR0cDovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1tb250Z29tLXh6Lmh0bWwjZG91YmxpbmctZGJsLTE5ODctbS0zXG4gIC8vIDJNICsgMlMgKyA0QVxuXG4gIC8vIEEgPSBYMSArIFoxXG4gIHZhciBhID0gdGhpcy54LnJlZEFkZCh0aGlzLnopO1xuICAvLyBBQSA9IEFeMlxuICB2YXIgYWEgPSBhLnJlZFNxcigpO1xuICAvLyBCID0gWDEgLSBaMVxuICB2YXIgYiA9IHRoaXMueC5yZWRTdWIodGhpcy56KTtcbiAgLy8gQkIgPSBCXjJcbiAgdmFyIGJiID0gYi5yZWRTcXIoKTtcbiAgLy8gQyA9IEFBIC0gQkJcbiAgdmFyIGMgPSBhYS5yZWRTdWIoYmIpO1xuICAvLyBYMyA9IEFBICogQkJcbiAgdmFyIG54ID0gYWEucmVkTXVsKGJiKTtcbiAgLy8gWjMgPSBDICogKEJCICsgQTI0ICogQylcbiAgdmFyIG56ID0gYy5yZWRNdWwoYmIucmVkQWRkKHRoaXMuY3VydmUuYTI0LnJlZE11bChjKSkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIG9uIE1vbnRnb21lcnkgY3VydmUnKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kaWZmQWRkID0gZnVuY3Rpb24gZGlmZkFkZChwLCBkaWZmKSB7XG4gIC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tbW9udGdvbS14ei5odG1sI2RpZmZhZGQtZGFkZC0xOTg3LW0tM1xuICAvLyA0TSArIDJTICsgNkFcblxuICAvLyBBID0gWDIgKyBaMlxuICB2YXIgYSA9IHRoaXMueC5yZWRBZGQodGhpcy56KTtcbiAgLy8gQiA9IFgyIC0gWjJcbiAgdmFyIGIgPSB0aGlzLngucmVkU3ViKHRoaXMueik7XG4gIC8vIEMgPSBYMyArIFozXG4gIHZhciBjID0gcC54LnJlZEFkZChwLnopO1xuICAvLyBEID0gWDMgLSBaM1xuICB2YXIgZCA9IHAueC5yZWRTdWIocC56KTtcbiAgLy8gREEgPSBEICogQVxuICB2YXIgZGEgPSBkLnJlZE11bChhKTtcbiAgLy8gQ0IgPSBDICogQlxuICB2YXIgY2IgPSBjLnJlZE11bChiKTtcbiAgLy8gWDUgPSBaMSAqIChEQSArIENCKV4yXG4gIHZhciBueCA9IGRpZmYuei5yZWRNdWwoZGEucmVkQWRkKGNiKS5yZWRTcXIoKSk7XG4gIC8vIFo1ID0gWDEgKiAoREEgLSBDQileMlxuICB2YXIgbnogPSBkaWZmLngucmVkTXVsKGRhLnJlZElTdWIoY2IpLnJlZFNxcigpKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICB2YXIgdCA9IGsuY2xvbmUoKTtcbiAgdmFyIGEgPSB0aGlzOyAvLyAoTiAvIDIpICogUSArIFFcbiAgdmFyIGIgPSB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpOyAvLyAoTiAvIDIpICogUVxuICB2YXIgYyA9IHRoaXM7IC8vIFFcblxuICBmb3IgKHZhciBiaXRzID0gW107IHQuY21wbigwKSAhPT0gMDsgdC5pdXNocm4oMSkpXG4gICAgYml0cy5wdXNoKHQuYW5kbG4oMSkpO1xuXG4gIGZvciAodmFyIGkgPSBiaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGJpdHNbaV0gPT09IDApIHtcbiAgICAgIC8vIE4gKiBRICsgUSA9ICgoTiAvIDIpICogUSArIFEpKSArIChOIC8gMikgKiBRXG4gICAgICBhID0gYS5kaWZmQWRkKGIsIGMpO1xuICAgICAgLy8gTiAqIFEgPSAyICogKChOIC8gMikgKiBRICsgUSkpXG4gICAgICBiID0gYi5kYmwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTiAqIFEgPSAoKE4gLyAyKSAqIFEgKyBRKSArICgoTiAvIDIpICogUSlcbiAgICAgIGIgPSBhLmRpZmZBZGQoYiwgYyk7XG4gICAgICAvLyBOICogUSArIFEgPSAyICogKChOIC8gMikgKiBRICsgUSlcbiAgICAgIGEgPSBhLmRibCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYjtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiBNb250Z29tZXJ5IGN1cnZlJyk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuanVtbEFkZCA9IGZ1bmN0aW9uIGp1bWxBZGQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiBNb250Z29tZXJ5IGN1cnZlJyk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShvdGhlcikge1xuICByZXR1cm4gdGhpcy5nZXRYKCkuY21wKG90aGVyLmdldFgoKSkgPT09IDA7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICB0aGlzLnggPSB0aGlzLngucmVkTXVsKHRoaXMuei5yZWRJbnZtKCkpO1xuICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIC8vIE5vcm1hbGl6ZSBjb29yZGluYXRlc1xuICB0aGlzLm5vcm1hbGl6ZSgpO1xuXG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvbW9udC5qc1xuLy8gbW9kdWxlIGlkID0gMjIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY3VydmUnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCYXNlID0gY3VydmUuYmFzZTtcblxudmFyIGFzc2VydCA9IGVsbGlwdGljLnV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gU2hvcnRDdXJ2ZShjb25mKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnc2hvcnQnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmIgPSBuZXcgQk4oY29uZi5iLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnRpbnYgPSB0aGlzLnR3by5yZWRJbnZtKCk7XG5cbiAgdGhpcy56ZXJvQSA9IHRoaXMuYS5mcm9tUmVkKCkuY21wbigwKSA9PT0gMDtcbiAgdGhpcy50aHJlZUEgPSB0aGlzLmEuZnJvbVJlZCgpLnN1Yih0aGlzLnApLmNtcG4oLTMpID09PSAwO1xuXG4gIC8vIElmIHRoZSBjdXJ2ZSBpcyBlbmRvbW9ycGhpYywgcHJlY2FsY3VsYXRlIGJldGEgYW5kIGxhbWJkYVxuICB0aGlzLmVuZG8gPSB0aGlzLl9nZXRFbmRvbW9ycGhpc20oY29uZik7XG4gIHRoaXMuX2VuZG9XbmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX2VuZG9XbmFmVDIgPSBuZXcgQXJyYXkoNCk7XG59XG5pbmhlcml0cyhTaG9ydEN1cnZlLCBCYXNlKTtcbm1vZHVsZS5leHBvcnRzID0gU2hvcnRDdXJ2ZTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9tb3JwaGlzbSA9IGZ1bmN0aW9uIF9nZXRFbmRvbW9ycGhpc20oY29uZikge1xuICAvLyBObyBlZmZpY2llbnQgZW5kb21vcnBoaXNtXG4gIGlmICghdGhpcy56ZXJvQSB8fCAhdGhpcy5nIHx8ICF0aGlzLm4gfHwgdGhpcy5wLm1vZG4oMykgIT09IDEpXG4gICAgcmV0dXJuO1xuXG4gIC8vIENvbXB1dGUgYmV0YSBhbmQgbGFtYmRhLCB0aGF0IGxhbWJkYSAqIFAgPSAoYmV0YSAqIFB4OyBQeSlcbiAgdmFyIGJldGE7XG4gIHZhciBsYW1iZGE7XG4gIGlmIChjb25mLmJldGEpIHtcbiAgICBiZXRhID0gbmV3IEJOKGNvbmYuYmV0YSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmV0YXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5wKTtcbiAgICAvLyBDaG9vc2UgdGhlIHNtYWxsZXN0IGJldGFcbiAgICBiZXRhID0gYmV0YXNbMF0uY21wKGJldGFzWzFdKSA8IDAgPyBiZXRhc1swXSA6IGJldGFzWzFdO1xuICAgIGJldGEgPSBiZXRhLnRvUmVkKHRoaXMucmVkKTtcbiAgfVxuICBpZiAoY29uZi5sYW1iZGEpIHtcbiAgICBsYW1iZGEgPSBuZXcgQk4oY29uZi5sYW1iZGEsIDE2KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDaG9vc2UgdGhlIGxhbWJkYSB0aGF0IGlzIG1hdGNoaW5nIHNlbGVjdGVkIGJldGFcbiAgICB2YXIgbGFtYmRhcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLm4pO1xuICAgIGlmICh0aGlzLmcubXVsKGxhbWJkYXNbMF0pLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSkgPT09IDApIHtcbiAgICAgIGxhbWJkYSA9IGxhbWJkYXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhbWJkYSA9IGxhbWJkYXNbMV07XG4gICAgICBhc3NlcnQodGhpcy5nLm11bChsYW1iZGEpLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSkgPT09IDApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBiYXNpcyB2ZWN0b3JzLCB1c2VkIGZvciBiYWxhbmNlZCBsZW5ndGgtdHdvIHJlcHJlc2VudGF0aW9uXG4gIHZhciBiYXNpcztcbiAgaWYgKGNvbmYuYmFzaXMpIHtcbiAgICBiYXNpcyA9IGNvbmYuYmFzaXMubWFwKGZ1bmN0aW9uKHZlYykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYTogbmV3IEJOKHZlYy5hLCAxNiksXG4gICAgICAgIGI6IG5ldyBCTih2ZWMuYiwgMTYpXG4gICAgICB9O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGJhc2lzID0gdGhpcy5fZ2V0RW5kb0Jhc2lzKGxhbWJkYSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJldGE6IGJldGEsXG4gICAgbGFtYmRhOiBsYW1iZGEsXG4gICAgYmFzaXM6IGJhc2lzXG4gIH07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb1Jvb3RzID0gZnVuY3Rpb24gX2dldEVuZG9Sb290cyhudW0pIHtcbiAgLy8gRmluZCByb290cyBvZiBmb3IgeF4yICsgeCArIDEgaW4gRlxuICAvLyBSb290ID0gKC0xICstIFNxcnQoLTMpKSAvIDJcbiAgLy9cbiAgdmFyIHJlZCA9IG51bSA9PT0gdGhpcy5wID8gdGhpcy5yZWQgOiBCTi5tb250KG51bSk7XG4gIHZhciB0aW52ID0gbmV3IEJOKDIpLnRvUmVkKHJlZCkucmVkSW52bSgpO1xuICB2YXIgbnRpbnYgPSB0aW52LnJlZE5lZygpO1xuXG4gIHZhciBzID0gbmV3IEJOKDMpLnRvUmVkKHJlZCkucmVkTmVnKCkucmVkU3FydCgpLnJlZE11bCh0aW52KTtcblxuICB2YXIgbDEgPSBudGludi5yZWRBZGQocykuZnJvbVJlZCgpO1xuICB2YXIgbDIgPSBudGludi5yZWRTdWIocykuZnJvbVJlZCgpO1xuICByZXR1cm4gWyBsMSwgbDIgXTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvQmFzaXMgPSBmdW5jdGlvbiBfZ2V0RW5kb0Jhc2lzKGxhbWJkYSkge1xuICAvLyBhcHJ4U3FydCA+PSBzcXJ0KHRoaXMubilcbiAgdmFyIGFwcnhTcXJ0ID0gdGhpcy5uLnVzaHJuKE1hdGguZmxvb3IodGhpcy5uLmJpdExlbmd0aCgpIC8gMikpO1xuXG4gIC8vIDMuNzRcbiAgLy8gUnVuIEVHQ0QsIHVudGlsIHIoTCArIDEpIDwgYXByeFNxcnRcbiAgdmFyIHUgPSBsYW1iZGE7XG4gIHZhciB2ID0gdGhpcy5uLmNsb25lKCk7XG4gIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgdmFyIHkxID0gbmV3IEJOKDApO1xuICB2YXIgeDIgPSBuZXcgQk4oMCk7XG4gIHZhciB5MiA9IG5ldyBCTigxKTtcblxuICAvLyBOT1RFOiBhbGwgdmVjdG9ycyBhcmUgcm9vdHMgb2Y6IGEgKyBiICogbGFtYmRhID0gMCAobW9kIG4pXG4gIHZhciBhMDtcbiAgdmFyIGIwO1xuICAvLyBGaXJzdCB2ZWN0b3JcbiAgdmFyIGExO1xuICB2YXIgYjE7XG4gIC8vIFNlY29uZCB2ZWN0b3JcbiAgdmFyIGEyO1xuICB2YXIgYjI7XG5cbiAgdmFyIHByZXZSO1xuICB2YXIgaSA9IDA7XG4gIHZhciByO1xuICB2YXIgeDtcbiAgd2hpbGUgKHUuY21wbigwKSAhPT0gMCkge1xuICAgIHZhciBxID0gdi5kaXYodSk7XG4gICAgciA9IHYuc3ViKHEubXVsKHUpKTtcbiAgICB4ID0geDIuc3ViKHEubXVsKHgxKSk7XG4gICAgdmFyIHkgPSB5Mi5zdWIocS5tdWwoeTEpKTtcblxuICAgIGlmICghYTEgJiYgci5jbXAoYXByeFNxcnQpIDwgMCkge1xuICAgICAgYTAgPSBwcmV2Ui5uZWcoKTtcbiAgICAgIGIwID0geDE7XG4gICAgICBhMSA9IHIubmVnKCk7XG4gICAgICBiMSA9IHg7XG4gICAgfSBlbHNlIGlmIChhMSAmJiArK2kgPT09IDIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2UiA9IHI7XG5cbiAgICB2ID0gdTtcbiAgICB1ID0gcjtcbiAgICB4MiA9IHgxO1xuICAgIHgxID0geDtcbiAgICB5MiA9IHkxO1xuICAgIHkxID0geTtcbiAgfVxuICBhMiA9IHIubmVnKCk7XG4gIGIyID0geDtcblxuICB2YXIgbGVuMSA9IGExLnNxcigpLmFkZChiMS5zcXIoKSk7XG4gIHZhciBsZW4yID0gYTIuc3FyKCkuYWRkKGIyLnNxcigpKTtcbiAgaWYgKGxlbjIuY21wKGxlbjEpID49IDApIHtcbiAgICBhMiA9IGEwO1xuICAgIGIyID0gYjA7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgc2lnbnNcbiAgaWYgKGExLm5lZ2F0aXZlKSB7XG4gICAgYTEgPSBhMS5uZWcoKTtcbiAgICBiMSA9IGIxLm5lZygpO1xuICB9XG4gIGlmIChhMi5uZWdhdGl2ZSkge1xuICAgIGEyID0gYTIubmVnKCk7XG4gICAgYjIgPSBiMi5uZWcoKTtcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgeyBhOiBhMSwgYjogYjEgfSxcbiAgICB7IGE6IGEyLCBiOiBiMiB9XG4gIF07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1NwbGl0ID0gZnVuY3Rpb24gX2VuZG9TcGxpdChrKSB7XG4gIHZhciBiYXNpcyA9IHRoaXMuZW5kby5iYXNpcztcbiAgdmFyIHYxID0gYmFzaXNbMF07XG4gIHZhciB2MiA9IGJhc2lzWzFdO1xuXG4gIHZhciBjMSA9IHYyLmIubXVsKGspLmRpdlJvdW5kKHRoaXMubik7XG4gIHZhciBjMiA9IHYxLmIubmVnKCkubXVsKGspLmRpdlJvdW5kKHRoaXMubik7XG5cbiAgdmFyIHAxID0gYzEubXVsKHYxLmEpO1xuICB2YXIgcDIgPSBjMi5tdWwodjIuYSk7XG4gIHZhciBxMSA9IGMxLm11bCh2MS5iKTtcbiAgdmFyIHEyID0gYzIubXVsKHYyLmIpO1xuXG4gIC8vIENhbGN1bGF0ZSBhbnN3ZXJcbiAgdmFyIGsxID0gay5zdWIocDEpLnN1YihwMik7XG4gIHZhciBrMiA9IHExLmFkZChxMikubmVnKCk7XG4gIHJldHVybiB7IGsxOiBrMSwgazI6IGsyIH07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gcG9pbnRGcm9tWCh4LCBvZGQpIHtcbiAgeCA9IG5ldyBCTih4LCAxNik7XG4gIGlmICgheC5yZWQpXG4gICAgeCA9IHgudG9SZWQodGhpcy5yZWQpO1xuXG4gIHZhciB5MiA9IHgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoeC5yZWRNdWwodGhpcy5hKSkucmVkSUFkZCh0aGlzLmIpO1xuICB2YXIgeSA9IHkyLnJlZFNxcnQoKTtcbiAgaWYgKHkucmVkU3FyKCkucmVkU3ViKHkyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcblxuICAvLyBYWFggSXMgdGhlcmUgYW55IHdheSB0byB0ZWxsIGlmIHRoZSBudW1iZXIgaXMgb2RkIHdpdGhvdXQgY29udmVydGluZyBpdFxuICAvLyB0byBub24tcmVkIGZvcm0/XG4gIHZhciBpc09kZCA9IHkuZnJvbVJlZCgpLmlzT2RkKCk7XG4gIGlmIChvZGQgJiYgIWlzT2RkIHx8ICFvZGQgJiYgaXNPZGQpXG4gICAgeSA9IHkucmVkTmVnKCk7XG5cbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG4gIGlmIChwb2ludC5pbmYpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHggPSBwb2ludC54O1xuICB2YXIgeSA9IHBvaW50Lnk7XG5cbiAgdmFyIGF4ID0gdGhpcy5hLnJlZE11bCh4KTtcbiAgdmFyIHJocyA9IHgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoYXgpLnJlZElBZGQodGhpcy5iKTtcbiAgcmV0dXJuIHkucmVkU3FyKCkucmVkSVN1YihyaHMpLmNtcG4oMCkgPT09IDA7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1duYWZNdWxBZGQgPVxuICAgIGZ1bmN0aW9uIF9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcywgamFjb2JpYW5SZXN1bHQpIHtcbiAgdmFyIG5wb2ludHMgPSB0aGlzLl9lbmRvV25hZlQxO1xuICB2YXIgbmNvZWZmcyA9IHRoaXMuX2VuZG9XbmFmVDI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNwbGl0ID0gdGhpcy5fZW5kb1NwbGl0KGNvZWZmc1tpXSk7XG4gICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgdmFyIGJldGEgPSBwLl9nZXRCZXRhKCk7XG5cbiAgICBpZiAoc3BsaXQuazEubmVnYXRpdmUpIHtcbiAgICAgIHNwbGl0LmsxLmluZWcoKTtcbiAgICAgIHAgPSBwLm5lZyh0cnVlKTtcbiAgICB9XG4gICAgaWYgKHNwbGl0LmsyLm5lZ2F0aXZlKSB7XG4gICAgICBzcGxpdC5rMi5pbmVnKCk7XG4gICAgICBiZXRhID0gYmV0YS5uZWcodHJ1ZSk7XG4gICAgfVxuXG4gICAgbnBvaW50c1tpICogMl0gPSBwO1xuICAgIG5wb2ludHNbaSAqIDIgKyAxXSA9IGJldGE7XG4gICAgbmNvZWZmc1tpICogMl0gPSBzcGxpdC5rMTtcbiAgICBuY29lZmZzW2kgKiAyICsgMV0gPSBzcGxpdC5rMjtcbiAgfVxuICB2YXIgcmVzID0gdGhpcy5fd25hZk11bEFkZCgxLCBucG9pbnRzLCBuY29lZmZzLCBpICogMiwgamFjb2JpYW5SZXN1bHQpO1xuXG4gIC8vIENsZWFuLXVwIHJlZmVyZW5jZXMgdG8gcG9pbnRzIGFuZCBjb2VmZmljaWVudHNcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBpICogMjsgaisrKSB7XG4gICAgbnBvaW50c1tqXSA9IG51bGw7XG4gICAgbmNvZWZmc1tqXSA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB5LCBpc1JlZCkge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnYWZmaW5lJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSBudWxsO1xuICAgIHRoaXMueSA9IG51bGw7XG4gICAgdGhpcy5pbmYgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBCTih4LCAxNik7XG4gICAgdGhpcy55ID0gbmV3IEJOKHksIDE2KTtcbiAgICAvLyBGb3JjZSByZWRnb21lcnkgcmVwcmVzZW50YXRpb24gd2hlbiBsb2FkaW5nIGZyb20gSlNPTlxuICAgIGlmIChpc1JlZCkge1xuICAgICAgdGhpcy54LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICAgIHRoaXMueS5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgfVxuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnkucmVkKVxuICAgICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICB0aGlzLmluZiA9IGZhbHNlO1xuICB9XG59XG5pbmhlcml0cyhQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHksIGlzUmVkKSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeSwgaXNSZWQpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqLCByZWQpIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaiwgcmVkKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICBpZiAoIXRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm47XG5cbiAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gIGlmIChwcmUgJiYgcHJlLmJldGEpXG4gICAgcmV0dXJuIHByZS5iZXRhO1xuXG4gIHZhciBiZXRhID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTXVsKHRoaXMuY3VydmUuZW5kby5iZXRhKSwgdGhpcy55KTtcbiAgaWYgKHByZSkge1xuICAgIHZhciBjdXJ2ZSA9IHRoaXMuY3VydmU7XG4gICAgdmFyIGVuZG9NdWwgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gY3VydmUucG9pbnQocC54LnJlZE11bChjdXJ2ZS5lbmRvLmJldGEpLCBwLnkpO1xuICAgIH07XG4gICAgcHJlLmJldGEgPSBiZXRhO1xuICAgIGJldGEucHJlY29tcHV0ZWQgPSB7XG4gICAgICBiZXRhOiBudWxsLFxuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAoZW5kb011bClcbiAgICAgIH0sXG4gICAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChlbmRvTXVsKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJldGE7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnkgXTtcblxuICByZXR1cm4gWyB0aGlzLngsIHRoaXMueSwgdGhpcy5wcmVjb21wdXRlZCAmJiB7XG4gICAgZG91YmxlczogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5zdGVwLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMucG9pbnRzLnNsaWNlKDEpXG4gICAgfSxcbiAgICBuYWY6IHRoaXMucHJlY29tcHV0ZWQubmFmICYmIHtcbiAgICAgIHduZDogdGhpcy5wcmVjb21wdXRlZC5uYWYud25kLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLm5hZi5wb2ludHMuc2xpY2UoMSlcbiAgICB9XG4gIH0gXTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaiwgcmVkKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJylcbiAgICBvYmogPSBKU09OLnBhcnNlKG9iaik7XG4gIHZhciByZXMgPSBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgaWYgKCFvYmpbMl0pXG4gICAgcmV0dXJuIHJlcztcblxuICBmdW5jdGlvbiBvYmoycG9pbnQob2JqKSB7XG4gICAgcmV0dXJuIGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuICB9XG5cbiAgdmFyIHByZSA9IG9ialsyXTtcbiAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgIGJldGE6IG51bGwsXG4gICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogWyByZXMgXS5jb25jYXQocHJlLmRvdWJsZXMucG9pbnRzLm1hcChvYmoycG9pbnQpKVxuICAgIH0sXG4gICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5uYWYucG9pbnRzLm1hcChvYmoycG9pbnQpKVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlcztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgcmV0dXJuIHRoaXMuaW5mO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBQICsgUCA9IDJQXG4gIGlmICh0aGlzLmVxKHApKVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIC8vIFAgKyAoLVApID0gT1xuICBpZiAodGhpcy5uZWcoKS5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICAvLyBQICsgUSA9IE9cbiAgaWYgKHRoaXMueC5jbXAocC54KSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYyA9IHRoaXMueS5yZWRTdWIocC55KTtcbiAgaWYgKGMuY21wbigwKSAhPT0gMClcbiAgICBjID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihwLngpLnJlZEludm0oKSk7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIocC54KTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAyUCA9IE9cbiAgdmFyIHlzMSA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgaWYgKHlzMS5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXG4gIHZhciB4MiA9IHRoaXMueC5yZWRTcXIoKTtcbiAgdmFyIGR5aW52ID0geXMxLnJlZEludm0oKTtcbiAgdmFyIGMgPSB4Mi5yZWRBZGQoeDIpLnJlZElBZGQoeDIpLnJlZElBZGQoYSkucmVkTXVsKGR5aW52KTtcblxuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54LnJlZEFkZCh0aGlzLngpKTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIGsgPSBuZXcgQk4oaywgMTYpO1xuXG4gIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9maXhlZE5hZk11bCh0aGlzLCBrKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChbIHRoaXMgXSwgWyBrIF0pO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKGsxLCBwMiwgazIpIHtcbiAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcbiAgdmFyIGNvZWZmcyA9IFsgazEsIGsyIF07XG4gIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIHBvaW50cywgY29lZmZzLCAyKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5qbXVsQWRkID0gZnVuY3Rpb24gam11bEFkZChrMSwgcDIsIGsyKSB7XG4gIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG4gIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcywgdHJ1ZSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMiwgdHJ1ZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG4gIHJldHVybiB0aGlzID09PSBwIHx8XG4gICAgICAgICB0aGlzLmluZiA9PT0gcC5pbmYgJiZcbiAgICAgICAgICAgICAodGhpcy5pbmYgfHwgdGhpcy54LmNtcChwLngpID09PSAwICYmIHRoaXMueS5jbXAocC55KSA9PT0gMCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKF9wcmVjb21wdXRlKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngsIHRoaXMueS5yZWROZWcoKSk7XG4gIGlmIChfcHJlY29tcHV0ZSAmJiB0aGlzLnByZWNvbXB1dGVkKSB7XG4gICAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gICAgdmFyIG5lZ2F0ZSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBwLm5lZygpO1xuICAgIH07XG4gICAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAobmVnYXRlKVxuICAgICAgfSxcbiAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKG5lZ2F0ZSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KID0gZnVuY3Rpb24gdG9KKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXG4gIHZhciByZXMgPSB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueSwgdGhpcy5jdXJ2ZS5vbmUpO1xuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gSlBvaW50KGN1cnZlLCB4LCB5LCB6KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdqYWNvYmlhbicpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnkgPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSBuZXcgQk4oMCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgQk4oeSwgMTYpO1xuICAgIHRoaXMueiA9IG5ldyBCTih6LCAxNik7XG4gIH1cbiAgaWYgKCF0aGlzLngucmVkKVxuICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIGlmICghdGhpcy55LnJlZClcbiAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICBpZiAoIXRoaXMuei5yZWQpXG4gICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcblxuICB0aGlzLnpPbmUgPSB0aGlzLnogPT09IHRoaXMuY3VydmUub25lO1xufVxuaW5oZXJpdHMoSlBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6KSB7XG4gIHJldHVybiBuZXcgSlBvaW50KHRoaXMsIHgsIHksIHopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50b1AgPSBmdW5jdGlvbiB0b1AoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgemludiA9IHRoaXMuei5yZWRJbnZtKCk7XG4gIHZhciB6aW52MiA9IHppbnYucmVkU3FyKCk7XG4gIHZhciBheCA9IHRoaXMueC5yZWRNdWwoemludjIpO1xuICB2YXIgYXkgPSB0aGlzLnkucmVkTXVsKHppbnYyKS5yZWRNdWwoemludik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQoYXgsIGF5KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCksIHRoaXMueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAxMk0gKyA0UyArIDdBXG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54LnJlZE11bChwejIpO1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55LnJlZE11bChwejIucmVkTXVsKHAueikpO1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyLnJlZE11bCh0aGlzLnopKTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChwLnopLnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gZnVuY3Rpb24gbWl4ZWRBZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwLnRvSigpO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gOE0gKyAzUyArIDdBXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54O1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55O1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyKS5yZWRNdWwodGhpcy56KTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKHBvdykge1xuICBpZiAocG93ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmICghcG93KVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIGlmICh0aGlzLmN1cnZlLnplcm9BIHx8IHRoaXMuY3VydmUudGhyZWVBKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG93OyBpKyspXG4gICAgICByID0gci5kYmwoKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIC8vIDFNICsgMlMgKyAxQSArIE4gKiAoNFMgKyA1TSArIDhBKVxuICAvLyBOID0gMSA9PiA2TSArIDZTICsgOUFcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG4gIHZhciB0aW52ID0gdGhpcy5jdXJ2ZS50aW52O1xuXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICAvLyBSZXVzZSByZXN1bHRzXG4gIHZhciBqeWQgPSBqeS5yZWRBZGQoankpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvdzsgaSsrKSB7XG4gICAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuICAgIHZhciBqeWQyID0ganlkLnJlZFNxcigpO1xuICAgIHZhciBqeWQ0ID0ganlkMi5yZWRTcXIoKTtcbiAgICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICAgIHZhciB0MSA9IGp4LnJlZE11bChqeWQyKTtcbiAgICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gICAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG4gICAgdmFyIGRueSA9IGMucmVkTXVsKHQyKTtcbiAgICBkbnkgPSBkbnkucmVkSUFkZChkbnkpLnJlZElTdWIoanlkNCk7XG4gICAgdmFyIG56ID0ganlkLnJlZE11bChqeik7XG4gICAgaWYgKGkgKyAxIDwgcG93KVxuICAgICAgano0ID0gano0LnJlZE11bChqeWQ0KTtcblxuICAgIGp4ID0gbng7XG4gICAganogPSBuejtcbiAgICBqeWQgPSBkbnk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQoangsIGp5ZC5yZWRNdWwodGludiksIGp6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuX3plcm9EYmwoKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS50aHJlZUEpXG4gICAgcmV0dXJuIHRoaXMuX3RocmVlRGJsKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fZGJsKCk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl96ZXJvRGJsID0gZnVuY3Rpb24gX3plcm9EYmwoKSB7XG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIC8vIFogPSAxXG4gIGlmICh0aGlzLnpPbmUpIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG4gICAgLy8gMU0gKyA1UyArIDE0QVxuXG4gICAgLy8gWFggPSBYMV4yXG4gICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBZWVlZID0gWVleMlxuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG4gICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIHMgPSBzLnJlZElBZGQocyk7XG4gICAgLy8gTSA9IDMgKiBYWCArIGE7IGEgPSAwXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAgIC8vIFQgPSBNIF4gMiAtIDIqU1xuICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG5cbiAgICAvLyA4ICogWVlZWVxuICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG5cbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHQ7XG4gICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG4gICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgIC8vIFozID0gMipZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOS1sXG4gICAgLy8gMk0gKyA1UyArIDEzQVxuXG4gICAgLy8gQSA9IFgxXjJcbiAgICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBCID0gWTFeMlxuICAgIHZhciBiID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIEMgPSBCXjJcbiAgICB2YXIgYyA9IGIucmVkU3FyKCk7XG4gICAgLy8gRCA9IDIgKiAoKFgxICsgQileMiAtIEEgLSBDKVxuICAgIHZhciBkID0gdGhpcy54LnJlZEFkZChiKS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYyk7XG4gICAgZCA9IGQucmVkSUFkZChkKTtcbiAgICAvLyBFID0gMyAqIEFcbiAgICB2YXIgZSA9IGEucmVkQWRkKGEpLnJlZElBZGQoYSk7XG4gICAgLy8gRiA9IEVeMlxuICAgIHZhciBmID0gZS5yZWRTcXIoKTtcblxuICAgIC8vIDggKiBDXG4gICAgdmFyIGM4ID0gYy5yZWRJQWRkKGMpO1xuICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG4gICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcblxuICAgIC8vIFgzID0gRiAtIDIgKiBEXG4gICAgbnggPSBmLnJlZElTdWIoZCkucmVkSVN1YihkKTtcbiAgICAvLyBZMyA9IEUgKiAoRCAtIFgzKSAtIDggKiBDXG4gICAgbnkgPSBlLnJlZE11bChkLnJlZElTdWIobngpKS5yZWRJU3ViKGM4KTtcbiAgICAvLyBaMyA9IDIgKiBZMSAqIFoxXG4gICAgbnogPSB0aGlzLnkucmVkTXVsKHRoaXMueik7XG4gICAgbnogPSBuei5yZWRJQWRkKG56KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX3RocmVlRGJsID0gZnVuY3Rpb24gX3RocmVlRGJsKCkge1xuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICAvLyBaID0gMVxuICBpZiAodGhpcy56T25lKSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuICAgIC8vIDFNICsgNVMgKyAxNUFcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBZWSA9IFkxXjJcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gWVlZWSA9IFlZXjJcbiAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICBzID0gcy5yZWRJQWRkKHMpO1xuICAgIC8vIE0gPSAzICogWFggKyBhXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpLnJlZElBZGQodGhpcy5jdXJ2ZS5hKTtcbiAgICAvLyBUID0gTV4yIC0gMiAqIFNcbiAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuICAgIC8vIFgzID0gVFxuICAgIG54ID0gdDtcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAvLyBaMyA9IDIgKiBZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sI2RvdWJsaW5nLWRibC0yMDAxLWJcbiAgICAvLyAzTSArIDVTXG5cbiAgICAvLyBkZWx0YSA9IFoxXjJcbiAgICB2YXIgZGVsdGEgPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgLy8gZ2FtbWEgPSBZMV4yXG4gICAgdmFyIGdhbW1hID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIGJldGEgPSBYMSAqIGdhbW1hXG4gICAgdmFyIGJldGEgPSB0aGlzLngucmVkTXVsKGdhbW1hKTtcbiAgICAvLyBhbHBoYSA9IDMgKiAoWDEgLSBkZWx0YSkgKiAoWDEgKyBkZWx0YSlcbiAgICB2YXIgYWxwaGEgPSB0aGlzLngucmVkU3ViKGRlbHRhKS5yZWRNdWwodGhpcy54LnJlZEFkZChkZWx0YSkpO1xuICAgIGFscGhhID0gYWxwaGEucmVkQWRkKGFscGhhKS5yZWRJQWRkKGFscGhhKTtcbiAgICAvLyBYMyA9IGFscGhhXjIgLSA4ICogYmV0YVxuICAgIHZhciBiZXRhNCA9IGJldGEucmVkSUFkZChiZXRhKTtcbiAgICBiZXRhNCA9IGJldGE0LnJlZElBZGQoYmV0YTQpO1xuICAgIHZhciBiZXRhOCA9IGJldGE0LnJlZEFkZChiZXRhNCk7XG4gICAgbnggPSBhbHBoYS5yZWRTcXIoKS5yZWRJU3ViKGJldGE4KTtcbiAgICAvLyBaMyA9IChZMSArIFoxKV4yIC0gZ2FtbWEgLSBkZWx0YVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnopLnJlZFNxcigpLnJlZElTdWIoZ2FtbWEpLnJlZElTdWIoZGVsdGEpO1xuICAgIC8vIFkzID0gYWxwaGEgKiAoNCAqIGJldGEgLSBYMykgLSA4ICogZ2FtbWFeMlxuICAgIHZhciBnZ2FtbWE4ID0gZ2FtbWEucmVkU3FyKCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgbnkgPSBhbHBoYS5yZWRNdWwoYmV0YTQucmVkSVN1YihueCkpLnJlZElTdWIoZ2dhbW1hOCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl9kYmwgPSBmdW5jdGlvbiBfZGJsKCkge1xuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICAvLyA0TSArIDZTICsgMTBBXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICB2YXIgangyID0gangucmVkU3FyKCk7XG4gIHZhciBqeTIgPSBqeS5yZWRTcXIoKTtcblxuICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICB2YXIganhkNCA9IGp4LnJlZEFkZChqeCk7XG4gIGp4ZDQgPSBqeGQ0LnJlZElBZGQoanhkNCk7XG4gIHZhciB0MSA9IGp4ZDQucmVkTXVsKGp5Mik7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG5cbiAgdmFyIGp5ZDggPSBqeTIucmVkU3FyKCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHQyKS5yZWRJU3ViKGp5ZDgpO1xuICB2YXIgbnogPSBqeS5yZWRBZGQoankpLnJlZE11bChqeik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50cnBsID0gZnVuY3Rpb24gdHJwbCgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLnplcm9BKVxuICAgIHJldHVybiB0aGlzLmRibCgpLmFkZCh0aGlzKTtcblxuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCN0cmlwbGluZy10cGwtMjAwNy1ibFxuICAvLyA1TSArIDEwUyArIC4uLlxuXG4gIC8vIFhYID0gWDFeMlxuICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIFlZID0gWTFeMlxuICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gIC8vIFpaID0gWjFeMlxuICB2YXIgenogPSB0aGlzLnoucmVkU3FyKCk7XG4gIC8vIFlZWVkgPSBZWV4yXG4gIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gIC8vIE0gPSAzICogWFggKyBhICogWloyOyBhID0gMFxuICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG4gIC8vIE1NID0gTV4yXG4gIHZhciBtbSA9IG0ucmVkU3FyKCk7XG4gIC8vIEUgPSA2ICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKSAtIE1NXG4gIHZhciBlID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgZSA9IGUucmVkSUFkZChlKTtcbiAgZSA9IGUucmVkQWRkKGUpLnJlZElBZGQoZSk7XG4gIGUgPSBlLnJlZElTdWIobW0pO1xuICAvLyBFRSA9IEVeMlxuICB2YXIgZWUgPSBlLnJlZFNxcigpO1xuICAvLyBUID0gMTYqWVlZWVxuICB2YXIgdCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgLy8gVSA9IChNICsgRSleMiAtIE1NIC0gRUUgLSBUXG4gIHZhciB1ID0gbS5yZWRJQWRkKGUpLnJlZFNxcigpLnJlZElTdWIobW0pLnJlZElTdWIoZWUpLnJlZElTdWIodCk7XG4gIC8vIFgzID0gNCAqIChYMSAqIEVFIC0gNCAqIFlZICogVSlcbiAgdmFyIHl5dTQgPSB5eS5yZWRNdWwodSk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHZhciBueCA9IHRoaXMueC5yZWRNdWwoZWUpLnJlZElTdWIoeXl1NCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIC8vIFkzID0gOCAqIFkxICogKFUgKiAoVCAtIFUpIC0gRSAqIEVFKVxuICB2YXIgbnkgPSB0aGlzLnkucmVkTXVsKHUucmVkTXVsKHQucmVkSVN1Yih1KSkucmVkSVN1YihlLnJlZE11bChlZSkpKTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgLy8gWjMgPSAoWjEgKyBFKV4yIC0gWlogLSBFRVxuICB2YXIgbnogPSB0aGlzLnoucmVkQWRkKGUpLnJlZFNxcigpLnJlZElTdWIoenopLnJlZElTdWIoZWUpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGssIGtiYXNlKSB7XG4gIGsgPSBuZXcgQk4oaywga2Jhc2UpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgcmV0dXJuIHRoaXMuZXEocC50b0ooKSk7XG5cbiAgaWYgKHRoaXMgPT09IHApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8geDEgKiB6Ml4yID09IHgyICogejFeMlxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIGlmICh0aGlzLngucmVkTXVsKHB6MikucmVkSVN1YihwLngucmVkTXVsKHoyKSkuY21wbigwKSAhPT0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8geTEgKiB6Ml4zID09IHkyICogejFeM1xuICB2YXIgejMgPSB6Mi5yZWRNdWwodGhpcy56KTtcbiAgdmFyIHB6MyA9IHB6Mi5yZWRNdWwocC56KTtcbiAgcmV0dXJuIHRoaXMueS5yZWRNdWwocHozKS5yZWRJU3ViKHAueS5yZWRNdWwoejMpKS5jbXBuKDApID09PSAwO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbiBlcVhUb1AoeCkge1xuICB2YXIgenMgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciByeCA9IHgudG9SZWQodGhpcy5jdXJ2ZS5yZWQpLnJlZE11bCh6cyk7XG4gIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeGMgPSB4LmNsb25lKCk7XG4gIHZhciB0ID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh6cyk7XG4gIGZvciAoOzspIHtcbiAgICB4Yy5pYWRkKHRoaXMuY3VydmUubik7XG4gICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByeC5yZWRJQWRkKHQpO1xuICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBKUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgSlBvaW50IHg6ICcgKyB0aGlzLngudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgeTogJyArIHRoaXMueS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB6OiAnICsgdGhpcy56LnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIC8vIFhYWCBUaGlzIGNvZGUgYXNzdW1lcyB0aGF0IHplcm8gaXMgYWx3YXlzIHplcm8gaW4gcmVkXG4gIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL3Nob3J0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmVzID0gZXhwb3J0cztcblxudmFyIGhhc2ggPSByZXF1aXJlKCdoYXNoLmpzJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi9lbGxpcHRpYycpO1xuXG52YXIgYXNzZXJ0ID0gZWxsaXB0aWMudXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBQcmVzZXRDdXJ2ZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnR5cGUgPT09ICdzaG9ydCcpXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5jdXJ2ZS5zaG9ydChvcHRpb25zKTtcbiAgZWxzZSBpZiAob3B0aW9ucy50eXBlID09PSAnZWR3YXJkcycpXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5jdXJ2ZS5lZHdhcmRzKG9wdGlvbnMpO1xuICBlbHNlXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5jdXJ2ZS5tb250KG9wdGlvbnMpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG4gIHRoaXMubiA9IHRoaXMuY3VydmUubjtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuXG4gIGFzc2VydCh0aGlzLmcudmFsaWRhdGUoKSwgJ0ludmFsaWQgY3VydmUnKTtcbiAgYXNzZXJ0KHRoaXMuZy5tdWwodGhpcy5uKS5pc0luZmluaXR5KCksICdJbnZhbGlkIGN1cnZlLCBHKk4gIT0gTycpO1xufVxuY3VydmVzLlByZXNldEN1cnZlID0gUHJlc2V0Q3VydmU7XG5cbmZ1bmN0aW9uIGRlZmluZUN1cnZlKG5hbWUsIG9wdGlvbnMpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3VydmUgPSBuZXcgUHJlc2V0Q3VydmUob3B0aW9ucyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGN1cnZlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjdXJ2ZTtcbiAgICB9XG4gIH0pO1xufVxuXG5kZWZpbmVDdXJ2ZSgncDE5MicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdwMTkyJyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzY0MjEwNTE5IGU1OWM4MGU3IDBmYTdlOWFiIDcyMjQzMDQ5IGZlYjhkZWVjIGMxNDZiOWIxJyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDk5ZGVmODM2IDE0NmJjOWIxIGI0ZDIyODMxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzE4OGRhODBlIGIwMzA5MGY2IDdjYmYyMGViIDQzYTE4ODAwIGY0ZmYwYWZkIDgyZmYxMDEyJyxcbiAgICAnMDcxOTJiOTUgZmZjOGRhNzggNjMxMDExZWQgNmIyNGNkZDUgNzNmOTc3YTEgMWU3OTQ4MTEnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDIyNCcsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdwMjI0JyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlJyxcbiAgYjogJ2I0MDUwYTg1IDBjMDRiM2FiIGY1NDEzMjU2IDUwNDRiMGI3IGQ3YmZkOGJhIDI3MGIzOTQzIDIzNTVmZmI0JyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmYxNmEyIGUwYjhmMDNlIDEzZGQyOTQ1IDVjNWMyYTNkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJ2I3MGUwY2JkIDZiYjRiZjdmIDMyMTM5MGI5IDRhMDNjMWQzIDU2YzIxMTIyIDM0MzI4MGQ2IDExNWMxZDIxJyxcbiAgICAnYmQzNzYzODggYjVmNzIzZmIgNGMyMmRmZTYgY2Q0Mzc1YTAgNWEwNzQ3NjQgNDRkNTgxOTkgODUwMDdlMzQnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDI1NicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICc1YWM2MzVkOCBhYTNhOTNlNyBiM2ViYmQ1NSA3Njk4ODZiYyA2NTFkMDZiMCBjYzUzYjBmNiAzYmNlM2MzZSAyN2QyNjA0YicsXG4gIG46ICdmZmZmZmZmZiAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc2YjE3ZDFmMiBlMTJjNDI0NyBmOGJjZTZlNSA2M2E0NDBmMiA3NzAzN2Q4MSAyZGViMzNhMCBmNGExMzk0NSBkODk4YzI5NicsXG4gICAgJzRmZTM0MmUyIGZlMWE3ZjliIDhlZTdlYjRhIDdjMGY5ZTE2IDJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1J1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AzODQnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZjJyxcbiAgYjogJ2IzMzEyZmE3IGUyM2VlN2U0IDk4OGUwNTZiIGUzZjgyZDE5IDE4MWQ5YzZlIGZlODE0MTEyIDAzMTQwODhmICcgK1xuICAgICAnNTAxMzg3NWEgYzY1NjM5OGQgOGEyZWQxOWQgMmE4NWM4ZWQgZDNlYzJhZWYnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgYzc2MzRkODEgJyArXG4gICAgICdmNDM3MmRkZiA1ODFhMGRiMiA0OGIwYTc3YSBlY2VjMTk2YSBjY2M1Mjk3MycsXG4gIGhhc2g6IGhhc2guc2hhMzg0LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICdhYTg3Y2EyMiBiZThiMDUzNyA4ZWIxYzcxZSBmMzIwYWQ3NCA2ZTFkM2I2MiA4YmE3OWI5OCA1OWY3NDFlMCA4MjU0MmEzOCAnICtcbiAgICAnNTUwMmYyNWQgYmY1NTI5NmMgM2E1NDVlMzggNzI3NjBhYjcnLFxuICAgICczNjE3ZGU0YSA5NjI2MmM2ZiA1ZDllOThiZiA5MjkyZGMyOSBmOGY0MWRiZCAyODlhMTQ3YyBlOWRhMzExMyBiNWYwYjhjMCAnICtcbiAgICAnMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWYnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDUyMScsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzAwMDAwMDUxIDk1M2ViOTYxIDhlMWM5YTFmIDkyOWEyMWEwIGI2ODU0MGVlIGEyZGE3MjViICcgK1xuICAgICAnOTliMzE1ZjMgYjhiNDg5OTEgOGVmMTA5ZTEgNTYxOTM5NTEgZWM3ZTkzN2IgMTY1MmMwYmQgJyArXG4gICAgICczYmIxYmYwNyAzNTczZGY4OCAzZDJjMzRmMSBlZjQ1MWZkNCA2YjUwM2YwMCcsXG4gIG46ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZhIDUxODY4NzgzIGJmMmY5NjZiIDdmY2MwMTQ4ICcgK1xuICAgICAnZjcwOWE1ZDAgM2JiNWM5YjggODk5YzQ3YWUgYmI2ZmI3MWUgOTEzODY0MDknLFxuICBoYXNoOiBoYXNoLnNoYTUxMixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMDAwMDAwYzYgODU4ZTA2YjcgMDQwNGU5Y2QgOWUzZWNiNjYgMjM5NWI0NDIgOWM2NDgxMzkgJyArXG4gICAgJzA1M2ZiNTIxIGY4MjhhZjYwIDZiNGQzZGJhIGExNGI1ZTc3IGVmZTc1OTI4IGZlMWRjMTI3ICcgK1xuICAgICdhMmZmYThkZSAzMzQ4YjNjMSA4NTZhNDI5YiBmOTdlN2UzMSBjMmU1YmQ2NicsXG4gICAgJzAwMDAwMTE4IDM5Mjk2YTc4IDlhM2JjMDA0IDVjOGE1ZmI0IDJjN2QxYmQ5IDk4ZjU0NDQ5ICcgK1xuICAgICc1NzliNDQ2OCAxN2FmYmQxNyAyNzNlNjYyYyA5N2VlNzI5OSA1ZWY0MjY0MCBjNTUwYjkwMSAnICtcbiAgICAnM2ZhZDA3NjEgMzUzYzcwODYgYTI3MmMyNDAgODhiZTk0NzYgOWZkMTY2NTAnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnY3VydmUyNTUxOScsIHtcbiAgdHlwZTogJ21vbnQnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJzc2ZDA2JyxcbiAgYjogJzEnLFxuICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc5J1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ2VkMjU1MTknLCB7XG4gIHR5cGU6ICdlZHdhcmRzJyxcbiAgcHJpbWU6ICdwMjU1MTknLFxuICBwOiAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcsXG4gIGE6ICctMScsXG4gIGM6ICcxJyxcbiAgLy8gLTEyMTY2NSAqICgxMjE2NjZeKC0xKSkgKG1vZCBQKVxuICBkOiAnNTIwMzZjZWUyYjZmZmU3MyA4Y2M3NDA3OTc3NzllODk4IDAwNzAwYTRkNDE0MWQ4YWIgNzVlYjRkY2ExMzU5NzhhMycsXG4gIG46ICcxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWEnLFxuXG4gICAgLy8gNC81XG4gICAgJzY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NTgnXG4gIF1cbn0pO1xuXG52YXIgcHJlO1xudHJ5IHtcbiAgcHJlID0gcmVxdWlyZSgnLi9wcmVjb21wdXRlZC9zZWNwMjU2azEnKTtcbn0gY2F0Y2ggKGUpIHtcbiAgcHJlID0gdW5kZWZpbmVkO1xufVxuXG5kZWZpbmVDdXJ2ZSgnc2VjcDI1NmsxJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ2syNTYnLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnLFxuICBhOiAnMCcsXG4gIGI6ICc3JyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGJhYWVkY2U2IGFmNDhhMDNiIGJmZDI1ZThjIGQwMzY0MTQxJyxcbiAgaDogJzEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcblxuICAvLyBQcmVjb21wdXRlZCBlbmRvbW9ycGhpc21cbiAgYmV0YTogJzdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnLFxuICBsYW1iZGE6ICc1MzYzYWQ0Y2MwNWMzMGUwYTUyNjFjMDI4ODEyNjQ1YTEyMmUyMmVhMjA4MTY2NzhkZjAyOTY3YzFiMjNiZDcyJyxcbiAgYmFzaXM6IFtcbiAgICB7XG4gICAgICBhOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnLFxuICAgICAgYjogJy1lNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMydcbiAgICB9LFxuICAgIHtcbiAgICAgIGE6ICcxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnLFxuICAgICAgYjogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1J1xuICAgIH1cbiAgXSxcblxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4JyxcbiAgICAnNDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOCcsXG4gICAgcHJlXG4gIF1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDIyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgSG1hY0RSQkcgPSByZXF1aXJlKCdobWFjLWRyYmcnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbnZhciBLZXlQYWlyID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xuXG5mdW5jdGlvbiBFQyhvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFQykpXG4gICAgcmV0dXJuIG5ldyBFQyhvcHRpb25zKTtcblxuICAvLyBTaG9ydGN1dCBgZWxsaXB0aWMuZWMoY3VydmUtbmFtZSlgXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBhc3NlcnQoZWxsaXB0aWMuY3VydmVzLmhhc093blByb3BlcnR5KG9wdGlvbnMpLCAnVW5rbm93biBjdXJ2ZSAnICsgb3B0aW9ucyk7XG5cbiAgICBvcHRpb25zID0gZWxsaXB0aWMuY3VydmVzW29wdGlvbnNdO1xuICB9XG5cbiAgLy8gU2hvcnRjdXQgZm9yIGBlbGxpcHRpYy5lYyhlbGxpcHRpYy5jdXJ2ZXMuY3VydmVOYW1lKWBcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBlbGxpcHRpYy5jdXJ2ZXMuUHJlc2V0Q3VydmUpXG4gICAgb3B0aW9ucyA9IHsgY3VydmU6IG9wdGlvbnMgfTtcblxuICB0aGlzLmN1cnZlID0gb3B0aW9ucy5jdXJ2ZS5jdXJ2ZTtcbiAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICB0aGlzLm5oID0gdGhpcy5uLnVzaHJuKDEpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG5cbiAgLy8gUG9pbnQgb24gY3VydmVcbiAgdGhpcy5nID0gb3B0aW9ucy5jdXJ2ZS5nO1xuICB0aGlzLmcucHJlY29tcHV0ZShvcHRpb25zLmN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcblxuICAvLyBIYXNoIGZvciBmdW5jdGlvbiBmb3IgRFJCR1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2ggfHwgb3B0aW9ucy5jdXJ2ZS5oYXNoO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFQztcblxuRUMucHJvdG90eXBlLmtleVBhaXIgPSBmdW5jdGlvbiBrZXlQYWlyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBLZXlQYWlyKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuRUMucHJvdG90eXBlLmtleUZyb21Qcml2YXRlID0gZnVuY3Rpb24ga2V5RnJvbVByaXZhdGUocHJpdiwgZW5jKSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21Qcml2YXRlKHRoaXMsIHByaXYsIGVuYyk7XG59O1xuXG5FQy5wcm90b3R5cGUua2V5RnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViLCBlbmMpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVB1YmxpYyh0aGlzLCBwdWIsIGVuYyk7XG59O1xuXG5FQy5wcm90b3R5cGUuZ2VuS2V5UGFpciA9IGZ1bmN0aW9uIGdlbktleVBhaXIob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9O1xuXG4gIC8vIEluc3RhbnRpYXRlIEhtYWNfRFJCR1xuICB2YXIgZHJiZyA9IG5ldyBIbWFjRFJCRyh7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIHBlcnM6IG9wdGlvbnMucGVycyxcbiAgICBwZXJzRW5jOiBvcHRpb25zLnBlcnNFbmMgfHwgJ3V0ZjgnLFxuICAgIGVudHJvcHk6IG9wdGlvbnMuZW50cm9weSB8fCBlbGxpcHRpYy5yYW5kKHRoaXMuaGFzaC5obWFjU3RyZW5ndGgpLFxuICAgIGVudHJvcHlFbmM6IG9wdGlvbnMuZW50cm9weSAmJiBvcHRpb25zLmVudHJvcHlFbmMgfHwgJ3V0ZjgnLFxuICAgIG5vbmNlOiB0aGlzLm4udG9BcnJheSgpXG4gIH0pO1xuXG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBuczIgPSB0aGlzLm4uc3ViKG5ldyBCTigyKSk7XG4gIGRvIHtcbiAgICB2YXIgcHJpdiA9IG5ldyBCTihkcmJnLmdlbmVyYXRlKGJ5dGVzKSk7XG4gICAgaWYgKHByaXYuY21wKG5zMikgPiAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBwcml2LmlhZGRuKDEpO1xuICAgIHJldHVybiB0aGlzLmtleUZyb21Qcml2YXRlKHByaXYpO1xuICB9IHdoaWxlICh0cnVlKTtcbn07XG5cbkVDLnByb3RvdHlwZS5fdHJ1bmNhdGVUb04gPSBmdW5jdGlvbiB0cnVuY2F0ZVRvTihtc2csIHRydW5jT25seSkge1xuICB2YXIgZGVsdGEgPSBtc2cuYnl0ZUxlbmd0aCgpICogOCAtIHRoaXMubi5iaXRMZW5ndGgoKTtcbiAgaWYgKGRlbHRhID4gMClcbiAgICBtc2cgPSBtc2cudXNocm4oZGVsdGEpO1xuICBpZiAoIXRydW5jT25seSAmJiBtc2cuY21wKHRoaXMubikgPj0gMClcbiAgICByZXR1cm4gbXNnLnN1Yih0aGlzLm4pO1xuICBlbHNlXG4gICAgcmV0dXJuIG1zZztcbn07XG5cbkVDLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGtleSwgZW5jLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZW5jID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSBlbmM7XG4gICAgZW5jID0gbnVsbDtcbiAgfVxuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9O1xuXG4gIGtleSA9IHRoaXMua2V5RnJvbVByaXZhdGUoa2V5LCBlbmMpO1xuICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgQk4obXNnLCAxNikpO1xuXG4gIC8vIFplcm8tZXh0ZW5kIGtleSB0byBwcm92aWRlIGVub3VnaCBlbnRyb3B5XG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBia2V5ID0ga2V5LmdldFByaXZhdGUoKS50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuICAvLyBaZXJvLWV4dGVuZCBub25jZSB0byBoYXZlIHRoZSBzYW1lIGJ5dGUgc2l6ZSBhcyBOXG4gIHZhciBub25jZSA9IG1zZy50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgSG1hY0RSQkcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBlbnRyb3B5OiBia2V5LFxuICAgIG5vbmNlOiBub25jZSxcbiAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG4gICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4J1xuICB9KTtcblxuICAvLyBOdW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGVcbiAgdmFyIG5zMSA9IHRoaXMubi5zdWIobmV3IEJOKDEpKTtcblxuICBmb3IgKHZhciBpdGVyID0gMDsgdHJ1ZTsgaXRlcisrKSB7XG4gICAgdmFyIGsgPSBvcHRpb25zLmsgP1xuICAgICAgICBvcHRpb25zLmsoaXRlcikgOlxuICAgICAgICBuZXcgQk4oZHJiZy5nZW5lcmF0ZSh0aGlzLm4uYnl0ZUxlbmd0aCgpKSk7XG4gICAgayA9IHRoaXMuX3RydW5jYXRlVG9OKGssIHRydWUpO1xuICAgIGlmIChrLmNtcG4oMSkgPD0gMCB8fCBrLmNtcChuczEpID49IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBrcCA9IHRoaXMuZy5tdWwoayk7XG4gICAgaWYgKGtwLmlzSW5maW5pdHkoKSlcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtwWCA9IGtwLmdldFgoKTtcbiAgICB2YXIgciA9IGtwWC51bW9kKHRoaXMubik7XG4gICAgaWYgKHIuY21wbigwKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIHMgPSBrLmludm0odGhpcy5uKS5tdWwoci5tdWwoa2V5LmdldFByaXZhdGUoKSkuaWFkZChtc2cpKTtcbiAgICBzID0gcy51bW9kKHRoaXMubik7XG4gICAgaWYgKHMuY21wbigwKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIHJlY292ZXJ5UGFyYW0gPSAoa3AuZ2V0WSgpLmlzT2RkKCkgPyAxIDogMCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGtwWC5jbXAocikgIT09IDAgPyAyIDogMCk7XG5cbiAgICAvLyBVc2UgY29tcGxlbWVudCBvZiBgc2AsIGlmIGl0IGlzID4gYG4gLyAyYFxuICAgIGlmIChvcHRpb25zLmNhbm9uaWNhbCAmJiBzLmNtcCh0aGlzLm5oKSA+IDApIHtcbiAgICAgIHMgPSB0aGlzLm4uc3ViKHMpO1xuICAgICAgcmVjb3ZlcnlQYXJhbSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHsgcjogciwgczogcywgcmVjb3ZlcnlQYXJhbTogcmVjb3ZlcnlQYXJhbSB9KTtcbiAgfVxufTtcblxuRUMucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSwga2V5LCBlbmMpIHtcbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IEJOKG1zZywgMTYpKTtcbiAga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKGtleSwgZW5jKTtcbiAgc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZShzaWduYXR1cmUsICdoZXgnKTtcblxuICAvLyBQZXJmb3JtIHByaW1pdGl2ZSB2YWx1ZXMgdmFsaWRhdGlvblxuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuICBpZiAoci5jbXBuKDEpIDwgMCB8fCByLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAocy5jbXBuKDEpIDwgMCB8fCBzLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFZhbGlkYXRlIHNpZ25hdHVyZVxuICB2YXIgc2ludiA9IHMuaW52bSh0aGlzLm4pO1xuICB2YXIgdTEgPSBzaW52Lm11bChtc2cpLnVtb2QodGhpcy5uKTtcbiAgdmFyIHUyID0gc2ludi5tdWwocikudW1vZCh0aGlzLm4pO1xuXG4gIGlmICghdGhpcy5jdXJ2ZS5fbWF4d2VsbFRyaWNrKSB7XG4gICAgdmFyIHAgPSB0aGlzLmcubXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcbiAgICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gcC5nZXRYKCkudW1vZCh0aGlzLm4pLmNtcChyKSA9PT0gMDtcbiAgfVxuXG4gIC8vIE5PVEU6IEdyZWcgTWF4d2VsbCdzIHRyaWNrLCBpbnNwaXJlZCBieTpcbiAgLy8gaHR0cHM6Ly9naXQuaW8vdmFkM0tcblxuICB2YXIgcCA9IHRoaXMuZy5qbXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBDb21wYXJlIGBwLnhgIG9mIEphY29iaWFuIHBvaW50IHdpdGggYHJgLFxuICAvLyB0aGlzIHdpbGwgZG8gYHAueCA9PSByICogcC56XjJgIGluc3RlYWQgb2YgbXVsdGlwbHlpbmcgYHAueGAgYnkgdGhlXG4gIC8vIGludmVyc2Ugb2YgYHAuel4yYFxuICByZXR1cm4gcC5lcVhUb1Aocik7XG59O1xuXG5FQy5wcm90b3R5cGUucmVjb3ZlclB1YktleSA9IGZ1bmN0aW9uKG1zZywgc2lnbmF0dXJlLCBqLCBlbmMpIHtcbiAgYXNzZXJ0KCgzICYgaikgPT09IGosICdUaGUgcmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzJyk7XG4gIHNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoc2lnbmF0dXJlLCBlbmMpO1xuXG4gIHZhciBuID0gdGhpcy5uO1xuICB2YXIgZSA9IG5ldyBCTihtc2cpO1xuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuXG4gIC8vIEEgc2V0IExTQiBzaWduaWZpZXMgdGhhdCB0aGUgeS1jb29yZGluYXRlIGlzIG9kZFxuICB2YXIgaXNZT2RkID0gaiAmIDE7XG4gIHZhciBpc1NlY29uZEtleSA9IGogPj4gMTtcbiAgaWYgKHIuY21wKHRoaXMuY3VydmUucC51bW9kKHRoaXMuY3VydmUubikpID49IDAgJiYgaXNTZWNvbmRLZXkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGUnKTtcblxuICAvLyAxLjEuIExldCB4ID0gciArIGpuLlxuICBpZiAoaXNTZWNvbmRLZXkpXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLmFkZCh0aGlzLmN1cnZlLm4pLCBpc1lPZGQpO1xuICBlbHNlXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLCBpc1lPZGQpO1xuXG4gIHZhciBySW52ID0gc2lnbmF0dXJlLnIuaW52bShuKTtcbiAgdmFyIHMxID0gbi5zdWIoZSkubXVsKHJJbnYpLnVtb2Qobik7XG4gIHZhciBzMiA9IHMubXVsKHJJbnYpLnVtb2Qobik7XG5cbiAgLy8gMS42LjEgQ29tcHV0ZSBRID0gcl4tMSAoc1IgLSAgZUcpXG4gIC8vICAgICAgICAgICAgICAgUSA9IHJeLTEgKHNSICsgLWVHKVxuICByZXR1cm4gdGhpcy5nLm11bEFkZChzMSwgciwgczIpO1xufTtcblxuRUMucHJvdG90eXBlLmdldEtleVJlY292ZXJ5UGFyYW0gPSBmdW5jdGlvbihlLCBzaWduYXR1cmUsIFEsIGVuYykge1xuICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHNpZ25hdHVyZSwgZW5jKTtcbiAgaWYgKHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtICE9PSBudWxsKVxuICAgIHJldHVybiBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWU7XG4gICAgdHJ5IHtcbiAgICAgIFFwcmltZSA9IHRoaXMucmVjb3ZlclB1YktleShlLCBzaWduYXR1cmUsIGkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChRcHJpbWUuZXEoUSkpXG4gICAgICByZXR1cm4gaTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHZhbGlkIHJlY292ZXJ5IGZhY3RvcicpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBLZXlQYWlyKGVjLCBvcHRpb25zKSB7XG4gIHRoaXMuZWMgPSBlYztcbiAgdGhpcy5wcml2ID0gbnVsbDtcbiAgdGhpcy5wdWIgPSBudWxsO1xuXG4gIC8vIEtleVBhaXIoZWMsIHsgcHJpdjogLi4uLCBwdWI6IC4uLiB9KVxuICBpZiAob3B0aW9ucy5wcml2KVxuICAgIHRoaXMuX2ltcG9ydFByaXZhdGUob3B0aW9ucy5wcml2LCBvcHRpb25zLnByaXZFbmMpO1xuICBpZiAob3B0aW9ucy5wdWIpXG4gICAgdGhpcy5faW1wb3J0UHVibGljKG9wdGlvbnMucHViLCBvcHRpb25zLnB1YkVuYyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEtleVBhaXI7XG5cbktleVBhaXIuZnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGZyb21QdWJsaWMoZWMsIHB1YiwgZW5jKSB7XG4gIGlmIChwdWIgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwdWI7XG5cbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG4gICAgcHViOiBwdWIsXG4gICAgcHViRW5jOiBlbmNcbiAgfSk7XG59O1xuXG5LZXlQYWlyLmZyb21Qcml2YXRlID0gZnVuY3Rpb24gZnJvbVByaXZhdGUoZWMsIHByaXYsIGVuYykge1xuICBpZiAocHJpdiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHByaXY7XG5cbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG4gICAgcHJpdjogcHJpdixcbiAgICBwcml2RW5jOiBlbmNcbiAgfSk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICB2YXIgcHViID0gdGhpcy5nZXRQdWJsaWMoKTtcblxuICBpZiAocHViLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdJbnZhbGlkIHB1YmxpYyBrZXknIH07XG4gIGlmICghcHViLnZhbGlkYXRlKCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnUHVibGljIGtleSBpcyBub3QgYSBwb2ludCcgfTtcbiAgaWYgKCFwdWIubXVsKHRoaXMuZWMuY3VydmUubikuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgKiBOICE9IE8nIH07XG5cbiAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCByZWFzb246IG51bGwgfTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFB1YmxpYyA9IGZ1bmN0aW9uIGdldFB1YmxpYyhjb21wYWN0LCBlbmMpIHtcbiAgLy8gY29tcGFjdCBpcyBvcHRpb25hbCBhcmd1bWVudFxuICBpZiAodHlwZW9mIGNvbXBhY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jID0gY29tcGFjdDtcbiAgICBjb21wYWN0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdGhpcy5wdWIpXG4gICAgdGhpcy5wdWIgPSB0aGlzLmVjLmcubXVsKHRoaXMucHJpdik7XG5cbiAgaWYgKCFlbmMpXG4gICAgcmV0dXJuIHRoaXMucHViO1xuXG4gIHJldHVybiB0aGlzLnB1Yi5lbmNvZGUoZW5jLCBjb21wYWN0KTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFByaXZhdGUgPSBmdW5jdGlvbiBnZXRQcml2YXRlKGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdGhpcy5wcml2LnRvU3RyaW5nKDE2LCAyKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLnByaXY7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5faW1wb3J0UHJpdmF0ZSA9IGZ1bmN0aW9uIF9pbXBvcnRQcml2YXRlKGtleSwgZW5jKSB7XG4gIHRoaXMucHJpdiA9IG5ldyBCTihrZXksIGVuYyB8fCAxNik7XG5cbiAgLy8gRW5zdXJlIHRoYXQgdGhlIHByaXYgd29uJ3QgYmUgYmlnZ2VyIHRoYW4gbiwgb3RoZXJ3aXNlIHdlIG1heSBmYWlsXG4gIC8vIGluIGZpeGVkIG11bHRpcGxpY2F0aW9uIG1ldGhvZFxuICB0aGlzLnByaXYgPSB0aGlzLnByaXYudW1vZCh0aGlzLmVjLmN1cnZlLm4pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIF9pbXBvcnRQdWJsaWMoa2V5LCBlbmMpIHtcbiAgaWYgKGtleS54IHx8IGtleS55KSB7XG4gICAgLy8gTW9udGdvbWVyeSBwb2ludHMgb25seSBoYXZlIGFuIGB4YCBjb29yZGluYXRlLlxuICAgIC8vIFdlaWVyc3RyYXNzL0Vkd2FyZHMgcG9pbnRzIG9uIHRoZSBvdGhlciBoYW5kIGhhdmUgYm90aCBgeGAgYW5kXG4gICAgLy8gYHlgIGNvb3JkaW5hdGVzLlxuICAgIGlmICh0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdtb250Jykge1xuICAgICAgYXNzZXJ0KGtleS54LCAnTmVlZCB4IGNvb3JkaW5hdGUnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ3Nob3J0JyB8fFxuICAgICAgICAgICAgICAgdGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnZWR3YXJkcycpIHtcbiAgICAgIGFzc2VydChrZXkueCAmJiBrZXkueSwgJ05lZWQgYm90aCB4IGFuZCB5IGNvb3JkaW5hdGUnKTtcbiAgICB9XG4gICAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLnBvaW50KGtleS54LCBrZXkueSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5kZWNvZGVQb2ludChrZXksIGVuYyk7XG59O1xuXG4vLyBFQ0RIXG5LZXlQYWlyLnByb3RvdHlwZS5kZXJpdmUgPSBmdW5jdGlvbiBkZXJpdmUocHViKSB7XG4gIHJldHVybiBwdWIubXVsKHRoaXMucHJpdikuZ2V0WCgpO1xufTtcblxuLy8gRUNEU0FcbktleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywgZW5jLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmVjLnNpZ24obXNnLCB0aGlzLCBlbmMsIG9wdGlvbnMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlKSB7XG4gIHJldHVybiB0aGlzLmVjLnZlcmlmeShtc2csIHNpZ25hdHVyZSwgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgcmV0dXJuICc8S2V5IHByaXY6ICcgKyAodGhpcy5wcml2ICYmIHRoaXMucHJpdi50b1N0cmluZygxNiwgMikpICtcbiAgICAgICAgICcgcHViOiAnICsgKHRoaXMucHViICYmIHRoaXMucHViLmluc3BlY3QoKSkgKyAnID4nO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMva2V5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xuXG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBTaWduYXR1cmUob3B0aW9ucywgZW5jKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuICAgIHJldHVybiBvcHRpb25zO1xuXG4gIGlmICh0aGlzLl9pbXBvcnRERVIob3B0aW9ucywgZW5jKSlcbiAgICByZXR1cm47XG5cbiAgYXNzZXJ0KG9wdGlvbnMuciAmJiBvcHRpb25zLnMsICdTaWduYXR1cmUgd2l0aG91dCByIG9yIHMnKTtcbiAgdGhpcy5yID0gbmV3IEJOKG9wdGlvbnMuciwgMTYpO1xuICB0aGlzLnMgPSBuZXcgQk4ob3B0aW9ucy5zLCAxNik7XG4gIGlmIChvcHRpb25zLnJlY292ZXJ5UGFyYW0gPT09IHVuZGVmaW5lZClcbiAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsO1xuICBlbHNlXG4gICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gb3B0aW9ucy5yZWNvdmVyeVBhcmFtO1xufVxubW9kdWxlLmV4cG9ydHMgPSBTaWduYXR1cmU7XG5cbmZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuICB0aGlzLnBsYWNlID0gMDtcbn1cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoKGJ1ZiwgcCkge1xuICB2YXIgaW5pdGlhbCA9IGJ1ZltwLnBsYWNlKytdO1xuICBpZiAoIShpbml0aWFsICYgMHg4MCkpIHtcbiAgICByZXR1cm4gaW5pdGlhbDtcbiAgfVxuICB2YXIgb2N0ZXRMZW4gPSBpbml0aWFsICYgMHhmO1xuICB2YXIgdmFsID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIG9mZiA9IHAucGxhY2U7IGkgPCBvY3RldExlbjsgaSsrLCBvZmYrKykge1xuICAgIHZhbCA8PD0gODtcbiAgICB2YWwgfD0gYnVmW29mZl07XG4gIH1cbiAgcC5wbGFjZSA9IG9mZjtcbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gcm1QYWRkaW5nKGJ1Zikge1xuICB2YXIgaSA9IDA7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCFidWZbaV0gJiYgIShidWZbaSArIDFdICYgMHg4MCkgJiYgaSA8IGxlbikge1xuICAgIGkrKztcbiAgfVxuICBpZiAoaSA9PT0gMCkge1xuICAgIHJldHVybiBidWY7XG4gIH1cbiAgcmV0dXJuIGJ1Zi5zbGljZShpKTtcbn1cblxuU2lnbmF0dXJlLnByb3RvdHlwZS5faW1wb3J0REVSID0gZnVuY3Rpb24gX2ltcG9ydERFUihkYXRhLCBlbmMpIHtcbiAgZGF0YSA9IHV0aWxzLnRvQXJyYXkoZGF0YSwgZW5jKTtcbiAgdmFyIHAgPSBuZXcgUG9zaXRpb24oKTtcbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgzMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAoKGxlbiArIHAucGxhY2UpICE9PSBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBybGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICB2YXIgciA9IGRhdGEuc2xpY2UocC5wbGFjZSwgcmxlbiArIHAucGxhY2UpO1xuICBwLnBsYWNlICs9IHJsZW47XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHNsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gc2xlbiArIHAucGxhY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHMgPSBkYXRhLnNsaWNlKHAucGxhY2UsIHNsZW4gKyBwLnBsYWNlKTtcbiAgaWYgKHJbMF0gPT09IDAgJiYgKHJbMV0gJiAweDgwKSkge1xuICAgIHIgPSByLnNsaWNlKDEpO1xuICB9XG4gIGlmIChzWzBdID09PSAwICYmIChzWzFdICYgMHg4MCkpIHtcbiAgICBzID0gcy5zbGljZSgxKTtcbiAgfVxuXG4gIHRoaXMuciA9IG5ldyBCTihyKTtcbiAgdGhpcy5zID0gbmV3IEJOKHMpO1xuICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gY29uc3RydWN0TGVuZ3RoKGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPCAweDgwKSB7XG4gICAgYXJyLnB1c2gobGVuKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9jdGV0cyA9IDEgKyAoTWF0aC5sb2cobGVuKSAvIE1hdGguTE4yID4+PiAzKTtcbiAgYXJyLnB1c2gob2N0ZXRzIHwgMHg4MCk7XG4gIHdoaWxlICgtLW9jdGV0cykge1xuICAgIGFyci5wdXNoKChsZW4gPj4+IChvY3RldHMgPDwgMykpICYgMHhmZik7XG4gIH1cbiAgYXJyLnB1c2gobGVuKTtcbn1cblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0RFUiA9IGZ1bmN0aW9uIHRvREVSKGVuYykge1xuICB2YXIgciA9IHRoaXMuci50b0FycmF5KCk7XG4gIHZhciBzID0gdGhpcy5zLnRvQXJyYXkoKTtcblxuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChyWzBdICYgMHg4MClcbiAgICByID0gWyAwIF0uY29uY2F0KHIpO1xuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChzWzBdICYgMHg4MClcbiAgICBzID0gWyAwIF0uY29uY2F0KHMpO1xuXG4gIHIgPSBybVBhZGRpbmcocik7XG4gIHMgPSBybVBhZGRpbmcocyk7XG5cbiAgd2hpbGUgKCFzWzBdICYmICEoc1sxXSAmIDB4ODApKSB7XG4gICAgcyA9IHMuc2xpY2UoMSk7XG4gIH1cbiAgdmFyIGFyciA9IFsgMHgwMiBdO1xuICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCByLmxlbmd0aCk7XG4gIGFyciA9IGFyci5jb25jYXQocik7XG4gIGFyci5wdXNoKDB4MDIpO1xuICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCBzLmxlbmd0aCk7XG4gIHZhciBiYWNrSGFsZiA9IGFyci5jb25jYXQocyk7XG4gIHZhciByZXMgPSBbIDB4MzAgXTtcbiAgY29uc3RydWN0TGVuZ3RoKHJlcywgYmFja0hhbGYubGVuZ3RoKTtcbiAgcmVzID0gcmVzLmNvbmNhdChiYWNrSGFsZik7XG4gIHJldHVybiB1dGlscy5lbmNvZGUocmVzLCBlbmMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMvc2lnbmF0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJ2hhc2guanMnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG52YXIgcGFyc2VCeXRlcyA9IHV0aWxzLnBhcnNlQnl0ZXM7XG52YXIgS2V5UGFpciA9IHJlcXVpcmUoJy4va2V5Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcblxuZnVuY3Rpb24gRUREU0EoY3VydmUpIHtcbiAgYXNzZXJ0KGN1cnZlID09PSAnZWQyNTUxOScsICdvbmx5IHRlc3RlZCB3aXRoIGVkMjU1MTkgc28gZmFyJyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVERFNBKSlcbiAgICByZXR1cm4gbmV3IEVERFNBKGN1cnZlKTtcblxuICB2YXIgY3VydmUgPSBlbGxpcHRpYy5jdXJ2ZXNbY3VydmVdLmN1cnZlO1xuICB0aGlzLmN1cnZlID0gY3VydmU7XG4gIHRoaXMuZyA9IGN1cnZlLmc7XG4gIHRoaXMuZy5wcmVjb21wdXRlKGN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcblxuICB0aGlzLnBvaW50Q2xhc3MgPSBjdXJ2ZS5wb2ludCgpLmNvbnN0cnVjdG9yO1xuICB0aGlzLmVuY29kaW5nTGVuZ3RoID0gTWF0aC5jZWlsKGN1cnZlLm4uYml0TGVuZ3RoKCkgLyA4KTtcbiAgdGhpcy5oYXNoID0gaGFzaC5zaGE1MTI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRUREU0E7XG5cbi8qKlxuKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gbWVzc2FnZSAtIG1lc3NhZ2UgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8S2V5UGFpcn0gc2VjcmV0IC0gc2VjcmV0IGJ5dGVzIG9yIGEga2V5cGFpclxuKiBAcmV0dXJucyB7U2lnbmF0dXJlfSAtIHNpZ25hdHVyZVxuKi9cbkVERFNBLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtZXNzYWdlLCBzZWNyZXQpIHtcbiAgbWVzc2FnZSA9IHBhcnNlQnl0ZXMobWVzc2FnZSk7XG4gIHZhciBrZXkgPSB0aGlzLmtleUZyb21TZWNyZXQoc2VjcmV0KTtcbiAgdmFyIHIgPSB0aGlzLmhhc2hJbnQoa2V5Lm1lc3NhZ2VQcmVmaXgoKSwgbWVzc2FnZSk7XG4gIHZhciBSID0gdGhpcy5nLm11bChyKTtcbiAgdmFyIFJlbmNvZGVkID0gdGhpcy5lbmNvZGVQb2ludChSKTtcbiAgdmFyIHNfID0gdGhpcy5oYXNoSW50KFJlbmNvZGVkLCBrZXkucHViQnl0ZXMoKSwgbWVzc2FnZSlcbiAgICAgICAgICAgICAgIC5tdWwoa2V5LnByaXYoKSk7XG4gIHZhciBTID0gci5hZGQoc18pLnVtb2QodGhpcy5jdXJ2ZS5uKTtcbiAgcmV0dXJuIHRoaXMubWFrZVNpZ25hdHVyZSh7IFI6IFIsIFM6IFMsIFJlbmNvZGVkOiBSZW5jb2RlZCB9KTtcbn07XG5cbi8qKlxuKiBAcGFyYW0ge0FycmF5fSBtZXNzYWdlIC0gbWVzc2FnZSBieXRlc1xuKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xTaWduYXR1cmV9IHNpZyAtIHNpZyBieXRlc1xuKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xQb2ludHxLZXlQYWlyfSBwdWIgLSBwdWJsaWMga2V5XG4qIEByZXR1cm5zIHtCb29sZWFufSAtIHRydWUgaWYgcHVibGljIGtleSBtYXRjaGVzIHNpZyBvZiBtZXNzYWdlXG4qL1xuRUREU0EucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlLCBzaWcsIHB1Yikge1xuICBtZXNzYWdlID0gcGFyc2VCeXRlcyhtZXNzYWdlKTtcbiAgc2lnID0gdGhpcy5tYWtlU2lnbmF0dXJlKHNpZyk7XG4gIHZhciBrZXkgPSB0aGlzLmtleUZyb21QdWJsaWMocHViKTtcbiAgdmFyIGggPSB0aGlzLmhhc2hJbnQoc2lnLlJlbmNvZGVkKCksIGtleS5wdWJCeXRlcygpLCBtZXNzYWdlKTtcbiAgdmFyIFNHID0gdGhpcy5nLm11bChzaWcuUygpKTtcbiAgdmFyIFJwbHVzQWggPSBzaWcuUigpLmFkZChrZXkucHViKCkubXVsKGgpKTtcbiAgcmV0dXJuIFJwbHVzQWguZXEoU0cpO1xufTtcblxuRUREU0EucHJvdG90eXBlLmhhc2hJbnQgPSBmdW5jdGlvbiBoYXNoSW50KCkge1xuICB2YXIgaGFzaCA9IHRoaXMuaGFzaCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICBoYXNoLnVwZGF0ZShhcmd1bWVudHNbaV0pO1xuICByZXR1cm4gdXRpbHMuaW50RnJvbUxFKGhhc2guZGlnZXN0KCkpLnVtb2QodGhpcy5jdXJ2ZS5uKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5rZXlGcm9tUHVibGljID0gZnVuY3Rpb24ga2V5RnJvbVB1YmxpYyhwdWIpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVB1YmxpYyh0aGlzLCBwdWIpO1xufTtcblxuRUREU0EucHJvdG90eXBlLmtleUZyb21TZWNyZXQgPSBmdW5jdGlvbiBrZXlGcm9tU2VjcmV0KHNlY3JldCkge1xuICByZXR1cm4gS2V5UGFpci5mcm9tU2VjcmV0KHRoaXMsIHNlY3JldCk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUubWFrZVNpZ25hdHVyZSA9IGZ1bmN0aW9uIG1ha2VTaWduYXR1cmUoc2lnKSB7XG4gIGlmIChzaWcgaW5zdGFuY2VvZiBTaWduYXR1cmUpXG4gICAgcmV0dXJuIHNpZztcbiAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcywgc2lnKTtcbn07XG5cbi8qKlxuKiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1qb3NlZnNzb24tZWRkc2EtZWQyNTUxOS0wMyNzZWN0aW9uLTUuMlxuKlxuKiBFRERTQSBkZWZpbmVzIG1ldGhvZHMgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBwb2ludHMgYW5kIGludGVnZXJzLiBUaGVzZSBhcmVcbiogaGVscGVyIGNvbnZlbmllbmNlIG1ldGhvZHMsIHRoYXQgcGFzcyBhbG9uZyB0byB1dGlsaXR5IGZ1bmN0aW9ucyBpbXBsaWVkXG4qIHBhcmFtZXRlcnMuXG4qXG4qL1xuRUREU0EucHJvdG90eXBlLmVuY29kZVBvaW50ID0gZnVuY3Rpb24gZW5jb2RlUG9pbnQocG9pbnQpIHtcbiAgdmFyIGVuYyA9IHBvaW50LmdldFkoKS50b0FycmF5KCdsZScsIHRoaXMuZW5jb2RpbmdMZW5ndGgpO1xuICBlbmNbdGhpcy5lbmNvZGluZ0xlbmd0aCAtIDFdIHw9IHBvaW50LmdldFgoKS5pc09kZCgpID8gMHg4MCA6IDA7XG4gIHJldHVybiBlbmM7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuZGVjb2RlUG9pbnQgPSBmdW5jdGlvbiBkZWNvZGVQb2ludChieXRlcykge1xuICBieXRlcyA9IHV0aWxzLnBhcnNlQnl0ZXMoYnl0ZXMpO1xuXG4gIHZhciBsYXN0SXggPSBieXRlcy5sZW5ndGggLSAxO1xuICB2YXIgbm9ybWVkID0gYnl0ZXMuc2xpY2UoMCwgbGFzdEl4KS5jb25jYXQoYnl0ZXNbbGFzdEl4XSAmIH4weDgwKTtcbiAgdmFyIHhJc09kZCA9IChieXRlc1tsYXN0SXhdICYgMHg4MCkgIT09IDA7XG5cbiAgdmFyIHkgPSB1dGlscy5pbnRGcm9tTEUobm9ybWVkKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnRGcm9tWSh5LCB4SXNPZGQpO1xufTtcblxuRUREU0EucHJvdG90eXBlLmVuY29kZUludCA9IGZ1bmN0aW9uIGVuY29kZUludChudW0pIHtcbiAgcmV0dXJuIG51bS50b0FycmF5KCdsZScsIHRoaXMuZW5jb2RpbmdMZW5ndGgpO1xufTtcblxuRUREU0EucHJvdG90eXBlLmRlY29kZUludCA9IGZ1bmN0aW9uIGRlY29kZUludChieXRlcykge1xuICByZXR1cm4gdXRpbHMuaW50RnJvbUxFKGJ5dGVzKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5pc1BvaW50ID0gZnVuY3Rpb24gaXNQb2ludCh2YWwpIHtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIHRoaXMucG9pbnRDbGFzcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xudmFyIGNhY2hlZFByb3BlcnR5ID0gdXRpbHMuY2FjaGVkUHJvcGVydHk7XG5cbi8qKlxuKiBAcGFyYW0ge0VERFNBfSBlZGRzYSAtIGluc3RhbmNlXG4qIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBwdWJsaWMvcHJpdmF0ZSBrZXkgcGFyYW1ldGVyc1xuKlxuKiBAcGFyYW0ge0FycmF5PEJ5dGU+fSBbcGFyYW1zLnNlY3JldF0gLSBzZWNyZXQgc2VlZCBieXRlc1xuKiBAcGFyYW0ge1BvaW50fSBbcGFyYW1zLnB1Yl0gLSBwdWJsaWMga2V5IHBvaW50IChha2EgYEFgIGluIGVkZHNhIHRlcm1zKVxuKiBAcGFyYW0ge0FycmF5PEJ5dGU+fSBbcGFyYW1zLnB1Yl0gLSBwdWJsaWMga2V5IHBvaW50IGVuY29kZWQgYXMgYnl0ZXNcbipcbiovXG5mdW5jdGlvbiBLZXlQYWlyKGVkZHNhLCBwYXJhbXMpIHtcbiAgdGhpcy5lZGRzYSA9IGVkZHNhO1xuICB0aGlzLl9zZWNyZXQgPSBwYXJzZUJ5dGVzKHBhcmFtcy5zZWNyZXQpO1xuICBpZiAoZWRkc2EuaXNQb2ludChwYXJhbXMucHViKSlcbiAgICB0aGlzLl9wdWIgPSBwYXJhbXMucHViO1xuICBlbHNlXG4gICAgdGhpcy5fcHViQnl0ZXMgPSBwYXJzZUJ5dGVzKHBhcmFtcy5wdWIpO1xufVxuXG5LZXlQYWlyLmZyb21QdWJsaWMgPSBmdW5jdGlvbiBmcm9tUHVibGljKGVkZHNhLCBwdWIpIHtcbiAgaWYgKHB1YiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHB1YjtcbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVkZHNhLCB7IHB1YjogcHViIH0pO1xufTtcblxuS2V5UGFpci5mcm9tU2VjcmV0ID0gZnVuY3Rpb24gZnJvbVNlY3JldChlZGRzYSwgc2VjcmV0KSB7XG4gIGlmIChzZWNyZXQgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBzZWNyZXQ7XG4gIHJldHVybiBuZXcgS2V5UGFpcihlZGRzYSwgeyBzZWNyZXQ6IHNlY3JldCB9KTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnNlY3JldCA9IGZ1bmN0aW9uIHNlY3JldCgpIHtcbiAgcmV0dXJuIHRoaXMuX3NlY3JldDtcbn07XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdwdWJCeXRlcycsIGZ1bmN0aW9uIHB1YkJ5dGVzKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5lbmNvZGVQb2ludCh0aGlzLnB1YigpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHViJywgZnVuY3Rpb24gcHViKCkge1xuICBpZiAodGhpcy5fcHViQnl0ZXMpXG4gICAgcmV0dXJuIHRoaXMuZWRkc2EuZGVjb2RlUG9pbnQodGhpcy5fcHViQnl0ZXMpO1xuICByZXR1cm4gdGhpcy5lZGRzYS5nLm11bCh0aGlzLnByaXYoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ3ByaXZCeXRlcycsIGZ1bmN0aW9uIHByaXZCeXRlcygpIHtcbiAgdmFyIGVkZHNhID0gdGhpcy5lZGRzYTtcbiAgdmFyIGhhc2ggPSB0aGlzLmhhc2goKTtcbiAgdmFyIGxhc3RJeCA9IGVkZHNhLmVuY29kaW5nTGVuZ3RoIC0gMTtcblxuICB2YXIgYSA9IGhhc2guc2xpY2UoMCwgZWRkc2EuZW5jb2RpbmdMZW5ndGgpO1xuICBhWzBdICY9IDI0ODtcbiAgYVtsYXN0SXhdICY9IDEyNztcbiAgYVtsYXN0SXhdIHw9IDY0O1xuXG4gIHJldHVybiBhO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdwcml2JywgZnVuY3Rpb24gcHJpdigpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZGVjb2RlSW50KHRoaXMucHJpdkJ5dGVzKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdoYXNoJywgZnVuY3Rpb24gaGFzaCgpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuaGFzaCgpLnVwZGF0ZSh0aGlzLnNlY3JldCgpKS5kaWdlc3QoKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAnbWVzc2FnZVByZWZpeCcsIGZ1bmN0aW9uIG1lc3NhZ2VQcmVmaXgoKSB7XG4gIHJldHVybiB0aGlzLmhhc2goKS5zbGljZSh0aGlzLmVkZHNhLmVuY29kaW5nTGVuZ3RoKTtcbn0pO1xuXG5LZXlQYWlyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtZXNzYWdlKSB7XG4gIGFzc2VydCh0aGlzLl9zZWNyZXQsICdLZXlQYWlyIGNhbiBvbmx5IHZlcmlmeScpO1xuICByZXR1cm4gdGhpcy5lZGRzYS5zaWduKG1lc3NhZ2UsIHRoaXMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UsIHNpZykge1xuICByZXR1cm4gdGhpcy5lZGRzYS52ZXJpZnkobWVzc2FnZSwgc2lnLCB0aGlzKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFNlY3JldCA9IGZ1bmN0aW9uIGdldFNlY3JldChlbmMpIHtcbiAgYXNzZXJ0KHRoaXMuX3NlY3JldCwgJ0tleVBhaXIgaXMgcHVibGljIG9ubHknKTtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZSh0aGlzLnNlY3JldCgpLCBlbmMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuZ2V0UHVibGljID0gZnVuY3Rpb24gZ2V0UHVibGljKGVuYykge1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMucHViQnl0ZXMoKSwgZW5jKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5UGFpcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWRkc2Eva2V5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBjYWNoZWRQcm9wZXJ0eSA9IHV0aWxzLmNhY2hlZFByb3BlcnR5O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xuXG4vKipcbiogQHBhcmFtIHtFRERTQX0gZWRkc2EgLSBlZGRzYSBpbnN0YW5jZVxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxPYmplY3R9IHNpZyAtXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fFBvaW50fSBbc2lnLlJdIC0gUiBwb2ludCBhcyBQb2ludCBvciBieXRlc1xuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxibn0gW3NpZy5TXSAtIFMgc2NhbGFyIGFzIGJuIG9yIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fSBbc2lnLlJlbmNvZGVkXSAtIFIgcG9pbnQgZW5jb2RlZFxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPn0gW3NpZy5TZW5jb2RlZF0gLSBTIHNjYWxhciBlbmNvZGVkXG4qL1xuZnVuY3Rpb24gU2lnbmF0dXJlKGVkZHNhLCBzaWcpIHtcbiAgdGhpcy5lZGRzYSA9IGVkZHNhO1xuXG4gIGlmICh0eXBlb2Ygc2lnICE9PSAnb2JqZWN0JylcbiAgICBzaWcgPSBwYXJzZUJ5dGVzKHNpZyk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc2lnKSkge1xuICAgIHNpZyA9IHtcbiAgICAgIFI6IHNpZy5zbGljZSgwLCBlZGRzYS5lbmNvZGluZ0xlbmd0aCksXG4gICAgICBTOiBzaWcuc2xpY2UoZWRkc2EuZW5jb2RpbmdMZW5ndGgpXG4gICAgfTtcbiAgfVxuXG4gIGFzc2VydChzaWcuUiAmJiBzaWcuUywgJ1NpZ25hdHVyZSB3aXRob3V0IFIgb3IgUycpO1xuXG4gIGlmIChlZGRzYS5pc1BvaW50KHNpZy5SKSlcbiAgICB0aGlzLl9SID0gc2lnLlI7XG4gIGlmIChzaWcuUyBpbnN0YW5jZW9mIEJOKVxuICAgIHRoaXMuX1MgPSBzaWcuUztcblxuICB0aGlzLl9SZW5jb2RlZCA9IEFycmF5LmlzQXJyYXkoc2lnLlIpID8gc2lnLlIgOiBzaWcuUmVuY29kZWQ7XG4gIHRoaXMuX1NlbmNvZGVkID0gQXJyYXkuaXNBcnJheShzaWcuUykgPyBzaWcuUyA6IHNpZy5TZW5jb2RlZDtcbn1cblxuY2FjaGVkUHJvcGVydHkoU2lnbmF0dXJlLCAnUycsIGZ1bmN0aW9uIFMoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZUludCh0aGlzLlNlbmNvZGVkKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1InLCBmdW5jdGlvbiBSKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVQb2ludCh0aGlzLlJlbmNvZGVkKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1JlbmNvZGVkJywgZnVuY3Rpb24gUmVuY29kZWQoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmVuY29kZVBvaW50KHRoaXMuUigpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdTZW5jb2RlZCcsIGZ1bmN0aW9uIFNlbmNvZGVkKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5lbmNvZGVJbnQodGhpcy5TKCkpO1xufSk7XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXMoKSB7XG4gIHJldHVybiB0aGlzLlJlbmNvZGVkKCkuY29uY2F0KHRoaXMuU2VuY29kZWQoKSk7XG59O1xuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24gdG9IZXgoKSB7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy50b0J5dGVzKCksICdoZXgnKS50b1VwcGVyQ2FzZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaWduYXR1cmU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL3NpZ25hdHVyZS5qc1xuLy8gbW9kdWxlIGlkID0gMjMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBkb3VibGVzOiB7XG4gICAgc3RlcDogNCxcbiAgICBwb2ludHM6IFtcbiAgICAgIFtcbiAgICAgICAgJ2U2MGZjZTkzYjU5ZTllYzUzMDExYWFiYzIxYzIzZTk3YjJhMzEzNjliODdhNWFlOWM0NGVlODllMmE2ZGVjMGEnLFxuICAgICAgICAnZjdlMzUwNzM5OWU1OTU5MjlkYjk5ZjM0ZjU3OTM3MTAxMjk2ODkxZTQ0ZDIzZjBiZTFmMzJjY2U2OTYxNjgyMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MjgyMjYzMjEyYzYwOWQ5ZWEyYTZlM2UxNzJkZTIzOGQ4YzM5Y2FiZDVhYzFjYTEwNjQ2ZTIzZmQ1ZjUxNTA4JyxcbiAgICAgICAgJzExZjhhODA5ODU1N2RmZTQ1ZTgyNTZlODMwYjYwYWNlNjJkNjEzYWMyZjdiMTdiZWQzMWI2ZWFmZjZlMjZjYWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTc1ZTE1OWY3MjhiODY1YTcyZjk5Y2M2YzZmYzg0NmRlMGI5MzgzM2ZkMjIyMmVkNzNmY2U1YjU1MWU1YjczOScsXG4gICAgICAgICdkMzUwNmUwZDllM2M3OWViYTRlZjk3YTUxZmY3MWY1ZWFjYjU5NTVhZGQyNDM0NWM2ZWZhNmZmZWU5ZmVkNjk1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM2M2Q5MGQ0NDdiMDBjOWM5OWNlYWMwNWI2MjYyZWUwNTM0NDFjN2U1NTU1MmZmZTUyNmJhZDhmODNmZjQ2NDAnLFxuICAgICAgICAnNGUyNzNhZGZjNzMyMjIxOTUzYjQ0NTM5N2YzMzYzMTQ1YjlhODkwMDgxOTllY2I2MjAwM2M3ZjNiZWU5ZGU5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhiNGI1ZjE2NWRmM2MyYmU4YzYyNDRiNWI3NDU2Mzg4NDNlNGE3ODFhMTViY2QxYjY5Zjc5YTU1ZGZmZGY4MGMnLFxuICAgICAgICAnNGFhZDBhNmY2OGQzMDhiNGIzZmJkNzgxM2FiMGRhMDRmOWUzMzY1NDYxNjJlZTU2YjNlZmYwYzY1ZmQ0ZmQzNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3MjNjYmFhNmU1ZGI5OTZkNmJmNzcxYzAwYmQ1NDhjN2I3MDBkYmZmYTZjMGU3N2JjYjYxMTU5MjUyMzJmY2RhJyxcbiAgICAgICAgJzk2ZTg2N2I1NTk1Y2M0OThhOTIxMTM3NDg4ODI0ZDZlMjY2MGEwNjUzNzc5NDk0ODAxZGMwNjlkOWViMzlmNWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWViZmE0ZDQ5M2JlYmY5OGJhNWZlZWM4MTJjMmQzYjUwOTQ3OTYxMjM3YTkxOTgzOWE1MzNlY2EwZTdkZDdmYScsXG4gICAgICAgICc1ZDlhOGNhMzk3MGVmMGYyNjllZTdlZGFmMTc4MDg5ZDlhZTRjZGMzYTcxMWY3MTJkZGZkNGZkYWUxZGU4OTk5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzEwMGY0NGRhNjk2ZTcxNjcyNzkxZDBhMDliN2JkZTQ1OWYxMjE1YTI5YjNjMDNiZmVmZDc4MzViMzlhNDhkYjAnLFxuICAgICAgICAnY2RkOWUxMzE5MmEwMGI3NzJlYzhmMzMwMGMwOTA2NjZiN2ZmNGExOGZmNTE5NWFjMGZiZDVjZDYyYmM2NWEwOSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMTAzMWJlMjYyYzdlZDFiMWRjOTIyN2E0YTA0YzAxN2E3N2Y4ZDQ0NjRmM2IzODUyYzhhY2RlNmU1MzRmZDJkJyxcbiAgICAgICAgJzlkNzA2MTkyODk0MDQwNWU2YmI2YTQxNzY1OTc1MzVhZjI5MmRkNDE5ZTFjZWQ3OWE0NGYxOGYyOTQ1NmEwMGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmVlYTZjYWU0NmQ1NWI1MzBhYzI4MzlmMTQzYmQ3ZWM1Y2Y4YjI2NmE0MWQ2YWY1MmQ1ZTY4OGQ5MDk0Njk2ZCcsXG4gICAgICAgICdlNTdjNmI2Yzk3ZGNlMWJhYjA2ZTRlMTJiZjNlY2Q1Yzk4MWM4OTU3Y2M0MTQ0MmQzMTU1ZGViZjE4MDkwMDg4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhNjdhOTFkOTEwNDljZGNiMzY3YmU0YmU2ZmZjYTNjZmVlZDY1N2Q4MDg1ODNkZTMzZmE5NzhiYzFlYzZjYjEnLFxuICAgICAgICAnOWJhY2FhMzU0ODE2NDJiYzQxZjQ2M2Y3ZWM5NzgwZTVkZWM3YWRjNTA4Zjc0MGExN2U5ZWE4ZTI3YTY4YmUxZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1MzkwNGZhYTBiMzM0Y2RkYTZlMDAwOTM1ZWYyMjE1MWVjMDhkMGY3YmIxMTA2OWY1NzU0NWNjYzFhMzdiN2MwJyxcbiAgICAgICAgJzViYzA4N2QwYmM4MDEwNmQ4OGM5ZWNjYWMyMGQzYzFjMTM5OTk5ODFlMTQ0MzQ2OTlkY2IwOTZiMDIyNzcxYzgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGU3YmNkMGJkMzU5ODNhNzcxOWNjYTc3NjRjYTkwNjc3OWI1M2EwNDNhOWI4YmNhZWZmOTU5ZjQzYWQ4NjA0NycsXG4gICAgICAgICcxMGI3NzcwYjJhM2RhNGIzOTQwMzEwNDIwY2E5NTE0NTc5ZTg4ZTJlNDdmZDY4YjNlYTEwMDQ3ZTg0NjAzNzJhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM4NWVlZDM0YzFjZGZmMjFlNmQwODE4Njg5YjgxYmRlNzFhN2Y0ZjE4Mzk3ZTY2OTBhODQxZTE1OTljNDM4NjInLFxuICAgICAgICAnMjgzYmViYzNlOGVhMjNmNTY3MDFkZTE5ZTllYmY0NTc2YjMwNGVlYzIwODZkYzhjYzA0NThmZTU1NDJlNTQ1MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2ZjlkOWI4MDNlY2YxOTE2MzdjNzNhNDQxM2RmYTE4MGZkZGY4NGE1OTQ3ZmJjOWM2MDZlZDg2YzNmYWMzYTcnLFxuICAgICAgICAnN2M4MGM2OGU2MDMwNTliYTY5YjhlMmEzMGU0NWM0ZDQ3ZWE0ZGQyZjVjMjgxMDAyZDg2ODkwNjAzYTg0MjE2MCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMzIyZDQwMTI0M2M0ZTI1ODJhMjE0N2MxMDRkNmVjYmY3NzRkMTYzZGIwZjVlNTMxM2I3ZTBlNzQyZDBlNmJkJyxcbiAgICAgICAgJzU2ZTcwNzk3ZTk2NjRlZjViZmIwMTliYzRkZGFmOWI3MjgwNWY2M2VhMjg3M2FmNjI0ZjNhMmU5NmMyOGIyYTAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODU2NzJjN2QyZGUwYjdkYTJiZDE3NzBkODk2NjU4Njg3NDFiM2Y5YWY3NjQzMzk3NzIxZDc0ZDI4MTM0YWI4MycsXG4gICAgICAgICc3YzQ4MWI5YjViNDNiMmViNjM3NDA0OWJmYTYyYzJlNWU3N2YxN2ZjYzUyOThmNDRjOGUzMDk0Zjc5MDMxM2E2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzk0OGJmODA5YjE5ODhhNDZiMDZjOWYxOTE5NDEzYjEwZjkyMjZjNjBmNjY4ODMyZmZkOTU5YWY2MGM4MmEwYScsXG4gICAgICAgICc1M2E1NjI4NTZkY2I2NjQ2ZGM2Yjc0YzVkMWMzNDE4YzZkNGRmZjA4Yzk3Y2QyYmVkNGNiN2Y4OGQ4YzhlNTg5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYyNjBjZTdmNDYxODAxYzM0ZjA2N2NlMGYwMjg3M2E4ZjFiMGU0NGRmYzY5NzUyYWNjZWNkODE5ZjM4ZmQ4ZTgnLFxuICAgICAgICAnYmMyZGE4MmI2ZmE1YjU3MWE3ZjA5MDQ5Nzc2YTFlZjdlY2QyOTIyMzgwNTFjMTk4YzFhODRlOTViMmI0YWUxNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNTAzN2RlMGFmYzFkOGQ0M2Q4MzQ4NDE0YmJmNDEwMzA0M2VjOGY1NzViZmRjNDMyOTUzY2M4ZDIwMzdmYTJkJyxcbiAgICAgICAgJzQ1NzE1MzRiYWE5NGQzYjVmOWY5OGQwOWZiOTkwYmRkYmQ1ZjViMDNlYzQ4MWYxMGUwZTVkYzg0MWQ3NTViZGEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTA2MzcyYjBmNGEyMDdhZGY1ZWE5MDVlOGYxNzcxYjRlN2U4ZGJkMWM2YTZjNWI3MjU4NjZhMGFlNGZjZTcyNScsXG4gICAgICAgICc3YTkwODk3NGJjZTE4Y2ZlMTJhMjdiYjJhZDVhNDg4Y2Q3NDg0YTc3ODcxMDQ4NzBiMjcwMzRmOTRlZWUzMWRkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzIxM2M3YTcxNWNkNWQ0NTM1OGQwYmJmOWRjMGNlMDIyMDRiMTBiZGRlMmEzZjU4NTQwYWQ2OTA4ZDA1NTk3NTQnLFxuICAgICAgICAnNGI2ZGFkMGI1YWU0NjI1MDcwMTNhZDA2MjQ1YmExOTBiYjQ4NTBmNWYzNmE3ZWVkZGZmMmMyNzUzNGI0NThmMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZTdjMjcyYTdhZjRiMzRlOGRiYjkzNTJhNTQxOWE4N2UyODM4YzcwYWRjNjJjZGRmMGNjM2EzYjA4ZmJkNTNjJyxcbiAgICAgICAgJzE3NzQ5Yzc2NmM5ZDBiMThlMTZmZDA5ZjZkZWY2ODFiNTMwYjk2MTRiZmY3ZGQzM2UwYjM5NDE4MTdkY2FhZTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmVhNzRlM2RiZTc3OGIxYjEwZjIzOGFkNjE2ODZhYTVjNzZlM2RiMmJlNDMwNTc2MzI0MjdlMjg0MGZiMjdiNicsXG4gICAgICAgICc2ZTA1NjhkYjliMGIxMzI5N2NmNjc0ZGVjY2I2YWY5MzEyNmI1OTZiOTczZjdiNzc3MDFkM2RiN2YyM2NiOTZmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc2ZTY0MTEzZjY3N2NmMGUxMGEyNTcwZDU5OTk2OGQzMTU0NGUxNzliNzYwNDMyOTUyYzAyYTQ0MTdiZGRlMzknLFxuICAgICAgICAnYzkwZGRmOGRlZTRlOTVjZjU3NzA2NmQ3MDY4MWYwZDM1ZTJhMzNkMmI1NmQyMDMyYjRiMTc1MmQxOTAxYWMwMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNzM4YzU2YjAzYjJhYmUxZTgyODFiYWE3NDNmOGY5YThmN2NjNjQzZGYyNmNiZWUzYWIxNTAyNDJiY2JiODkxJyxcbiAgICAgICAgJzg5M2ZiNTc4OTUxYWQyNTM3ZjcxOGYyZWFjYmZiYmJiODIzMTRlZWY3ODgwY2ZlOTE3ZTczNWQ5Njk5YTg0YzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDg5NTYyNjU0OGI2NWI4MWUyNjRjNzYzN2M5NzI4NzdkMWQ3MmU1ZjNhOTI1MDE0MzcyZTlmNjU4OGY2YzE0YicsXG4gICAgICAgICdmZWJmYWEzOGYyYmM3ZWFlNzI4ZWM2MDgxOGMzNDBlYjAzNDI4ZDYzMmJiMDY3ZTE3OTM2M2VkNzVkN2Q5OTFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2I4ZGE5NDAzMmE5NTc1MThlYjBmNjQzMzU3MWU4NzYxY2VmZmM3MzY5M2U4NGVkZDQ5MTUwYTU2NGY2NzZlMDMnLFxuICAgICAgICAnMjgwNGRmYTQ0ODA1YTFlNGQ3Yzk5Y2M5NzYyODA4YjA5MmNjNTg0ZDk1ZmYzYjUxMTQ4OGU0ZTc0ZWZkZjZlNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlODBmZWExNDQ0MWZiMzNhN2Q4YWRhYjk0NzVkN2ZhYjIwMTllZmZiNTE1NmE3OTJmMWExMTc3OGUzYzBkZjVkJyxcbiAgICAgICAgJ2VlZDFkZTdmNjM4ZTAwNzcxZTg5NzY4Y2EzY2E5NDQ3MmQxNTVlODBhZjMyMmVhOWZjYjQyOTFiNmFjOWVjNzgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTMwMTY5N2JkZmNkNzA0MzEzYmE0OGU1MWQ1Njc1NDNmMmExODIwMzFlZmQ2OTE1ZGRjMDdiYmNjNGUxNjA3MCcsXG4gICAgICAgICc3MzcwZjkxY2ZiNjdlNGY1MDgxODA5ZmEyNWQ0MGY5YjE3MzVkYmY3YzBhMTFhMTMwYzBkMWEwNDFlMTc3ZWExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkwYWQ4NWIzODlkNmI5MzY0NjNmOWQwNTEyNjc4ZGUyMDhjYzMzMGIxMTMwN2ZmZmFiN2FjNjNlM2ZiMDRlZDQnLFxuICAgICAgICAnZTUwN2EzNjIwYTM4MjYxYWZmZGNiZDk0MjcyMjJiODM5YWVmYWJlMTU4Mjg5NGQ5OTFkNGQ0OGNiNmVmMTUwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhmNjhiOWQyZjYzYjVmMzM5MjM5YzFhZDk4MWYxNjJlZTg4YzU2Nzg3MjNlYTMzNTFiN2I0NDRjOWVjNGMwZGEnLFxuICAgICAgICAnNjYyYTlmMmRiYTA2Mzk4NmRlMWQ5MGMyYjZiZTIxNWRiYmVhMmNmZTk1NTEwYmZkZjIzY2JmNzk1MDFmZmY4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNGYzZmIwMTc2YWY4NWQ2NWZmOTlmZjkxOThjMzYwOTFmNDhlODY1MDM2ODFlM2U2Njg2ZmQ1MDUzMjMxZTExJyxcbiAgICAgICAgJzFlNjM2MzNhZDBlZjRmMWMxNjYxYTZkMGVhMDJiNzI4NmNjN2U3NGVjOTUxZDFjOTgyMmMzODU3NmZlYjczYmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGMwMGZhOWIxOGViZjMzMWViOTYxNTM3YTQ1YTQyNjZjNzAzNGYyZjBkNGUxZDA3MTZmYjZlYWUyMGVhZTI5ZScsXG4gICAgICAgICdlZmE0NzI2N2ZlYTUyMWExYTlkYzM0M2EzNzM2Yzk3NGMyZmFkYWZhODFlMzZjNTRlN2QyYTRjNjY3MDI0MTRiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U3YTI2Y2U2OWRkNDgyOWYzZTEwY2VjMGE5ZTk4ZWQzMTQzZDA4NGYzMDhiOTJjMDk5N2ZkZGZjNjBjYjNlNDEnLFxuICAgICAgICAnMmE3NThlMzAwZmE3OTg0YjQ3MWIwMDZhMWFhZmJiMThkMGE2YjJjMDQyMGU4M2UyMGU4YTk0MjFjZjJjZmQ1MSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiNjQ1OWUwZWUzNjYyZWM4ZDIzNTQwYzIyM2JjYmRjNTcxY2JjYjk2N2Q3OTQyNGYzY2YyOWViM2RlNmI4MGVmJyxcbiAgICAgICAgJzY3Yzg3NmQwNmYzZTA2ZGUxZGFkZjE2ZTU2NjFkYjNjNGIzYWU2ZDQ4ZTM1YjJmZjMwYmYwYjYxYTcxYmE0NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNjhhODBjODI4MGJiODQwNzkzMjM0YWExMThmMDYyMzFkNmYxZmM2N2U3M2M1YTVkZWRhMGY1YjQ5Njk0M2U4JyxcbiAgICAgICAgJ2RiOGJhOWZmZjRiNTg2ZDAwYzRiMWY5MTc3YjBlMjhiNWIwZTdiOGY3ODQ1Mjk1YTI5NGM4NDI2NmIxMzMxMjAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzI0YWVkN2RmNjVjODA0MjUyZGMwMjcwOTA3YTMwYjA5NjEyYWViOTczNDQ5Y2VhNDA5NTk4MGZjMjhkM2Q1ZCcsXG4gICAgICAgICc2NDhhMzY1Nzc0YjYxZjJmZjEzMGMwYzM1YWVjMWY0ZjE5MjEzYjBjN2UzMzI4NDM5NjcyMjRhZjk2YWI3Yzg0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRkZjljMTQ5MTljZGU2MWY2ZDUxZGZkYmU1ZmVlNWRjZWVjNDE0M2JhOGQxY2E4ODhlOGJkMzczZmQwNTRjOTYnLFxuICAgICAgICAnMzVlYzUxMDkyZDg3MjgwNTA5NzRjMjNhMWQ4NWQ0YjVkNTA2Y2RjMjg4NDkwMTkyZWJhYzA2Y2FkMTBkNWQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOWMzOTE5YTg0YTQ3NDg3MGZhZWQ4YTljMWNjNjYwMjE1MjM0ODkwNTRkN2YwMzA4Y2JmYzk5YzhhYzFmOThjZCcsXG4gICAgICAgICdkZGI4NGYwZjRhNGRkZDU3NTg0ZjA0NGJmMjYwZTY0MTkwNTMyNmY3NmM2NGM4ZTZiZTdlNWUwM2Q0ZmM1OTlkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYwNTcxNzBiMWRkMTJmZGY4ZGUwNWYyODFkOGUwNmJiOTFlMTQ5M2E4YjkxZDRjYzVhMjEzODIxMjBhOTU5ZTUnLFxuICAgICAgICAnOWExYWYwYjI2YTZhNDgwN2FkZDlhMmRhZjcxZGYyNjI0NjUxNTJiYzNlZTI0YzY1ZTg5OWJlOTMyMzg1YTJhOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhNTc2ZGY4ZTIzYTA4NDExNDIxNDM5YTQ1MThkYTMxODgwY2VmMGZiYTdkNGRmMTJiMWE2OTczZWVjYjk0MjY2JyxcbiAgICAgICAgJzQwYTZiZjIwZTc2NjQwYjJjOTJiOTdhZmU1OGNkODJjNDMyZTEwYTdmNTE0ZDlmM2VlOGJlMTFhZTFiMjhlYzgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzc3OGE3OGMyOGRlYzNlMzBhMDVmZTk2MjlkZThjMzhiYjMwZDFmNWNmOWEzYTIwOGY3NjM4ODliZTU4YWQ3MScsXG4gICAgICAgICczNDYyNmQ5YWI1YTViMjJmZjcwOThlMTJmMmZmNTgwMDg3YjM4NDExZmYyNGFjNTYzYjUxM2ZjMWZkOWY0M2FjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkyODk1NWVlNjM3YTg0NDYzNzI5ZmQzMGU3YWZkMmVkNWY5NjI3NGU1YWQ3ZTVjYjA5ZWRhOWMwNmQ5MDNhYycsXG4gICAgICAgICdjMjU2MjEwMDNkM2Y0MmE4MjdiNzhhMTMwOTNhOTVlZWFjM2QyNmVmYThhOGQ4M2ZjNTE4MGU5MzViY2QwOTFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg1ZDBmZWYzZWM2ZGIxMDkzOTkwNjRmM2EwZTNiMjg1NTY0NWI0YTkwN2FkMzU0NTI3YWFlNzUxNjNkODI3NTEnLFxuICAgICAgICAnMWYwMzY0ODQxM2EzOGMwYmUyOWQ0OTZlNTgyY2Y1NjYzZTg3NTFlOTY4NzczMzE1ODJjMjM3YTI0ZWIxZjk2MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZjJiMGRjZTk3ZWVjZTk3YzFjOWI2MDQxNzk4Yjg1ZGZkZmI2ZDg4ODJkYTIwMzA4ZjU0MDQ4MjQ1MjYwODdlJyxcbiAgICAgICAgJzQ5M2QxM2ZlZjUyNGJhMTg4YWY0YzRkYzU0ZDA3OTM2YzdiN2VkNmZiOTBlMmNlYjJjOTUxZTAxZjBjMjk5MDcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODI3ZmJiZTRiMWU4ODBlYTllZDJiMmU2MzAxYjIxMmI1N2YxZWUxNDhjZDZkZDI4NzgwZTVlMmNmODU2ZTI0MScsXG4gICAgICAgICdjNjBmOWM5MjNjNzI3YjBiNzFiZWYyYzY3ZDFkMTI2ODdmZjdhNjMxODY5MDMxNjZkNjA1YjY4YmFlYzI5M2VjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VhYTY0OWYyMWY1MWJkYmFlN2JlNGFlMzRjZTZlNTIxN2E1OGZkY2U3ZjQ3ZjlhYTdmM2I1OGZhMjEyMGUyYjMnLFxuICAgICAgICAnYmUzMjc5ZWQ1YmJiYjAzYWM2OWE4MGY4OTg3OWFhNWEwMWE2Yjk2NWYxM2Y3ZTU5ZDQ3YTUzMDViYTVhZDkzZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNGE0MmQ0M2M1Y2YxNjlkOTM5MWRmNmRlY2Y0MmVlNTQxYjZkOGYwYzlhMTM3NDAxZTIzNjMyZGRhMzRkMjRmJyxcbiAgICAgICAgJzRkOWY5MmU3MTZkMWM3MzUyNmZjOTljY2ZiOGFkMzRjZTg4NmVlZGZhOGQ4ZTRmMTNhN2Y3MTMxZGViYTk0MTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMWVjODBmZWYzNjBjYmRkOTU0MTYwZmFkYWIzNTJiNmI5MmI1MzU3NmE4OGZlYTQ5NDcxNzNiOWQ0MzAwYmYxOScsXG4gICAgICAgICdhZWVmZTkzNzU2YjUzNDBkMmYzYTQ5NThhN2FiYmY1ZTAxNDZlNzdmNjI5NWEwN2I2NzFjZGMxY2MxMDdjZWZkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE0NmE3NzhjMDQ2NzBjMmY5MWIwMGFmNDY4MGRmYThiY2UzNDkwNzE3ZDU4YmE4ODlkZGI1OTI4MzY2NjQyYmUnLFxuICAgICAgICAnYjMxOGUwZWMzMzU0MDI4YWRkNjY5ODI3ZjlkNGIyODcwYWFhOTcxZDJmN2U1ZWQxZDBiMjk3NDgzZDgzZWZkMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmYTUwYzBmNjFkMjJlNWYwN2UzYWNlYmIxYWEwN2IxMjhkMDAxMjIwOWEyOGI5Nzc2ZDc2YTg3OTMxODBlZWY5JyxcbiAgICAgICAgJzZiODRjNjkyMjM5N2ViYTliNzJjZDI4NzIyODFhNjhhNWU2ODMyOTNhNTdhMjEzYjM4Y2Q4ZDdkM2Y0ZjI4MTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGExZDYxZDBjYTcyMWExMWIxYTViZjZiN2Q4OGU4NDIxYTI4OGFiNWQ1YmJhNTIyMGU1M2QzMmI1ZjA2N2VjMicsXG4gICAgICAgICc4MTU3ZjU1YTdjOTkzMDZjNzljMDc2NjE2MWM5MWUyOTY2YTczODk5ZDI3OWI0OGE2NTVmYmEwZjFhZDgzNmYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E4ZTI4MmZmMGM5NzA2OTA3MjE1ZmY5OGU4ZmQ0MTY2MTUzMTFkZTA0NDZmMWUwNjJhNzNiMDYxMGQwNjRlMTMnLFxuICAgICAgICAnN2Y5NzM1NWI4ZGI4MWMwOWFiZmI3ZjNjNWIyNTE1ODg4YjY3OWEzZTUwZGQ2YmQ2Y2VmN2M3MzExMWY0Y2MwYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNzRhNTNiOWM5YTI4NTg3MmQzOWU1NmU2OTEzY2FiMTVkNTliMWZhNTEyNTA4YzAyMmYzODJkZTgzMTk0OTdjJyxcbiAgICAgICAgJ2NjYzlkYzM3YWJmYzljMTY1N2I0MTU1ZjJjNDdmOWU2NjQ2YjNhMWQ4Y2I5ODU0MzgzZGExM2FjMDc5YWZhNzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTU5Mzk2OTgxOTQzNzg1YzNkM2U1N2VkZjUwMThjZGJlMDM5ZTczMGU0OTE4YjNkODg0ZmRmZjA5NDc1YjdiYScsXG4gICAgICAgICcyZTdlNTUyODg4YzMzMWRkOGJhMDM4NmE0YjljZDY4NDljNjUzZjY0Yzg3MDkzODVlOWI4YWJmODc1MjRmMmZkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QyYTYzYTUwYWU0MDFlNTZkNjQ1YTExNTNiMTA5YThmY2NhMGE0M2Q1NjFmYmEyZGJiNTEzNDBjOWQ4MmIxNTEnLFxuICAgICAgICAnZTgyZDg2ZmI2NDQzZmNiNzU2NWFlZTU4YjI5NDgyMjBhNzBmNzUwYWY0ODRjYTUyZDQxNDIxNzRkY2Y4OTQwNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2NDU4N2UyMzM1NDcxZWI4OTBlZTc4OTZkN2NmZGM4NjZiYWNiZGJkMzgzOTMxN2IzNDM2ZjliNDU2MTdlMDczJyxcbiAgICAgICAgJ2Q5OWZjZGQ1YmY2OTAyZTJhZTk2ZGQ2NDQ3YzI5OWExODViOTBhMzkxMzNhZWFiMzU4Mjk5ZTVlOWZhZjY1ODknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODQ4MWJkZTBlNGU0ZDg4NWIzYTU0NmQzZTU0OWRlMDQyZjBhYTZjZWEyNTBlN2ZkMzU4ZDZjODZkZDQ1ZTQ1OCcsXG4gICAgICAgICczOGVlN2I4Y2JhNTQwNGRkODRhMjViZjM5Y2VjYjJjYTkwMGE3OWM0MmIyNjJlNTU2ZDY0YjFiNTk3NzkwNTdlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzEzNDY0YTU3YTc4MTAyYWE2MmI2OTc5YWU4MTdmNDYzN2ZmY2ZlZDNjNGIxY2UzMGJjZDYzMDNmNmNhZjY2NmInLFxuICAgICAgICAnNjliZTE1OTAwNDYxNDU4MGVmN2U0MzM0NTNjY2IwY2E0OGYzMDBhODFkMDk0MmUxM2Y0OTVhOTA3ZjZlY2MyNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiYzRhOWRmNWI3MTNmZTJlOWFlZjQzMGJjYzFkYzk3YTBjZDljY2VkZTJmMjg1ODhjYWRhM2EwZDJkODNmMzY2JyxcbiAgICAgICAgJ2QzYTgxY2E2ZTc4NWMwNjM4MzkzN2FkZjRiNzk4Y2FhNmU4YTlmYmZhNTQ3YjE2ZDc1OGQ2NjY1ODFmMzNjMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YzI4YTk3YmY4Mjk4YmMwZDIzZDhjNzQ5NDUyYTMyZTY5NGI2NWUzMGE5NDcyYTM5NTRhYjMwZmU1MzI0Y2FhJyxcbiAgICAgICAgJzQwYTMwNDYzYTMzMDUxOTMzNzhmZWRmMzFmN2NjMGViN2FlNzg0ZjA0NTFjYjk0NTllNzFkYzczY2JlZjk0ODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGVhOTY2NjEzOTUyN2E4YzFkZDk0Y2U0ZjA3MWZkMjNjOGIzNTBjNWE0YmIzMzc0OGM0YmExMTFmYWNjYWUwJyxcbiAgICAgICAgJzYyMGVmYWJiYzhlZTI3ODJlMjRlN2MwY2ZiOTVjNWQ3MzViNzgzYmU5Y2YwZjhlOTU1YWYzNGEzMGU2MmI5NDUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGQzNjI1ZmFlZjViYTA2MDc0NjY5NzE2YmJkMzc4OGQ4OWJkZGU4MTU5NTk5NjgwOTJmNzZjYzRlYjlhOTc4NycsXG4gICAgICAgICc3YTE4OGZhMzUyMGUzMGQ0NjFkYTI1MDEwNDU3MzFjYTk0MTQ2MTk4Mjg4MzM5NTkzN2Y2OGQwMGM2NDRhNTczJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Y3MTBkNzlkOWViOTYyMjk3ZTRmNjIzMmI0MGU4ZjdmZWIyYmM2MzgxNDYxNGQ2OTJjMTJkZTc1MjQwODIyMWUnLFxuICAgICAgICAnZWE5OGU2NzIzMmQzYjMyOTVkM2I1MzU1MzIxMTVjY2FjODYxMmM3MjE4NTE2MTc1MjZhZTQ3YTljNzdiZmM4MidcbiAgICAgIF1cbiAgICBdXG4gIH0sXG4gIG5hZjoge1xuICAgIHduZDogNyxcbiAgICBwb2ludHM6IFtcbiAgICAgIFtcbiAgICAgICAgJ2Y5MzA4YTAxOTI1OGMzMTA0OTM0NGY4NWY4OWQ1MjI5YjUzMWM4NDU4MzZmOTliMDg2MDFmMTEzYmNlMDM2ZjknLFxuICAgICAgICAnMzg4ZjdiMGY2MzJkZTgxNDBmZTMzN2U2MmEzN2YzNTY2NTAwYTk5OTM0YzIyMzFiNmNiOWZkNzU4NGI4ZTY3MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyZjhiZGU0ZDFhMDcyMDkzNTViNGE3MjUwYTVjNTEyOGU4OGI4NGJkZGM2MTlhYjdjYmE4ZDU2OWIyNDBlZmU0JyxcbiAgICAgICAgJ2Q4YWMyMjI2MzZlNWUzZDZkNGRiYTlkZGE2YzljNDI2Zjc4ODI3MWJhYjBkNjg0MGRjYTg3ZDNhYTZhYzYyZDYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNWNiZGYwNjQ2ZTVkYjRlYWEzOThmMzY1ZjJlYTdhMGUzZDQxOWI3ZTAzMzBlMzljZTkyYmRkZWRjYWM0ZjliYycsXG4gICAgICAgICc2YWViY2E0MGJhMjU1OTYwYTMxNzhkNmQ4NjFhNTRkYmE4MTNkMGI4MTNmZGU3YjVhNTA4MjYyODA4NzI2NGRhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2FjZDQ4NGUyZjBjN2Y2NTMwOWFkMTc4YTlmNTU5YWJkZTA5Nzk2OTc0YzU3ZTcxNGMzNWYxMTBkZmMyN2NjYmUnLFxuICAgICAgICAnY2MzMzg5MjFiMGE3ZDlmZDY0MzgwOTcxNzYzYjYxZTlhZGQ4ODhhNDM3NWY4ZTBmMDVjYzI2MmFjNjRmOWMzNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NzRhZTdmODU4YTk0MTFlNWVmNDI0NmI3MGM2NWFhYzU2NDk5ODBiZTVjMTc4OTFiYmVjMTc4OTVkYTAwOGNiJyxcbiAgICAgICAgJ2Q5ODRhMDMyZWI2YjVlMTkwMjQzZGQ1NmQ3YjdiMzY1MzcyZGIxZTJkZmY5ZDZhODMwMWQ3NGM5Yzk1M2M2MWInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjI4NzczYzJkOTc1Mjg4YmM3ZDFkMjA1YzM3NDg2NTFiMDc1ZmJjNjYxMGU1OGNkZGVlZGRmOGYxOTQwNWFhOCcsXG4gICAgICAgICdhYjA5MDJlOGQ4ODBhODk3NTgyMTJlYjY1Y2RhZjQ3M2ExYTA2ZGE1MjFmYTkxZjI5YjVjYjUyZGIwM2VkODEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDc5MjRkNGY3ZDQzZWE5NjVhNDY1YWUzMDk1ZmY0MTEzMWU1OTQ2ZjNjODVmNzllNDRhZGJjZjhlMjdlMDgwZScsXG4gICAgICAgICc1ODFlMjg3MmE4NmM3MmE2ODM4NDJlYzIyOGNjNmRlZmVhNDBhZjJiZDg5NmQzYTVjNTA0ZGM5ZmY2YTI2YjU4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RlZmRlYTRjZGI2Nzc3NTBhNDIwZmVlODA3ZWFjZjIxZWI5ODk4YWU3OWI5NzY4NzY2ZTRmYWEwNGEyZDRhMzQnLFxuICAgICAgICAnNDIxMWFiMDY5NDYzNTE2OGU5OTdiMGVhZDJhOTNkYWVjZWQxZjRhMDRhOTVjMGY2Y2ZiMTk5ZjY5ZTU2ZWI3NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyYjRlYTBhNzk3YTQ0M2QyOTNlZjVjZmY0NDRmNDk3OWYwNmFjZmViZDdlODZkMjc3NDc1NjU2MTM4Mzg1YjZjJyxcbiAgICAgICAgJzg1ZTg5YmMwMzc5NDVkOTNiMzQzMDgzYjVhMWM4NjEzMWEwMWY2MGM1MDI2OTc2M2I1NzBjODU0ZTVjMDliN2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzUyYmJmNGE0Y2RkMTI1NjRmOTNmYTMzMmNlMzMzMzAxZDlhZDQwMjcxZjgxMDcxODEzNDBhZWYyNWJlNTlkNScsXG4gICAgICAgICczMjFlYjQwNzUzNDhmNTM0ZDU5YzE4MjU5ZGRhM2UxZjRhMWIzYjJlNzFiMTAzOWM2N2JkM2Q4YmNmODE5OThjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzJmYTIxMDRkNmIzOGQxMWIwMjMwMDEwNTU5ODc5MTI0ZTQyYWI4ZGZlZmY1ZmYyOWRjOWNkYWRkNGVjYWNjM2YnLFxuICAgICAgICAnMmRlMTA2ODI5NWRkODY1YjY0NTY5MzM1YmQ1ZGQ4MDE4MWQ3MGVjZmM4ODI2NDg0MjNiYTc2YjUzMmI3ZDY3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkyNDgyNzliMDliNGQ2OGRhYjIxYTliMDY2ZWRkYTgzMjYzYzNkODRlMDk1NzJlMjY5Y2EwY2Q3ZjU0NTM3MTQnLFxuICAgICAgICAnNzMwMTZmN2JmMjM0YWFkZTVkMWFhNzFiZGVhMmIxZmYzZmMwZGUyYTg4NzkxMmZmZTU0YTMyY2U5N2NiMzQwMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYWVkNGYyYmUzYThiZjI3OGU3MDEzMmZiMGJlYjc1MjJmNTcwZTE0NGJmNjE1YzA3ZTk5NmQ0NDNkZWU4NzI5JyxcbiAgICAgICAgJ2E2OWRjZTRhN2Q2Yzk4ZThkNGExYWNhODdlZjhkNzAwM2Y4M2MyMzBmM2FmYTcyNmFiNDBlNTIyOTBiZTFjNTUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzQ0ZDEyYzcwNjVkODEyZThhY2YyOGQ3Y2JiMTlmOTAxMWVjZDllOWZkZjI4MWIwZTZhM2I1ZTg3ZDIyZTdkYicsXG4gICAgICAgICcyMTE5YTQ2MGNlMzI2Y2RjNzZjNDU5MjZjOTgyZmRhYzBlMTA2ZTg2MWVkZjYxYzVhMDM5MDYzZjBlMGU2NDgyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzZhMjQ1YmY2ZGM2OTg1MDRjODlhMjBjZmRlZDYwODUzMTUyYjY5NTMzNmMyODA2M2I2MWM2NWNiZDI2OWU2YjQnLFxuICAgICAgICAnZTAyMmNmNDJjMmJkNGE3MDhiM2Y1MTI2ZjE2YTI0YWQ4YjMzYmE0OGQwNDIzYjZlZmQ1ZTYzNDgxMDBkOGE4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNjk3ZmZhNmZkOWRlNjI3YzA3N2UzZDJmZTU0MTA4NGNlMTMzMDBiMGJlYzExNDZmOTVhZTU3ZjBkMGJkNmE1JyxcbiAgICAgICAgJ2I5YzM5OGYxODY4MDZmNWQyNzU2MTUwNmU0NTU3NDMzYTJjZjE1MDA5ZTQ5OGFlN2FkZWU5ZDYzZDAxYjIzOTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjA1YmRiMDE5OTgxNzE4Yjk4NmQwZjA3ZTgzNGNiMGQ5ZGViODM2MGZmYjdmNjFkZjk4MjM0NWVmMjdhNzQ3OScsXG4gICAgICAgICcyOTcyZDJkZTRmOGQyMDY4MWE3OGQ5M2VjOTZmZTIzYzI2YmZhZTg0ZmIxNGRiNDNiMDFlMWU5MDU2YjhjNDknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjJkMTRkYWI0MTUwYmY0OTc0MDJmZGM0NWEyMTVlMTBkY2IwMWMzNTQ5NTliMTBjZmUzMWM3ZTlkODdmZjMzZCcsXG4gICAgICAgICc4MGZjMDZiZDhjYzViMDEwOTgwODhhMTk1MGVlZDBkYjAxYWExMzI5NjdhYjQ3MjIzNWY1NjQyNDgzYjI1ZWFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgwYzYwYWQwMDQwZjI3ZGFkZTViNGIwNmM0MDhlNTZiMmM1MGU5ZjU2YjliOGI0MjVlNTU1YzJmODYzMDhiNmYnLFxuICAgICAgICAnMWMzODMwM2YxY2M1YzMwZjI2ZTY2YmFkN2ZlNzJmNzBhNjVlZWQ0Y2JlNzAyNGViMWFhMDFmNTY0MzBiZDU3YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3YTkzNzVhZDYxNjdhZDU0YWE3NGM2MzQ4Y2M1NGQzNDRjYzVkYzk0ODdkODQ3MDQ5ZDVlYWJiMGZhMDNjOGZiJyxcbiAgICAgICAgJ2QwZTNmYTllY2E4NzI2OTA5NTU5ZTBkNzkyNjkwNDZiZGM1OWVhMTBjNzBjZTJiMDJkNDk5ZWMyMjRkYzdmNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNTI4ZWNkOWI2OTZiNTRjOTA3YTllZDA0NTQ0N2E3OWJiNDA4ZWMzOWI2OGRmNTA0YmI1MWY0NTliYzNmZmM5JyxcbiAgICAgICAgJ2VlY2Y0MTI1MzEzNmU1Zjk5OTY2ZjIxODgxZmQ2NTZlYmM0MzQ1NDA1YzUyMGRiYzA2MzQ2NWI1MjE0MDk5MzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDkzNzBhNGI1ZjQzNDEyZWEyNWY1MTRlOGVjZGFkMDUyNjYxMTVlNGE3ZWNiMTM4NzIzMTgwOGY4YjQ1OTYzJyxcbiAgICAgICAgJzc1OGYzZjQxYWZkNmVkNDI4YjMwODFiMDUxMmZkNjJhNTRjM2YzYWZiYjViNjc2NGI2NTMwNTJhMTI5NDljOWEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzdmMjMwOTM2ZWU4OGNiYmQ3M2RmOTMwZDY0NzAyZWY4ODFkODExZTBlMTQ5OGUyZjFjMTNlYjFmYzM0NWQ3NCcsXG4gICAgICAgICc5NThlZjQyYTc4ODZiNjQwMGEwODI2NmU5YmExYjM3ODk2Yzk1MzMwZDk3MDc3Y2JiZThlYjNjNzY3MWM2MGQ2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YyZGFjOTkxY2M0Y2U0YjllYTQ0ODg3ZTVjN2MwYmNlNThjODAwNzRhYjlkNGRiYWViMjg1MzFiNzczOWY1MzAnLFxuICAgICAgICAnZTBkZWRjOWIzYjJmOGRhZDRkYTFmMzJkZWMyNTMxZGY5ZWI1ZmJlYjA1OThlNGZkMWExMTdkYmE3MDNhM2MzNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0NjNiM2Q5ZjY2MjYyMWZiMWI0YmU4ZmJiZTI1MjAxMjVhMjE2Y2RmYzlkYWUzZGViY2JhNDg1MGM2OTBkNDViJyxcbiAgICAgICAgJzVlZDQzMGQ3OGMyOTZjMzU0MzExNDMwNmRkODYyMmQ3YzYyMmUyN2M5NzBhMWRlMzFjYjM3N2IwMWFmNzMwN2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjE2ZjgwNDI0NGU0NmUyYTA5MjMyZDRhZmYzYjU5OTc2Yjk4ZmFjMTQzMjhhMmQxYTMyNDk2YjQ5OTk4ZjI0NycsXG4gICAgICAgICdjZWRhYmQ5YjgyMjAzZjdlMTNkMjA2ZmNkZjRlMzNkOTJhNmM1M2MyNmU1Y2NlMjZkNjU3OTk2MmM0ZTMxZGY2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2NhZjc1NDI3MmRjODQ1NjNiMDM1MmI3YTE0MzExYWY1NWQyNDUzMTVhY2UyN2M2NTM2OWUxNWY3MTUxZDQxZDEnLFxuICAgICAgICAnY2I0NzQ2NjBlZjM1ZjVmMmE0MWI2NDNmYTVlNDYwNTc1ZjRmYTliNzk2MjIzMmE1YzMyZjkwODMxOGEwNDQ3NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyNjAwY2E0YjI4MmNiOTg2Zjg1ZDBmMTcwOTk3OWQ4YjQ0YTA5YzA3Y2I4NmQ3YzEyNDQ5N2JjODZmMDgyMTIwJyxcbiAgICAgICAgJzQxMTliODg3NTNjMTViZDZhNjkzYjAzZmNkZGJiNDVkNWFjNmJlNzRhYjVmMGVmNDRiMGJlOTQ3NWE3ZTRiNDAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzYzNWNhNzJkN2U4NDMyYzMzOGVjNTNjZDEyMjIwYmMwMWM0ODY4NWUyNGY3ZGM4YzYwMmE3NzQ2OTk4ZTQzNScsXG4gICAgICAgICc5MWI2NDk2MDk0ODlkNjEzZDFkNWU1OTBmNzhlNmQ3NGVjZmMwNjFkNTcwNDhiYWQ5ZTc2ZjMwMmM1YjljNjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzU0ZTMyMzlmMzI1NTcwY2RiYmY0YTg3ZGVlZThhNjZiN2YyYjMzNDc5ZDQ2OGZiYzFhNTA3NDNiZjU2Y2MxOCcsXG4gICAgICAgICc2NzNmYjg2ZTViZGEzMGZiM2NkMGVkMzA0ZWE0OWEwMjNlZTMzZDAxOTdhNjk1ZDBjNWQ5ODA5M2M1MzY2ODMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTNlNmJkMTA3MWExZTk2YWZmNTc4NTljODJkNTcwZjAzMzA4MDA2NjFkMWM5NTJmOWZlMjY5NDY5MWQ5YjllOCcsXG4gICAgICAgICc1OWM5ZTBiYmEzOTRlNzZmNDBjMGFhNTgzNzlhM2NiNmE1YTIyODM5OTNlOTBjNDE2NzAwMmFmNDkyMGUzN2Y1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE4NmI0ODNkMDU2YTAzMzgyNmFlNzNkODhmNzMyOTg1YzRjY2IxZjMyYmEzNWY0YjRjYzQ3ZmRjZjA0YWE2ZWInLFxuICAgICAgICAnM2I5NTJkMzJjNjdjZjc3ZTJlMTc0NDZlMjA0MTgwYWIyMWZiODA5MDg5NTEzOGI0YTRhNzk3Zjg2ZTgwODg4YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZjlkNzBhNmI5ODc2Y2U1NDRjOTg1NjFmNGJlNGY3MjU0NDJlNmQyYjczN2Q5YzkxYTgzMjE3MjRjZTA5NjNmJyxcbiAgICAgICAgJzU1ZWIyZGFmZDg0ZDZjY2Q1Zjg2MmI3ODVkYzM5ZDRhYjE1NzIyMjcyMGVmOWRhMjE3YjhjNDVjZjJiYTI0MTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNWVkZDVjYzIzYzUxZTg3YTQ5N2NhODE1ZDVkY2UwZjhhYjUyNTU0Zjg0OWVkODk5NWRlNjRjNWYzNGNlNzE0MycsXG4gICAgICAgICdlZmFlOWM4ZGJjMTQxMzA2NjFlOGNlYzAzMGM4OWFkMGMxM2M2NmMwZDE3YTI5MDVjZGM3MDZhYjczOTlhODY4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzI5MDc5OGMyYjY0NzY4MzBkYTEyZmUwMjI4N2U5ZTc3N2FhM2ZiYTFjMzU1YjE3YTcyMmQzNjJmODQ2MTRmYmEnLFxuICAgICAgICAnZTM4ZGE3NmRjZDQ0MDYyMTk4OGQwMGJjZjc5YWYyNWQ1YjI5YzA5NGRiMmEyMzE0NmQwMDNhZmQ0MTk0M2U3YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhZjNjNDIzYTk1ZDlmNWIzMDU0NzU0ZWZhMTUwYWMzOWNkMjk1NTJmZTM2MDI1NzM2MmRmZGVjZWY0MDUzYjQ1JyxcbiAgICAgICAgJ2Y5OGEzZmQ4MzFlYjJiNzQ5YTkzYjBlNmYzNWNmYjQwYzhjZDVhYTY2N2ExNTU4MWJjMmZlZGVkNDk4ZmQ5YzYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzY2ZGJiMjRkMTM0ZTc0NWNjY2FhMjhjOTliZjI3NDkwNmJiNjZiMjZkY2Y5OGRmOGQyZmVkNTBkODg0MjQ5YScsXG4gICAgICAgICc3NDRiMTE1MmVhY2JlNWUzOGRjYzg4Nzk4MGRhMzhiODk3NTg0YTY1ZmEwNmNlZGQyYzkyNGY5N2NiYWM1OTk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzU5ZGJmNDZmOGM5NDc1OWJhMjEyNzdjMzM3ODRmNDE2NDVmN2I0NGY2YzU5NmE1OGNlOTJlNjY2MTkxYWJlM2UnLFxuICAgICAgICAnYzUzNGFkNDQxNzVmYmMzMDBmNGVhNmNlNjQ4MzA5YTA0MmNlNzM5YTc5MTk3OThjZDg1ZTIxNmM0YTMwN2Y2ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMTNhZGE5NTEwM2M0NTM3MzA1ZTY5MWU3NGU5YTRhOGRkNjQ3ZTcxMWE5NWU3M2NiNjJkYzYwMThjZmQ4N2I4JyxcbiAgICAgICAgJ2UxMzgxN2I0NGVlMTRkZTY2M2JmNGJjODA4MzQxZjMyNjk0OWUyMWE2YTc1YzI1NzA3Nzg0MTliZGFmNTczM2QnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzc1NGI0ZmEwZThhY2VkMDZkNDE2N2EyYzU5Y2NhNGNkYTE4NjljMDZlYmFkZmI2NDg4NTUwMDE1YTg4NTIyYycsXG4gICAgICAgICczMGU5M2U4NjRlNjY5ZDgyMjI0Yjk2N2MzMDIwYjhmYThkMWU0ZTM1MGI2Y2JjYzUzN2E0OGI1Nzg0MTE2M2EyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzk0OGRjYWRmNTk5MGUwNDhhYTM4NzRkNDZhYmVmOWQ3MDE4NThmOTVkZTgwNDFkMmE2ODI4Yzk5ZTIyNjI1MTknLFxuICAgICAgICAnZTQ5MWE0MjUzN2Y2ZTU5N2Q1ZDI4YTMyMjRiMWJjMjVkZjkxNTRlZmJkMmVmMWQyY2JiYTJjYWU1MzQ3ZDU3ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3OTYyNDE0NDUwYzc2YzE2ODljN2I0OGY4MjAyZWMzN2ZiMjI0Y2Y1YWMwYmZhMTU3MDMyOGE4YTNkN2M3N2FiJyxcbiAgICAgICAgJzEwMGI2MTBlYzRmZmI0NzYwZDVjMWZjMTMzZWY2ZjZiMTI1MDdhMDUxZjA0YWM1NzYwYWZhNWIyOWRiODM0MzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzUxNDA4NzgzNDk2NGI1NGIxNWIxNjA2NDRkOTE1NDg1YTE2OTc3MjI1Yjg4NDdiYjBkZDA4NTEzN2VjNDdjYScsXG4gICAgICAgICdlZjBhZmJiMjA1NjIwNTQ0OGUxNjUyYzQ4ZTgxMjdmYzYwMzllNzdjMTVjMjM3OGI3ZTdkMTVhMGRlMjkzMzExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QzY2MzMGFkNmI0ODNlNGJjNzljZTJjOWRkOGJjNTQ5OTNlOTQ3ZWI4ZGY3ODdiNDQyOTQzZDNmN2I1MjdlYWYnLFxuICAgICAgICAnOGIzNzhhMjJkODI3Mjc4ZDg5YzVlOWJlOGY5NTA4YWUzYzJhZDQ2MjkwMzU4NjMwYWZiMzRkYjA0ZWVkZTBhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNjI0ZDg0NzgwNzMyODYwY2UxYzc4ZmNiZmVmZTA4YjJiMjk4MjNkYjkxM2Y2NDkzOTc1YmEwZmY0ODQ3NjEwJyxcbiAgICAgICAgJzY4NjUxY2Y5YjZkYTkwM2UwOTE0NDQ4YzZjZDlkNGNhODk2ODc4ZjUyODJiZTRjOGNjMDZlMmE0MDQwNzg1NzUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzMzY2U4MGRhOTU1YThhMjY5MDJjOTU2MzNlNjJhOTg1MTkyNDc0YjVhZjIwN2RhNmRmN2I0ZmQ1ZmM2MWNkNCcsXG4gICAgICAgICdmNTQzNWEyYmQyYmFkZjdkNDg1YTRkOGI4ZGI5ZmNjZTNlMWVmOGUwMjAxZTQ1NzhjNTQ2NzNiYzFkYzVlYTFkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE1ZDk0NDEyNTQ5NDUwNjRjZjFhMWMzM2JiZDNiNDlmODk2NmM1MDkyMTcxZTY5OWVmMjU4ZGZhYjgxYzA0NWMnLFxuICAgICAgICAnZDU2ZWIzMGI2OTQ2M2U3MjM0ZjUxMzdiNzNiODQxNzc0MzQ4MDBiYWNlYmZjNjg1ZmMzN2JiZTllZmU0MDcwZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhMWQwZmNmMmVjOWRlNjc1YjYxMjEzNmU1Y2U3MGQyNzFjMjE0MTdjOWQyYjhhYWFhYzEzODU5OWQwNzE3OTQwJyxcbiAgICAgICAgJ2VkZDc3ZjUwYmNiNWEzY2FiMmU5MDczNzMwOTY2N2YyNjQxNDYyYTU0MDcwZjNkNTE5MjEyZDM5YzE5N2E2MjknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTIyZmJlMTVjMGFmOGNjYzU3ODBjMDczNWY4NGRiZTlhNzkwYmFkZWU4MjQ1YzA2YzdjYTM3MzMxY2IzNjk4MCcsXG4gICAgICAgICdhODU1YmFiYWQ1Y2Q2MGM4OGI0MzBhNjlmNTNhMWE3YTM4Mjg5MTU0OTY0Nzk5YmU0M2QwNmQ3N2QzMWRhMDYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzExMDkxZGQ5ODYwZThlMjBlZTEzNDczYzExNTVmNWY2OTYzNWUzOTQ3MDRlYWE3NDAwOTQ1MjI0NmNmYTliMycsXG4gICAgICAgICc2NmRiNjU2Zjg3ZDFmMDRmZmZkMWYwNDc4OGMwNjgzMDg3MWVjNWE2NGZlZWU2ODViZDgwZjBiMTI4NmQ4Mzc0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM0YzFmZDA0ZDMwMWJlODliMzFjMDQ0MmQzZTZhYzI0ODgzOTI4YjQ1YTkzNDA3ODE4NjdkNDIzMmVjMmRiZGYnLFxuICAgICAgICAnOTQxNDY4NWU5N2IxYjU5NTRiZDQ2ZjczMDE3NDEzNmQ1N2YxY2VlYjQ4NzQ0M2RjNTMyMTg1N2JhNzNhYmVlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YyMTllYTVkNmI1NDcwMWMxYzE0ZGU1YjU1N2ViNDJhOGQxM2YzYWJiY2QwOGFmZmNjMmE1ZTZiMDQ5YjhkNjMnLFxuICAgICAgICAnNGNiOTU5NTdlODNkNDBiMGY3M2FmNDU0NGNjY2Y2YjFmNGIwOGQzYzA3YjI3ZmI4ZDhjMjk2MmE0MDA3NjZkMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkN2I4NzQwZjc0YThmYmFhYjFmNjgzZGI4ZjQ1ZGUyNjU0M2E1NDkwYmNhNjI3MDg3MjM2OTEyNDY5YTBiNDQ4JyxcbiAgICAgICAgJ2ZhNzc5NjgxMjhkOWM5MmVlMTAxMGYzMzdhZDQ3MTdlZmYxNWRiNWVkM2MwNDliMzQxMWUwMzE1ZWFhNDU5M2InXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzJkMzFjMjIyZjhmNmYwZWY4NmY3Yzk4ZDNhMzMzNWVhZDViY2QzMmFiZGQ5NDI4OWZlNGQzMDkxYWE4MjRiZicsXG4gICAgICAgICc1ZjMwMzJmNTg5MjE1NmUzOWNjZDNkNzkxNWI5ZTFkYTJlNmRhYzllNmYyNmU5NjExMThkMTRiODQ2MmUxNjYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc0NjFmMzcxOTE0YWIzMjY3MTA0NWExNTVkOTgzMWVhODc5M2Q3N2NkNTk1OTJjNDM0MGY4NmNiYzE4MzQ3YjUnLFxuICAgICAgICAnOGVjMGJhMjM4Yjk2YmVjMGNiZGRkY2FlMGFhNDQyNTQyZWVlMWZmNTBjOTg2ZWE2YjM5ODQ3YjNjYzA5MmZmNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlZTA3OWFkYjFkZjE4NjAwNzQzNTZhMjVhYTM4MjA2YTZkNzE2YjJjM2U2NzQ1M2QyODc2OThiYWQ3YjJiMmQ2JyxcbiAgICAgICAgJzhkYzI0MTJhYWZlM2JlNWM0YzVmMzdlMGVjYzVmOWY2YTQ0Njk4OWFmMDRjNGUyNWViYWFjNDc5ZWMxYzhjMWUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTZlYzkzZTQ0N2VjODNmMDQ2N2IxODMwMmVlNjIwZjdlNjVkZTMzMTg3NGM5ZGM3MmJmZDg2MTZiYTlkYTZiNScsXG4gICAgICAgICc1ZTQ2MzExNTBlNjJmYjQwZDBlOGMyYTdjYTU4MDRhMzlkNTgxODZhNTBlNDk3MTM5NjI2Nzc4ZTI1YjA2NzRkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VhYTVmOTgwYzI0NWY2ZjAzODk3ODI5MGFmYTcwYjZiZDg4NTU4OTdmOThiNmFhNDg1Yjk2MDY1ZDUzN2JkOTknLFxuICAgICAgICAnZjY1ZjVkM2UyOTJjMmUwODE5YTUyODM5MWM5OTQ2MjRkNzg0ODY5ZDdlNmVhNjdmYjE4MDQxMDI0ZWRjMDdkYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3OGM5NDA3NTQ0YWMxMzI2OTJlZTE5MTBhMDI0Mzk5NThhZTA0ODc3MTUxMzQyZWE5NmM0YjZiMzVhNDlmNTEnLFxuICAgICAgICAnZjNlMDMxOTE2OWViOWI4NWQ1NDA0Nzk1NTM5YTVlNjhmYTFmYmQ1ODNjMDY0ZDI0NjJiNjc1ZjE5NGEzZGRiNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0OTRmNGJlMjE5YTFhNzcwMTZkY2Q4Mzg0MzFhZWEwMDAxY2RjOGFlN2E2ZmM2ODg3MjY1NzhkOTcwMjg1N2E1JyxcbiAgICAgICAgJzQyMjQyYTk2OTI4M2E1ZjMzOWJhN2YwNzVlMzZiYTJhZjkyNWNlMzBkNzY3ZWQ2ZTU1ZjRiMDMxODgwZDU2MmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTU5OGE4MDMwZGE2ZDg2YzZiYzdmMmY1MTQ0ZWE1NDlkMjgyMTFlYTU4ZmFhNzBlYmY0YzFlNjY1YzFmZTliNScsXG4gICAgICAgICcyMDRiNWQ2Zjg0ODIyYzMwN2U0YjRhNzE0MDczN2FlYzIzZmM2M2I2NWIzNWY4NmExMDAyNmRiZDJkODY0ZTZiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0MTkxNjM2NWFiYjJiNWQwOTE5MmY1ZjJkYmVhZmVjMjA4ZjAyMGYxMjU3MGExODRkYmFkYzNlNTg1OTU5OTcnLFxuICAgICAgICAnNGYxNDM1MWQwMDg3ZWZhNDlkMjQ1YjMyODk4NDk4OWQ1Y2FmOTQ1MGYzNGJmYzBlZDE2ZTk2YjU4ZmE5OTEzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg0MWQ2MDYzYTU4NmZhNDc1YTcyNDYwNGRhMDNiYzViOTJhMmUwZDJlMGEzNmFjZmU0YzczYTU1MTQ3NDI4ODEnLFxuICAgICAgICAnNzM4NjdmNTljMDY1OWU4MTkwNGY5YTFjNzU0MzY5OGU2MjU2MmQ2NzQ0YzE2OWNlN2EzNmRlMDFhOGQ2MTU0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzVlOTViYjM5OWE2OTcxZDM3NjAyNjk0N2Y4OWJkZTJmMjgyYjMzODEwOTI4YmU0ZGVkMTEyYWM0ZDcwZTIwZDUnLFxuICAgICAgICAnMzlmMjNmMzY2ODA5MDg1YmVlYmZjNzExODEzMTM3NzVhOTljOWFlZDdkOGJhMzhiMTYxMzg0Yzc0NjAxMjg2NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNmU0NjQxYTUzOTQ4ZmQ0NzZjMzlmOGE5OWZkOTc0ZTVlYzA3NTY0YjUzMTVkOGJmOTk0NzFiY2EwZWYyZjY2JyxcbiAgICAgICAgJ2QyNDI0YjFiMWFiZTRlYjgxNjQyMjdiMDg1YzlhYTk0NTZlYTEzNDkzZmQ1NjNlMDZmZDUxY2Y1Njk0Yzc4ZmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzM2NTgxZWE3YmZiYmIyOTBjMTkxYTJmNTA3YTQxY2Y1NjQzODQyMTcwZTkxNGZhZWFiMjdjMmM1NzlmNzI2JyxcbiAgICAgICAgJ2VhZDEyMTY4NTk1ZmUxYmU5OTI1MjEyOWI2ZTU2YjMzOTFmN2FiMTQxMGNkMWUwZWYzZGNkY2FiZDJmZGEyMjQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGFiODk4MTZkYWRmZDZiNmExZjI2MzRmY2YwMGVjODQwMzc4MTAyNWVkNjg5MGM0ODQ5NzQyNzA2YmQ0M2VkZScsXG4gICAgICAgICc2ZmRjZWYwOWYyZjZkMGEwNDRlNjU0YWVmNjI0MTM2ZjUwM2Q0NTljM2U4OTg0NTg1OGE0N2E5MTI5Y2RkMjRlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzFlMzNmMWE3NDZjOWM1Nzc4MTMzMzQ0ZDkyOTlmY2FhMjBiMDkzOGU4YWNmZjI1NDRiYjQwMjg0YjhjNWZiOTQnLFxuICAgICAgICAnNjA2NjAyNTdkZDExYjNhYTljOGVkNjE4ZDI0ZWRmZjIzMDZkMzIwZjFkMDMwMTBlMzNhN2QyMDU3ZjNiM2I2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg1YjdjMWRjYjNjZWMxYjdlZTdmMzBkZWQ3OWRkMjBhMGVkMWY0Y2MxOGNiY2ZjZmE0MTAzNjFmZDhmMDhmMzEnLFxuICAgICAgICAnM2Q5OGE5Y2RkMDI2ZGQ0M2YzOTA0OGYyNWE4ODQ3ZjRmY2FmYWQxODk1ZDdhNjMzYzZmZWQzYzM1ZTk5OTUxMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyOWRmOWZiZDhkOWU0NjUwOTI3NWY0YjEyNWQ2ZDQ1ZDdmYmU5YTNiODc4YTdhZjg3MmEyODAwNjYxYWM1ZjUxJyxcbiAgICAgICAgJ2I0YzRmZTk5Yzc3NWE2MDZlMmQ4ODYyMTc5MTM5ZmZkYTYxZGM4NjFjMDE5ZTU1Y2QyODc2ZWIyYTI3ZDg0YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhMGIxY2FlMDZiMGE4NDdhM2ZlYTZlNjcxYWFmOGFkZmRmZTU4Y2EyZjc2ODEwNWM4MDgyYjJlNDQ5ZmNlMjUyJyxcbiAgICAgICAgJ2FlNDM0MTAyZWRkZTA5NThlYzRiMTlkOTE3YTZhMjhlNmI3MmRhMTgzNGFmZjBlNjUwZjA0OTUwM2EyOTZjZjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGU4Y2VhZmI5YjNlOWExMzZkYzdmZjY3ZTg0MDI5NWI0OTlkZmIzYjIxMzNlNGJhMTEzZjJlNGMwZTEyMWU1JyxcbiAgICAgICAgJ2NmMjE3NDExOGM4YjZkN2E0YjQ4ZjZkNTM0Y2U1Yzc5NDIyYzA4NmE2MzQ2MDUwMmI4MjdjZTYyYTMyNjY4M2MnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDI0YTQ0ZTA0N2UxOWI2ZjVhZmI4MWM3Y2EyZjY5MDgwYTUwNzY2ODlhMDEwOTE5ZjQyNzI1YzJiNzg5YTMzYicsXG4gICAgICAgICc2ZmI4ZDU1OTFiNDY2ZjhmYzYzZGI1MGYxYzBmMWM2OTAxM2Y5OTY4ODdiODI0NGQyY2RlYzQxN2FmZWE4ZmEzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VhMDE2MDZhN2E2YzljZGQyNDlmZGZjZmFjYjk5NTg0MDAxZWRkMjhhYmJhYjc3YjUxMDRlOThlOGUzYjM1ZDQnLFxuICAgICAgICAnMzIyYWY0OTA4YzczMTJiMGNmYmZlMzY5ZjdhN2IzY2RiN2Q0NDk0YmMyODIzNzAwY2ZkNjUyMTg4YTNlYTk4ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhZjhhZGRiZjJiNjYxYzhhNmM2MzI4NjU1ZWI5NjY1MTI1MjAwN2Q4YzVlYTMxYmU0YWQxOTZkZThjZTIxMzFmJyxcbiAgICAgICAgJzY3NDllNjdjMDI5Yjg1ZjUyYTAzNGVhZmQwOTY4MzZiMjUyMDgxODY4MGUyNmFjOGYzZGZiY2RiNzE3NDk3MDAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTNhZTE5NzQ1NjZjYTA2Y2M1MTZkNDdlMGZiMTY1YTY3NGEzZGFiY2ZjYTE1ZTcyMmYwZTM0NTBmNDU4ODknLFxuICAgICAgICAnMmFlYWJlN2U0NTMxNTEwMTE2MjE3ZjA3YmY0ZDA3MzAwZGU5N2U0ODc0ZjgxZjUzMzQyMGE3MmVlYjBiZDZhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1OTFlZTM1NTMxM2Q5OTcyMWNmNjk5M2ZmZWQxZTNlMzAxOTkzZmYzZWQyNTg4MDIwNzVlYThjZWQzOTdlMjQ2JyxcbiAgICAgICAgJ2IwZWE1NThhMTEzYzMwYmVhNjBmYzQ3NzU0NjBjNzkwMWZmMGIwNTNkMjVjYTJiZGVlZTk4ZjFhNGJlNWQxOTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTEzOTZkNTVmZGE1NGM0OWYxOWFhOTczMThkOGRhNjFmYTg1ODRlNDdiMDg0OTQ1MDc3Y2YwMzI1NWI1Mjk4NCcsXG4gICAgICAgICc5OThjNzRhOGNkNDVhYzAxMjg5ZDU4MzNhN2JlYjQ3NDRmZjUzNmIwMWIyNTdiZTRjNTc2N2JlYTkzZWE1N2E0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzNjNWQyYTFiYTM5YzVhMTc5MDAwMDczOGM5ZTBjNDBiOGRjZGZkNTQ2ODc1NGI2NDA1NTQwMTU3ZTAxN2FhN2EnLFxuICAgICAgICAnYjIyODQyNzk5OTVhMzRlMmY5ZDRkZTczOTZmYzE4YjgwZjliOGI5ZmRkMjcwZjY2NjFmNzljYTRjODFiZDI1NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjYzg3MDRiOGE2MGEwZGVmYTNhOTlhNzI5OWYyZTljM2ZiYzM5NWFmYjA0YWMwNzg0MjVlZjhhMTc5M2NjMDMwJyxcbiAgICAgICAgJ2JkZDQ2MDM5ZmVlZDE3ODgxZDFlMDg2MmRiMzQ3ZjhjZjM5NWI3NGZjNGJjZGM0ZTk0MGI3NGUzYWMxZjFiMTMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzUzM2U0ZjdlYTg1NTVhYWNkOTc3N2FjNWNhZDI5Yjk3ZGQ0ZGVmY2NjNTNlZTdlYTIwNDExOWIyODg5YjE5NycsXG4gICAgICAgICc2ZjBhMjU2YmM1ZWZkZjQyOWEyZmI2MjQyZjFhNDNhMmQ5YjkyNWJiNGE0YjNhMjZiYjhlMGY0NWViNTk2MDk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2MxNGY4ZjJjY2IyN2Q2ZjEwOWY2ZDA4ZDAzY2M5NmE2OWJhOGMzNGVlYzA3YmJjZjU2NmQ0OGUzM2RhNjU5MycsXG4gICAgICAgICdjMzU5ZDY5MjNiYjM5OGY3ZmQ0NDczZTE2ZmUxYzI4NDc1Yjc0MGRkMDk4MDc1ZTZjMGU4NjQ5MTEzZGMzYTM4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E2Y2JjMzA0NmJjNmE0NTBiYWMyNDc4OWZhMTcxMTVhNGM5NzM5ZWQ3NWY4ZjIxY2U0NDFmNzJlMGI5MGU2ZWYnLFxuICAgICAgICAnMjFhZTdmNDY4MGU4ODliYjEzMDYxOWUyYzBmOTVhMzYwY2ViNTczYzcwNjAzMTM5ODYyYWZkNjE3ZmE5YjlmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM0N2Q2ZDlhMDJjNDg5MjdlYmZiODZjMTM1OWIxY2FmMTMwYTNjMDI2N2QxMWNlNjM0NGIzOWY5OWQ0M2NjMzgnLFxuICAgICAgICAnNjBlYTdmNjFhMzUzNTI0ZDFjOTg3ZjZlY2VjOTJmMDg2ZDU2NWFiNjg3ODcwY2IxMjY4OWZmMWUzMWM3NDQ0OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYTY1NDVkMjE4MWRiOGQ5ODNmN2RjYjM3NWVmNTg2NmQ0N2M2N2IxYmYzMWM4Y2Y4NTVlZjc0MzdiNzI2NTZhJyxcbiAgICAgICAgJzQ5Yjk2NzE1YWI2ODc4YTc5ZTc4ZjA3Y2U1NjgwYzVkNjY3MzA1MWI0OTM1YmQ4OTdmZWE4MjRiNzdkYzIwOGEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzQwNzQ3Y2M5ZDAxMmNiMWExM2I4MTQ4MzA5YzZkZTdlYzI1ZDY5NDVkNjU3MTQ2YjlkNTk5NGI4ZmViMTExMScsXG4gICAgICAgICc1Y2E1NjA3NTNiZTJhMTJmYzZkZTZjYWYyY2I0ODk1NjVkYjkzNjE1NmI5NTE0ZTFiYjVlODMwMzdlMGZhMmQ0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRlNDJjOGVjODJjOTk3OThjY2YzYTYxMGJlODcwZTc4MzM4YzdmNzEzMzQ4YmQzNGM4MjAzZWY0MDM3ZjM1MDInLFxuICAgICAgICAnNzU3MWQ3NGVlNWUwZmI5MmE3YThiMzNhMDc3ODMzNDFhNTQ5MjE0NGNjNTRiY2M0MGE5NDQ3MzY5MzYwNjQzNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNzc1YWI3MDg5YmM2YWY4MjNhYmEyZTFhZjcwYjIzNmQyNTFjYWRiMGM4Njc0MzI4NzUyMmExYjNiMGRlZGVhJyxcbiAgICAgICAgJ2JlNTJkMTA3YmNmYTA5ZDhiY2I5NzM2YTgyOGNmYTdmYWM4ZGIxN2JmN2E3NmEyYzQyYWQ5NjE0MDkwMThjZjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnY2VlMzFjYmY3ZTM0ZWMzNzlkOTRmYjgxNGQzZDc3NWFkOTU0NTk1ZDEzMTRiYTg4NDY5NTllM2U4MmY3NGUyNicsXG4gICAgICAgICc4ZmQ2NGExNGMwNmI1ODljMjZiOTQ3YWUyYmNmNmJmYTAxNDllZjBiZTE0ZWQ0ZDgwZjQ0OGEwMWM0M2IxYzZkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2I0ZjllYWVhMDliNjkxNzYxOWY2ZWE2YTRlYjU0NjRlZmRkYjU4ZmQ0NWIxZWJlZmNkYzFhMDFkMDhiNDc5ODYnLFxuICAgICAgICAnMzllNWM5OTI1YjVhNTRiMDc0MzNhNGYxOGM2MTcyNmY4YmIxMzFjMDEyY2E1NDJlYjI0YThhYzA3MjAwNjgyYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNDI2M2RmYzNkMmRmOTIzYTAxNzlhNDg5NjZkMzBjZTg0ZTI1MTVhZmMzZGNjYzFiNzc5MDc3OTJlYmNjNjBlJyxcbiAgICAgICAgJzYyZGZhZjA3YTBmNzhmZWIzMGUzMGQ2Mjk1ODUzY2UxODllMTI3NzYwYWQ2Y2Y3ZmFlMTY0ZTEyMmEyMDhkNTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDg0NTc1MjQ4MjBmYTY1YTRmOGQzNWViNjkzMDg1N2MwMDMyYWNjMGE0YTJkZTQyMjIzM2VlZGE4OTc2MTJjNCcsXG4gICAgICAgICcyNWE3NDhhYjM2Nzk3OWQ5ODczM2MzOGExZmExYzJlN2RjNmNjMDdkYjJkNjBhOWFlN2E3NmFhYTQ5YmQwZjc3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RmZWVlZjE4ODExMDFmMmNiMTE2NDRmM2EyYWZkZmMyMDQ1ZTE5OTE5MTUyOTIzZjM2N2ExNzY3YzExY2NlZGEnLFxuICAgICAgICAnZWNmYjcwNTZjZjFkZTA0MmY5NDIwYmFiMzk2NzkzYzBjMzkwYmRlNzRiNGJiZGZmMTZhODNhZTA5YTlhNzUxNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2ZDdlZjZiMTc1NDNmODM3M2M1NzNmNDRlMWYzODk4MzVkODliY2JjNjA2MmNlZDM2YzgyZGY4M2I4ZmFlODU5JyxcbiAgICAgICAgJ2NkNDUwZWMzMzU0Mzg5ODZkZmVmYTEwYzU3ZmVhOWJjYzUyMWEwOTU5YjJkODBiYmY3NGIxOTBkY2E3MTJkMTAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTc1NjA1ZDU5MTAyYTVhMjY4NDUwMGQzYjk5MWYyZTNmM2M4OGI5MzIyNTU0NzAzNWFmMjVhZjY2ZTA0NTQxZicsXG4gICAgICAgICdmNWM1NDc1NGE4ZjcxZWU1NDBiOWI0ODcyODQ3M2UzMTRmNzI5YWM1MzA4YjA2OTM4MzYwOTkwZTJiZmFkMTI1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ViOTg2NjBmNGM0ZGZhYTA2YTJiZTQ1M2Q1MDIwYmM5OWEwYzJlNjBhYmUzODg0NTdkZDQzZmVmYjFlZDYyMGMnLFxuICAgICAgICAnNmNiOWE4ODc2ZDljYjg1MjA2MDlhZjNhZGQyNmNkMjBhMGE3Y2Q4YTk0MTExMzFjZTg1ZjQ0MTAwMDk5MjIzZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxM2U4N2IwMjdkODUxNGQzNTkzOWYyZTY4OTJiMTk5MjIxNTQ1OTY5NDE4ODgzMzZkYzM1NjNlM2I4ZGJhOTQyJyxcbiAgICAgICAgJ2ZlZjVhM2M2ODA1OWE2ZGVjNWQ2MjQxMTRiZjFlOTFhYWMyYjlkYTU2OGQ2YWJlYjI1NzBkNTU2NDZiOGFkZjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWUxNjMwMjZlOWZkNmZlMDE3YzM4ZjA2YTViZTZmYzEyNTQyNGIzNzFjZTI3MDhlN2JmNDQ5MTY5MWU1NzY0YScsXG4gICAgICAgICcxYWNiMjUwZjI1NWRkNjFjNDNkOTRjY2M2NzBkMGY1OGY0OWFlM2ZhMTViOTY2MjNlNTQzMGRhMGFkNmM2MmIyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2IyNjhmNWVmOWFkNTFlNGQ3OGRlM2E3NTBjMmRjODliMWU2MjZkNDM1MDU4Njc5OTk5MzJlNWRiMzNhZjNkODAnLFxuICAgICAgICAnNWYzMTBkNGIzYzk5YjllYmIxOWY3N2Q0MWMxZGVlMDE4Y2YwZDM0ZmQ0MTkxNjE0MDAzZTk0NWExMjE2ZTQyMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZjA3ZjMxMThhOWRmMDM1ZTlmYWQ4NWViNmM3YmZlNDJiMDJmMDFjYTk5Y2VlYTNiZjdmZmRiYTkzYzQ3NTBkJyxcbiAgICAgICAgJzQzODEzNmQ2MDNlODU4YTNhNWM0NDBjMzhlY2NiYWRkYzFkMjk0MjExNGUyZWRkZDQ3NDBkMDk4Y2VkMWYwZDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGQ4Yjk4NTVjN2MwNTJhMzQxNDZmZDIwZmZiNjU4YmVhNGI5ZjY5ZTBkODI1ZWJlYzE2ZThjM2NlMmI1MjZhMScsXG4gICAgICAgICdjZGI1NTllZWRjMmQ3OWY5MjZiYWY0NGZiODRlYTRkNDRiY2Y1MGZlZTUxZDdjZWIzMGUyZTdmNDYzMDM2NzU4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzUyZGIwYjUzODRkZmJmMDViZmE5ZDQ3MmQ3YWUyNmRmZTRiODUxY2VjYTkxYjFlYmE1NDI2MzE4MGRhMzJiNjMnLFxuICAgICAgICAnYzNiOTk3ZDA1MGVlNWQ0MjNlYmFmNjZhNmRiOWY1N2IzMTgwYzkwMjg3NTY3OWRlOTI0YjY5ZDg0YTdiMzc1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U2MmY5NDkwZDNkNTFkYTYzOTVlZmQyNGU4MDkxOWNjN2QwZjI5YzNmM2ZhNDhjNmZmZjU0M2JlY2JkNDMzNTInLFxuICAgICAgICAnNmQ4OWFkN2JhNDg3NmIwYjIyYzJjYTI4MGM2ODI4NjJmMzQyYzg1OTFmMWRhZjUxNzBlMDdiZmQ5Y2NhZmE3ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3ZjMwZWEyNDc2YjM5OWI0OTU3NTA5Yzg4Zjc3ZDAxOTFhZmEyZmY1Y2I3YjE0ZmQ2ZDhlN2Q2NWFhYWIxMTkzJyxcbiAgICAgICAgJ2NhNWVmN2Q0YjIzMWM5NGMzYjE1Mzg5YTVmNjMxMWU5ZGFmZjdiYjY3YjEwM2U5ODgwZWY0YmZmNjM3YWNhZWMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTA5OGZmMWUxZDlmMTRmYjQ2YTIxMGZhZGE2YzkwM2ZlZjBmYjdiNGExZGQxZDlhYzYwYTAzNjE4MDBiN2EwMCcsXG4gICAgICAgICc5NzMxMTQxZDgxZmM4ZjgwODRkMzdjNmU3NTQyMDA2YjNlZTFiNDBkNjBkZmU1MzYyYTViMTMyZmQxN2RkYzAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzJiNzhjN2RlOWVlNTEyYTcyODk1YmU2YjljYmVmYTZlMmYzYzRjY2NlNDQ1Yzk2YjlmMmM4MWUyNzc4YWQ1OCcsXG4gICAgICAgICdlZTE4NDlmNTEzZGY3MWUzMmVmYzM4OTZlZTI4MjYwYzczYmI4MDU0N2FlMjI3NWJhNDk3MjM3Nzk0Yzg3NTNjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UyY2I3NGZkZGM4ZTlmYmNkMDc2ZWVmMmE3YzcyYjBjZTM3ZDUwZjA4MjY5ZGZjMDc0YjU4MTU1MDU0N2E0ZjcnLFxuICAgICAgICAnZDNhYTJlZDcxYzlkZDIyNDdhNjJkZjA2MjczNmViMGJhZGRlYTllMzYxMjJkMmJlODY0MWFiY2IwMDVjYzRhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NDM4NDQ3NTY2ZDRkN2JlZGFkYzI5OTQ5NmFiMzU3NDI2MDA5YTM1ZjIzNWNiMTQxYmUwZDk5Y2QxMGFlM2E4JyxcbiAgICAgICAgJ2M0ZTEwMjA5MTY5ODBhNGRhNWQwMWFjNWU2YWQzMzA3MzRlZjBkNzkwNjYzMWM0ZjIzOTA0MjZiMmVkZDc5MWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDE2MmQ0ODhiODk0MDIwMzliNTg0YzZmYzZjMzA4ODcwNTg3ZDljNDZmNjYwYjg3OGFiNjVjODJjNzExZDY3ZScsXG4gICAgICAgICc2NzE2M2U5MDMyMzYyODlmNzc2ZjIyYzI1ZmI4YTNhZmMxNzMyZjJiODRiNGU5NWRiZGE0N2FlNWEwODUyNjQ5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzNmYWQzZmE4NGNhZjBmMzRmMGY4OWJmZDJkY2Y1NGZjMTc1ZDc2N2FlYzNlNTA2ODRmM2JhNGE0YmY1ZjY4M2QnLFxuICAgICAgICAnY2QxYmM3Y2I2Y2M0MDdiYjJmMGNhNjQ3YzcxOGE3MzBjZjcxODcyZTdkMGQyYTUzZmEyMGVmY2RmZTYxODI2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzY3NGYyNjAwYTMwMDdhMDA1NjhjMWE3Y2UwNWQwODE2YzFmYjg0YmYxMzcwNzk4ZjFjNjk1MzJmYWViMWE4NmInLFxuICAgICAgICAnMjk5ZDIxZjk0MTNmMzNiM2VkZjQzYjI1NzAwNDU4MGI3MGRiNTdkYTBiMTgyMjU5ZTA5ZWVjYzY5ZTBkMzhhNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkMzJmNGRhNTRhZGU3NGFiYjgxYjgxNWFkMWZiM2IyNjNkODJkNmM2OTI3MTRiY2ZmODdkMjliZDVlZTlmMDhmJyxcbiAgICAgICAgJ2Y5NDI5ZTczOGI4ZTUzYjk2OGU5OTAxNmMwNTk3MDc3ODJlMTRmNDUzNTM1OWQ1ODJmYzQxNjkxMGIzZWVhODcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzBlNGU2NzA0MzUzODU1NTZlNTkzNjU3MTM1ODQ1ZDM2ZmJiNjkzMWY3MmIwOGNiMWVkOTU0ZjFlM2NlM2ZmNicsXG4gICAgICAgICc0NjJmOWJjZTYxOTg5ODYzODQ5OTM1MDExM2JiYzliMTBhODc4ZDM1ZGE3MDc0MGRjNjk1YTU1OWViODhkYjdiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2JlMjA2MjAwM2M1MWNjMzAwNDY4MjkwNDMzMGU0ZGVlN2YzZGNkMTBiMDFlNTgwYmYxOTcxYjA0ZDRjYWQyOTcnLFxuICAgICAgICAnNjIxODhiYzQ5ZDYxZTU0Mjg1NzNkNDhhNzRlMWM2NTViMWM2MTA5MDkwNTY4MmEwZDU1NThlZDcyZGNjYjliYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5MzE0NDQyM2FjZTM0NTFlZDI5ZTBmYjlhYzJhZjIxMWNiNmU4NGE2MDFkZjU5OTNjNDE5ODU5ZmZmNWRmMDRhJyxcbiAgICAgICAgJzdjMTBkZmIxNjRjMzQyNWY1YzcxYTNmOWQ3OTkyMDM4ZjEwNjUyMjRmNzJiYjlkMWQ5MDJhNmQxMzAzN2I0N2MnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjAxNWY4MDQ0ZjVmY2JkY2YyMWNhMjZkNmMzNGZiODE5NzgyOTIwNWM3YjdkMmE3Y2I2NjQxOGMxNTdiMTEyYycsXG4gICAgICAgICdhYjhjMWUwODZkMDRlODEzNzQ0YTY1NWIyZGY4ZDVmODNiM2NkYzZmYWEzMDg4YzFkM2FlYTE0NTRlM2ExZDVmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q1ZTllMWRhNjQ5ZDk3ZDg5ZTQ4NjgxMTdhNDY1YTNhNGY4YTE4ZGU1N2ExNDBkMzZiM2YyYWYzNDFhMjFiNTInLFxuICAgICAgICAnNGNiMDQ0MzdmMzkxZWQ3MzExMWExM2NjMWQ0ZGQwZGIxNjkzNDY1YzIyNDA0ODBkODk1NWU4NTkyZjI3NDQ3YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkM2FlNDEwNDdkZDdjYTA2NWRiZjhlZDc3Yjk5MjQzOTk4MzAwNWNkNzJlMTZkNmY5OTZhNTMxNmQzNjk2NmJiJyxcbiAgICAgICAgJ2JkMWFlYjIxYWQyMmViYjIyYTEwZjAzMDM0MTdjNmQ5NjRmOGNkZDdkZjBhY2E2MTRiMTBkYzE0ZDEyNWFjNDYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDYzZTI3NjNkODg1Zjk1OGZjNjZjZGQyMjgwMGYwYTQ4NzE5N2QwYTgyZTM3N2I0OWY4MGFmODdjODk3YjA2NScsXG4gICAgICAgICdiZmVmYWNkYjBlNWQwZmQ3ZGYzYTMxMWE5NGRlMDYyYjI2YjgwYzYxZmJjOTc1MDhiNzk5OTI2NzFlZjdjYTdmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc5ODVmZGZkMTI3YzA1NjdjNmY1M2VjMWJiNjNlYzMxNThlNTk3YzQwYmZlNzQ3YzgzY2RkZmM5MTA2NDE5MTcnLFxuICAgICAgICAnNjAzYzEyZGFmM2Q5ODYyZWYyYjI1ZmUxZGUyODlhZWQyNGVkMjkxZTBlYzY3MDg3MDNhNWJkNTY3ZjMyZWQwMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NGExYWQ2YjVmNzZlMzlkYjJkZDI0OTQxMGVhYzdmOTllNzRjNTljYjgzZDJkMGVkNWZmMTU0M2RhNzcwM2U5JyxcbiAgICAgICAgJ2NjNjE1N2VmMThjOWM2M2NkNjE5M2Q4MzYzMWJiZWEwMDkzZTA5Njg5NDJlOGMzM2Q1NzM3ZmQ3OTBlMGRiMDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzA2ODJhNTA3MDMzNzVmNjAyZDQxNjY2NGJhMTliN2ZjOWJhYjQyYzcyNzQ3NDYzYTcxZDA4OTZiMjJmNmRhMycsXG4gICAgICAgICc1NTNlMDRmNmIwMThiNGZhNmM4ZjM5ZTdmMzExZDMxNzYyOTBkMGUwZjE5Y2E3M2YxNzcxNGQ5OTc3YTIyZmY4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzllMjE1OGYwZDdjMGQ1ZjI2YzM3OTFlZmVmYTc5NTk3NjU0ZTdhMmIyNDY0ZjUyYjFlZTZjMTM0Nzc2OWVmNTcnLFxuICAgICAgICAnNzEyZmNkZDFiOTA1M2YwOTAwM2EzNDgxZmE3NzYyZTlmZmQ3YzhlZjM1YTM4NTA5ZTJmYmYyNjI5MDA4MzczJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE3NmUyNjk4OWE0M2M5Y2ZlYmE0MDI5YzIwMjUzOGMyODE3MmU1NjZlM2M0ZmNlNzMyMjg1N2YzYmUzMjdkNjYnLFxuICAgICAgICAnZWQ4Y2M5ZDA0YjI5ZWI4NzdkMjcwYjQ4NzhkYzQzYzE5YWVmZDMxZjRlZWUwOWVlN2I0NzgzNGMxZmE0YjFjMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NWQ0NmVmZWEzNzcxZTZlNjhhYmI4OWExM2FkNzQ3ZWNmMTg5MjM5M2RmYzRmMWI3MDA0Nzg4YzUwMzc0ZGE4JyxcbiAgICAgICAgJzk4NTIzOTBhOTk1MDc2NzlmZDBiODZmZDJiMzlhODY4ZDdlZmMyMjE1MTM0NmUxYTNjYTQ3MjY1ODZhNmJlZDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODA5YTIwYzY3ZDY0OTAwZmZiNjk4YzRjODI1ZjZkNWYyMzEwZmIwNDUxYzg2OTM0NWI3MzE5ZjY0NTYwNTcyMScsXG4gICAgICAgICc5ZTk5NDk4MGQ5OTE3ZTIyYjc2YjA2MTkyN2ZhMDQxNDNkMDk2Y2NjNTQ5NjNlNmE1ZWJmYTVmM2Y4ZTI4NmMxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzFiMzg5MDNhNDNmN2YxMTRlZDQ1MDBiNGVhYzcwODNmZGVmZWNlMWNmMjljNjM1MjhkNTYzNDQ2Zjk3MmMxODAnLFxuICAgICAgICAnNDAzNmVkYzkzMWE2MGFlODg5MzUzZjc3ZmQ1M2RlNGEyNzA4YjI2YjZmNWRhNzJhZDMzOTQxMTlkYWY0MDhmOSdcbiAgICAgIF1cbiAgICBdXG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWxsaXB0aWMvbGliL2VsbGlwdGljL3ByZWNvbXB1dGVkL3NlY3AyNTZrMS5qc1xuLy8gbW9kdWxlIGlkID0gMjMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gZXhwb3J0cztcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgbWluQXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xudmFyIG1pblV0aWxzID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWNyeXB0by11dGlscycpO1xuXG51dGlscy5hc3NlcnQgPSBtaW5Bc3NlcnQ7XG51dGlscy50b0FycmF5ID0gbWluVXRpbHMudG9BcnJheTtcbnV0aWxzLnplcm8yID0gbWluVXRpbHMuemVybzI7XG51dGlscy50b0hleCA9IG1pblV0aWxzLnRvSGV4O1xudXRpbHMuZW5jb2RlID0gbWluVXRpbHMuZW5jb2RlO1xuXG4vLyBSZXByZXNlbnQgbnVtIGluIGEgdy1OQUYgZm9ybVxuZnVuY3Rpb24gZ2V0TkFGKG51bSwgdykge1xuICB2YXIgbmFmID0gW107XG4gIHZhciB3cyA9IDEgPDwgKHcgKyAxKTtcbiAgdmFyIGsgPSBudW0uY2xvbmUoKTtcbiAgd2hpbGUgKGsuY21wbigxKSA+PSAwKSB7XG4gICAgdmFyIHo7XG4gICAgaWYgKGsuaXNPZGQoKSkge1xuICAgICAgdmFyIG1vZCA9IGsuYW5kbG4od3MgLSAxKTtcbiAgICAgIGlmIChtb2QgPiAod3MgPj4gMSkgLSAxKVxuICAgICAgICB6ID0gKHdzID4+IDEpIC0gbW9kO1xuICAgICAgZWxzZVxuICAgICAgICB6ID0gbW9kO1xuICAgICAgay5pc3Vibih6KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeiA9IDA7XG4gICAgfVxuICAgIG5hZi5wdXNoKHopO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uLCBzaGlmdCBieSB3b3JkIGlmIHBvc3NpYmxlXG4gICAgdmFyIHNoaWZ0ID0gKGsuY21wbigwKSAhPT0gMCAmJiBrLmFuZGxuKHdzIC0gMSkgPT09IDApID8gKHcgKyAxKSA6IDE7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaGlmdDsgaSsrKVxuICAgICAgbmFmLnB1c2goMCk7XG4gICAgay5pdXNocm4oc2hpZnQpO1xuICB9XG5cbiAgcmV0dXJuIG5hZjtcbn1cbnV0aWxzLmdldE5BRiA9IGdldE5BRjtcblxuLy8gUmVwcmVzZW50IGsxLCBrMiBpbiBhIEpvaW50IFNwYXJzZSBGb3JtXG5mdW5jdGlvbiBnZXRKU0YoazEsIGsyKSB7XG4gIHZhciBqc2YgPSBbXG4gICAgW10sXG4gICAgW11cbiAgXTtcblxuICBrMSA9IGsxLmNsb25lKCk7XG4gIGsyID0gazIuY2xvbmUoKTtcbiAgdmFyIGQxID0gMDtcbiAgdmFyIGQyID0gMDtcbiAgd2hpbGUgKGsxLmNtcG4oLWQxKSA+IDAgfHwgazIuY21wbigtZDIpID4gMCkge1xuXG4gICAgLy8gRmlyc3QgcGhhc2VcbiAgICB2YXIgbTE0ID0gKGsxLmFuZGxuKDMpICsgZDEpICYgMztcbiAgICB2YXIgbTI0ID0gKGsyLmFuZGxuKDMpICsgZDIpICYgMztcbiAgICBpZiAobTE0ID09PSAzKVxuICAgICAgbTE0ID0gLTE7XG4gICAgaWYgKG0yNCA9PT0gMylcbiAgICAgIG0yNCA9IC0xO1xuICAgIHZhciB1MTtcbiAgICBpZiAoKG0xNCAmIDEpID09PSAwKSB7XG4gICAgICB1MSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtOCA9IChrMS5hbmRsbig3KSArIGQxKSAmIDc7XG4gICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMjQgPT09IDIpXG4gICAgICAgIHUxID0gLW0xNDtcbiAgICAgIGVsc2VcbiAgICAgICAgdTEgPSBtMTQ7XG4gICAgfVxuICAgIGpzZlswXS5wdXNoKHUxKTtcblxuICAgIHZhciB1MjtcbiAgICBpZiAoKG0yNCAmIDEpID09PSAwKSB7XG4gICAgICB1MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtOCA9IChrMi5hbmRsbig3KSArIGQyKSAmIDc7XG4gICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMTQgPT09IDIpXG4gICAgICAgIHUyID0gLW0yNDtcbiAgICAgIGVsc2VcbiAgICAgICAgdTIgPSBtMjQ7XG4gICAgfVxuICAgIGpzZlsxXS5wdXNoKHUyKTtcblxuICAgIC8vIFNlY29uZCBwaGFzZVxuICAgIGlmICgyICogZDEgPT09IHUxICsgMSlcbiAgICAgIGQxID0gMSAtIGQxO1xuICAgIGlmICgyICogZDIgPT09IHUyICsgMSlcbiAgICAgIGQyID0gMSAtIGQyO1xuICAgIGsxLml1c2hybigxKTtcbiAgICBrMi5pdXNocm4oMSk7XG4gIH1cblxuICByZXR1cm4ganNmO1xufVxudXRpbHMuZ2V0SlNGID0gZ2V0SlNGO1xuXG5mdW5jdGlvbiBjYWNoZWRQcm9wZXJ0eShvYmosIG5hbWUsIGNvbXB1dGVyKSB7XG4gIHZhciBrZXkgPSAnXycgKyBuYW1lO1xuICBvYmoucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkID8gdGhpc1trZXldIDpcbiAgICAgICAgICAgdGhpc1trZXldID0gY29tcHV0ZXIuY2FsbCh0aGlzKTtcbiAgfTtcbn1cbnV0aWxzLmNhY2hlZFByb3BlcnR5ID0gY2FjaGVkUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHBhcnNlQnl0ZXMoYnl0ZXMpIHtcbiAgcmV0dXJuIHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycgPyB1dGlscy50b0FycmF5KGJ5dGVzLCAnaGV4JykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzO1xufVxudXRpbHMucGFyc2VCeXRlcyA9IHBhcnNlQnl0ZXM7XG5cbmZ1bmN0aW9uIGludEZyb21MRShieXRlcykge1xuICByZXR1cm4gbmV3IEJOKGJ5dGVzLCAnaGV4JywgJ2xlJyk7XG59XG51dGlscy5pbnRGcm9tTEUgPSBpbnRGcm9tTEU7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbGxpcHRpYy9saWIvZWxsaXB0aWMvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDIzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJfYXJnc1wiOiBbXG5cdFx0W1xuXHRcdFx0e1xuXHRcdFx0XHRcInJhd1wiOiBcImVsbGlwdGljQF42LjAuMFwiLFxuXHRcdFx0XHRcInNjb3BlXCI6IG51bGwsXG5cdFx0XHRcdFwiZXNjYXBlZE5hbWVcIjogXCJlbGxpcHRpY1wiLFxuXHRcdFx0XHRcIm5hbWVcIjogXCJlbGxpcHRpY1wiLFxuXHRcdFx0XHRcInJhd1NwZWNcIjogXCJeNi4wLjBcIixcblx0XHRcdFx0XCJzcGVjXCI6IFwiPj02LjAuMCA8Ny4wLjBcIixcblx0XHRcdFx0XCJ0eXBlXCI6IFwicmFuZ2VcIlxuXHRcdFx0fSxcblx0XHRcdFwiL1VzZXJzL2RldmljYWxpbi9EZXNrdG9wL3dvcmtzcGFjZS9qcy1zdGwvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnblwiXG5cdFx0XVxuXHRdLFxuXHRcIl9mcm9tXCI6IFwiZWxsaXB0aWNAPj02LjAuMCA8Ny4wLjBcIixcblx0XCJfaWRcIjogXCJlbGxpcHRpY0A2LjQuMFwiLFxuXHRcIl9pbkNhY2hlXCI6IHRydWUsXG5cdFwiX2xvY2F0aW9uXCI6IFwiL2VsbGlwdGljXCIsXG5cdFwiX25vZGVWZXJzaW9uXCI6IFwiNy4wLjBcIixcblx0XCJfbnBtT3BlcmF0aW9uYWxJbnRlcm5hbFwiOiB7XG5cdFx0XCJob3N0XCI6IFwicGFja2FnZXMtMTgtZWFzdC5pbnRlcm5hbC5ucG1qcy5jb21cIixcblx0XHRcInRtcFwiOiBcInRtcC9lbGxpcHRpYy02LjQuMC50Z3pfMTQ4Nzc5ODg2NjQyOF8wLjMwNTEwNjIwMTkwNzYxOTgzXCJcblx0fSxcblx0XCJfbnBtVXNlclwiOiB7XG5cdFx0XCJuYW1lXCI6IFwiaW5kdXRueVwiLFxuXHRcdFwiZW1haWxcIjogXCJmZWRvckBpbmR1dG55LmNvbVwiXG5cdH0sXG5cdFwiX25wbVZlcnNpb25cIjogXCIzLjEwLjhcIixcblx0XCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuXHRcIl9yZXF1ZXN0ZWRcIjoge1xuXHRcdFwicmF3XCI6IFwiZWxsaXB0aWNAXjYuMC4wXCIsXG5cdFx0XCJzY29wZVwiOiBudWxsLFxuXHRcdFwiZXNjYXBlZE5hbWVcIjogXCJlbGxpcHRpY1wiLFxuXHRcdFwibmFtZVwiOiBcImVsbGlwdGljXCIsXG5cdFx0XCJyYXdTcGVjXCI6IFwiXjYuMC4wXCIsXG5cdFx0XCJzcGVjXCI6IFwiPj02LjAuMCA8Ny4wLjBcIixcblx0XHRcInR5cGVcIjogXCJyYW5nZVwiXG5cdH0sXG5cdFwiX3JlcXVpcmVkQnlcIjogW1xuXHRcdFwiL2Jyb3dzZXJpZnktc2lnblwiLFxuXHRcdFwiL2NyZWF0ZS1lY2RoXCJcblx0XSxcblx0XCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9lbGxpcHRpYy8tL2VsbGlwdGljLTYuNC4wLnRnelwiLFxuXHRcIl9zaGFzdW1cIjogXCJjYWM5YWY4NzYyYzg1ODM2MTg3MDAzYzhkZmUxOTNlNWUyZWFlNWRmXCIsXG5cdFwiX3Nocmlua3dyYXBcIjogbnVsbCxcblx0XCJfc3BlY1wiOiBcImVsbGlwdGljQF42LjAuMFwiLFxuXHRcIl93aGVyZVwiOiBcIi9Vc2Vycy9kZXZpY2FsaW4vRGVza3RvcC93b3Jrc3BhY2UvanMtc3RsL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ25cIixcblx0XCJhdXRob3JcIjoge1xuXHRcdFwibmFtZVwiOiBcIkZlZG9yIEluZHV0bnlcIixcblx0XHRcImVtYWlsXCI6IFwiZmVkb3JAaW5kdXRueS5jb21cIlxuXHR9LFxuXHRcImJ1Z3NcIjoge1xuXHRcdFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWMvaXNzdWVzXCJcblx0fSxcblx0XCJkZXBlbmRlbmNpZXNcIjoge1xuXHRcdFwiYm4uanNcIjogXCJeNC40LjBcIixcblx0XHRcImJyb3JhbmRcIjogXCJeMS4wLjFcIixcblx0XHRcImhhc2guanNcIjogXCJeMS4wLjBcIixcblx0XHRcImhtYWMtZHJiZ1wiOiBcIl4xLjAuMFwiLFxuXHRcdFwiaW5oZXJpdHNcIjogXCJeMi4wLjFcIixcblx0XHRcIm1pbmltYWxpc3RpYy1hc3NlcnRcIjogXCJeMS4wLjBcIixcblx0XHRcIm1pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHNcIjogXCJeMS4wLjBcIlxuXHR9LFxuXHRcImRlc2NyaXB0aW9uXCI6IFwiRUMgY3J5cHRvZ3JhcGh5XCIsXG5cdFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcImJyZnNcIjogXCJeMS40LjNcIixcblx0XHRcImNvdmVyYWxsc1wiOiBcIl4yLjExLjNcIixcblx0XHRcImdydW50XCI6IFwiXjAuNC41XCIsXG5cdFx0XCJncnVudC1icm93c2VyaWZ5XCI6IFwiXjUuMC4wXCIsXG5cdFx0XCJncnVudC1jbGlcIjogXCJeMS4yLjBcIixcblx0XHRcImdydW50LWNvbnRyaWItY29ubmVjdFwiOiBcIl4xLjAuMFwiLFxuXHRcdFwiZ3J1bnQtY29udHJpYi1jb3B5XCI6IFwiXjEuMC4wXCIsXG5cdFx0XCJncnVudC1jb250cmliLXVnbGlmeVwiOiBcIl4xLjAuMVwiLFxuXHRcdFwiZ3J1bnQtbW9jaGEtaXN0YW5idWxcIjogXCJeMy4wLjFcIixcblx0XHRcImdydW50LXNhdWNlbGFic1wiOiBcIl44LjYuMlwiLFxuXHRcdFwiaXN0YW5idWxcIjogXCJeMC40LjJcIixcblx0XHRcImpzY3NcIjogXCJeMi45LjBcIixcblx0XHRcImpzaGludFwiOiBcIl4yLjYuMFwiLFxuXHRcdFwibW9jaGFcIjogXCJeMi4xLjBcIlxuXHR9LFxuXHRcImRpcmVjdG9yaWVzXCI6IHt9LFxuXHRcImRpc3RcIjoge1xuXHRcdFwic2hhc3VtXCI6IFwiY2FjOWFmODc2MmM4NTgzNjE4NzAwM2M4ZGZlMTkzZTVlMmVhZTVkZlwiLFxuXHRcdFwidGFyYmFsbFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2VsbGlwdGljLy0vZWxsaXB0aWMtNi40LjAudGd6XCJcblx0fSxcblx0XCJmaWxlc1wiOiBbXG5cdFx0XCJsaWJcIlxuXHRdLFxuXHRcImdpdEhlYWRcIjogXCI2YjBkMmI3NmNhYWU5MTQ3MTY0OWM4ZTIxZjBiMWQzYmEwZjk2MDkwXCIsXG5cdFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9lbGxpcHRpY1wiLFxuXHRcImtleXdvcmRzXCI6IFtcblx0XHRcIkVDXCIsXG5cdFx0XCJFbGxpcHRpY1wiLFxuXHRcdFwiY3VydmVcIixcblx0XHRcIkNyeXB0b2dyYXBoeVwiXG5cdF0sXG5cdFwibGljZW5zZVwiOiBcIk1JVFwiLFxuXHRcIm1haW5cIjogXCJsaWIvZWxsaXB0aWMuanNcIixcblx0XCJtYWludGFpbmVyc1wiOiBbXG5cdFx0e1xuXHRcdFx0XCJuYW1lXCI6IFwiaW5kdXRueVwiLFxuXHRcdFx0XCJlbWFpbFwiOiBcImZlZG9yQGluZHV0bnkuY29tXCJcblx0XHR9XG5cdF0sXG5cdFwibmFtZVwiOiBcImVsbGlwdGljXCIsXG5cdFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge30sXG5cdFwicmVhZG1lXCI6IFwiRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kIVwiLFxuXHRcInJlcG9zaXRvcnlcIjoge1xuXHRcdFwidHlwZVwiOiBcImdpdFwiLFxuXHRcdFwidXJsXCI6IFwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWMuZ2l0XCJcblx0fSxcblx0XCJzY3JpcHRzXCI6IHtcblx0XHRcImpzY3NcIjogXCJqc2NzIGJlbmNobWFya3MvKi5qcyBsaWIvKi5qcyBsaWIvKiovKi5qcyBsaWIvKiovKiovKi5qcyB0ZXN0L2luZGV4LmpzXCIsXG5cdFx0XCJqc2hpbnRcIjogXCJqc2NzIGJlbmNobWFya3MvKi5qcyBsaWIvKi5qcyBsaWIvKiovKi5qcyBsaWIvKiovKiovKi5qcyB0ZXN0L2luZGV4LmpzXCIsXG5cdFx0XCJsaW50XCI6IFwibnBtIHJ1biBqc2NzICYmIG5wbSBydW4ganNoaW50XCIsXG5cdFx0XCJ0ZXN0XCI6IFwibnBtIHJ1biBsaW50ICYmIG5wbSBydW4gdW5pdFwiLFxuXHRcdFwidW5pdFwiOiBcImlzdGFuYnVsIHRlc3QgX21vY2hhIC0tcmVwb3J0ZXI9c3BlYyB0ZXN0L2luZGV4LmpzXCIsXG5cdFx0XCJ2ZXJzaW9uXCI6IFwiZ3J1bnQgZGlzdCAmJiBnaXQgYWRkIGRpc3QvXCJcblx0fSxcblx0XCJ2ZXJzaW9uXCI6IFwiNi40LjBcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZWxsaXB0aWMvcGFja2FnZS5qc29uXG4vLyBtb2R1bGUgaWQgPSAyMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhc2ggPSByZXF1aXJlKCcuLi9oYXNoJyk7XG52YXIgdXRpbHMgPSBoYXNoLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gQmxvY2tIYXNoKCkge1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdUb3RhbCA9IDA7XG4gIHRoaXMuYmxvY2tTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5ibG9ja1NpemU7XG4gIHRoaXMub3V0U2l6ZSA9IHRoaXMuY29uc3RydWN0b3Iub3V0U2l6ZTtcbiAgdGhpcy5obWFjU3RyZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLmhtYWNTdHJlbmd0aDtcbiAgdGhpcy5wYWRMZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLnBhZExlbmd0aCAvIDg7XG4gIHRoaXMuZW5kaWFuID0gJ2JpZyc7XG5cbiAgdGhpcy5fZGVsdGE4ID0gdGhpcy5ibG9ja1NpemUgLyA4O1xuICB0aGlzLl9kZWx0YTMyID0gdGhpcy5ibG9ja1NpemUgLyAzMjtcbn1cbmV4cG9ydHMuQmxvY2tIYXNoID0gQmxvY2tIYXNoO1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuICAvLyBDb252ZXJ0IG1lc3NhZ2UgdG8gYXJyYXksIHBhZCBpdCwgYW5kIGpvaW4gaW50byAzMmJpdCBibG9ja3NcbiAgbXNnID0gdXRpbHMudG9BcnJheShtc2csIGVuYyk7XG4gIGlmICghdGhpcy5wZW5kaW5nKVxuICAgIHRoaXMucGVuZGluZyA9IG1zZztcbiAgZWxzZVxuICAgIHRoaXMucGVuZGluZyA9IHRoaXMucGVuZGluZy5jb25jYXQobXNnKTtcbiAgdGhpcy5wZW5kaW5nVG90YWwgKz0gbXNnLmxlbmd0aDtcblxuICAvLyBFbm91Z2ggZGF0YSwgdHJ5IHVwZGF0aW5nXG4gIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID49IHRoaXMuX2RlbHRhOCkge1xuICAgIG1zZyA9IHRoaXMucGVuZGluZztcblxuICAgIC8vIFByb2Nlc3MgcGVuZGluZyBkYXRhIGluIGJsb2Nrc1xuICAgIHZhciByID0gbXNnLmxlbmd0aCAlIHRoaXMuX2RlbHRhODtcbiAgICB0aGlzLnBlbmRpbmcgPSBtc2cuc2xpY2UobXNnLmxlbmd0aCAtIHIsIG1zZy5sZW5ndGgpO1xuICAgIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcblxuICAgIG1zZyA9IHV0aWxzLmpvaW4zMihtc2csIDAsIG1zZy5sZW5ndGggLSByLCB0aGlzLmVuZGlhbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IHRoaXMuX2RlbHRhMzIpXG4gICAgICB0aGlzLl91cGRhdGUobXNnLCBpLCBpICsgdGhpcy5fZGVsdGEzMik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICB0aGlzLnVwZGF0ZSh0aGlzLl9wYWQoKSk7XG4gIGFzc2VydCh0aGlzLnBlbmRpbmcgPT09IG51bGwpO1xuXG4gIHJldHVybiB0aGlzLl9kaWdlc3QoZW5jKTtcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIHBhZCgpIHtcbiAgdmFyIGxlbiA9IHRoaXMucGVuZGluZ1RvdGFsO1xuICB2YXIgYnl0ZXMgPSB0aGlzLl9kZWx0YTg7XG4gIHZhciBrID0gYnl0ZXMgLSAoKGxlbiArIHRoaXMucGFkTGVuZ3RoKSAlIGJ5dGVzKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShrICsgdGhpcy5wYWRMZW5ndGgpO1xuICByZXNbMF0gPSAweDgwO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGs7IGkrKylcbiAgICByZXNbaV0gPSAwO1xuXG4gIC8vIEFwcGVuZCBsZW5ndGhcbiAgbGVuIDw8PSAzO1xuICBpZiAodGhpcy5lbmRpYW4gPT09ICdiaWcnKSB7XG4gICAgZm9yICh2YXIgdCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuXG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiA4KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuICB9IGVsc2Uge1xuICAgIHJlc1tpKytdID0gbGVuICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcblxuICAgIGZvciAodmFyIHQgPSA4OyB0IDwgdGhpcy5wYWRMZW5ndGg7IHQrKylcbiAgICAgIHJlc1tpKytdID0gMDtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hhc2guanMvbGliL2hhc2gvY29tbW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhtYWMgPSBleHBvcnRzO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJy4uL2hhc2gnKTtcbnZhciB1dGlscyA9IGhhc2gudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBIbWFjKGhhc2gsIGtleSwgZW5jKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjKSlcbiAgICByZXR1cm4gbmV3IEhtYWMoaGFzaCwga2V5LCBlbmMpO1xuICB0aGlzLkhhc2ggPSBoYXNoO1xuICB0aGlzLmJsb2NrU2l6ZSA9IGhhc2guYmxvY2tTaXplIC8gODtcbiAgdGhpcy5vdXRTaXplID0gaGFzaC5vdXRTaXplIC8gODtcbiAgdGhpcy5pbm5lciA9IG51bGw7XG4gIHRoaXMub3V0ZXIgPSBudWxsO1xuXG4gIHRoaXMuX2luaXQodXRpbHMudG9BcnJheShrZXksIGVuYykpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBIbWFjO1xuXG5IbWFjLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoa2V5KSB7XG4gIC8vIFNob3J0ZW4ga2V5LCBpZiBuZWVkZWRcbiAgaWYgKGtleS5sZW5ndGggPiB0aGlzLmJsb2NrU2l6ZSlcbiAgICBrZXkgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSkuZGlnZXN0KCk7XG4gIGFzc2VydChrZXkubGVuZ3RoIDw9IHRoaXMuYmxvY2tTaXplKTtcblxuICAvLyBBZGQgcGFkZGluZyB0byBrZXlcbiAgZm9yICh2YXIgaSA9IGtleS5sZW5ndGg7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgIGtleS5wdXNoKDApO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuICAgIGtleVtpXSBePSAweDM2O1xuICB0aGlzLmlubmVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xuXG4gIC8vIDB4MzYgXiAweDVjID0gMHg2YVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKylcbiAgICBrZXlbaV0gXj0gMHg2YTtcbiAgdGhpcy5vdXRlciA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KTtcbn07XG5cbkhtYWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuICB0aGlzLmlubmVyLnVwZGF0ZShtc2csIGVuYyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuSG1hYy5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICB0aGlzLm91dGVyLnVwZGF0ZSh0aGlzLmlubmVyLmRpZ2VzdCgpKTtcbiAgcmV0dXJuIHRoaXMub3V0ZXIuZGlnZXN0KGVuYyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hhc2guanMvbGliL2hhc2gvaG1hYy5qc1xuLy8gbW9kdWxlIGlkID0gMjM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXNoID0gcmVxdWlyZSgnLi4vaGFzaCcpO1xudmFyIHV0aWxzID0gaGFzaC51dGlscztcblxudmFyIHJvdGwzMiA9IHV0aWxzLnJvdGwzMjtcbnZhciBzdW0zMiA9IHV0aWxzLnN1bTMyO1xudmFyIHN1bTMyXzMgPSB1dGlscy5zdW0zMl8zO1xudmFyIHN1bTMyXzQgPSB1dGlscy5zdW0zMl80O1xudmFyIEJsb2NrSGFzaCA9IGhhc2guY29tbW9uLkJsb2NrSGFzaDtcblxuZnVuY3Rpb24gUklQRU1EMTYwKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUklQRU1EMTYwKSlcbiAgICByZXR1cm4gbmV3IFJJUEVNRDE2MCgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuaCA9IFsgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMCBdO1xuICB0aGlzLmVuZGlhbiA9ICdsaXR0bGUnO1xufVxudXRpbHMuaW5oZXJpdHMoUklQRU1EMTYwLCBCbG9ja0hhc2gpO1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBSSVBFTUQxNjA7XG5cblJJUEVNRDE2MC5ibG9ja1NpemUgPSA1MTI7XG5SSVBFTUQxNjAub3V0U2l6ZSA9IDE2MDtcblJJUEVNRDE2MC5obWFjU3RyZW5ndGggPSAxOTI7XG5SSVBFTUQxNjAucGFkTGVuZ3RoID0gNjQ7XG5cblJJUEVNRDE2MC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHZhciBBID0gdGhpcy5oWzBdO1xuICB2YXIgQiA9IHRoaXMuaFsxXTtcbiAgdmFyIEMgPSB0aGlzLmhbMl07XG4gIHZhciBEID0gdGhpcy5oWzNdO1xuICB2YXIgRSA9IHRoaXMuaFs0XTtcbiAgdmFyIEFoID0gQTtcbiAgdmFyIEJoID0gQjtcbiAgdmFyIENoID0gQztcbiAgdmFyIERoID0gRDtcbiAgdmFyIEVoID0gRTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgaisrKSB7XG4gICAgdmFyIFQgPSBzdW0zMihcbiAgICAgIHJvdGwzMihcbiAgICAgICAgc3VtMzJfNChBLCBmKGosIEIsIEMsIEQpLCBtc2dbcltqXSArIHN0YXJ0XSwgSyhqKSksXG4gICAgICAgIHNbal0pLFxuICAgICAgRSk7XG4gICAgQSA9IEU7XG4gICAgRSA9IEQ7XG4gICAgRCA9IHJvdGwzMihDLCAxMCk7XG4gICAgQyA9IEI7XG4gICAgQiA9IFQ7XG4gICAgVCA9IHN1bTMyKFxuICAgICAgcm90bDMyKFxuICAgICAgICBzdW0zMl80KEFoLCBmKDc5IC0gaiwgQmgsIENoLCBEaCksIG1zZ1tyaFtqXSArIHN0YXJ0XSwgS2goaikpLFxuICAgICAgICBzaFtqXSksXG4gICAgICBFaCk7XG4gICAgQWggPSBFaDtcbiAgICBFaCA9IERoO1xuICAgIERoID0gcm90bDMyKENoLCAxMCk7XG4gICAgQ2ggPSBCaDtcbiAgICBCaCA9IFQ7XG4gIH1cbiAgVCA9IHN1bTMyXzModGhpcy5oWzFdLCBDLCBEaCk7XG4gIHRoaXMuaFsxXSA9IHN1bTMyXzModGhpcy5oWzJdLCBELCBFaCk7XG4gIHRoaXMuaFsyXSA9IHN1bTMyXzModGhpcy5oWzNdLCBFLCBBaCk7XG4gIHRoaXMuaFszXSA9IHN1bTMyXzModGhpcy5oWzRdLCBBLCBCaCk7XG4gIHRoaXMuaFs0XSA9IHN1bTMyXzModGhpcy5oWzBdLCBCLCBDaCk7XG4gIHRoaXMuaFswXSA9IFQ7XG59O1xuXG5SSVBFTUQxNjAucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2xpdHRsZScpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnbGl0dGxlJyk7XG59O1xuXG5mdW5jdGlvbiBmKGosIHgsIHksIHopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIHggXiB5IF4gejtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gKHggJiB5KSB8ICgofngpICYgeik7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuICh4IHwgKH55KSkgXiB6O1xuICBlbHNlIGlmIChqIDw9IDYzKVxuICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiAofnopKTtcbiAgZWxzZVxuICAgIHJldHVybiB4IF4gKHkgfCAofnopKTtcbn1cblxuZnVuY3Rpb24gSyhqKSB7XG4gIGlmIChqIDw9IDE1KVxuICAgIHJldHVybiAweDAwMDAwMDAwO1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAweDVhODI3OTk5O1xuICBlbHNlIGlmIChqIDw9IDQ3KVxuICAgIHJldHVybiAweDZlZDllYmExO1xuICBlbHNlIGlmIChqIDw9IDYzKVxuICAgIHJldHVybiAweDhmMWJiY2RjO1xuICBlbHNlXG4gICAgcmV0dXJuIDB4YTk1M2ZkNGU7XG59XG5cbmZ1bmN0aW9uIEtoKGopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIDB4NTBhMjhiZTY7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuIDB4NWM0ZGQxMjQ7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuIDB4NmQ3MDNlZjM7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuIDB4N2E2ZDc2ZTk7XG4gIGVsc2VcbiAgICByZXR1cm4gMHgwMDAwMDAwMDtcbn1cblxudmFyIHIgPSBbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDgsXG4gIDMsIDEwLCAxNCwgNCwgOSwgMTUsIDgsIDEsIDIsIDcsIDAsIDYsIDEzLCAxMSwgNSwgMTIsXG4gIDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDIsXG4gIDQsIDAsIDUsIDksIDcsIDEyLCAyLCAxMCwgMTQsIDEsIDMsIDgsIDExLCA2LCAxNSwgMTNcbl07XG5cbnZhciByaCA9IFtcbiAgNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMixcbiAgNiwgMTEsIDMsIDcsIDAsIDEzLCA1LCAxMCwgMTQsIDE1LCA4LCAxMiwgNCwgOSwgMSwgMixcbiAgMTUsIDUsIDEsIDMsIDcsIDE0LCA2LCA5LCAxMSwgOCwgMTIsIDIsIDEwLCAwLCA0LCAxMyxcbiAgOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNCxcbiAgMTIsIDE1LCAxMCwgNCwgMSwgNSwgOCwgNywgNiwgMiwgMTMsIDE0LCAwLCAzLCA5LCAxMVxuXTtcblxudmFyIHMgPSBbXG4gIDExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOCxcbiAgNywgNiwgOCwgMTMsIDExLCA5LCA3LCAxNSwgNywgMTIsIDE1LCA5LCAxMSwgNywgMTMsIDEyLFxuICAxMSwgMTMsIDYsIDcsIDE0LCA5LCAxMywgMTUsIDE0LCA4LCAxMywgNiwgNSwgMTIsIDcsIDUsXG4gIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsIDksIDgsIDksIDE0LCA1LCA2LCA4LCA2LCA1LCAxMixcbiAgOSwgMTUsIDUsIDExLCA2LCA4LCAxMywgMTIsIDUsIDEyLCAxMywgMTQsIDExLCA4LCA1LCA2XG5dO1xuXG52YXIgc2ggPSBbXG4gIDgsIDksIDksIDExLCAxMywgMTUsIDE1LCA1LCA3LCA3LCA4LCAxMSwgMTQsIDE0LCAxMiwgNixcbiAgOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExLFxuICA5LCA3LCAxNSwgMTEsIDgsIDYsIDYsIDE0LCAxMiwgMTMsIDUsIDE0LCAxMywgMTMsIDcsIDUsXG4gIDE1LCA1LCA4LCAxMSwgMTQsIDE0LCA2LCAxNCwgNiwgOSwgMTIsIDksIDEyLCA1LCAxNSwgOCxcbiAgOCwgNSwgMTIsIDksIDEyLCA1LCAxNCwgNiwgOCwgMTMsIDYsIDUsIDE1LCAxMywgMTEsIDExXG5dO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hhc2guanMvbGliL2hhc2gvcmlwZW1kLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhc2ggPSByZXF1aXJlKCcuLi9oYXNoJyk7XG52YXIgdXRpbHMgPSBoYXNoLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxudmFyIHJvdHIzMiA9IHV0aWxzLnJvdHIzMjtcbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl80ID0gdXRpbHMuc3VtMzJfNDtcbnZhciBzdW0zMl81ID0gdXRpbHMuc3VtMzJfNTtcbnZhciByb3RyNjRfaGkgPSB1dGlscy5yb3RyNjRfaGk7XG52YXIgcm90cjY0X2xvID0gdXRpbHMucm90cjY0X2xvO1xudmFyIHNocjY0X2hpID0gdXRpbHMuc2hyNjRfaGk7XG52YXIgc2hyNjRfbG8gPSB1dGlscy5zaHI2NF9sbztcbnZhciBzdW02NCA9IHV0aWxzLnN1bTY0O1xudmFyIHN1bTY0X2hpID0gdXRpbHMuc3VtNjRfaGk7XG52YXIgc3VtNjRfbG8gPSB1dGlscy5zdW02NF9sbztcbnZhciBzdW02NF80X2hpID0gdXRpbHMuc3VtNjRfNF9oaTtcbnZhciBzdW02NF80X2xvID0gdXRpbHMuc3VtNjRfNF9sbztcbnZhciBzdW02NF81X2hpID0gdXRpbHMuc3VtNjRfNV9oaTtcbnZhciBzdW02NF81X2xvID0gdXRpbHMuc3VtNjRfNV9sbztcbnZhciBCbG9ja0hhc2ggPSBoYXNoLmNvbW1vbi5CbG9ja0hhc2g7XG5cbnZhciBzaGEyNTZfSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSxcbiAgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMyxcbiAgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYyxcbiAgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNyxcbiAgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMyxcbiAgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMyxcbiAgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSxcbiAgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCxcbiAgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXTtcblxudmFyIHNoYTUxMl9LID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dO1xuXG52YXIgc2hhMV9LID0gW1xuICAweDVBODI3OTk5LCAweDZFRDlFQkExLFxuICAweDhGMUJCQ0RDLCAweENBNjJDMUQ2XG5dO1xuXG5mdW5jdGlvbiBTSEEyNTYoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEyNTYpKVxuICAgIHJldHVybiBuZXcgU0hBMjU2KCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFsgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSxcbiAgICAgICAgICAgICAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5IF07XG4gIHRoaXMuayA9IHNoYTI1Nl9LO1xuICB0aGlzLlcgPSBuZXcgQXJyYXkoNjQpO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBMjU2LCBCbG9ja0hhc2gpO1xuZXhwb3J0cy5zaGEyNTYgPSBTSEEyNTY7XG5cblNIQTI1Ni5ibG9ja1NpemUgPSA1MTI7XG5TSEEyNTYub3V0U2l6ZSA9IDI1NjtcblNIQTI1Ni5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEEyNTYucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTI1Ni5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuICB2YXIgVyA9IHRoaXMuVztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuICBmb3IgKDsgaSA8IFcubGVuZ3RoOyBpKyspXG4gICAgV1tpXSA9IHN1bTMyXzQoZzFfMjU2KFdbaSAtIDJdKSwgV1tpIC0gN10sIGcwXzI1NihXW2kgLSAxNV0pLCBXW2kgLSAxNl0pO1xuXG4gIHZhciBhID0gdGhpcy5oWzBdO1xuICB2YXIgYiA9IHRoaXMuaFsxXTtcbiAgdmFyIGMgPSB0aGlzLmhbMl07XG4gIHZhciBkID0gdGhpcy5oWzNdO1xuICB2YXIgZSA9IHRoaXMuaFs0XTtcbiAgdmFyIGYgPSB0aGlzLmhbNV07XG4gIHZhciBnID0gdGhpcy5oWzZdO1xuICB2YXIgaCA9IHRoaXMuaFs3XTtcblxuICBhc3NlcnQodGhpcy5rLmxlbmd0aCA9PT0gVy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IFcubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgVDEgPSBzdW0zMl81KGgsIHMxXzI1NihlKSwgY2gzMihlLCBmLCBnKSwgdGhpcy5rW2ldLCBXW2ldKTtcbiAgICB2YXIgVDIgPSBzdW0zMihzMF8yNTYoYSksIG1hajMyKGEsIGIsIGMpKTtcbiAgICBoID0gZztcbiAgICBnID0gZjtcbiAgICBmID0gZTtcbiAgICBlID0gc3VtMzIoZCwgVDEpO1xuICAgIGQgPSBjO1xuICAgIGMgPSBiO1xuICAgIGIgPSBhO1xuICAgIGEgPSBzdW0zMihUMSwgVDIpO1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbiAgdGhpcy5oWzVdID0gc3VtMzIodGhpcy5oWzVdLCBmKTtcbiAgdGhpcy5oWzZdID0gc3VtMzIodGhpcy5oWzZdLCBnKTtcbiAgdGhpcy5oWzddID0gc3VtMzIodGhpcy5oWzddLCBoKTtcbn07XG5cblNIQTI1Ni5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG5cbmZ1bmN0aW9uIFNIQTIyNCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTIyNCkpXG4gICAgcmV0dXJuIG5ldyBTSEEyMjQoKTtcblxuICBTSEEyNTYuY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gWyAweGMxMDU5ZWQ4LCAweDM2N2NkNTA3LCAweDMwNzBkZDE3LCAweGY3MGU1OTM5LFxuICAgICAgICAgICAgIDB4ZmZjMDBiMzEsIDB4Njg1ODE1MTEsIDB4NjRmOThmYTcsIDB4YmVmYTRmYTQgXTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTIyNCwgU0hBMjU2KTtcbmV4cG9ydHMuc2hhMjI0ID0gU0hBMjI0O1xuXG5TSEEyMjQuYmxvY2tTaXplID0gNTEyO1xuU0hBMjI0Lm91dFNpemUgPSAyMjQ7XG5TSEEyMjQuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMjI0LnBhZExlbmd0aCA9IDY0O1xuXG5TSEEyMjQucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIC8vIEp1c3QgdHJ1bmNhdGUgb3V0cHV0XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaC5zbGljZSgwLCA3KSwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDcpLCAnYmlnJyk7XG59O1xuXG5mdW5jdGlvbiBTSEE1MTIoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEE1MTIpKVxuICAgIHJldHVybiBuZXcgU0hBNTEyKCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFsgMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCxcbiAgICAgICAgICAgICAweGJiNjdhZTg1LCAweDg0Y2FhNzNiLFxuICAgICAgICAgICAgIDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIsXG4gICAgICAgICAgICAgMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSxcbiAgICAgICAgICAgICAweDUxMGU1MjdmLCAweGFkZTY4MmQxLFxuICAgICAgICAgICAgIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsXG4gICAgICAgICAgICAgMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YixcbiAgICAgICAgICAgICAweDViZTBjZDE5LCAweDEzN2UyMTc5IF07XG4gIHRoaXMuayA9IHNoYTUxMl9LO1xuICB0aGlzLlcgPSBuZXcgQXJyYXkoMTYwKTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTUxMiwgQmxvY2tIYXNoKTtcbmV4cG9ydHMuc2hhNTEyID0gU0hBNTEyO1xuXG5TSEE1MTIuYmxvY2tTaXplID0gMTAyNDtcblNIQTUxMi5vdXRTaXplID0gNTEyO1xuU0hBNTEyLmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTUxMi5wYWRMZW5ndGggPSAxMjg7XG5cblNIQTUxMi5wcm90b3R5cGUuX3ByZXBhcmVCbG9jayA9IGZ1bmN0aW9uIF9wcmVwYXJlQmxvY2sobXNnLCBzdGFydCkge1xuICB2YXIgVyA9IHRoaXMuVztcblxuICAvLyAzMiB4IDMyYml0IHdvcmRzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG4gIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBjMF9oaSA9IGcxXzUxMl9oaShXW2kgLSA0XSwgV1tpIC0gM10pOyAgLy8gaSAtIDJcbiAgICB2YXIgYzBfbG8gPSBnMV81MTJfbG8oV1tpIC0gNF0sIFdbaSAtIDNdKTtcbiAgICB2YXIgYzFfaGkgPSBXW2kgLSAxNF07ICAvLyBpIC0gN1xuICAgIHZhciBjMV9sbyA9IFdbaSAtIDEzXTtcbiAgICB2YXIgYzJfaGkgPSBnMF81MTJfaGkoV1tpIC0gMzBdLCBXW2kgLSAyOV0pOyAgLy8gaSAtIDE1XG4gICAgdmFyIGMyX2xvID0gZzBfNTEyX2xvKFdbaSAtIDMwXSwgV1tpIC0gMjldKTtcbiAgICB2YXIgYzNfaGkgPSBXW2kgLSAzMl07ICAvLyBpIC0gMTZcbiAgICB2YXIgYzNfbG8gPSBXW2kgLSAzMV07XG5cbiAgICBXW2ldID0gc3VtNjRfNF9oaShjMF9oaSwgYzBfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgICAgICAgICAgICAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgICAgICAgICAgICAgICAgICBjM19oaSwgYzNfbG8pO1xuICAgIFdbaSArIDFdID0gc3VtNjRfNF9sbyhjMF9oaSwgYzBfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjM19oaSwgYzNfbG8pO1xuICB9XG59O1xuXG5TSEE1MTIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdGhpcy5fcHJlcGFyZUJsb2NrKG1zZywgc3RhcnQpO1xuXG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIHZhciBhaCA9IHRoaXMuaFswXTtcbiAgdmFyIGFsID0gdGhpcy5oWzFdO1xuICB2YXIgYmggPSB0aGlzLmhbMl07XG4gIHZhciBibCA9IHRoaXMuaFszXTtcbiAgdmFyIGNoID0gdGhpcy5oWzRdO1xuICB2YXIgY2wgPSB0aGlzLmhbNV07XG4gIHZhciBkaCA9IHRoaXMuaFs2XTtcbiAgdmFyIGRsID0gdGhpcy5oWzddO1xuICB2YXIgZWggPSB0aGlzLmhbOF07XG4gIHZhciBlbCA9IHRoaXMuaFs5XTtcbiAgdmFyIGZoID0gdGhpcy5oWzEwXTtcbiAgdmFyIGZsID0gdGhpcy5oWzExXTtcbiAgdmFyIGdoID0gdGhpcy5oWzEyXTtcbiAgdmFyIGdsID0gdGhpcy5oWzEzXTtcbiAgdmFyIGhoID0gdGhpcy5oWzE0XTtcbiAgdmFyIGhsID0gdGhpcy5oWzE1XTtcblxuICBhc3NlcnQodGhpcy5rLmxlbmd0aCA9PT0gVy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IFcubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgYzBfaGkgPSBoaDtcbiAgICB2YXIgYzBfbG8gPSBobDtcbiAgICB2YXIgYzFfaGkgPSBzMV81MTJfaGkoZWgsIGVsKTtcbiAgICB2YXIgYzFfbG8gPSBzMV81MTJfbG8oZWgsIGVsKTtcbiAgICB2YXIgYzJfaGkgPSBjaDY0X2hpKGVoLCBlbCwgZmgsIGZsLCBnaCwgZ2wpO1xuICAgIHZhciBjMl9sbyA9IGNoNjRfbG8oZWgsIGVsLCBmaCwgZmwsIGdoLCBnbCk7XG4gICAgdmFyIGMzX2hpID0gdGhpcy5rW2ldO1xuICAgIHZhciBjM19sbyA9IHRoaXMua1tpICsgMV07XG4gICAgdmFyIGM0X2hpID0gV1tpXTtcbiAgICB2YXIgYzRfbG8gPSBXW2kgKyAxXTtcblxuICAgIHZhciBUMV9oaSA9IHN1bTY0XzVfaGkoYzBfaGksIGMwX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzRfaGksIGM0X2xvKTtcbiAgICB2YXIgVDFfbG8gPSBzdW02NF81X2xvKGMwX2hpLCBjMF9sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzX2hpLCBjM19sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0X2hpLCBjNF9sbyk7XG5cbiAgICB2YXIgYzBfaGkgPSBzMF81MTJfaGkoYWgsIGFsKTtcbiAgICB2YXIgYzBfbG8gPSBzMF81MTJfbG8oYWgsIGFsKTtcbiAgICB2YXIgYzFfaGkgPSBtYWo2NF9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsKTtcbiAgICB2YXIgYzFfbG8gPSBtYWo2NF9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsKTtcblxuICAgIHZhciBUMl9oaSA9IHN1bTY0X2hpKGMwX2hpLCBjMF9sbywgYzFfaGksIGMxX2xvKTtcbiAgICB2YXIgVDJfbG8gPSBzdW02NF9sbyhjMF9oaSwgYzBfbG8sIGMxX2hpLCBjMV9sbyk7XG5cbiAgICBoaCA9IGdoO1xuICAgIGhsID0gZ2w7XG5cbiAgICBnaCA9IGZoO1xuICAgIGdsID0gZmw7XG5cbiAgICBmaCA9IGVoO1xuICAgIGZsID0gZWw7XG5cbiAgICBlaCA9IHN1bTY0X2hpKGRoLCBkbCwgVDFfaGksIFQxX2xvKTtcbiAgICBlbCA9IHN1bTY0X2xvKGRsLCBkbCwgVDFfaGksIFQxX2xvKTtcblxuICAgIGRoID0gY2g7XG4gICAgZGwgPSBjbDtcblxuICAgIGNoID0gYmg7XG4gICAgY2wgPSBibDtcblxuICAgIGJoID0gYWg7XG4gICAgYmwgPSBhbDtcblxuICAgIGFoID0gc3VtNjRfaGkoVDFfaGksIFQxX2xvLCBUMl9oaSwgVDJfbG8pO1xuICAgIGFsID0gc3VtNjRfbG8oVDFfaGksIFQxX2xvLCBUMl9oaSwgVDJfbG8pO1xuICB9XG5cbiAgc3VtNjQodGhpcy5oLCAwLCBhaCwgYWwpO1xuICBzdW02NCh0aGlzLmgsIDIsIGJoLCBibCk7XG4gIHN1bTY0KHRoaXMuaCwgNCwgY2gsIGNsKTtcbiAgc3VtNjQodGhpcy5oLCA2LCBkaCwgZGwpO1xuICBzdW02NCh0aGlzLmgsIDgsIGVoLCBlbCk7XG4gIHN1bTY0KHRoaXMuaCwgMTAsIGZoLCBmbCk7XG4gIHN1bTY0KHRoaXMuaCwgMTIsIGdoLCBnbCk7XG4gIHN1bTY0KHRoaXMuaCwgMTQsIGhoLCBobCk7XG59O1xuXG5TSEE1MTIucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuXG5mdW5jdGlvbiBTSEEzODQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEzODQpKVxuICAgIHJldHVybiBuZXcgU0hBMzg0KCk7XG5cbiAgU0hBNTEyLmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFsgMHhjYmJiOWQ1ZCwgMHhjMTA1OWVkOCxcbiAgICAgICAgICAgICAweDYyOWEyOTJhLCAweDM2N2NkNTA3LFxuICAgICAgICAgICAgIDB4OTE1OTAxNWEsIDB4MzA3MGRkMTcsXG4gICAgICAgICAgICAgMHgxNTJmZWNkOCwgMHhmNzBlNTkzOSxcbiAgICAgICAgICAgICAweDY3MzMyNjY3LCAweGZmYzAwYjMxLFxuICAgICAgICAgICAgIDB4OGViNDRhODcsIDB4Njg1ODE1MTEsXG4gICAgICAgICAgICAgMHhkYjBjMmUwZCwgMHg2NGY5OGZhNyxcbiAgICAgICAgICAgICAweDQ3YjU0ODFkLCAweGJlZmE0ZmE0IF07XG59XG51dGlscy5pbmhlcml0cyhTSEEzODQsIFNIQTUxMik7XG5leHBvcnRzLnNoYTM4NCA9IFNIQTM4NDtcblxuU0hBMzg0LmJsb2NrU2l6ZSA9IDEwMjQ7XG5TSEEzODQub3V0U2l6ZSA9IDM4NDtcblNIQTM4NC5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEEzODQucGFkTGVuZ3RoID0gMTI4O1xuXG5TSEEzODQucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaC5zbGljZSgwLCAxMiksICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaC5zbGljZSgwLCAxMiksICdiaWcnKTtcbn07XG5cbmZ1bmN0aW9uIFNIQTEoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEExKSlcbiAgICByZXR1cm4gbmV3IFNIQTEoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gWyAweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLFxuICAgICAgICAgICAgIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjAgXTtcbiAgdGhpcy5XID0gbmV3IEFycmF5KDgwKTtcbn1cblxudXRpbHMuaW5oZXJpdHMoU0hBMSwgQmxvY2tIYXNoKTtcbmV4cG9ydHMuc2hhMSA9IFNIQTE7XG5cblNIQTEuYmxvY2tTaXplID0gNTEyO1xuU0hBMS5vdXRTaXplID0gMTYwO1xuU0hBMS5obWFjU3RyZW5ndGggPSA4MDtcblNIQTEucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcblxuICBmb3IoOyBpIDwgVy5sZW5ndGg7IGkrKylcbiAgICBXW2ldID0gcm90bDMyKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0sIDEpO1xuXG4gIHZhciBhID0gdGhpcy5oWzBdO1xuICB2YXIgYiA9IHRoaXMuaFsxXTtcbiAgdmFyIGMgPSB0aGlzLmhbMl07XG4gIHZhciBkID0gdGhpcy5oWzNdO1xuICB2YXIgZSA9IHRoaXMuaFs0XTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IFcubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcyA9IH5+KGkgLyAyMCk7XG4gICAgdmFyIHQgPSBzdW0zMl81KHJvdGwzMihhLCA1KSwgZnRfMShzLCBiLCBjLCBkKSwgZSwgV1tpXSwgc2hhMV9LW3NdKTtcbiAgICBlID0gZDtcbiAgICBkID0gYztcbiAgICBjID0gcm90bDMyKGIsIDMwKTtcbiAgICBiID0gYTtcbiAgICBhID0gdDtcbiAgfVxuXG4gIHRoaXMuaFswXSA9IHN1bTMyKHRoaXMuaFswXSwgYSk7XG4gIHRoaXMuaFsxXSA9IHN1bTMyKHRoaXMuaFsxXSwgYik7XG4gIHRoaXMuaFsyXSA9IHN1bTMyKHRoaXMuaFsyXSwgYyk7XG4gIHRoaXMuaFszXSA9IHN1bTMyKHRoaXMuaFszXSwgZCk7XG4gIHRoaXMuaFs0XSA9IHN1bTMyKHRoaXMuaFs0XSwgZSk7XG59O1xuXG5TSEExLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gY2gzMih4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIF4gKCh+eCkgJiB6KTtcbn1cblxuZnVuY3Rpb24gbWFqMzIoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSBeICh4ICYgeikgXiAoeSAmIHopO1xufVxuXG5mdW5jdGlvbiBwMzIoeCwgeSwgeikge1xuICByZXR1cm4geCBeIHkgXiB6O1xufVxuXG5mdW5jdGlvbiBzMF8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDIpIF4gcm90cjMyKHgsIDEzKSBeIHJvdHIzMih4LCAyMik7XG59XG5cbmZ1bmN0aW9uIHMxXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgNikgXiByb3RyMzIoeCwgMTEpIF4gcm90cjMyKHgsIDI1KTtcbn1cblxuZnVuY3Rpb24gZzBfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCA3KSBeIHJvdHIzMih4LCAxOCkgXiAoeCA+Pj4gMyk7XG59XG5cbmZ1bmN0aW9uIGcxXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgMTcpIF4gcm90cjMyKHgsIDE5KSBeICh4ID4+PiAxMCk7XG59XG5cbmZ1bmN0aW9uIGZ0XzEocywgeCwgeSwgeikge1xuICBpZiAocyA9PT0gMClcbiAgICByZXR1cm4gY2gzMih4LCB5LCB6KTtcbiAgaWYgKHMgPT09IDEgfHwgcyA9PT0gMylcbiAgICByZXR1cm4gcDMyKHgsIHksIHopO1xuICBpZiAocyA9PT0gMilcbiAgICByZXR1cm4gbWFqMzIoeCwgeSwgeik7XG59XG5cbmZ1bmN0aW9uIGNoNjRfaGkoeGgsIHhsLCB5aCwgeWwsIHpoLCB6bCkge1xuICB2YXIgciA9ICh4aCAmIHloKSBeICgofnhoKSAmIHpoKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBjaDY0X2xvKHhoLCB4bCwgeWgsIHlsLCB6aCwgemwpIHtcbiAgdmFyIHIgPSAoeGwgJiB5bCkgXiAoKH54bCkgJiB6bCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gbWFqNjRfaGkoeGgsIHhsLCB5aCwgeWwsIHpoLCB6bCkge1xuICB2YXIgciA9ICh4aCAmIHloKSBeICh4aCAmIHpoKSBeICh5aCAmIHpoKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBtYWo2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhsICYgeWwpIF4gKHhsICYgemwpIF4gKHlsICYgemwpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMwXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMjgpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCAyKTsgIC8vIDM0XG4gIHZhciBjMl9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDcpOyAgLy8gMzlcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMF81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDI4KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgMik7ICAvLyAzNFxuICB2YXIgYzJfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCA3KTsgIC8vIDM5XG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczFfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxNCk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE4KTtcbiAgdmFyIGMyX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMxXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTQpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxOCk7XG4gIHZhciBjMl9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDkpOyAgLy8gNDFcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMF81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDEpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCA4KTtcbiAgdmFyIGMyX2hpID0gc2hyNjRfaGkoeGgsIHhsLCA3KTtcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMF81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDEpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCA4KTtcbiAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA3KTtcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMV81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE5KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgMjkpOyAgLy8gNjFcbiAgdmFyIGMyX2hpID0gc2hyNjRfaGkoeGgsIHhsLCA2KTtcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMV81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE5KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgMjkpOyAgLy8gNjFcbiAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA2KTtcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hhc2guanMvbGliL2hhc2gvc2hhLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHV0aWxzID0gZXhwb3J0cztcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmZ1bmN0aW9uIHRvQXJyYXkobXNnLCBlbmMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSlcbiAgICByZXR1cm4gbXNnLnNsaWNlKCk7XG4gIGlmICghbXNnKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHJlcyA9IFtdO1xuICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIWVuYykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGhpID0gYyA+PiA4O1xuICAgICAgICB2YXIgbG8gPSBjICYgMHhmZjtcbiAgICAgICAgaWYgKGhpKVxuICAgICAgICAgIHJlcy5wdXNoKGhpLCBsbyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXMucHVzaChsbyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmMgPT09ICdoZXgnKSB7XG4gICAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuICAgICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgICBtc2cgPSAnMCcgKyBtc2c7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldICsgbXNnW2kgKyAxXSwgMTYpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgICByZXNbaV0gPSBtc2dbaV0gfCAwO1xuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0FycmF5ID0gdG9BcnJheTtcblxuZnVuY3Rpb24gdG9IZXgobXNnKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9IZXggPSB0b0hleDtcblxuZnVuY3Rpb24gaHRvbmwodykge1xuICB2YXIgcmVzID0gKHcgPj4+IDI0KSB8XG4gICAgICAgICAgICAoKHcgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgICAgICAgICAoKHcgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgICAgICAgKCh3ICYgMHhmZikgPDwgMjQpO1xuICByZXR1cm4gcmVzID4+PiAwO1xufVxudXRpbHMuaHRvbmwgPSBodG9ubDtcblxuZnVuY3Rpb24gdG9IZXgzMihtc2csIGVuZGlhbikge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHcgPSBtc2dbaV07XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2xpdHRsZScpXG4gICAgICB3ID0gaHRvbmwodyk7XG4gICAgcmVzICs9IHplcm84KHcudG9TdHJpbmcoMTYpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9IZXgzMiA9IHRvSGV4MzI7XG5cbmZ1bmN0aW9uIHplcm8yKHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG51dGlscy56ZXJvMiA9IHplcm8yO1xuXG5mdW5jdGlvbiB6ZXJvOCh3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gNylcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDYpXG4gICAgcmV0dXJuICcwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNSlcbiAgICByZXR1cm4gJzAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNClcbiAgICByZXR1cm4gJzAwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDMpXG4gICAgcmV0dXJuICcwMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMilcbiAgICByZXR1cm4gJzAwMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAwMDAwMDAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxudXRpbHMuemVybzggPSB6ZXJvODtcblxuZnVuY3Rpb24gam9pbjMyKG1zZywgc3RhcnQsIGVuZCwgZW5kaWFuKSB7XG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgYXNzZXJ0KGxlbiAlIDQgPT09IDApO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbiAvIDQpO1xuICBmb3IgKHZhciBpID0gMCwgayA9IHN0YXJ0OyBpIDwgcmVzLmxlbmd0aDsgaSsrLCBrICs9IDQpIHtcbiAgICB2YXIgdztcbiAgICBpZiAoZW5kaWFuID09PSAnYmlnJylcbiAgICAgIHcgPSAobXNnW2tdIDw8IDI0KSB8IChtc2dbayArIDFdIDw8IDE2KSB8IChtc2dbayArIDJdIDw8IDgpIHwgbXNnW2sgKyAzXTtcbiAgICBlbHNlXG4gICAgICB3ID0gKG1zZ1trICsgM10gPDwgMjQpIHwgKG1zZ1trICsgMl0gPDwgMTYpIHwgKG1zZ1trICsgMV0gPDwgOCkgfCBtc2dba107XG4gICAgcmVzW2ldID0gdyA+Pj4gMDtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxudXRpbHMuam9pbjMyID0gam9pbjMyO1xuXG5mdW5jdGlvbiBzcGxpdDMyKG1zZywgZW5kaWFuKSB7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobXNnLmxlbmd0aCAqIDQpO1xuICBmb3IgKHZhciBpID0gMCwgayA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuICAgIHZhciBtID0gbXNnW2ldO1xuICAgIGlmIChlbmRpYW4gPT09ICdiaWcnKSB7XG4gICAgICByZXNba10gPSBtID4+PiAyNDtcbiAgICAgIHJlc1trICsgMV0gPSAobSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgIHJlc1trICsgMl0gPSAobSA+Pj4gOCkgJiAweGZmO1xuICAgICAgcmVzW2sgKyAzXSA9IG0gJiAweGZmO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbayArIDNdID0gbSA+Pj4gMjQ7XG4gICAgICByZXNbayArIDJdID0gKG0gPj4+IDE2KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDFdID0gKG0gPj4+IDgpICYgMHhmZjtcbiAgICAgIHJlc1trXSA9IG0gJiAweGZmO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxudXRpbHMuc3BsaXQzMiA9IHNwbGl0MzI7XG5cbmZ1bmN0aW9uIHJvdHIzMih3LCBiKSB7XG4gIHJldHVybiAodyA+Pj4gYikgfCAodyA8PCAoMzIgLSBiKSk7XG59XG51dGlscy5yb3RyMzIgPSByb3RyMzI7XG5cbmZ1bmN0aW9uIHJvdGwzMih3LCBiKSB7XG4gIHJldHVybiAodyA8PCBiKSB8ICh3ID4+PiAoMzIgLSBiKSk7XG59XG51dGlscy5yb3RsMzIgPSByb3RsMzI7XG5cbmZ1bmN0aW9uIHN1bTMyKGEsIGIpIHtcbiAgcmV0dXJuIChhICsgYikgPj4+IDA7XG59XG51dGlscy5zdW0zMiA9IHN1bTMyO1xuXG5mdW5jdGlvbiBzdW0zMl8zKGEsIGIsIGMpIHtcbiAgcmV0dXJuIChhICsgYiArIGMpID4+PiAwO1xufVxudXRpbHMuc3VtMzJfMyA9IHN1bTMyXzM7XG5cbmZ1bmN0aW9uIHN1bTMyXzQoYSwgYiwgYywgZCkge1xuICByZXR1cm4gKGEgKyBiICsgYyArIGQpID4+PiAwO1xufVxudXRpbHMuc3VtMzJfNCA9IHN1bTMyXzQ7XG5cbmZ1bmN0aW9uIHN1bTMyXzUoYSwgYiwgYywgZCwgZSkge1xuICByZXR1cm4gKGEgKyBiICsgYyArIGQgKyBlKSA+Pj4gMDtcbn1cbnV0aWxzLnN1bTMyXzUgPSBzdW0zMl81O1xuXG5mdW5jdGlvbiBhc3NlcnQoY29uZCwgbXNnKSB7XG4gIGlmICghY29uZClcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG59XG51dGlscy5hc3NlcnQgPSBhc3NlcnQ7XG5cbnV0aWxzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5cbmZ1bmN0aW9uIHN1bTY0KGJ1ZiwgcG9zLCBhaCwgYWwpIHtcbiAgdmFyIGJoID0gYnVmW3Bvc107XG4gIHZhciBibCA9IGJ1Zltwb3MgKyAxXTtcblxuICB2YXIgbG8gPSAoYWwgKyBibCkgPj4+IDA7XG4gIHZhciBoaSA9IChsbyA8IGFsID8gMSA6IDApICsgYWggKyBiaDtcbiAgYnVmW3Bvc10gPSBoaSA+Pj4gMDtcbiAgYnVmW3BvcyArIDFdID0gbG87XG59XG5leHBvcnRzLnN1bTY0ID0gc3VtNjQ7XG5cbmZ1bmN0aW9uIHN1bTY0X2hpKGFoLCBhbCwgYmgsIGJsKSB7XG4gIHZhciBsbyA9IChhbCArIGJsKSA+Pj4gMDtcbiAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuICByZXR1cm4gaGkgPj4+IDA7XG59O1xuZXhwb3J0cy5zdW02NF9oaSA9IHN1bTY0X2hpO1xuXG5mdW5jdGlvbiBzdW02NF9sbyhhaCwgYWwsIGJoLCBibCkge1xuICB2YXIgbG8gPSBhbCArIGJsO1xuICByZXR1cm4gbG8gPj4+IDA7XG59O1xuZXhwb3J0cy5zdW02NF9sbyA9IHN1bTY0X2xvO1xuXG5mdW5jdGlvbiBzdW02NF80X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCkge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgbG8gPSBhbDtcbiAgbG8gPSAobG8gKyBibCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgYWwgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBjbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgY2wgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBkbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgZGwgPyAxIDogMDtcblxuICB2YXIgaGkgPSBhaCArIGJoICsgY2ggKyBkaCArIGNhcnJ5O1xuICByZXR1cm4gaGkgPj4+IDA7XG59O1xuZXhwb3J0cy5zdW02NF80X2hpID0gc3VtNjRfNF9oaTtcblxuZnVuY3Rpb24gc3VtNjRfNF9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwpIHtcbiAgdmFyIGxvID0gYWwgKyBibCArIGNsICsgZGw7XG4gIHJldHVybiBsbyA+Pj4gMDtcbn07XG5leHBvcnRzLnN1bTY0XzRfbG8gPSBzdW02NF80X2xvO1xuXG5mdW5jdGlvbiBzdW02NF81X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCwgZWgsIGVsKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBsbyA9IGFsO1xuICBsbyA9IChsbyArIGJsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBhbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGNsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGRsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBkbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGVsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBlbCA/IDEgOiAwO1xuXG4gIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgZWggKyBjYXJyeTtcbiAgcmV0dXJuIGhpID4+PiAwO1xufTtcbmV4cG9ydHMuc3VtNjRfNV9oaSA9IHN1bTY0XzVfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0XzVfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcbiAgdmFyIGxvID0gYWwgKyBibCArIGNsICsgZGwgKyBlbDtcblxuICByZXR1cm4gbG8gPj4+IDA7XG59O1xuZXhwb3J0cy5zdW02NF81X2xvID0gc3VtNjRfNV9sbztcblxuZnVuY3Rpb24gcm90cjY0X2hpKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFsIDw8ICgzMiAtIG51bSkpIHwgKGFoID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn07XG5leHBvcnRzLnJvdHI2NF9oaSA9IHJvdHI2NF9oaTtcblxuZnVuY3Rpb24gcm90cjY0X2xvKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFoIDw8ICgzMiAtIG51bSkpIHwgKGFsID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn07XG5leHBvcnRzLnJvdHI2NF9sbyA9IHJvdHI2NF9sbztcblxuZnVuY3Rpb24gc2hyNjRfaGkoYWgsIGFsLCBudW0pIHtcbiAgcmV0dXJuIGFoID4+PiBudW07XG59O1xuZXhwb3J0cy5zaHI2NF9oaSA9IHNocjY0X2hpO1xuXG5mdW5jdGlvbiBzaHI2NF9sbyhhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhaCA8PCAoMzIgLSBudW0pKSB8IChhbCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59O1xuZXhwb3J0cy5zaHI2NF9sbyA9IHNocjY0X2xvO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hhc2guanMvbGliL2hhc2gvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDIzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnaGFzaC5qcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWNyeXB0by11dGlscycpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gSG1hY0RSQkcob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSG1hY0RSQkcpKVxuICAgIHJldHVybiBuZXcgSG1hY0RSQkcob3B0aW9ucyk7XG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcbiAgdGhpcy5wcmVkUmVzaXN0ID0gISFvcHRpb25zLnByZWRSZXNpc3Q7XG5cbiAgdGhpcy5vdXRMZW4gPSB0aGlzLmhhc2gub3V0U2l6ZTtcbiAgdGhpcy5taW5FbnRyb3B5ID0gb3B0aW9ucy5taW5FbnRyb3B5IHx8IHRoaXMuaGFzaC5obWFjU3RyZW5ndGg7XG5cbiAgdGhpcy5fcmVzZWVkID0gbnVsbDtcbiAgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IG51bGw7XG4gIHRoaXMuSyA9IG51bGw7XG4gIHRoaXMuViA9IG51bGw7XG5cbiAgdmFyIGVudHJvcHkgPSB1dGlscy50b0FycmF5KG9wdGlvbnMuZW50cm9weSwgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICdoZXgnKTtcbiAgdmFyIG5vbmNlID0gdXRpbHMudG9BcnJheShvcHRpb25zLm5vbmNlLCBvcHRpb25zLm5vbmNlRW5jIHx8ICdoZXgnKTtcbiAgdmFyIHBlcnMgPSB1dGlscy50b0FycmF5KG9wdGlvbnMucGVycywgb3B0aW9ucy5wZXJzRW5jIHx8ICdoZXgnKTtcbiAgYXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcbiAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcbiAgdGhpcy5faW5pdChlbnRyb3B5LCBub25jZSwgcGVycyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEhtYWNEUkJHO1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKSB7XG4gIHZhciBzZWVkID0gZW50cm9weS5jb25jYXQobm9uY2UpLmNvbmNhdChwZXJzKTtcblxuICB0aGlzLksgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcbiAgdGhpcy5WID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5WLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5LW2ldID0gMHgwMDtcbiAgICB0aGlzLlZbaV0gPSAweDAxO1xuICB9XG5cbiAgdGhpcy5fdXBkYXRlKHNlZWQpO1xuICB0aGlzLl9yZXNlZWQgPSAxO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gMHgxMDAwMDAwMDAwMDAwOyAgLy8gMl40OFxufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl9obWFjID0gZnVuY3Rpb24gaG1hYygpIHtcbiAgcmV0dXJuIG5ldyBoYXNoLmhtYWModGhpcy5oYXNoLCB0aGlzLkspO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2VlZCkge1xuICB2YXIga21hYyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcbiAgICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDAgXSk7XG4gIGlmIChzZWVkKVxuICAgIGttYWMgPSBrbWFjLnVwZGF0ZShzZWVkKTtcbiAgdGhpcy5LID0ga21hYy5kaWdlc3QoKTtcbiAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuICBpZiAoIXNlZWQpXG4gICAgcmV0dXJuO1xuXG4gIHRoaXMuSyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG4gICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMSBdKVxuICAgICAgICAgICAgICAgLnVwZGF0ZShzZWVkKVxuICAgICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUucmVzZWVkID0gZnVuY3Rpb24gcmVzZWVkKGVudHJvcHksIGVudHJvcHlFbmMsIGFkZCwgYWRkRW5jKSB7XG4gIC8vIE9wdGlvbmFsIGVudHJvcHkgZW5jXG4gIGlmICh0eXBlb2YgZW50cm9weUVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW50cm9weUVuYztcbiAgICBlbnRyb3B5RW5jID0gbnVsbDtcbiAgfVxuXG4gIGVudHJvcHkgPSB1dGlscy50b0FycmF5KGVudHJvcHksIGVudHJvcHlFbmMpO1xuICBhZGQgPSB1dGlscy50b0FycmF5KGFkZCwgYWRkRW5jKTtcblxuICBhc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuXG4gIHRoaXMuX3VwZGF0ZShlbnRyb3B5LmNvbmNhdChhZGQgfHwgW10pKTtcbiAgdGhpcy5fcmVzZWVkID0gMTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKGxlbiwgZW5jLCBhZGQsIGFkZEVuYykge1xuICBpZiAodGhpcy5fcmVzZWVkID4gdGhpcy5yZXNlZWRJbnRlcnZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2VlZCBpcyByZXF1aXJlZCcpO1xuXG4gIC8vIE9wdGlvbmFsIGVuY29kaW5nXG4gIGlmICh0eXBlb2YgZW5jICE9PSAnc3RyaW5nJykge1xuICAgIGFkZEVuYyA9IGFkZDtcbiAgICBhZGQgPSBlbmM7XG4gICAgZW5jID0gbnVsbDtcbiAgfVxuXG4gIC8vIE9wdGlvbmFsIGFkZGl0aW9uYWwgZGF0YVxuICBpZiAoYWRkKSB7XG4gICAgYWRkID0gdXRpbHMudG9BcnJheShhZGQsIGFkZEVuYyB8fCAnaGV4Jyk7XG4gICAgdGhpcy5fdXBkYXRlKGFkZCk7XG4gIH1cblxuICB2YXIgdGVtcCA9IFtdO1xuICB3aGlsZSAodGVtcC5sZW5ndGggPCBsZW4pIHtcbiAgICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG4gICAgdGVtcCA9IHRlbXAuY29uY2F0KHRoaXMuVik7XG4gIH1cblxuICB2YXIgcmVzID0gdGVtcC5zbGljZSgwLCBsZW4pO1xuICB0aGlzLl91cGRhdGUoYWRkKTtcbiAgdGhpcy5fcmVzZWVkKys7XG4gIHJldHVybiB1dGlscy5lbmNvZGUocmVzLCBlbmMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9obWFjLWRyYmcvbGliL2htYWMtZHJiZy5qc1xuLy8gbW9kdWxlIGlkID0gMjM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2llZWU3NTQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2luZGV4b2YvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS4xXCI6IFwiYWVzLTEyOC1lY2JcIixcblx0XCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS4yXCI6IFwiYWVzLTEyOC1jYmNcIixcblx0XCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS4zXCI6IFwiYWVzLTEyOC1vZmJcIixcblx0XCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS40XCI6IFwiYWVzLTEyOC1jZmJcIixcblx0XCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS4yMVwiOiBcImFlcy0xOTItZWNiXCIsXG5cdFwiMi4xNi44NDAuMS4xMDEuMy40LjEuMjJcIjogXCJhZXMtMTkyLWNiY1wiLFxuXHRcIjIuMTYuODQwLjEuMTAxLjMuNC4xLjIzXCI6IFwiYWVzLTE5Mi1vZmJcIixcblx0XCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS4yNFwiOiBcImFlcy0xOTItY2ZiXCIsXG5cdFwiMi4xNi44NDAuMS4xMDEuMy40LjEuNDFcIjogXCJhZXMtMjU2LWVjYlwiLFxuXHRcIjIuMTYuODQwLjEuMTAxLjMuNC4xLjQyXCI6IFwiYWVzLTI1Ni1jYmNcIixcblx0XCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS40M1wiOiBcImFlcy0yNTYtb2ZiXCIsXG5cdFwiMi4xNi44NDAuMS4xMDEuMy40LjEuNDRcIjogXCJhZXMtMjU2LWNmYlwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZS1hc24xL2Flc2lkLmpzb25cbi8vIG1vZHVsZSBpZCA9IDI0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L3NlbGYtc2lnbmVkL2Jsb2IvZ2gtcGFnZXMvbGliL2FzbjEuanNcbi8vIEZlZG9yLCB5b3UgYXJlIGFtYXppbmcuXG4ndXNlIHN0cmljdCdcblxudmFyIGFzbjEgPSByZXF1aXJlKCdhc24xLmpzJylcblxuZXhwb3J0cy5jZXJ0aWZpY2F0ZSA9IHJlcXVpcmUoJy4vY2VydGlmaWNhdGUnKVxuXG52YXIgUlNBUHJpdmF0ZUtleSA9IGFzbjEuZGVmaW5lKCdSU0FQcml2YXRlS2V5JywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgIHRoaXMua2V5KCdtb2R1bHVzJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3B1YmxpY0V4cG9uZW50JykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaXZhdGVFeHBvbmVudCcpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcmltZTEnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpbWUyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2V4cG9uZW50MScpLmludCgpLFxuICAgIHRoaXMua2V5KCdleHBvbmVudDInKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnY29lZmZpY2llbnQnKS5pbnQoKVxuICApXG59KVxuZXhwb3J0cy5SU0FQcml2YXRlS2V5ID0gUlNBUHJpdmF0ZUtleVxuXG52YXIgUlNBUHVibGljS2V5ID0gYXNuMS5kZWZpbmUoJ1JTQVB1YmxpY0tleScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ21vZHVsdXMnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHVibGljRXhwb25lbnQnKS5pbnQoKVxuICApXG59KVxuZXhwb3J0cy5SU0FQdWJsaWNLZXkgPSBSU0FQdWJsaWNLZXlcblxudmFyIFB1YmxpY0tleSA9IGFzbjEuZGVmaW5lKCdTdWJqZWN0UHVibGljS2V5SW5mbycsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFB1YmxpY0tleScpLmJpdHN0cigpXG4gIClcbn0pXG5leHBvcnRzLlB1YmxpY0tleSA9IFB1YmxpY0tleVxuXG52YXIgQWxnb3JpdGhtSWRlbnRpZmllciA9IGFzbjEuZGVmaW5lKCdBbGdvcml0aG1JZGVudGlmaWVyJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnYWxnb3JpdGhtJykub2JqaWQoKSxcbiAgICB0aGlzLmtleSgnbm9uZScpLm51bGxfKCkub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgnY3VydmUnKS5vYmppZCgpLm9wdGlvbmFsKCksXG4gICAgdGhpcy5rZXkoJ3BhcmFtcycpLnNlcSgpLm9iaihcbiAgICAgIHRoaXMua2V5KCdwJykuaW50KCksXG4gICAgICB0aGlzLmtleSgncScpLmludCgpLFxuICAgICAgdGhpcy5rZXkoJ2cnKS5pbnQoKVxuICAgICkub3B0aW9uYWwoKVxuICApXG59KVxuXG52YXIgUHJpdmF0ZUtleUluZm8gPSBhc24xLmRlZmluZSgnUHJpdmF0ZUtleUluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFByaXZhdGVLZXknKS5vY3RzdHIoKVxuICApXG59KVxuZXhwb3J0cy5Qcml2YXRlS2V5ID0gUHJpdmF0ZUtleUluZm9cbnZhciBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyA9IGFzbjEuZGVmaW5lKCdFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbycsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnNlcSgpLm9iaihcbiAgICAgIHRoaXMua2V5KCdpZCcpLm9iamlkKCksXG4gICAgICB0aGlzLmtleSgnZGVjcnlwdCcpLnNlcSgpLm9iaihcbiAgICAgICAgdGhpcy5rZXkoJ2tkZScpLnNlcSgpLm9iaihcbiAgICAgICAgICB0aGlzLmtleSgnaWQnKS5vYmppZCgpLFxuICAgICAgICAgIHRoaXMua2V5KCdrZGVwYXJhbXMnKS5zZXEoKS5vYmooXG4gICAgICAgICAgICB0aGlzLmtleSgnc2FsdCcpLm9jdHN0cigpLFxuICAgICAgICAgICAgdGhpcy5rZXkoJ2l0ZXJzJykuaW50KClcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIHRoaXMua2V5KCdjaXBoZXInKS5zZXEoKS5vYmooXG4gICAgICAgICAgdGhpcy5rZXkoJ2FsZ28nKS5vYmppZCgpLFxuICAgICAgICAgIHRoaXMua2V5KCdpdicpLm9jdHN0cigpXG4gICAgICAgIClcbiAgICAgIClcbiAgICApLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0UHJpdmF0ZUtleScpLm9jdHN0cigpXG4gIClcbn0pXG5cbmV4cG9ydHMuRW5jcnlwdGVkUHJpdmF0ZUtleSA9IEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvXG5cbnZhciBEU0FQcml2YXRlS2V5ID0gYXNuMS5kZWZpbmUoJ0RTQVByaXZhdGVLZXknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3AnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncScpLmludCgpLFxuICAgIHRoaXMua2V5KCdnJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3B1Yl9rZXknKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpdl9rZXknKS5pbnQoKVxuICApXG59KVxuZXhwb3J0cy5EU0FQcml2YXRlS2V5ID0gRFNBUHJpdmF0ZUtleVxuXG5leHBvcnRzLkRTQXBhcmFtID0gYXNuMS5kZWZpbmUoJ0RTQXBhcmFtJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLmludCgpXG59KVxuXG52YXIgRUNQcml2YXRlS2V5ID0gYXNuMS5kZWZpbmUoJ0VDUHJpdmF0ZUtleScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpdmF0ZUtleScpLm9jdHN0cigpLFxuICAgIHRoaXMua2V5KCdwYXJhbWV0ZXJzJykub3B0aW9uYWwoKS5leHBsaWNpdCgwKS51c2UoRUNQYXJhbWV0ZXJzKSxcbiAgICB0aGlzLmtleSgncHVibGljS2V5Jykub3B0aW9uYWwoKS5leHBsaWNpdCgxKS5iaXRzdHIoKVxuICApXG59KVxuZXhwb3J0cy5FQ1ByaXZhdGVLZXkgPSBFQ1ByaXZhdGVLZXlcblxudmFyIEVDUGFyYW1ldGVycyA9IGFzbjEuZGVmaW5lKCdFQ1BhcmFtZXRlcnMnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2hvaWNlKHtcbiAgICBuYW1lZEN1cnZlOiB0aGlzLm9iamlkKClcbiAgfSlcbn0pXG5cbmV4cG9ydHMuc2lnbmF0dXJlID0gYXNuMS5kZWZpbmUoJ3NpZ25hdHVyZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3InKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncycpLmludCgpXG4gIClcbn0pXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFyc2UtYXNuMS9hc24xLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vUmFudGFuZW4vbm9kZS1kdGxzL2Jsb2IvMjVhN2RjODYxYmRhMzhjZmVhYzkzYTcyMzUwMGVlYTRmMGFjMmU4Ni9DZXJ0aWZpY2F0ZS5qc1xuLy8gdGhhbmtzIHRvIEBSYW50YW5lblxuXG4ndXNlIHN0cmljdCdcblxudmFyIGFzbiA9IHJlcXVpcmUoJ2FzbjEuanMnKVxuXG52YXIgVGltZSA9IGFzbi5kZWZpbmUoJ1RpbWUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2hvaWNlKHtcbiAgICB1dGNUaW1lOiB0aGlzLnV0Y3RpbWUoKSxcbiAgICBnZW5lcmFsVGltZTogdGhpcy5nZW50aW1lKClcbiAgfSlcbn0pXG5cbnZhciBBdHRyaWJ1dGVUeXBlVmFsdWUgPSBhc24uZGVmaW5lKCdBdHRyaWJ1dGVUeXBlVmFsdWUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd0eXBlJykub2JqaWQoKSxcbiAgICB0aGlzLmtleSgndmFsdWUnKS5hbnkoKVxuICApXG59KVxuXG52YXIgQWxnb3JpdGhtSWRlbnRpZmllciA9IGFzbi5kZWZpbmUoJ0FsZ29yaXRobUlkZW50aWZpZXInLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS5vYmppZCgpLFxuICAgIHRoaXMua2V5KCdwYXJhbWV0ZXJzJykub3B0aW9uYWwoKVxuICApXG59KVxuXG52YXIgU3ViamVjdFB1YmxpY0tleUluZm8gPSBhc24uZGVmaW5lKCdTdWJqZWN0UHVibGljS2V5SW5mbycsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFB1YmxpY0tleScpLmJpdHN0cigpXG4gIClcbn0pXG5cbnZhciBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lID0gYXNuLmRlZmluZSgnUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXRvZihBdHRyaWJ1dGVUeXBlVmFsdWUpXG59KVxuXG52YXIgUkROU2VxdWVuY2UgPSBhc24uZGVmaW5lKCdSRE5TZXF1ZW5jZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXFvZihSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lKVxufSlcblxudmFyIE5hbWUgPSBhc24uZGVmaW5lKCdOYW1lJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLmNob2ljZSh7XG4gICAgcmRuU2VxdWVuY2U6IHRoaXMudXNlKFJETlNlcXVlbmNlKVxuICB9KVxufSlcblxudmFyIFZhbGlkaXR5ID0gYXNuLmRlZmluZSgnVmFsaWRpdHknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdub3RCZWZvcmUnKS51c2UoVGltZSksXG4gICAgdGhpcy5rZXkoJ25vdEFmdGVyJykudXNlKFRpbWUpXG4gIClcbn0pXG5cbnZhciBFeHRlbnNpb24gPSBhc24uZGVmaW5lKCdFeHRlbnNpb24nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdleHRuSUQnKS5vYmppZCgpLFxuICAgIHRoaXMua2V5KCdjcml0aWNhbCcpLmJvb2woKS5kZWYoZmFsc2UpLFxuICAgIHRoaXMua2V5KCdleHRuVmFsdWUnKS5vY3RzdHIoKVxuICApXG59KVxuXG52YXIgVEJTQ2VydGlmaWNhdGUgPSBhc24uZGVmaW5lKCdUQlNDZXJ0aWZpY2F0ZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5leHBsaWNpdCgwKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnc2VyaWFsTnVtYmVyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3NpZ25hdHVyZScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnaXNzdWVyJykudXNlKE5hbWUpLFxuICAgIHRoaXMua2V5KCd2YWxpZGl0eScpLnVzZShWYWxpZGl0eSksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3QnKS51c2UoTmFtZSksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQdWJsaWNLZXlJbmZvJykudXNlKFN1YmplY3RQdWJsaWNLZXlJbmZvKSxcbiAgICB0aGlzLmtleSgnaXNzdWVyVW5pcXVlSUQnKS5pbXBsaWNpdCgxKS5iaXRzdHIoKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0VW5pcXVlSUQnKS5pbXBsaWNpdCgyKS5iaXRzdHIoKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdleHRlbnNpb25zJykuZXhwbGljaXQoMykuc2Vxb2YoRXh0ZW5zaW9uKS5vcHRpb25hbCgpXG4gIClcbn0pXG5cbnZhciBYNTA5Q2VydGlmaWNhdGUgPSBhc24uZGVmaW5lKCdYNTA5Q2VydGlmaWNhdGUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd0YnNDZXJ0aWZpY2F0ZScpLnVzZShUQlNDZXJ0aWZpY2F0ZSksXG4gICAgdGhpcy5rZXkoJ3NpZ25hdHVyZUFsZ29yaXRobScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnc2lnbmF0dXJlVmFsdWUnKS5iaXRzdHIoKVxuICApXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IFg1MDlDZXJ0aWZpY2F0ZVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlLWFzbjEvY2VydGlmaWNhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDI0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FwYXRpbC9wZW1zdHJpcFxudmFyIGZpbmRQcm9jID0gL1Byb2MtVHlwZTogNCxFTkNSWVBURURcXG5cXHI/REVLLUluZm86IEFFUy0oKD86MTI4KXwoPzoxOTIpfCg/OjI1NikpLUNCQywoWzAtOUEtSF0rKVxcblxccj9cXG5cXHI/KFswLTlBLXpcXG5cXHJcXCtcXC9cXD1dKylcXG5cXHI/L21cbnZhciBzdGFydFJlZ2V4ID0gL14tLS0tLUJFR0lOICgoPzouKiBLRVkpfENFUlRJRklDQVRFKS0tLS0tXFxuL21cbnZhciBmdWxsUmVnZXggPSAvXi0tLS0tQkVHSU4gKCg/Oi4qIEtFWSl8Q0VSVElGSUNBVEUpLS0tLS1cXG5cXHI/KFswLTlBLXpcXG5cXHJcXCtcXC9cXD1dKylcXG5cXHI/LS0tLS1FTkQgXFwxLS0tLS0kL21cbnZhciBldnAgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG52YXIgY2lwaGVycyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzJylcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9rZXksIHBhc3N3b3JkKSB7XG4gIHZhciBrZXkgPSBva2V5LnRvU3RyaW5nKClcbiAgdmFyIG1hdGNoID0ga2V5Lm1hdGNoKGZpbmRQcm9jKVxuICB2YXIgZGVjcnlwdGVkXG4gIGlmICghbWF0Y2gpIHtcbiAgICB2YXIgbWF0Y2gyID0ga2V5Lm1hdGNoKGZ1bGxSZWdleClcbiAgICBkZWNyeXB0ZWQgPSBuZXcgQnVmZmVyKG1hdGNoMlsyXS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKSwgJ2Jhc2U2NCcpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN1aXRlID0gJ2FlcycgKyBtYXRjaFsxXVxuICAgIHZhciBpdiA9IG5ldyBCdWZmZXIobWF0Y2hbMl0sICdoZXgnKVxuICAgIHZhciBjaXBoZXJUZXh0ID0gbmV3IEJ1ZmZlcihtYXRjaFszXS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKSwgJ2Jhc2U2NCcpXG4gICAgdmFyIGNpcGhlcktleSA9IGV2cChwYXNzd29yZCwgaXYuc2xpY2UoMCwgOCksIHBhcnNlSW50KG1hdGNoWzFdLCAxMCkpLmtleVxuICAgIHZhciBvdXQgPSBbXVxuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJzLmNyZWF0ZURlY2lwaGVyaXYoc3VpdGUsIGNpcGhlcktleSwgaXYpXG4gICAgb3V0LnB1c2goY2lwaGVyLnVwZGF0ZShjaXBoZXJUZXh0KSlcbiAgICBvdXQucHVzaChjaXBoZXIuZmluYWwoKSlcbiAgICBkZWNyeXB0ZWQgPSBCdWZmZXIuY29uY2F0KG91dClcbiAgfVxuICB2YXIgdGFnID0ga2V5Lm1hdGNoKHN0YXJ0UmVnZXgpWzFdXG4gIHJldHVybiB7XG4gICAgdGFnOiB0YWcsXG4gICAgZGF0YTogZGVjcnlwdGVkXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXJzZS1hc24xL2ZpeFByb2MuanNcbi8vIG1vZHVsZSBpZCA9IDI0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUFYX0FMTE9DID0gTWF0aC5wb3coMiwgMzApIC0gMSAvLyBkZWZhdWx0IGluIGlvanNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdGlvbnMsIGtleWxlbikge1xuICBpZiAodHlwZW9mIGl0ZXJhdGlvbnMgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSXRlcmF0aW9ucyBub3QgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGl0ZXJhdGlvbnMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIGl0ZXJhdGlvbnMnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBrZXlsZW4gIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignS2V5IGxlbmd0aCBub3QgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGtleWxlbiA8IDAgfHwga2V5bGVuID4gTUFYX0FMTE9DIHx8IGtleWxlbiAhPT0ga2V5bGVuKSB7IC8qIGVzbGludCBuby1zZWxmLWNvbXBhcmU6IDAgKi9cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQga2V5IGxlbmd0aCcpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYmtkZjIvcHJlY29uZGl0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5wdWJsaWNFbmNyeXB0ID0gcmVxdWlyZSgnLi9wdWJsaWNFbmNyeXB0Jyk7XG5leHBvcnRzLnByaXZhdGVEZWNyeXB0ID0gcmVxdWlyZSgnLi9wcml2YXRlRGVjcnlwdCcpO1xuXG5leHBvcnRzLnByaXZhdGVFbmNyeXB0ID0gZnVuY3Rpb24gcHJpdmF0ZUVuY3J5cHQoa2V5LCBidWYpIHtcbiAgcmV0dXJuIGV4cG9ydHMucHVibGljRW5jcnlwdChrZXksIGJ1ZiwgdHJ1ZSk7XG59O1xuXG5leHBvcnRzLnB1YmxpY0RlY3J5cHQgPSBmdW5jdGlvbiBwdWJsaWNEZWNyeXB0KGtleSwgYnVmKSB7XG4gIHJldHVybiBleHBvcnRzLnByaXZhdGVEZWNyeXB0KGtleSwgYnVmLCB0cnVlKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3B1YmxpYy1lbmNyeXB0L2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpO1xudmFyIG1nZiA9IHJlcXVpcmUoJy4vbWdmJyk7XG52YXIgeG9yID0gcmVxdWlyZSgnLi94b3InKTtcbnZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgY3J0ID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1yc2EnKTtcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbnZhciB3aXRoUHVibGljID0gcmVxdWlyZSgnLi93aXRoUHVibGljJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHByaXZhdGVEZWNyeXB0KHByaXZhdGVfa2V5LCBlbmMsIHJldmVyc2UpIHtcbiAgdmFyIHBhZGRpbmc7XG4gIGlmIChwcml2YXRlX2tleS5wYWRkaW5nKSB7XG4gICAgcGFkZGluZyA9IHByaXZhdGVfa2V5LnBhZGRpbmc7XG4gIH0gZWxzZSBpZiAocmV2ZXJzZSkge1xuICAgIHBhZGRpbmcgPSAxO1xuICB9IGVsc2Uge1xuICAgIHBhZGRpbmcgPSA0O1xuICB9XG4gIFxuICB2YXIga2V5ID0gcGFyc2VLZXlzKHByaXZhdGVfa2V5KTtcbiAgdmFyIGsgPSBrZXkubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIGlmIChlbmMubGVuZ3RoID4gayB8fCBuZXcgYm4oZW5jKS5jbXAoa2V5Lm1vZHVsdXMpID49IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKTtcbiAgfVxuICB2YXIgbXNnO1xuICBpZiAocmV2ZXJzZSkge1xuICAgIG1zZyA9IHdpdGhQdWJsaWMobmV3IGJuKGVuYyksIGtleSk7XG4gIH0gZWxzZSB7XG4gICAgbXNnID0gY3J0KGVuYywga2V5KTtcbiAgfVxuICB2YXIgekJ1ZmZlciA9IG5ldyBCdWZmZXIoayAtIG1zZy5sZW5ndGgpO1xuICB6QnVmZmVyLmZpbGwoMCk7XG4gIG1zZyA9IEJ1ZmZlci5jb25jYXQoW3pCdWZmZXIsIG1zZ10sIGspO1xuICBpZiAocGFkZGluZyA9PT0gNCkge1xuICAgIHJldHVybiBvYWVwKGtleSwgbXNnKTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSAxKSB7XG4gICAgcmV0dXJuIHBrY3MxKGtleSwgbXNnLCByZXZlcnNlKTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSAzKSB7XG4gICAgcmV0dXJuIG1zZztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gcGFkZGluZycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvYWVwKGtleSwgbXNnKXtcbiAgdmFyIG4gPSBrZXkubW9kdWx1cztcbiAgdmFyIGsgPSBrZXkubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciBtTGVuID0gbXNnLmxlbmd0aDtcbiAgdmFyIGlIYXNoID0gY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShuZXcgQnVmZmVyKCcnKSkuZGlnZXN0KCk7XG4gIHZhciBoTGVuID0gaUhhc2gubGVuZ3RoO1xuICB2YXIgaExlbjIgPSAyICogaExlbjtcbiAgaWYgKG1zZ1swXSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpO1xuICB9XG4gIHZhciBtYXNrZWRTZWVkID0gbXNnLnNsaWNlKDEsIGhMZW4gKyAxKTtcbiAgdmFyIG1hc2tlZERiID0gIG1zZy5zbGljZShoTGVuICsgMSk7XG4gIHZhciBzZWVkID0geG9yKG1hc2tlZFNlZWQsIG1nZihtYXNrZWREYiwgaExlbikpO1xuICB2YXIgZGIgPSB4b3IobWFza2VkRGIsIG1nZihzZWVkLCBrIC0gaExlbiAtIDEpKTtcbiAgaWYgKGNvbXBhcmUoaUhhc2gsIGRiLnNsaWNlKDAsIGhMZW4pKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpO1xuICB9XG4gIHZhciBpID0gaExlbjtcbiAgd2hpbGUgKGRiW2ldID09PSAwKSB7XG4gICAgaSsrO1xuICB9XG4gIGlmIChkYltpKytdICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJyk7XG4gIH1cbiAgcmV0dXJuIGRiLnNsaWNlKGkpO1xufVxuXG5mdW5jdGlvbiBwa2NzMShrZXksIG1zZywgcmV2ZXJzZSl7XG4gIHZhciBwMSA9IG1zZy5zbGljZSgwLCAyKTtcbiAgdmFyIGkgPSAyO1xuICB2YXIgc3RhdHVzID0gMDtcbiAgd2hpbGUgKG1zZ1tpKytdICE9PSAwKSB7XG4gICAgaWYgKGkgPj0gbXNnLmxlbmd0aCkge1xuICAgICAgc3RhdHVzKys7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIHBzID0gbXNnLnNsaWNlKDIsIGkgLSAxKTtcbiAgdmFyIHAyID0gbXNnLnNsaWNlKGkgLSAxLCBpKTtcblxuICBpZiAoKHAxLnRvU3RyaW5nKCdoZXgnKSAhPT0gJzAwMDInICYmICFyZXZlcnNlKSB8fCAocDEudG9TdHJpbmcoJ2hleCcpICE9PSAnMDAwMScgJiYgcmV2ZXJzZSkpe1xuICAgIHN0YXR1cysrO1xuICB9XG4gIGlmIChwcy5sZW5ndGggPCA4KSB7XG4gICAgc3RhdHVzKys7XG4gIH1cbiAgaWYgKHN0YXR1cykge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpO1xuICB9XG4gIHJldHVybiAgbXNnLnNsaWNlKGkpO1xufVxuZnVuY3Rpb24gY29tcGFyZShhLCBiKXtcbiAgYSA9IG5ldyBCdWZmZXIoYSk7XG4gIGIgPSBuZXcgQnVmZmVyKGIpO1xuICB2YXIgZGlmID0gMDtcbiAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgZGlmKys7XG4gICAgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgfVxuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgZGlmICs9IChhW2ldIF4gYltpXSk7XG4gIH1cbiAgcmV0dXJuIGRpZjtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHVibGljLWVuY3J5cHQvcHJpdmF0ZURlY3J5cHQuanNcbi8vIG1vZHVsZSBpZCA9IDI0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpO1xudmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbnZhciBtZ2YgPSByZXF1aXJlKCcuL21nZicpO1xudmFyIHhvciA9IHJlcXVpcmUoJy4veG9yJyk7XG52YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIHdpdGhQdWJsaWMgPSByZXF1aXJlKCcuL3dpdGhQdWJsaWMnKTtcbnZhciBjcnQgPSByZXF1aXJlKCdicm93c2VyaWZ5LXJzYScpO1xuXG52YXIgY29uc3RhbnRzID0ge1xuICBSU0FfUEtDUzFfT0FFUF9QQURESU5HOiA0LFxuICBSU0FfUEtDUzFfUEFERElOOiAxLFxuICBSU0FfTk9fUEFERElORzogM1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwdWJsaWNFbmNyeXB0KHB1YmxpY19rZXksIG1zZywgcmV2ZXJzZSkge1xuICB2YXIgcGFkZGluZztcbiAgaWYgKHB1YmxpY19rZXkucGFkZGluZykge1xuICAgIHBhZGRpbmcgPSBwdWJsaWNfa2V5LnBhZGRpbmc7XG4gIH0gZWxzZSBpZiAocmV2ZXJzZSkge1xuICAgIHBhZGRpbmcgPSAxO1xuICB9IGVsc2Uge1xuICAgIHBhZGRpbmcgPSA0O1xuICB9XG4gIHZhciBrZXkgPSBwYXJzZUtleXMocHVibGljX2tleSk7XG4gIHZhciBwYWRkZWRNc2c7XG4gIGlmIChwYWRkaW5nID09PSA0KSB7XG4gICAgcGFkZGVkTXNnID0gb2FlcChrZXksIG1zZyk7XG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMSkge1xuICAgIHBhZGRlZE1zZyA9IHBrY3MxKGtleSwgbXNnLCByZXZlcnNlKTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSAzKSB7XG4gICAgcGFkZGVkTXNnID0gbmV3IGJuKG1zZyk7XG4gICAgaWYgKHBhZGRlZE1zZy5jbXAoa2V5Lm1vZHVsdXMpID49IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGF0YSB0b28gbG9uZyBmb3IgbW9kdWx1cycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gcGFkZGluZycpO1xuICB9XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgcmV0dXJuIGNydChwYWRkZWRNc2csIGtleSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdpdGhQdWJsaWMocGFkZGVkTXNnLCBrZXkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvYWVwKGtleSwgbXNnKXtcbiAgdmFyIGsgPSBrZXkubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciBtTGVuID0gbXNnLmxlbmd0aDtcbiAgdmFyIGlIYXNoID0gY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShuZXcgQnVmZmVyKCcnKSkuZGlnZXN0KCk7XG4gIHZhciBoTGVuID0gaUhhc2gubGVuZ3RoO1xuICB2YXIgaExlbjIgPSAyICogaExlbjtcbiAgaWYgKG1MZW4gPiBrIC0gaExlbjIgLSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtZXNzYWdlIHRvbyBsb25nJyk7XG4gIH1cbiAgdmFyIHBzID0gbmV3IEJ1ZmZlcihrIC0gbUxlbiAtIGhMZW4yIC0gMik7XG4gIHBzLmZpbGwoMCk7XG4gIHZhciBkYmxlbiA9IGsgLSBoTGVuIC0gMTtcbiAgdmFyIHNlZWQgPSByYW5kb21CeXRlcyhoTGVuKTtcbiAgdmFyIG1hc2tlZERiID0geG9yKEJ1ZmZlci5jb25jYXQoW2lIYXNoLCBwcywgbmV3IEJ1ZmZlcihbMV0pLCBtc2ddLCBkYmxlbiksIG1nZihzZWVkLCBkYmxlbikpO1xuICB2YXIgbWFza2VkU2VlZCA9IHhvcihzZWVkLCBtZ2YobWFza2VkRGIsIGhMZW4pKTtcbiAgcmV0dXJuIG5ldyBibihCdWZmZXIuY29uY2F0KFtuZXcgQnVmZmVyKFswXSksIG1hc2tlZFNlZWQsIG1hc2tlZERiXSwgaykpO1xufVxuZnVuY3Rpb24gcGtjczEoa2V5LCBtc2csIHJldmVyc2Upe1xuICB2YXIgbUxlbiA9IG1zZy5sZW5ndGg7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICBpZiAobUxlbiA+IGsgLSAxMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZSB0b28gbG9uZycpO1xuICB9XG4gIHZhciBwcztcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBwcyA9IG5ldyBCdWZmZXIoayAtIG1MZW4gLSAzKTtcbiAgICBwcy5maWxsKDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIHBzID0gbm9uWmVybyhrIC0gbUxlbiAtIDMpO1xuICB9XG4gIHJldHVybiBuZXcgYm4oQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbMCwgcmV2ZXJzZT8xOjJdKSwgcHMsIG5ldyBCdWZmZXIoWzBdKSwgbXNnXSwgaykpO1xufVxuZnVuY3Rpb24gbm9uWmVybyhsZW4sIGNyeXB0bykge1xuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihsZW4pO1xuICB2YXIgaSA9IDA7XG4gIHZhciBjYWNoZSA9IHJhbmRvbUJ5dGVzKGxlbioyKTtcbiAgdmFyIGN1ciA9IDA7XG4gIHZhciBudW07XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKGN1ciA9PT0gY2FjaGUubGVuZ3RoKSB7XG4gICAgICBjYWNoZSA9IHJhbmRvbUJ5dGVzKGxlbioyKTtcbiAgICAgIGN1ciA9IDA7XG4gICAgfVxuICAgIG51bSA9IGNhY2hlW2N1cisrXTtcbiAgICBpZiAobnVtKSB7XG4gICAgICBvdXRbaSsrXSA9IG51bTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHVibGljLWVuY3J5cHQvcHVibGljRW5jcnlwdC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCIpXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qc1xuLy8gbW9kdWxlIGlkID0gMjUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyTGlzdDtcblxuZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgdGhpcy5oZWFkID0gbnVsbDtcbiAgdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5sZW5ndGggPSAwO1xufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHYpIHtcbiAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgdGhpcy50YWlsID0gZW50cnk7XG4gICsrdGhpcy5sZW5ndGg7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKHYpIHtcbiAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgdGhpcy5oZWFkID0gZW50cnk7XG4gICsrdGhpcy5sZW5ndGg7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gIC0tdGhpcy5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5sZW5ndGggPSAwO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIChzKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHJldCArPSBzICsgcC5kYXRhO1xuICB9cmV0dXJuIHJldDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIChuKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGJ1ZmZlclNoaW0uYWxsb2MoMCk7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICB2YXIgcmV0ID0gYnVmZmVyU2hpbS5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKHApIHtcbiAgICBwLmRhdGEuY29weShyZXQsIGkpO1xuICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICBwID0gcC5uZXh0O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gMjUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcIilcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanNcbi8vIG1vZHVsZSBpZCA9IDI1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3RyZWFtID0gKGZ1bmN0aW9uICgpe1xuICB0cnkge1xuICAgIHJldHVybiByZXF1aXJlKCdzdCcgKyAncmVhbScpOyAvLyBoYWNrIHRvIGZpeCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgaXNzdWUgd2hlbiB1c2VkIHdpdGggYnJvd3NlcmlmeVxuICB9IGNhdGNoKF8pe31cbn0oKSk7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbSB8fCBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcblxuaWYgKCFwcm9jZXNzLmJyb3dzZXIgJiYgcHJvY2Vzcy5lbnYuUkVBREFCTEVfU1RSRUFNID09PSAnZGlzYWJsZScgJiYgU3RyZWFtKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCIpXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qc1xuLy8gbW9kdWxlIGlkID0gMjU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIilcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDI1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPVxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXM7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzXG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMjU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5DcnlwdG9KUyB2My4xLjJcbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4qL1xuLyoqIEBwcmVzZXJ2ZVxuKGMpIDIwMTIgYnkgQ8OpZHJpYyBNZXNuaWwuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4vLyBjb25zdGFudHMgdGFibGVcbnZhciB6bCA9IFtcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbiAgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMixcbiAgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMixcbiAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuXVxuXG52YXIgenIgPSBbXG4gIDUsIDE0LCA3LCAwLCA5LCAyLCAxMSwgNCwgMTMsIDYsIDE1LCA4LCAxLCAxMCwgMywgMTIsXG4gIDYsIDExLCAzLCA3LCAwLCAxMywgNSwgMTAsIDE0LCAxNSwgOCwgMTIsIDQsIDksIDEsIDIsXG4gIDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTMsXG4gIDgsIDYsIDQsIDEsIDMsIDExLCAxNSwgMCwgNSwgMTIsIDIsIDEzLCA5LCA3LCAxMCwgMTQsXG4gIDEyLCAxNSwgMTAsIDQsIDEsIDUsIDgsIDcsIDYsIDIsIDEzLCAxNCwgMCwgMywgOSwgMTFcbl1cblxudmFyIHNsID0gW1xuICAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsXG4gIDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMixcbiAgMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1LFxuICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsXG4gIDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNlxuXVxuXG52YXIgc3IgPSBbXG4gIDgsIDksIDksIDExLCAxMywgMTUsIDE1LCA1LCA3LCA3LCA4LCAxMSwgMTQsIDE0LCAxMiwgNixcbiAgOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExLFxuICA5LCA3LCAxNSwgMTEsIDgsIDYsIDYsIDE0LCAxMiwgMTMsIDUsIDE0LCAxMywgMTMsIDcsIDUsXG4gIDE1LCA1LCA4LCAxMSwgMTQsIDE0LCA2LCAxNCwgNiwgOSwgMTIsIDksIDEyLCA1LCAxNSwgOCxcbiAgOCwgNSwgMTIsIDksIDEyLCA1LCAxNCwgNiwgOCwgMTMsIDYsIDUsIDE1LCAxMywgMTEsIDExXG5dXG5cbnZhciBobCA9IFsweDAwMDAwMDAwLCAweDVBODI3OTk5LCAweDZFRDlFQkExLCAweDhGMUJCQ0RDLCAweEE5NTNGRDRFXVxudmFyIGhyID0gWzB4NTBBMjhCRTYsIDB4NUM0REQxMjQsIDB4NkQ3MDNFRjMsIDB4N0E2RDc2RTksIDB4MDAwMDAwMDBdXG5cbmZ1bmN0aW9uIGJ5dGVzVG9Xb3JkcyAoYnl0ZXMpIHtcbiAgdmFyIHdvcmRzID0gW11cbiAgZm9yICh2YXIgaSA9IDAsIGIgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyssIGIgKz0gOCkge1xuICAgIHdvcmRzW2IgPj4+IDVdIHw9IGJ5dGVzW2ldIDw8ICgyNCAtIGIgJSAzMilcbiAgfVxuICByZXR1cm4gd29yZHNcbn1cblxuZnVuY3Rpb24gd29yZHNUb0J5dGVzICh3b3Jkcykge1xuICB2YXIgYnl0ZXMgPSBbXVxuICBmb3IgKHZhciBiID0gMDsgYiA8IHdvcmRzLmxlbmd0aCAqIDMyOyBiICs9IDgpIHtcbiAgICBieXRlcy5wdXNoKCh3b3Jkc1tiID4+PiA1XSA+Pj4gKDI0IC0gYiAlIDMyKSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzQmxvY2sgKEgsIE0sIG9mZnNldCkge1xuICAvLyBzd2FwIGVuZGlhblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpXG4gICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXVxuXG4gICAgLy8gU3dhcFxuICAgIE1bb2Zmc2V0X2ldID0gKFxuICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSB8IChNX29mZnNldF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICYgMHhmZjAwZmYwMClcbiAgICApXG4gIH1cblxuICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuICB2YXIgYWwsIGJsLCBjbCwgZGwsIGVsXG4gIHZhciBhciwgYnIsIGNyLCBkciwgZXJcblxuICBhciA9IGFsID0gSFswXVxuICBiciA9IGJsID0gSFsxXVxuICBjciA9IGNsID0gSFsyXVxuICBkciA9IGRsID0gSFszXVxuICBlciA9IGVsID0gSFs0XVxuXG4gIC8vIGNvbXB1dGF0aW9uXG4gIHZhciB0XG4gIGZvciAoaSA9IDA7IGkgPCA4MDsgaSArPSAxKSB7XG4gICAgdCA9IChhbCArIE1bb2Zmc2V0ICsgemxbaV1dKSB8IDBcbiAgICBpZiAoaSA8IDE2KSB7XG4gICAgICB0ICs9IGYxKGJsLCBjbCwgZGwpICsgaGxbMF1cbiAgICB9IGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgdCArPSBmMihibCwgY2wsIGRsKSArIGhsWzFdXG4gICAgfSBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgIHQgKz0gZjMoYmwsIGNsLCBkbCkgKyBobFsyXVxuICAgIH0gZWxzZSBpZiAoaSA8IDY0KSB7XG4gICAgICB0ICs9IGY0KGJsLCBjbCwgZGwpICsgaGxbM11cbiAgICB9IGVsc2Ugey8vIGlmIChpPDgwKSB7XG4gICAgICB0ICs9IGY1KGJsLCBjbCwgZGwpICsgaGxbNF1cbiAgICB9XG4gICAgdCA9IHQgfCAwXG4gICAgdCA9IHJvdGwodCwgc2xbaV0pXG4gICAgdCA9ICh0ICsgZWwpIHwgMFxuICAgIGFsID0gZWxcbiAgICBlbCA9IGRsXG4gICAgZGwgPSByb3RsKGNsLCAxMClcbiAgICBjbCA9IGJsXG4gICAgYmwgPSB0XG5cbiAgICB0ID0gKGFyICsgTVtvZmZzZXQgKyB6cltpXV0pIHwgMFxuICAgIGlmIChpIDwgMTYpIHtcbiAgICAgIHQgKz0gZjUoYnIsIGNyLCBkcikgKyBoclswXVxuICAgIH0gZWxzZSBpZiAoaSA8IDMyKSB7XG4gICAgICB0ICs9IGY0KGJyLCBjciwgZHIpICsgaHJbMV1cbiAgICB9IGVsc2UgaWYgKGkgPCA0OCkge1xuICAgICAgdCArPSBmMyhiciwgY3IsIGRyKSArIGhyWzJdXG4gICAgfSBlbHNlIGlmIChpIDwgNjQpIHtcbiAgICAgIHQgKz0gZjIoYnIsIGNyLCBkcikgKyBoclszXVxuICAgIH0gZWxzZSB7Ly8gaWYgKGk8ODApIHtcbiAgICAgIHQgKz0gZjEoYnIsIGNyLCBkcikgKyBocls0XVxuICAgIH1cblxuICAgIHQgPSB0IHwgMFxuICAgIHQgPSByb3RsKHQsIHNyW2ldKVxuICAgIHQgPSAodCArIGVyKSB8IDBcbiAgICBhciA9IGVyXG4gICAgZXIgPSBkclxuICAgIGRyID0gcm90bChjciwgMTApXG4gICAgY3IgPSBiclxuICAgIGJyID0gdFxuICB9XG5cbiAgLy8gaW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcbiAgdCA9IChIWzFdICsgY2wgKyBkcikgfCAwXG4gIEhbMV0gPSAoSFsyXSArIGRsICsgZXIpIHwgMFxuICBIWzJdID0gKEhbM10gKyBlbCArIGFyKSB8IDBcbiAgSFszXSA9IChIWzRdICsgYWwgKyBicikgfCAwXG4gIEhbNF0gPSAoSFswXSArIGJsICsgY3IpIHwgMFxuICBIWzBdID0gdFxufVxuXG5mdW5jdGlvbiBmMSAoeCwgeSwgeikge1xuICByZXR1cm4gKCh4KSBeICh5KSBeICh6KSlcbn1cblxuZnVuY3Rpb24gZjIgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoKHgpICYgKHkpKSB8ICgofngpICYgKHopKSlcbn1cblxuZnVuY3Rpb24gZjMgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoKHgpIHwgKH4oeSkpKSBeICh6KSlcbn1cblxuZnVuY3Rpb24gZjQgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoKHgpICYgKHopKSB8ICgoeSkgJiAofih6KSkpKVxufVxuXG5mdW5jdGlvbiBmNSAoeCwgeSwgeikge1xuICByZXR1cm4gKCh4KSBeICgoeSkgfCAofih6KSkpKVxufVxuXG5mdW5jdGlvbiByb3RsICh4LCBuKSB7XG4gIHJldHVybiAoeCA8PCBuKSB8ICh4ID4+PiAoMzIgLSBuKSlcbn1cblxuZnVuY3Rpb24gcmlwZW1kMTYwIChtZXNzYWdlKSB7XG4gIHZhciBIID0gWzB4Njc0NTIzMDEsIDB4RUZDREFCODksIDB4OThCQURDRkUsIDB4MTAzMjU0NzYsIDB4QzNEMkUxRjBdXG5cbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBuZXcgQnVmZmVyKG1lc3NhZ2UsICd1dGY4JylcbiAgfVxuXG4gIHZhciBtID0gYnl0ZXNUb1dvcmRzKG1lc3NhZ2UpXG5cbiAgdmFyIG5CaXRzTGVmdCA9IG1lc3NhZ2UubGVuZ3RoICogOFxuICB2YXIgbkJpdHNUb3RhbCA9IG1lc3NhZ2UubGVuZ3RoICogOFxuXG4gIC8vIEFkZCBwYWRkaW5nXG4gIG1bbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKVxuICBtWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSAoXG4gICAgKCgobkJpdHNUb3RhbCA8PCA4KSB8IChuQml0c1RvdGFsID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICgoKG5CaXRzVG90YWwgPDwgMjQpIHwgKG5CaXRzVG90YWwgPj4+IDgpKSAmIDB4ZmYwMGZmMDApXG4gIClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgcHJvY2Vzc0Jsb2NrKEgsIG0sIGkpXG4gIH1cblxuICAvLyBzd2FwIGVuZGlhblxuICBmb3IgKGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgLy8gc2hvcnRjdXRcbiAgICB2YXIgSF9pID0gSFtpXVxuXG4gICAgLy8gU3dhcFxuICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAmIDB4ZmYwMGZmMDApXG4gIH1cblxuICB2YXIgZGlnZXN0Ynl0ZXMgPSB3b3Jkc1RvQnl0ZXMoSClcbiAgcmV0dXJuIG5ldyBCdWZmZXIoZGlnZXN0Ynl0ZXMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmlwZW1kMTYwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmlwZW1kMTYwL2xpYi9yaXBlbWQxNjAuanNcbi8vIG1vZHVsZSBpZCA9IDI1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTSEEgKGFsZ29yaXRobSkge1xuICBhbGdvcml0aG0gPSBhbGdvcml0aG0udG9Mb3dlckNhc2UoKVxuXG4gIHZhciBBbGdvcml0aG0gPSBleHBvcnRzW2FsZ29yaXRobV1cbiAgaWYgKCFBbGdvcml0aG0pIHRocm93IG5ldyBFcnJvcihhbGdvcml0aG0gKyAnIGlzIG5vdCBzdXBwb3J0ZWQgKHdlIGFjY2VwdCBwdWxsIHJlcXVlc3RzKScpXG5cbiAgcmV0dXJuIG5ldyBBbGdvcml0aG0oKVxufVxuXG5leHBvcnRzLnNoYSA9IHJlcXVpcmUoJy4vc2hhJylcbmV4cG9ydHMuc2hhMSA9IHJlcXVpcmUoJy4vc2hhMScpXG5leHBvcnRzLnNoYTIyNCA9IHJlcXVpcmUoJy4vc2hhMjI0JylcbmV4cG9ydHMuc2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxuZXhwb3J0cy5zaGEzODQgPSByZXF1aXJlKCcuL3NoYTM4NCcpXG5leHBvcnRzLnNoYTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zaGEuanMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0wLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBkZXJpdmVkIGZyb20gc2hhMS5qcyBvZiB0aGUgc2FtZSByZXBvc2l0b3J5LlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBTSEEtMCBhbmQgU0hBLTEgaXMganVzdCBhIGJpdHdpc2Ugcm90YXRlIGxlZnRcbiAqIG9wZXJhdGlvbiB3YXMgYWRkZWQuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgSyA9IFtcbiAgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYyB8IDAsIDB4Y2E2MmMxZDYgfCAwXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDgwKVxuXG5mdW5jdGlvbiBTaGEgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYSwgSGFzaClcblxuU2hhLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgNSkgfCAobnVtID4+PiAyNylcbn1cblxuZnVuY3Rpb24gcm90bDMwIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcbn1cblxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxuICBpZiAocyA9PT0gMikgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKVxuICByZXR1cm4gYiBeIGMgXiBkXG59XG5cblNoYS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgODA7ICsraSkgV1tpXSA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyArK2opIHtcbiAgICB2YXIgcyA9IH5+KGogLyAyMClcbiAgICB2YXIgdCA9IChyb3RsNShhKSArIGZ0KHMsIGIsIGMsIGQpICsgZSArIFdbal0gKyBLW3NdKSB8IDBcblxuICAgIGUgPSBkXG4gICAgZCA9IGNcbiAgICBjID0gcm90bDMwKGIpXG4gICAgYiA9IGFcbiAgICBhID0gdFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxufVxuXG5TaGEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zaGEuanMvc2hhLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFZlcnNpb24gMi4xYSBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgSyA9IFtcbiAgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYyB8IDAsIDB4Y2E2MmMxZDYgfCAwXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDgwKVxuXG5mdW5jdGlvbiBTaGExICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGExLCBIYXNoKVxuXG5TaGExLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIHJvdGwxIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMSkgfCAobnVtID4+PiAzMSlcbn1cblxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxufVxuXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAzMCkgfCAobnVtID4+PiAyKVxufVxuXG5mdW5jdGlvbiBmdCAocywgYiwgYywgZCkge1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXG4gIHJldHVybiBiIF4gYyBeIGRcbn1cblxuU2hhMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgODA7ICsraSkgV1tpXSA9IHJvdGwxKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0pXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG4gICAgdmFyIHMgPSB+fihqIC8gMjApXG4gICAgdmFyIHQgPSAocm90bDUoYSkgKyBmdChzLCBiLCBjLCBkKSArIGUgKyBXW2pdICsgS1tzXSkgfCAwXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvdGwzMChiKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhMS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTFcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zaGEuanMvc2hhMS5qc1xuLy8gbW9kdWxlIGlkID0gMjYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgVyA9IG5ldyBBcnJheSg2NClcblxuZnVuY3Rpb24gU2hhMjI0ICgpIHtcbiAgdGhpcy5pbml0KClcblxuICB0aGlzLl93ID0gVyAvLyBuZXcgQXJyYXkoNjQpXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMjI0LCBTaGEyNTYpXG5cblNoYTIyNC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4YzEwNTllZDhcbiAgdGhpcy5fYiA9IDB4MzY3Y2Q1MDdcbiAgdGhpcy5fYyA9IDB4MzA3MGRkMTdcbiAgdGhpcy5fZCA9IDB4ZjcwZTU5MzlcbiAgdGhpcy5fZSA9IDB4ZmZjMDBiMzFcbiAgdGhpcy5fZiA9IDB4Njg1ODE1MTFcbiAgdGhpcy5fZyA9IDB4NjRmOThmYTdcbiAgdGhpcy5faCA9IDB4YmVmYTRmYTRcblxuICByZXR1cm4gdGhpc1xufVxuXG5TaGEyMjQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMjgpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyMjRcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zaGEuanMvc2hhMjI0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNIQTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGEzODQgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhMzg0LCBTSEE1MTIpXG5cblNoYTM4NC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweGNiYmI5ZDVkXG4gIHRoaXMuX2JoID0gMHg2MjlhMjkyYVxuICB0aGlzLl9jaCA9IDB4OTE1OTAxNWFcbiAgdGhpcy5fZGggPSAweDE1MmZlY2Q4XG4gIHRoaXMuX2VoID0gMHg2NzMzMjY2N1xuICB0aGlzLl9maCA9IDB4OGViNDRhODdcbiAgdGhpcy5fZ2ggPSAweGRiMGMyZTBkXG4gIHRoaXMuX2hoID0gMHg0N2I1NDgxZFxuXG4gIHRoaXMuX2FsID0gMHhjMTA1OWVkOFxuICB0aGlzLl9ibCA9IDB4MzY3Y2Q1MDdcbiAgdGhpcy5fY2wgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2RsID0gMHhmNzBlNTkzOVxuICB0aGlzLl9lbCA9IDB4ZmZjMDBiMzFcbiAgdGhpcy5fZmwgPSAweDY4NTgxNTExXG4gIHRoaXMuX2dsID0gMHg2NGY5OGZhN1xuICB0aGlzLl9obCA9IDB4YmVmYTRmYTRcblxuICByZXR1cm4gdGhpc1xufVxuXG5TaGEzODQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoNDgpXG5cbiAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFIChoLCBsLCBvZmZzZXQpIHtcbiAgICBILndyaXRlSW50MzJCRShoLCBvZmZzZXQpXG4gICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcbiAgfVxuXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9haCwgdGhpcy5fYWwsIDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iaCwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jaCwgdGhpcy5fY2wsIDE2KVxuICB3cml0ZUludDY0QkUodGhpcy5fZGgsIHRoaXMuX2RsLCAyNClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2VoLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9maCwgdGhpcy5fZmwsIDQwKVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMzg0XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2hhLmpzL3NoYTM4NC5qc1xuLy8gbW9kdWxlIGlkID0gMjY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDI2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMjY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xuXG52YXIgT2JqZWN0X2tleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKSByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSlcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICh4cywgZm4pIHtcbiAgICBpZiAoeHMuZm9yRWFjaCkgcmV0dXJuIHhzLmZvckVhY2goZm4pXG4gICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuKHhzW2ldLCBpLCB4cyk7XG4gICAgfVxufTtcblxudmFyIGRlZmluZVByb3AgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnXycsIHt9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgb2JqW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxufSgpKTtcblxudmFyIGdsb2JhbHMgPSBbJ0FycmF5JywgJ0Jvb2xlYW4nLCAnRGF0ZScsICdFcnJvcicsICdFdmFsRXJyb3InLCAnRnVuY3Rpb24nLFxuJ0luZmluaXR5JywgJ0pTT04nLCAnTWF0aCcsICdOYU4nLCAnTnVtYmVyJywgJ09iamVjdCcsICdSYW5nZUVycm9yJyxcbidSZWZlcmVuY2VFcnJvcicsICdSZWdFeHAnLCAnU3RyaW5nJywgJ1N5bnRheEVycm9yJywgJ1R5cGVFcnJvcicsICdVUklFcnJvcicsXG4nZGVjb2RlVVJJJywgJ2RlY29kZVVSSUNvbXBvbmVudCcsICdlbmNvZGVVUkknLCAnZW5jb2RlVVJJQ29tcG9uZW50JywgJ2VzY2FwZScsXG4nZXZhbCcsICdpc0Zpbml0ZScsICdpc05hTicsICdwYXJzZUZsb2F0JywgJ3BhcnNlSW50JywgJ3VuZGVmaW5lZCcsICd1bmVzY2FwZSddO1xuXG5mdW5jdGlvbiBDb250ZXh0KCkge31cbkNvbnRleHQucHJvdG90eXBlID0ge307XG5cbnZhciBTY3JpcHQgPSBleHBvcnRzLlNjcmlwdCA9IGZ1bmN0aW9uIE5vZGVTY3JpcHQgKGNvZGUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2NyaXB0KSkgcmV0dXJuIG5ldyBTY3JpcHQoY29kZSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5Db250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBpZiAoIShjb250ZXh0IGluc3RhbmNlb2YgQ29udGV4dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5lZWRzIGEgJ2NvbnRleHQnIGFyZ3VtZW50LlwiKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmICghaWZyYW1lLnN0eWxlKSBpZnJhbWUuc3R5bGUgPSB7fTtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgXG4gICAgdmFyIHdpbiA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuICAgIHZhciB3RXZhbCA9IHdpbi5ldmFsLCB3RXhlY1NjcmlwdCA9IHdpbi5leGVjU2NyaXB0O1xuXG4gICAgaWYgKCF3RXZhbCAmJiB3RXhlY1NjcmlwdCkge1xuICAgICAgICAvLyB3aW4uZXZhbCgpIG1hZ2ljYWxseSBhcHBlYXJzIHdoZW4gdGhpcyBpcyBjYWxsZWQgaW4gSUU6XG4gICAgICAgIHdFeGVjU2NyaXB0LmNhbGwod2luLCAnbnVsbCcpO1xuICAgICAgICB3RXZhbCA9IHdpbi5ldmFsO1xuICAgIH1cbiAgICBcbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGNvbnRleHQpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHdpbltrZXldID0gY29udGV4dFtrZXldO1xuICAgIH0pO1xuICAgIGZvckVhY2goZ2xvYmFscywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoY29udGV4dFtrZXldKSB7XG4gICAgICAgICAgICB3aW5ba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHZhciB3aW5LZXlzID0gT2JqZWN0X2tleXMod2luKTtcblxuICAgIHZhciByZXMgPSB3RXZhbC5jYWxsKHdpbiwgdGhpcy5jb2RlKTtcbiAgICBcbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKHdpbiksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy8gQXZvaWQgY29weWluZyBjaXJjdWxhciBvYmplY3RzIGxpa2UgYHRvcGAgYW5kIGB3aW5kb3dgIGJ5IG9ubHlcbiAgICAgICAgLy8gdXBkYXRpbmcgZXhpc3RpbmcgY29udGV4dCBwcm9wZXJ0aWVzIG9yIG5ldyBwcm9wZXJ0aWVzIGluIHRoZSBgd2luYFxuICAgICAgICAvLyB0aGF0IHdhcyBvbmx5IGludHJvZHVjZWQgYWZ0ZXIgdGhlIGV2YWwuXG4gICAgICAgIGlmIChrZXkgaW4gY29udGV4dCB8fCBpbmRleE9mKHdpbktleXMsIGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250ZXh0W2tleV0gPSB3aW5ba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZm9yRWFjaChnbG9iYWxzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBjb250ZXh0KSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcChjb250ZXh0LCBrZXksIHdpbltrZXldKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICBcbiAgICByZXR1cm4gcmVzO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5JblRoaXNDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBldmFsKHRoaXMuY29kZSk7IC8vIG1heWJlLi4uXG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnJ1bkluTmV3Q29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGN0eCA9IFNjcmlwdC5jcmVhdGVDb250ZXh0KGNvbnRleHQpO1xuICAgIHZhciByZXMgPSB0aGlzLnJ1bkluQ29udGV4dChjdHgpO1xuXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjdHgpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGNvbnRleHRba2V5XSA9IGN0eFtrZXldO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlcztcbn07XG5cbmZvckVhY2goT2JqZWN0X2tleXMoU2NyaXB0LnByb3RvdHlwZSksIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgZXhwb3J0c1tuYW1lXSA9IFNjcmlwdFtuYW1lXSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIHZhciBzID0gU2NyaXB0KGNvZGUpO1xuICAgICAgICByZXR1cm4gc1tuYW1lXS5hcHBseShzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH07XG59KTtcblxuZXhwb3J0cy5jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiBleHBvcnRzLlNjcmlwdChjb2RlKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IFNjcmlwdC5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgY29weSA9IG5ldyBDb250ZXh0KCk7XG4gICAgaWYodHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvckVhY2goT2JqZWN0X2tleXMoY29udGV4dCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92bS1icm93c2VyaWZ5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdGgzMjogcmVxdWlyZShcIi4veHhoYXNoXCIpXG4sXHRoNjQ6IHJlcXVpcmUoXCIuL3h4aGFzaDY0XCIpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34veHhoYXNoanMvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG54eEhhc2ggaW1wbGVtZW50YXRpb24gaW4gcHVyZSBKYXZhc2NyaXB0XG5cbkNvcHlyaWdodCAoQykgMjAxMywgUGllcnJlIEN1cnRvXG5NSVQgbGljZW5zZVxuKi9cbnZhciBVSU5UMzIgPSByZXF1aXJlKCdjdWludCcpLlVJTlQzMlxuXG4vKlxuXHRNZXJnZWQgdGhpcyBzZXF1ZW5jZSBvZiBtZXRob2QgY2FsbHMgYXMgaXQgc3BlZWRzIHVwXG5cdHRoZSBjYWxjdWxhdGlvbnMgYnkgYSBmYWN0b3Igb2YgMlxuICovXG4vLyB0aGlzLnYxLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUUzMl8yKSApLnJvdGwoMTMpLm11bHRpcGx5KFBSSU1FMzJfMSk7XG5VSU5UMzIucHJvdG90eXBlLnh4aF91cGRhdGUgPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XG5cdHZhciBiMDAgPSBQUklNRTMyXzIuX2xvd1xuXHR2YXIgYjE2ID0gUFJJTUUzMl8yLl9oaWdoXG5cblx0dmFyIGMxNiwgYzAwXG5cdGMwMCA9IGxvdyAqIGIwMFxuXHRjMTYgPSBjMDAgPj4+IDE2XG5cblx0YzE2ICs9IGhpZ2ggKiBiMDBcblx0YzE2ICY9IDB4RkZGRlx0XHQvLyBOb3QgcmVxdWlyZWQgYnV0IGltcHJvdmVzIHBlcmZvcm1hbmNlXG5cdGMxNiArPSBsb3cgKiBiMTZcblxuXHR2YXIgYTAwID0gdGhpcy5fbG93ICsgKGMwMCAmIDB4RkZGRilcblx0dmFyIGExNiA9IGEwMCA+Pj4gMTZcblxuXHRhMTYgKz0gdGhpcy5faGlnaCArIChjMTYgJiAweEZGRkYpXG5cblx0dmFyIHYgPSAoYTE2IDw8IDE2KSB8IChhMDAgJiAweEZGRkYpXG5cdHYgPSAodiA8PCAxMykgfCAodiA+Pj4gMTkpXG5cblx0YTAwID0gdiAmIDB4RkZGRlxuXHRhMTYgPSB2ID4+PiAxNlxuXG5cdGIwMCA9IFBSSU1FMzJfMS5fbG93XG5cdGIxNiA9IFBSSU1FMzJfMS5faGlnaFxuXG5cdGMwMCA9IGEwMCAqIGIwMFxuXHRjMTYgPSBjMDAgPj4+IDE2XG5cblx0YzE2ICs9IGExNiAqIGIwMFxuXHRjMTYgJj0gMHhGRkZGXHRcdC8vIE5vdCByZXF1aXJlZCBidXQgaW1wcm92ZXMgcGVyZm9ybWFuY2Vcblx0YzE2ICs9IGEwMCAqIGIxNlxuXG5cdHRoaXMuX2xvdyA9IGMwMCAmIDB4RkZGRlxuXHR0aGlzLl9oaWdoID0gYzE2ICYgMHhGRkZGXG59XG5cbi8qXG4gKiBDb25zdGFudHNcbiAqL1xudmFyIFBSSU1FMzJfMSA9IFVJTlQzMiggJzI2NTQ0MzU3NjEnIClcbnZhciBQUklNRTMyXzIgPSBVSU5UMzIoICcyMjQ2ODIyNTE5JyApXG52YXIgUFJJTUUzMl8zID0gVUlOVDMyKCAnMzI2NjQ4OTkxNycgKVxudmFyIFBSSU1FMzJfNCA9IFVJTlQzMiggICc2NjgyNjUyNjMnIClcbnZhciBQUklNRTMyXzUgPSBVSU5UMzIoICAnMzc0NzYxMzkzJyApXG5cbi8qKlxuKiBDb252ZXJ0IHN0cmluZyB0byBwcm9wZXIgVVRGLTggYXJyYXlcbiogQHBhcmFtIHN0ciBJbnB1dCBzdHJpbmdcbiogQHJldHVybnMge1VpbnQ4QXJyYXl9IFVURjggYXJyYXkgaXMgcmV0dXJuZWQgYXMgdWludDggYXJyYXlcbiovXG5mdW5jdGlvbiB0b1VURjhBcnJheSAoc3RyKSB7XG5cdHZhciB1dGY4ID0gW11cblx0Zm9yICh2YXIgaT0wLCBuPXN0ci5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHR2YXIgY2hhcmNvZGUgPSBzdHIuY2hhckNvZGVBdChpKVxuXHRcdGlmIChjaGFyY29kZSA8IDB4ODApIHV0ZjgucHVzaChjaGFyY29kZSlcblx0XHRlbHNlIGlmIChjaGFyY29kZSA8IDB4ODAwKSB7XG5cdFx0XHR1dGY4LnB1c2goMHhjMCB8IChjaGFyY29kZSA+PiA2KSxcblx0XHRcdDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAoY2hhcmNvZGUgPCAweGQ4MDAgfHwgY2hhcmNvZGUgPj0gMHhlMDAwKSB7XG5cdFx0XHR1dGY4LnB1c2goMHhlMCB8IChjaGFyY29kZSA+PiAxMiksXG5cdFx0XHQweDgwIHwgKChjaGFyY29kZT4+NikgJiAweDNmKSxcblx0XHRcdDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSlcblx0XHR9XG5cdFx0Ly8gc3Vycm9nYXRlIHBhaXJcblx0XHRlbHNlIHtcblx0XHRcdGkrKztcblx0XHRcdC8vIFVURi0xNiBlbmNvZGVzIDB4MTAwMDAtMHgxMEZGRkYgYnlcblx0XHRcdC8vIHN1YnRyYWN0aW5nIDB4MTAwMDAgYW5kIHNwbGl0dGluZyB0aGVcblx0XHRcdC8vIDIwIGJpdHMgb2YgMHgwLTB4RkZGRkYgaW50byB0d28gaGFsdmVzXG5cdFx0XHRjaGFyY29kZSA9IDB4MTAwMDAgKyAoKChjaGFyY29kZSAmIDB4M2ZmKTw8MTApXG5cdFx0XHR8IChzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmKSlcblx0XHRcdHV0ZjgucHVzaCgweGYwIHwgKGNoYXJjb2RlID4+MTgpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjEyKSAmIDB4M2YpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ldyBVaW50OEFycmF5KHV0ZjgpXG59XG5cbi8qKlxuICogWFhIIG9iamVjdCB1c2VkIGFzIGEgY29uc3RydWN0b3Igb3IgYSBmdW5jdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBvclxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge051bWJlcnxVSU5UMzJ9IHNlZWRcbiAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cbiAqIG9yXG4gKiBAcmV0dXJuIHtVSU5UMzJ9IHh4SGFzaFxuICovXG5mdW5jdGlvbiBYWEggKCkge1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKVxuXHRcdHJldHVybiBuZXcgWFhIKCBhcmd1bWVudHNbMV0gKS51cGRhdGUoIGFyZ3VtZW50c1swXSApLmRpZ2VzdCgpXG5cblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFhYSCkpXG5cdFx0cmV0dXJuIG5ldyBYWEgoIGFyZ3VtZW50c1swXSApXG5cblx0aW5pdC5jYWxsKHRoaXMsIGFyZ3VtZW50c1swXSlcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBYWEggaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gc2VlZFxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHNlZWQgYXMgYSBudW1iZXIgb3IgYW4gdW5zaWduZWQgMzIgYml0cyBpbnRlZ2VyXG4gKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG4gKi9cbiBmdW5jdGlvbiBpbml0IChzZWVkKSB7XG5cdHRoaXMuc2VlZCA9IHNlZWQgaW5zdGFuY2VvZiBVSU5UMzIgPyBzZWVkLmNsb25lKCkgOiBVSU5UMzIoc2VlZClcblx0dGhpcy52MSA9IHRoaXMuc2VlZC5jbG9uZSgpLmFkZChQUklNRTMyXzEpLmFkZChQUklNRTMyXzIpXG5cdHRoaXMudjIgPSB0aGlzLnNlZWQuY2xvbmUoKS5hZGQoUFJJTUUzMl8yKVxuXHR0aGlzLnYzID0gdGhpcy5zZWVkLmNsb25lKClcblx0dGhpcy52NCA9IHRoaXMuc2VlZC5jbG9uZSgpLnN1YnRyYWN0KFBSSU1FMzJfMSlcblx0dGhpcy50b3RhbF9sZW4gPSAwXG5cdHRoaXMubWVtc2l6ZSA9IDBcblx0dGhpcy5tZW1vcnkgPSBudWxsXG5cblx0cmV0dXJuIHRoaXNcbn1cblhYSC5wcm90b3R5cGUuaW5pdCA9IGluaXRcblxuLyoqXG4gKiBBZGQgZGF0YSB0byBiZSBjb21wdXRlZCBmb3IgdGhlIFhYSCBoYXNoXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfEFycmF5QnVmZmVyfSBpbnB1dCBhcyBhIHN0cmluZyBvciBub2RlanMgQnVmZmVyIG9yIEFycmF5QnVmZmVyXG4gKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG4gKi9cblhYSC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cdHZhciBpc1N0cmluZyA9IHR5cGVvZiBpbnB1dCA9PSAnc3RyaW5nJ1xuXHR2YXIgaXNBcnJheUJ1ZmZlclxuXG5cdC8vIENvbnZlcnQgYWxsIHN0cmluZ3MgdG8gdXRmLTggZmlyc3QgKGlzc3VlICM1KVxuXHRpZiAoaXNTdHJpbmcpIHtcblx0XHRpbnB1dCA9IHRvVVRGOEFycmF5KGlucHV0KVxuXHRcdGlzU3RyaW5nID0gZmFsc2Vcblx0XHRpc0FycmF5QnVmZmVyID0gdHJ1ZVxuXHR9XG5cblx0aWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuXHR7XG5cdFx0aXNBcnJheUJ1ZmZlciA9IHRydWVcblx0XHRpbnB1dCA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcblx0fVxuXG5cdHZhciBwID0gMFxuXHR2YXIgbGVuID0gaW5wdXQubGVuZ3RoXG5cdHZhciBiRW5kID0gcCArIGxlblxuXG5cdGlmIChsZW4gPT0gMCkgcmV0dXJuIHRoaXNcblxuXHR0aGlzLnRvdGFsX2xlbiArPSBsZW5cblxuXHRpZiAodGhpcy5tZW1zaXplID09IDApXG5cdHtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gJydcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gbmV3IFVpbnQ4QXJyYXkoMTYpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gbmV3IEJ1ZmZlcigxNilcblx0XHR9XG5cdH1cblxuXHRpZiAodGhpcy5tZW1zaXplICsgbGVuIDwgMTYpICAgLy8gZmlsbCBpbiB0bXAgYnVmZmVyXG5cdHtcblx0XHQvLyBYWEhfbWVtY3B5KHRoaXMubWVtb3J5ICsgdGhpcy5tZW1zaXplLCBpbnB1dCwgbGVuKVxuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXRcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkoMCwgbGVuKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgMCwgbGVuIClcblx0XHR9XG5cblx0XHR0aGlzLm1lbXNpemUgKz0gbGVuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdGlmICh0aGlzLm1lbXNpemUgPiAwKSAgIC8vIHNvbWUgZGF0YSBsZWZ0IGZyb20gcHJldmlvdXMgdXBkYXRlXG5cdHtcblx0XHQvLyBYWEhfbWVtY3B5KHRoaXMubWVtb3J5ICsgdGhpcy5tZW1zaXplLCBpbnB1dCwgMTYtdGhpcy5tZW1zaXplKTtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMubWVtb3J5ICs9IGlucHV0LnNsaWNlKDAsIDE2IC0gdGhpcy5tZW1zaXplKVxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkuc2V0KCBpbnB1dC5zdWJhcnJheSgwLCAxNiAtIHRoaXMubWVtc2l6ZSksIHRoaXMubWVtc2l6ZSApXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlucHV0LmNvcHkoIHRoaXMubWVtb3J5LCB0aGlzLm1lbXNpemUsIDAsIDE2IC0gdGhpcy5tZW1zaXplIClcblx0XHR9XG5cblx0XHR2YXIgcDMyID0gMFxuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy52MS54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMilcblx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMiszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzIpXG5cdFx0XHQpXG5cdFx0XHRwMzIgKz0gNFxuXHRcdFx0dGhpcy52Mi54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMilcblx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMiszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzIpXG5cdFx0XHQpXG5cdFx0XHRwMzIgKz0gNFxuXHRcdFx0dGhpcy52My54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMilcblx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMiszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzIpXG5cdFx0XHQpXG5cdFx0XHRwMzIgKz0gNFxuXHRcdFx0dGhpcy52NC54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMilcblx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMiszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzIpXG5cdFx0XHQpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudjEueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5W3AzMisxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMl1cblx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwMzIrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzIrMl1cblx0XHRcdClcblx0XHRcdHAzMiArPSA0XG5cdFx0XHR0aGlzLnYyLnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeVtwMzIrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzJdXG5cdFx0XHQsXHQodGhpcy5tZW1vcnlbcDMyKzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyKzJdXG5cdFx0XHQpXG5cdFx0XHRwMzIgKz0gNFxuXHRcdFx0dGhpcy52My54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnlbcDMyKzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyXVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5W3AzMiszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMisyXVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjQueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5W3AzMisxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMl1cblx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwMzIrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzIrMl1cblx0XHRcdClcblx0XHR9XG5cblx0XHRwICs9IDE2IC0gdGhpcy5tZW1zaXplXG5cdFx0dGhpcy5tZW1zaXplID0gMFxuXHRcdGlmIChpc1N0cmluZykgdGhpcy5tZW1vcnkgPSAnJ1xuXHR9XG5cblx0aWYgKHAgPD0gYkVuZCAtIDE2KVxuXHR7XG5cdFx0dmFyIGxpbWl0ID0gYkVuZCAtIDE2XG5cblx0XHRkb1xuXHRcdHtcblx0XHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0XHR0aGlzLnYxLnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHQpXG5cdFx0XHRcdHAgKz0gNFxuXHRcdFx0XHR0aGlzLnYyLnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHQpXG5cdFx0XHRcdHAgKz0gNFxuXHRcdFx0XHR0aGlzLnYzLnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHQpXG5cdFx0XHRcdHAgKz0gNFxuXHRcdFx0XHR0aGlzLnY0Lnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0XHQpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnYxLnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52Mi54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdClcblx0XHRcdFx0cCArPSA0XG5cdFx0XHRcdHRoaXMudjMueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHQpXG5cdFx0XHRcdHAgKz0gNFxuXHRcdFx0XHR0aGlzLnY0Lnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdFx0cCArPSA0XG5cdFx0fSB3aGlsZSAocCA8PSBsaW1pdClcblx0fVxuXG5cdGlmIChwIDwgYkVuZClcblx0e1xuXHRcdC8vIFhYSF9tZW1jcHkodGhpcy5tZW1vcnksIHAsIGJFbmQtcCk7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dC5zbGljZShwKVxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkuc2V0KCBpbnB1dC5zdWJhcnJheShwLCBiRW5kKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgcCwgYkVuZCApXG5cdFx0fVxuXG5cdFx0dGhpcy5tZW1zaXplID0gYkVuZCAtIHBcblx0fVxuXG5cdHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogRmluYWxpemUgdGhlIFhYSCBjb21wdXRhdGlvbi4gVGhlIFhYSCBpbnN0YW5jZSBpcyByZWFkeSBmb3IgcmV1c2UgZm9yIHRoZSBnaXZlbiBzZWVkXG4gKiBAbWV0aG9kIGRpZ2VzdFxuICogQHJldHVybiB7VUlOVDMyfSB4eEhhc2hcbiAqL1xuWFhILnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBpbnB1dCA9IHRoaXMubWVtb3J5XG5cdHZhciBpc1N0cmluZyA9IHR5cGVvZiBpbnB1dCA9PSAnc3RyaW5nJ1xuXHR2YXIgcCA9IDBcblx0dmFyIGJFbmQgPSB0aGlzLm1lbXNpemVcblx0dmFyIGgzMiwgaFxuXHR2YXIgdSA9IG5ldyBVSU5UMzJcblxuXHRpZiAodGhpcy50b3RhbF9sZW4gPj0gMTYpXG5cdHtcblx0XHRoMzIgPSB0aGlzLnYxLnJvdGwoMSkuYWRkKCB0aGlzLnYyLnJvdGwoNykuYWRkKCB0aGlzLnYzLnJvdGwoMTIpLmFkZCggdGhpcy52NC5yb3RsKDE4KSApICkgKVxuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdGgzMiAgPSB0aGlzLnNlZWQuY2xvbmUoKS5hZGQoIFBSSU1FMzJfNSApXG5cdH1cblxuXHRoMzIuYWRkKCB1LmZyb21OdW1iZXIodGhpcy50b3RhbF9sZW4pIClcblxuXHR3aGlsZSAocCA8PSBiRW5kIC0gNClcblx0e1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dS5mcm9tQml0cyhcblx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdClcblx0XHR9IGVsc2Uge1xuXHRcdFx0dS5mcm9tQml0cyhcblx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHQpXG5cdFx0fVxuXHRcdGgzMlxuXHRcdFx0LmFkZCggdS5tdWx0aXBseShQUklNRTMyXzMpIClcblx0XHRcdC5yb3RsKDE3KVxuXHRcdFx0Lm11bHRpcGx5KCBQUklNRTMyXzQgKVxuXHRcdHAgKz0gNFxuXHR9XG5cblx0d2hpbGUgKHAgPCBiRW5kKVxuXHR7XG5cdFx0dS5mcm9tQml0cyggaXNTdHJpbmcgPyBpbnB1dC5jaGFyQ29kZUF0KHArKykgOiBpbnB1dFtwKytdLCAwIClcblx0XHRoMzJcblx0XHRcdC5hZGQoIHUubXVsdGlwbHkoUFJJTUUzMl81KSApXG5cdFx0XHQucm90bCgxMSlcblx0XHRcdC5tdWx0aXBseShQUklNRTMyXzEpXG5cdH1cblxuXHRoID0gaDMyLmNsb25lKCkuc2hpZnRSaWdodCgxNSlcblx0aDMyLnhvcihoKS5tdWx0aXBseShQUklNRTMyXzIpXG5cblx0aCA9IGgzMi5jbG9uZSgpLnNoaWZ0UmlnaHQoMTMpXG5cdGgzMi54b3IoaCkubXVsdGlwbHkoUFJJTUUzMl8zKVxuXG5cdGggPSBoMzIuY2xvbmUoKS5zaGlmdFJpZ2h0KDE2KVxuXHRoMzIueG9yKGgpXG5cblx0Ly8gUmVzZXQgdGhlIHN0YXRlXG5cdHRoaXMuaW5pdCggdGhpcy5zZWVkIClcblxuXHRyZXR1cm4gaDMyXG59XG5cbm1vZHVsZS5leHBvcnRzID0gWFhIXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34veHhoYXNoanMvbGliL3h4aGFzaC5qc1xuLy8gbW9kdWxlIGlkID0gMjY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxueHhIYXNoNjQgaW1wbGVtZW50YXRpb24gaW4gcHVyZSBKYXZhc2NyaXB0XG5cbkNvcHlyaWdodCAoQykgMjAxNiwgUGllcnJlIEN1cnRvXG5NSVQgbGljZW5zZVxuKi9cbnZhciBVSU5UNjQgPSByZXF1aXJlKCdjdWludCcpLlVJTlQ2NFxuXG4vKlxuICogQ29uc3RhbnRzXG4gKi9cbnZhciBQUklNRTY0XzEgPSBVSU5UNjQoICcxMTQwMDcxNDc4NTA3NDY5NDc5MScgKVxudmFyIFBSSU1FNjRfMiA9IFVJTlQ2NCggJzE0MDI5NDY3MzY2ODk3MDE5NzI3JyApXG52YXIgUFJJTUU2NF8zID0gVUlOVDY0KCAgJzE2MDk1ODc5MjkzOTI4MzkxNjEnIClcbnZhciBQUklNRTY0XzQgPSBVSU5UNjQoICAnOTY1MDAyOTI0MjI4NzgyODU3OScgKVxudmFyIFBSSU1FNjRfNSA9IFVJTlQ2NCggICcyODcwMTc3NDUwMDEyNjAwMjYxJyApXG5cbi8qKlxuKiBDb252ZXJ0IHN0cmluZyB0byBwcm9wZXIgVVRGLTggYXJyYXlcbiogQHBhcmFtIHN0ciBJbnB1dCBzdHJpbmdcbiogQHJldHVybnMge1VpbnQ4QXJyYXl9IFVURjggYXJyYXkgaXMgcmV0dXJuZWQgYXMgdWludDggYXJyYXlcbiovXG5mdW5jdGlvbiB0b1VURjhBcnJheSAoc3RyKSB7XG5cdHZhciB1dGY4ID0gW11cblx0Zm9yICh2YXIgaT0wLCBuPXN0ci5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHR2YXIgY2hhcmNvZGUgPSBzdHIuY2hhckNvZGVBdChpKVxuXHRcdGlmIChjaGFyY29kZSA8IDB4ODApIHV0ZjgucHVzaChjaGFyY29kZSlcblx0XHRlbHNlIGlmIChjaGFyY29kZSA8IDB4ODAwKSB7XG5cdFx0XHR1dGY4LnB1c2goMHhjMCB8IChjaGFyY29kZSA+PiA2KSxcblx0XHRcdDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAoY2hhcmNvZGUgPCAweGQ4MDAgfHwgY2hhcmNvZGUgPj0gMHhlMDAwKSB7XG5cdFx0XHR1dGY4LnB1c2goMHhlMCB8IChjaGFyY29kZSA+PiAxMiksXG5cdFx0XHQweDgwIHwgKChjaGFyY29kZT4+NikgJiAweDNmKSxcblx0XHRcdDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSlcblx0XHR9XG5cdFx0Ly8gc3Vycm9nYXRlIHBhaXJcblx0XHRlbHNlIHtcblx0XHRcdGkrKztcblx0XHRcdC8vIFVURi0xNiBlbmNvZGVzIDB4MTAwMDAtMHgxMEZGRkYgYnlcblx0XHRcdC8vIHN1YnRyYWN0aW5nIDB4MTAwMDAgYW5kIHNwbGl0dGluZyB0aGVcblx0XHRcdC8vIDIwIGJpdHMgb2YgMHgwLTB4RkZGRkYgaW50byB0d28gaGFsdmVzXG5cdFx0XHRjaGFyY29kZSA9IDB4MTAwMDAgKyAoKChjaGFyY29kZSAmIDB4M2ZmKTw8MTApXG5cdFx0XHR8IChzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmKSlcblx0XHRcdHV0ZjgucHVzaCgweGYwIHwgKGNoYXJjb2RlID4+MTgpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjEyKSAmIDB4M2YpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ldyBVaW50OEFycmF5KHV0ZjgpXG59XG5cbi8qKlxuICogWFhINjQgb2JqZWN0IHVzZWQgYXMgYSBjb25zdHJ1Y3RvciBvciBhIGZ1bmN0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIG9yXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfFVJTlQ2NH0gc2VlZFxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICogb3JcbiAqIEByZXR1cm4ge1VJTlQ2NH0geHhIYXNoXG4gKi9cbmZ1bmN0aW9uIFhYSDY0ICgpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMilcblx0XHRyZXR1cm4gbmV3IFhYSDY0KCBhcmd1bWVudHNbMV0gKS51cGRhdGUoIGFyZ3VtZW50c1swXSApLmRpZ2VzdCgpXG5cblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFhYSDY0KSlcblx0XHRyZXR1cm4gbmV3IFhYSDY0KCBhcmd1bWVudHNbMF0gKVxuXG5cdGluaXQuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0pXG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgWFhINjQgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gc2VlZFxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHNlZWQgYXMgYSBudW1iZXIgb3IgYW4gdW5zaWduZWQgMzIgYml0cyBpbnRlZ2VyXG4gKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG4gKi9cbiBmdW5jdGlvbiBpbml0IChzZWVkKSB7XG5cdHRoaXMuc2VlZCA9IHNlZWQgaW5zdGFuY2VvZiBVSU5UNjQgPyBzZWVkLmNsb25lKCkgOiBVSU5UNjQoc2VlZClcblx0dGhpcy52MSA9IHRoaXMuc2VlZC5jbG9uZSgpLmFkZChQUklNRTY0XzEpLmFkZChQUklNRTY0XzIpXG5cdHRoaXMudjIgPSB0aGlzLnNlZWQuY2xvbmUoKS5hZGQoUFJJTUU2NF8yKVxuXHR0aGlzLnYzID0gdGhpcy5zZWVkLmNsb25lKClcblx0dGhpcy52NCA9IHRoaXMuc2VlZC5jbG9uZSgpLnN1YnRyYWN0KFBSSU1FNjRfMSlcblx0dGhpcy50b3RhbF9sZW4gPSAwXG5cdHRoaXMubWVtc2l6ZSA9IDBcblx0dGhpcy5tZW1vcnkgPSBudWxsXG5cblx0cmV0dXJuIHRoaXNcbn1cblhYSDY0LnByb3RvdHlwZS5pbml0ID0gaW5pdFxuXG4vKipcbiAqIEFkZCBkYXRhIHRvIGJlIGNvbXB1dGVkIGZvciB0aGUgWFhINjQgaGFzaFxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcnxBcnJheUJ1ZmZlcn0gaW5wdXQgYXMgYSBzdHJpbmcgb3Igbm9kZWpzIEJ1ZmZlciBvciBBcnJheUJ1ZmZlclxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICovXG5YWEg2NC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cdHZhciBpc1N0cmluZyA9IHR5cGVvZiBpbnB1dCA9PSAnc3RyaW5nJ1xuXHR2YXIgaXNBcnJheUJ1ZmZlclxuXG5cdC8vIENvbnZlcnQgYWxsIHN0cmluZ3MgdG8gdXRmLTggZmlyc3QgKGlzc3VlICM1KVxuXHRpZiAoaXNTdHJpbmcpIHtcblx0XHRpbnB1dCA9IHRvVVRGOEFycmF5KGlucHV0KVxuXHRcdGlzU3RyaW5nID0gZmFsc2Vcblx0XHRpc0FycmF5QnVmZmVyID0gdHJ1ZVxuXHR9XG5cblx0aWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuXHR7XG5cdFx0aXNBcnJheUJ1ZmZlciA9IHRydWVcblx0XHRpbnB1dCA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcblx0fVxuXG5cdHZhciBwID0gMFxuXHR2YXIgbGVuID0gaW5wdXQubGVuZ3RoXG5cdHZhciBiRW5kID0gcCArIGxlblxuXG5cdGlmIChsZW4gPT0gMCkgcmV0dXJuIHRoaXNcblxuXHR0aGlzLnRvdGFsX2xlbiArPSBsZW5cblxuXHRpZiAodGhpcy5tZW1zaXplID09IDApXG5cdHtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gJydcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gbmV3IEJ1ZmZlcigzMilcblx0XHR9XG5cdH1cblxuXHRpZiAodGhpcy5tZW1zaXplICsgbGVuIDwgMzIpICAgLy8gZmlsbCBpbiB0bXAgYnVmZmVyXG5cdHtcblx0XHQvLyBYWEg2NF9tZW1jcHkodGhpcy5tZW1vcnkgKyB0aGlzLm1lbXNpemUsIGlucHV0LCBsZW4pXG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dFxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkuc2V0KCBpbnB1dC5zdWJhcnJheSgwLCBsZW4pLCB0aGlzLm1lbXNpemUgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dC5jb3B5KCB0aGlzLm1lbW9yeSwgdGhpcy5tZW1zaXplLCAwLCBsZW4gKVxuXHRcdH1cblxuXHRcdHRoaXMubWVtc2l6ZSArPSBsZW5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0aWYgKHRoaXMubWVtc2l6ZSA+IDApICAgLy8gc29tZSBkYXRhIGxlZnQgZnJvbSBwcmV2aW91cyB1cGRhdGVcblx0e1xuXHRcdC8vIFhYSDY0X21lbWNweSh0aGlzLm1lbW9yeSArIHRoaXMubWVtc2l6ZSwgaW5wdXQsIDE2LXRoaXMubWVtc2l6ZSk7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dC5zbGljZSgwLCAzMiAtIHRoaXMubWVtc2l6ZSlcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkoMCwgMzIgLSB0aGlzLm1lbXNpemUpLCB0aGlzLm1lbXNpemUgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dC5jb3B5KCB0aGlzLm1lbW9yeSwgdGhpcy5tZW1zaXplLCAwLCAzMiAtIHRoaXMubWVtc2l6ZSApXG5cdFx0fVxuXG5cdFx0dmFyIHA2NCA9IDBcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHZhciBvdGhlclxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzIpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs1KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs3KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzYpXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjEuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdHA2NCArPSA4XG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NClcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzMpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMilcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzUpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNClcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzcpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNilcblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52Mi5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0cDY0ICs9IDhcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsyKVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs2KVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnYzLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRwNjQgKz0gOFxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzIpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs1KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs3KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzYpXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjQuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG90aGVyXG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnlbcDY0KzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzJdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrNV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs3XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs2XVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnYxLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRwNjQgKz0gOFxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5W3A2NCsxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCsyXVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzVdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrN10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNl1cblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52Mi5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0cDY0ICs9IDhcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeVtwNjQrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrMl1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs1XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzddIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzZdXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjMuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdHA2NCArPSA4XG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnlbcDY0KzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzJdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrNV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs3XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs2XVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnY0LmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0fVxuXG5cdFx0cCArPSAzMiAtIHRoaXMubWVtc2l6ZVxuXHRcdHRoaXMubWVtc2l6ZSA9IDBcblx0XHRpZiAoaXNTdHJpbmcpIHRoaXMubWVtb3J5ID0gJydcblx0fVxuXG5cdGlmIChwIDw9IGJFbmQgLSAzMilcblx0e1xuXHRcdHZhciBsaW1pdCA9IGJFbmQgLSAzMlxuXG5cdFx0ZG9cblx0XHR7XG5cdFx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdFx0dmFyIG90aGVyXG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjEuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjIuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjMuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjQuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBvdGhlclxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs1XSA8PCA4KSB8IGlucHV0W3ArNF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs3XSA8PCA4KSB8IGlucHV0W3ArNl1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjEuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzVdIDw8IDgpIHwgaW5wdXRbcCs0XVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzddIDw8IDgpIHwgaW5wdXRbcCs2XVxuXHRcdFx0XHRcdClcblx0XHRcdFx0dGhpcy52Mi5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0XHRwICs9IDhcblx0XHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArNV0gPDwgOCkgfCBpbnB1dFtwKzRdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArN10gPDwgOCkgfCBpbnB1dFtwKzZdXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYzLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs1XSA8PCA4KSB8IGlucHV0W3ArNF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs3XSA8PCA4KSB8IGlucHV0W3ArNl1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjQuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdH1cblx0XHRcdHAgKz0gOFxuXHRcdH0gd2hpbGUgKHAgPD0gbGltaXQpXG5cdH1cblxuXHRpZiAocCA8IGJFbmQpXG5cdHtcblx0XHQvLyBYWEg2NF9tZW1jcHkodGhpcy5tZW1vcnksIHAsIGJFbmQtcCk7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dC5zbGljZShwKVxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkuc2V0KCBpbnB1dC5zdWJhcnJheShwLCBiRW5kKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgcCwgYkVuZCApXG5cdFx0fVxuXG5cdFx0dGhpcy5tZW1zaXplID0gYkVuZCAtIHBcblx0fVxuXG5cdHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogRmluYWxpemUgdGhlIFhYSDY0IGNvbXB1dGF0aW9uLiBUaGUgWFhINjQgaW5zdGFuY2UgaXMgcmVhZHkgZm9yIHJldXNlIGZvciB0aGUgZ2l2ZW4gc2VlZFxuICogQG1ldGhvZCBkaWdlc3RcbiAqIEByZXR1cm4ge1VJTlQ2NH0geHhIYXNoXG4gKi9cblhYSDY0LnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBpbnB1dCA9IHRoaXMubWVtb3J5XG5cdHZhciBpc1N0cmluZyA9IHR5cGVvZiBpbnB1dCA9PSAnc3RyaW5nJ1xuXHR2YXIgcCA9IDBcblx0dmFyIGJFbmQgPSB0aGlzLm1lbXNpemVcblx0dmFyIGg2NCwgaFxuXHR2YXIgdSA9IG5ldyBVSU5UNjRcblxuXHRpZiAodGhpcy50b3RhbF9sZW4gPj0gMzIpXG5cdHtcblx0XHRoNjQgPSB0aGlzLnYxLmNsb25lKCkucm90bCgxKVxuXHRcdGg2NC5hZGQoIHRoaXMudjIuY2xvbmUoKS5yb3RsKDcpIClcblx0XHRoNjQuYWRkKCB0aGlzLnYzLmNsb25lKCkucm90bCgxMikgKVxuXHRcdGg2NC5hZGQoIHRoaXMudjQuY2xvbmUoKS5yb3RsKDE4KSApXG5cblx0XHRoNjQueG9yKCB0aGlzLnYxLm11bHRpcGx5KFBSSU1FNjRfMikucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKSApXG5cdFx0aDY0Lm11bHRpcGx5KFBSSU1FNjRfMSkuYWRkKFBSSU1FNjRfNClcblxuXHRcdGg2NC54b3IoIHRoaXMudjIubXVsdGlwbHkoUFJJTUU2NF8yKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpIClcblx0XHRoNjQubXVsdGlwbHkoUFJJTUU2NF8xKS5hZGQoUFJJTUU2NF80KVxuXG5cdFx0aDY0LnhvciggdGhpcy52My5tdWx0aXBseShQUklNRTY0XzIpLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSkgKVxuXHRcdGg2NC5tdWx0aXBseShQUklNRTY0XzEpLmFkZChQUklNRTY0XzQpXG5cblx0XHRoNjQueG9yKCB0aGlzLnY0Lm11bHRpcGx5KFBSSU1FNjRfMikucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKSApXG5cdFx0aDY0Lm11bHRpcGx5KFBSSU1FNjRfMSkuYWRkKFBSSU1FNjRfNClcblx0fVxuXHRlbHNlXG5cdHtcblx0XHRoNjQgID0gdGhpcy5zZWVkLmNsb25lKCkuYWRkKCBQUklNRTY0XzUgKVxuXHR9XG5cblx0aDY0LmFkZCggdS5mcm9tTnVtYmVyKHRoaXMudG90YWxfbGVuKSApXG5cblx0d2hpbGUgKHAgPD0gYkVuZCAtIDgpXG5cdHtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHUuZnJvbUJpdHMoXG5cdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzUpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzQpXG5cdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHQpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHUuZnJvbUJpdHMoXG5cdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0LFx0KGlucHV0W3ArNV0gPDwgOCkgfCBpbnB1dFtwKzRdXG5cdFx0XHQsXHQoaW5wdXRbcCs3XSA8PCA4KSB8IGlucHV0W3ArNl1cblx0XHRcdClcblx0XHR9XG5cdFx0dS5tdWx0aXBseShQUklNRTY0XzIpLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSlcblx0XHRoNjRcblx0XHRcdC54b3IodSlcblx0XHRcdC5yb3RsKDI3KVxuXHRcdFx0Lm11bHRpcGx5KCBQUklNRTY0XzEgKVxuXHRcdFx0LmFkZCggUFJJTUU2NF80IClcblx0XHRwICs9IDhcblx0fVxuXG5cdGlmIChwICsgNCA8PSBiRW5kKSB7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0LFx0MFxuXHRcdFx0LFx0MFxuXHRcdFx0KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdCxcdDBcblx0XHRcdCxcdDBcblx0XHRcdClcblx0XHR9XG5cdFx0aDY0XG5cdFx0XHQueG9yKCB1Lm11bHRpcGx5KFBSSU1FNjRfMSkgKVxuXHRcdFx0LnJvdGwoMjMpXG5cdFx0XHQubXVsdGlwbHkoIFBSSU1FNjRfMiApXG5cdFx0XHQuYWRkKCBQUklNRTY0XzMgKVxuXHRcdHAgKz0gNFxuXHR9XG5cblx0d2hpbGUgKHAgPCBiRW5kKVxuXHR7XG5cdFx0dS5mcm9tQml0cyggaXNTdHJpbmcgPyBpbnB1dC5jaGFyQ29kZUF0KHArKykgOiBpbnB1dFtwKytdLCAwLCAwLCAwIClcblx0XHRoNjRcblx0XHRcdC54b3IoIHUubXVsdGlwbHkoUFJJTUU2NF81KSApXG5cdFx0XHQucm90bCgxMSlcblx0XHRcdC5tdWx0aXBseShQUklNRTY0XzEpXG5cdH1cblxuXHRoID0gaDY0LmNsb25lKCkuc2hpZnRSaWdodCgzMylcblx0aDY0LnhvcihoKS5tdWx0aXBseShQUklNRTY0XzIpXG5cblx0aCA9IGg2NC5jbG9uZSgpLnNoaWZ0UmlnaHQoMjkpXG5cdGg2NC54b3IoaCkubXVsdGlwbHkoUFJJTUU2NF8zKVxuXG5cdGggPSBoNjQuY2xvbmUoKS5zaGlmdFJpZ2h0KDMyKVxuXHRoNjQueG9yKGgpXG5cblx0Ly8gUmVzZXQgdGhlIHN0YXRlXG5cdHRoaXMuaW5pdCggdGhpcy5zZWVkIClcblxuXHRyZXR1cm4gaDY0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWFhINjRcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi94eGhhc2hqcy9saWIveHhoYXNoNjQuanNcbi8vIG1vZHVsZSBpZCA9IDI3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBjcnlwdG8gKGlnbm9yZWQpXG4vLyBtb2R1bGUgaWQgPSAyNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogKGlnbm9yZWQpICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gdXRpbCAoaWdub3JlZClcbi8vIG1vZHVsZSBpZCA9IDI3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9